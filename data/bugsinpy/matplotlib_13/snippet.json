[
    {
        "name": "lib.matplotlib.dviread.PsfontsMap.__new__#806",
        "src_path": "lib/matplotlib/dviread.py",
        "class_name": "lib.matplotlib.dviread.PsfontsMap",
        "signature": "lib.matplotlib.dviread.PsfontsMap.__new__(cls, filename)",
        "snippet": "    def __new__(cls, filename):\n        self = object.__new__(cls)\n        self._font = {}\n        self._filename = os.fsdecode(filename)\n        with open(filename, 'rb') as file:\n            self._parse(file)\n        return self",
        "begin_line": 806,
        "end_line": 812,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dviread.PsfontsMap.__getitem__#814",
        "src_path": "lib/matplotlib/dviread.py",
        "class_name": "lib.matplotlib.dviread.PsfontsMap",
        "signature": "lib.matplotlib.dviread.PsfontsMap.__getitem__(self, texname)",
        "snippet": "    def __getitem__(self, texname):\n        assert isinstance(texname, bytes)\n        try:\n            result = self._font[texname]\n        except KeyError:\n            fmt = ('A PostScript file for the font whose TeX name is \"{0}\" '\n                   'could not be found in the file \"{1}\". The dviread module '\n                   'can only handle fonts that have an associated PostScript '\n                   'font file. '\n                   'This problem can often be solved by installing '\n                   'a suitable PostScript font package in your (TeX) '\n                   'package manager.')\n            msg = fmt.format(texname.decode('ascii'), self._filename)\n            msg = textwrap.fill(msg, break_on_hyphens=False,\n                                break_long_words=False)\n            _log.info(msg)\n            raise\n        fn, enc = result.filename, result.encoding\n        if fn is not None and not fn.startswith(b'/'):\n            fn = find_tex_file(fn)\n        if enc is not None and not enc.startswith(b'/'):\n            enc = find_tex_file(result.encoding)\n        return result._replace(filename=fn, encoding=enc)",
        "begin_line": 814,
        "end_line": 836,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dviread.PsfontsMap._parse#838",
        "src_path": "lib/matplotlib/dviread.py",
        "class_name": "lib.matplotlib.dviread.PsfontsMap",
        "signature": "lib.matplotlib.dviread.PsfontsMap._parse(self, file)",
        "snippet": "    def _parse(self, file):\n        \"\"\"\n        Parse the font mapping file.\n\n        The format is, AFAIK: texname fontname [effects and filenames]\n        Effects are PostScript snippets like \".177 SlantFont\",\n        filenames begin with one or two less-than signs. A filename\n        ending in enc is an encoding file, other filenames are font\n        files. This can be overridden with a left bracket: <[foobar\n        indicates an encoding file named foobar.\n\n        There is some difference between <foo.pfb and <<bar.pfb in\n        subsetting, but I have no example of << in my TeX installation.\n        \"\"\"\n        # If the map file specifies multiple encodings for a font, we\n        # follow pdfTeX in choosing the last one specified. Such\n        # entries are probably mistakes but they have occurred.\n        # http://tex.stackexchange.com/questions/10826/\n        # http://article.gmane.org/gmane.comp.tex.pdftex/4914\n\n        empty_re = re.compile(br'%|\\s*$')\n        word_re = re.compile(\n            br'''(?x) (?:\n                 \"<\\[ (?P<enc1>  [^\"]+    )\" | # quoted encoding marked by [\n                 \"<   (?P<enc2>  [^\"]+.enc)\" | # quoted encoding, ends in .enc\n                 \"<<? (?P<file1> [^\"]+    )\" | # quoted font file name\n                 \"    (?P<eff1>  [^\"]+    )\" | # quoted effects or font name\n                 <\\[  (?P<enc3>  \\S+      )  | # encoding marked by [\n                 <    (?P<enc4>  \\S+  .enc)  | # encoding, ends in .enc\n                 <<?  (?P<file2> \\S+      )  | # font file name\n                      (?P<eff2>  \\S+      )    # effects or font name\n            )''')\n        effects_re = re.compile(\n            br'''(?x) (?P<slant> -?[0-9]*(?:\\.[0-9]+)) \\s* SlantFont\n                    | (?P<extend>-?[0-9]*(?:\\.[0-9]+)) \\s* ExtendFont''')\n\n        lines = (line.strip()\n                 for line in file\n                 if not empty_re.match(line))\n        for line in lines:\n            effects, encoding, filename = b'', None, None\n            words = word_re.finditer(line)\n\n            # The named groups are mutually exclusive and are\n            # referenced below at an estimated order of probability of\n            # occurrence based on looking at my copy of pdftex.map.\n            # The font names are probably unquoted:\n            w = next(words)\n            texname = w.group('eff2') or w.group('eff1')\n            w = next(words)\n            psname = w.group('eff2') or w.group('eff1')\n\n            for w in words:\n                # Any effects are almost always quoted:\n                eff = w.group('eff1') or w.group('eff2')\n                if eff:\n                    effects = eff\n                    continue\n                # Encoding files usually have the .enc suffix\n                # and almost never need quoting:\n                enc = (w.group('enc4') or w.group('enc3') or\n                       w.group('enc2') or w.group('enc1'))\n                if enc:\n                    if encoding is not None:\n                        _log.debug('Multiple encodings for %s = %s',\n                                   texname, psname)\n                    encoding = enc\n                    continue\n                # File names are probably unquoted:\n                filename = w.group('file2') or w.group('file1')\n\n            effects_dict = {}\n            for match in effects_re.finditer(effects):\n                slant = match.group('slant')\n                if slant:\n                    effects_dict['slant'] = float(slant)\n                else:\n                    effects_dict['extend'] = float(match.group('extend'))\n\n            self._font[texname] = PsFont(\n                texname=texname, psname=psname, effects=effects_dict,\n                encoding=encoding, filename=filename)",
        "begin_line": 838,
        "end_line": 919,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.style.core._remove_blacklisted_style_params#45",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core._remove_blacklisted_style_params(d, warn=True)",
        "snippet": "def _remove_blacklisted_style_params(d, warn=True):\n    o = {}\n    for key, val in d.items():\n        if key in STYLE_BLACKLIST:\n            if warn:\n                cbook._warn_external(\n                    \"Style includes a parameter, '{0}', that is not related \"\n                    \"to style.  Ignoring\".format(key))\n        else:\n            o[key] = val\n    return o",
        "begin_line": 45,
        "end_line": 55,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00034048348655090226,
            "pseudo_dstar_susp": 0.0007598784194528875,
            "pseudo_tarantula_susp": 0.00028392958546280523,
            "pseudo_op2_susp": 0.0007598784194528875,
            "pseudo_barinel_susp": 0.00028392958546280523
        }
    },
    {
        "name": "lib.matplotlib.style.core._apply_style#64",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core._apply_style(d, warn=True)",
        "snippet": "def _apply_style(d, warn=True):\n    mpl.rcParams.update(_remove_blacklisted_style_params(d, warn=warn))",
        "begin_line": 64,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00032310177705977385,
            "pseudo_dstar_susp": 0.0007575757575757576,
            "pseudo_tarantula_susp": 0.0002800336040324839,
            "pseudo_op2_susp": 0.0007575757575757576,
            "pseudo_barinel_susp": 0.0002800336040324839
        }
    },
    {
        "name": "lib.matplotlib.style.core.use#68",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core.use(style)",
        "snippet": "def use(style):\n    \"\"\"Use matplotlib style settings from a style specification.\n\n    The style name of 'default' is reserved for reverting back to\n    the default style settings.\n\n    Parameters\n    ----------\n    style : str, dict, Path or list\n        A style specification. Valid options are:\n\n        +------+-------------------------------------------------------------+\n        | str  | The name of a style or a path/URL to a style file. For a    |\n        |      | list of available style names, see `style.available`.       |\n        +------+-------------------------------------------------------------+\n        | dict | Dictionary with valid key/value pairs for                   |\n        |      | `matplotlib.rcParams`.                                      |\n        +------+-------------------------------------------------------------+\n        | Path | A path-like object which is a path to a style file.         |\n        +------+-------------------------------------------------------------+\n        | list | A list of style specifiers (str, Path or dict) applied from |\n        |      | first to last in the list.                                  |\n        +------+-------------------------------------------------------------+\n\n    \"\"\"\n    style_alias = {'mpl20': 'default',\n                   'mpl15': 'classic'}\n    if isinstance(style, (str, Path)) or hasattr(style, 'keys'):\n        # If name is a single str, Path or dict, make it a single element list.\n        styles = [style]\n    else:\n        styles = style\n\n    styles = (style_alias.get(s, s) if isinstance(s, str) else s\n              for s in styles)\n    for style in styles:\n        if not isinstance(style, (str, Path)):\n            _apply_style(style)\n        elif style == 'default':\n            # Deprecation warnings were already handled when creating\n            # rcParamsDefault, no need to reemit them here.\n            with cbook._suppress_matplotlib_deprecation_warning():\n                _apply_style(rcParamsDefault, warn=False)\n        elif style in library:\n            _apply_style(library[style])\n        else:\n            try:\n                rc = rc_params_from_file(style, use_default_template=False)\n                _apply_style(rc)\n            except IOError as err:\n                raise IOError(\n                    \"{!r} not found in the style library and input is not a \"\n                    \"valid URL or path; see `style.available` for list of \"\n                    \"available styles\".format(style)) from err",
        "begin_line": 68,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007598784194528875,
            "pseudo_dstar_susp": 0.006097560975609756,
            "pseudo_tarantula_susp": 0.00033909799932180403,
            "pseudo_op2_susp": 0.006097560975609756,
            "pseudo_barinel_susp": 0.00033909799932180403
        }
    },
    {
        "name": "lib.matplotlib.style.core.context#125",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core.context(style, after_reset=False)",
        "snippet": "def context(style, after_reset=False):\n    \"\"\"Context manager for using style settings temporarily.\n\n    Parameters\n    ----------\n    style : str, dict, Path or list\n        A style specification. Valid options are:\n\n        +------+-------------------------------------------------------------+\n        | str  | The name of a style or a path/URL to a style file. For a    |\n        |      | list of available style names, see `style.available`.       |\n        +------+-------------------------------------------------------------+\n        | dict | Dictionary with valid key/value pairs for                   |\n        |      | `matplotlib.rcParams`.                                      |\n        +------+-------------------------------------------------------------+\n        | Path | A path-like object which is a path to a style file.         |\n        +------+-------------------------------------------------------------+\n        | list | A list of style specifiers (str, Path or dict) applied from |\n        |      | first to last in the list.                                  |\n        +------+-------------------------------------------------------------+\n\n    after_reset : bool\n        If True, apply style after resetting settings to their defaults;\n        otherwise, apply style on top of the current settings.\n    \"\"\"\n    with mpl.rc_context():\n        if after_reset:\n            mpl.rcdefaults()\n        use(style)\n        yield",
        "begin_line": 125,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.19793966151582e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.style.core.iter_user_libraries#163",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core.iter_user_libraries()",
        "snippet": "def iter_user_libraries():\n    for stylelib_path in USER_LIBRARY_PATHS:\n        stylelib_path = os.path.expanduser(stylelib_path)\n        if os.path.exists(stylelib_path) and os.path.isdir(stylelib_path):\n            yield stylelib_path",
        "begin_line": 163,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.style.core.update_user_library#170",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core.update_user_library(library)",
        "snippet": "def update_user_library(library):\n    \"\"\"Update style library with user-defined rc files\"\"\"\n    for stylelib_path in iter_user_libraries():\n        styles = read_style_directory(stylelib_path)\n        update_nested_dict(library, styles)\n    return library",
        "begin_line": 170,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.46880030300161e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.style.core.read_style_directory#189",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core.read_style_directory(style_dir)",
        "snippet": "def read_style_directory(style_dir):\n    \"\"\"Return dictionary of styles defined in *style_dir*.\"\"\"\n    styles = dict()\n    for path in Path(style_dir).glob(f\"*.{STYLE_EXTENSION}\"):\n        with warnings.catch_warnings(record=True) as warns:\n            styles[path.stem] = rc_params_from_file(\n                path, use_default_template=False)\n        for w in warns:\n            _log.warning('In %s: %s', path, w.message)\n    return styles",
        "begin_line": 189,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.style.core.update_nested_dict#201",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core.update_nested_dict(main_dict, new_dict)",
        "snippet": "def update_nested_dict(main_dict, new_dict):\n    \"\"\"Update nested dict (only level of nesting) with new values.\n\n    Unlike dict.update, this assumes that the values of the parent dict are\n    dicts (or dict-like), so you shouldn't replace the nested dict if it\n    already exists. Instead you should update the sub-dict.\n    \"\"\"\n    # update named styles specified by user\n    for name, rc_dict in new_dict.items():\n        main_dict.setdefault(name, {}).update(rc_dict)\n    return main_dict",
        "begin_line": 201,
        "end_line": 211,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.style.core.reload_library#222",
        "src_path": "lib/matplotlib/style/core.py",
        "class_name": "lib.matplotlib.style.core",
        "signature": "lib.matplotlib.style.core.reload_library()",
        "snippet": "def reload_library():\n    \"\"\"Reload style library.\"\"\"\n    global library\n    library = update_user_library(_base_library)\n    available[:] = sorted(library.keys())",
        "begin_line": 222,
        "end_line": 226,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.scale.ScaleBase.limit_range_for_scale#80",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.ScaleBase",
        "signature": "lib.matplotlib.scale.ScaleBase.limit_range_for_scale(self, vmin, vmax, minpos)",
        "snippet": "    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"\n        Returns the range *vmin*, *vmax*, possibly limited to the\n        domain supported by this scale.\n\n        *minpos* should be the minimum positive value in the data.\n        This is used by log scales to determine a minimum value.\n        \"\"\"\n        return vmin, vmax",
        "begin_line": 80,
        "end_line": 88,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00980392156862745,
            "pseudo_dstar_susp": 0.007575757575757576,
            "pseudo_tarantula_susp": 0.0006675567423230974,
            "pseudo_op2_susp": 0.007246376811594203,
            "pseudo_barinel_susp": 0.0006675567423230974
        }
    },
    {
        "name": "lib.matplotlib.scale.LinearScale.set_default_locators_and_formatters#106",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.LinearScale",
        "signature": "lib.matplotlib.scale.LinearScale.set_default_locators_and_formatters(self, axis)",
        "snippet": "    def set_default_locators_and_formatters(self, axis):\n        # docstring inherited\n        axis.set_major_locator(AutoLocator())\n        axis.set_major_formatter(ScalarFormatter())\n        axis.set_minor_formatter(NullFormatter())\n        # update the minor locator for x and y axis based on rcParams\n        if (axis.axis_name == 'x' and mpl.rcParams['xtick.minor.visible']\n            or axis.axis_name == 'y' and mpl.rcParams['ytick.minor.visible']):\n            axis.set_minor_locator(AutoMinorLocator())\n        else:\n            axis.set_minor_locator(NullLocator())",
        "begin_line": 106,
        "end_line": 116,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014064697609001407,
            "pseudo_dstar_susp": 0.005,
            "pseudo_tarantula_susp": 0.0004079967360261118,
            "pseudo_op2_susp": 0.004975124378109453,
            "pseudo_barinel_susp": 0.0004079967360261118
        }
    },
    {
        "name": "lib.matplotlib.scale.LogTransform.__init__#208",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.LogTransform",
        "signature": "lib.matplotlib.scale.LogTransform.__init__(self, base, nonpositive='clip')",
        "snippet": "    def __init__(self, base, nonpositive='clip'):\n        Transform.__init__(self)\n        if base <= 0 or base == 1:\n            raise ValueError('The log base cannot be <= 0 or == 1')\n        self.base = base\n        self._clip = cbook._check_getitem(\n            {\"clip\": True, \"mask\": False}, nonpositive=nonpositive)",
        "begin_line": 208,
        "end_line": 214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.007687379884689e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.scale.LogTransform.inverted#242",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.LogTransform",
        "signature": "lib.matplotlib.scale.LogTransform.inverted(self)",
        "snippet": "    def inverted(self):\n        return InvertedLogTransform(self.base)",
        "begin_line": 242,
        "end_line": 243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.714396735962697e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.scale.InvertedLogTransform.__init__#249",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.InvertedLogTransform",
        "signature": "lib.matplotlib.scale.InvertedLogTransform.__init__(self, base)",
        "snippet": "    def __init__(self, base):\n        Transform.__init__(self)\n        self.base = base",
        "begin_line": 249,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.920792079207921e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.scale.LogScale.__init__#279",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.LogScale",
        "signature": "lib.matplotlib.scale.LogScale.__init__(self, axis, **kwargs)",
        "snippet": "    def __init__(self, axis, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        axis : `~matplotlib.axis.Axis`\n            The axis for the scale.\n        base : float, default: 10\n            The base of the logarithm.\n        nonpositive : {'clip', 'mask'}, default: 'clip'\n            Determines the behavior for non-positive values. They can either\n            be masked as invalid, or clipped to a very small positive number.\n        subs : sequence of int, default: None\n            Where to place the subticks between each major tick.  For example,\n            in a log10 scale, ``[2, 3, 4, 5, 6, 7, 8, 9]`` will place 8\n            logarithmically spaced minor ticks between each major tick.\n        \"\"\"\n        # After the deprecation, the whole (outer) __init__ can be replaced by\n        # def __init__(self, axis, *, base=10, subs=None, nonpositive=\"clip\")\n        # The following is to emit the right warnings depending on the axis\n        # used, as the *old* kwarg names depended on the axis.\n        axis_name = getattr(axis, \"axis_name\", \"x\")\n        @cbook._rename_parameter(\"3.3\", f\"base{axis_name}\", \"base\")\n        @cbook._rename_parameter(\"3.3\", f\"subs{axis_name}\", \"subs\")\n        @cbook._rename_parameter(\"3.3\", f\"nonpos{axis_name}\", \"nonpositive\")\n        def __init__(*, base=10, subs=None, nonpositive=\"clip\"):\n            return base, subs, nonpositive\n\n        base, subs, nonpositive = __init__(**kwargs)\n        self._transform = LogTransform(base, nonpositive)\n        self.subs = subs",
        "begin_line": 279,
        "end_line": 308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.scale.LogScale.__init__#303",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.LogScale",
        "signature": "lib.matplotlib.scale.LogScale.__init__(*, base=10, subs=None, nonpositive='clip')",
        "snippet": "        def __init__(*, base=10, subs=None, nonpositive=\"clip\"):\n            return base, subs, nonpositive",
        "begin_line": 303,
        "end_line": 304,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.scale.InvertedSymmetricalLogTransform.transform_non_affine#416",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.InvertedSymmetricalLogTransform",
        "signature": "lib.matplotlib.scale.InvertedSymmetricalLogTransform.transform_non_affine(self, a)",
        "snippet": "    def transform_non_affine(self, a):\n        abs_a = np.abs(a)\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            out = np.sign(a) * self.linthresh * (\n                np.power(self.base,\n                         abs_a / self.linthresh - self._linscale_adj))\n            inside = abs_a <= self.invlinthresh\n        out[inside] = a[inside] / self._linscale_adj\n        return out",
        "begin_line": 416,
        "end_line": 424,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.scale.SymmetricalLogScale.__init__#476",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.SymmetricalLogScale",
        "signature": "lib.matplotlib.scale.SymmetricalLogScale.__init__(self, axis, **kwargs)",
        "snippet": "    def __init__(self, axis, **kwargs):\n        axis_name = getattr(axis, \"axis_name\", \"x\")\n        # See explanation in LogScale.__init__.\n        @cbook._rename_parameter(\"3.3\", f\"base{axis_name}\", \"base\")\n        @cbook._rename_parameter(\"3.3\", f\"linthresh{axis_name}\", \"linthresh\")\n        @cbook._rename_parameter(\"3.3\", f\"subs{axis_name}\", \"subs\")\n        @cbook._rename_parameter(\"3.3\", f\"linscale{axis_name}\", \"linscale\")\n        def __init__(*, base=10, linthresh=2, subs=None, linscale=1, **kwargs):\n            if kwargs:\n                warn_deprecated(\n                    \"3.2.0\",\n                    message=(\n                        f\"SymmetricalLogScale got an unexpected keyword \"\n                        f\"argument {next(iter(kwargs))!r}; in the future, \"\n                        f\"this will raise a TypeError\")\n                )\n            return base, linthresh, subs, linscale\n\n        base, linthresh, subs, linscale = __init__(**kwargs)\n        self._transform = SymmetricalLogTransform(base, linthresh, linscale)\n        self.subs = subs",
        "begin_line": 476,
        "end_line": 496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.scale.SymmetricalLogScale.__init__#483",
        "src_path": "lib/matplotlib/scale.py",
        "class_name": "lib.matplotlib.scale.SymmetricalLogScale",
        "signature": "lib.matplotlib.scale.SymmetricalLogScale.__init__(*, base=10, linthresh=2, subs=None, linscale=1, **kwargs)",
        "snippet": "        def __init__(*, base=10, linthresh=2, subs=None, linscale=1, **kwargs):\n            if kwargs:\n                warn_deprecated(\n                    \"3.2.0\",\n                    message=(\n                        f\"SymmetricalLogScale got an unexpected keyword \"\n                        f\"argument {next(iter(kwargs))!r}; in the future, \"\n                        f\"this will raise a TypeError\")\n                )\n            return base, linthresh, subs, linscale",
        "begin_line": 483,
        "end_line": 492,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.__init__#286",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.__init__(self, parent, handles, labels, loc=None, numpoints=None, markerscale=None, markerfirst=True, scatterpoints=None, scatteryoffsets=None, prop=None, fontsize=None, borderpad=None, labelspacing=None, handlelength=None, handleheight=None, handletextpad=None, borderaxespad=None, columnspacing=None, ncol=1, mode=None, fancybox=None, shadow=None, title=None, title_fontsize=None, framealpha=None, edgecolor=None, facecolor=None, bbox_to_anchor=None, bbox_transform=None, frameon=None, handler_map=None)",
        "snippet": "    def __init__(self, parent, handles, labels,\n                 loc=None,\n                 numpoints=None,    # the number of points in the legend line\n                 markerscale=None,  # the relative size of legend markers\n                                    # vs. original\n                 markerfirst=True,  # controls ordering (left-to-right) of\n                                    # legend marker and label\n                 scatterpoints=None,    # number of scatter points\n                 scatteryoffsets=None,\n                 prop=None,          # properties for the legend texts\n                 fontsize=None,        # keyword to set font size directly\n\n                 # spacing & pad defined as a fraction of the font-size\n                 borderpad=None,      # the whitespace inside the legend border\n                 labelspacing=None,   # the vertical space between the legend\n                                      # entries\n                 handlelength=None,   # the length of the legend handles\n                 handleheight=None,   # the height of the legend handles\n                 handletextpad=None,  # the pad between the legend handle\n                                      # and text\n                 borderaxespad=None,  # the pad between the axes and legend\n                                      # border\n                 columnspacing=None,  # spacing between columns\n\n                 ncol=1,     # number of columns\n                 mode=None,  # mode for horizontal distribution of columns.\n                             # None, \"expand\"\n\n                 fancybox=None,  # True use a fancy box, false use a rounded\n                                 # box, none use rc\n                 shadow=None,\n                 title=None,  # set a title for the legend\n                 title_fontsize=None,  # the font size for the title\n                 framealpha=None,  # set frame alpha\n                 edgecolor=None,  # frame patch edgecolor\n                 facecolor=None,  # frame patch facecolor\n\n                 bbox_to_anchor=None,  # bbox that the legend will be anchored.\n                 bbox_transform=None,  # transform for the bbox\n                 frameon=None,  # draw frame\n                 handler_map=None,\n                 ):\n        \"\"\"\n        Parameters\n        ----------\n        parent : `~matplotlib.axes.Axes` or `.Figure`\n            The artist that contains the legend.\n\n        handles : list of `.Artist`\n            A list of Artists (lines, patches) to be added to the legend.\n\n        labels : list of str\n            A list of labels to show next to the artists. The length of handles\n            and labels should be the same. If they are not, they are truncated\n            to the smaller of both lengths.\n\n        Other Parameters\n        ----------------\n        %(_legend_kw_doc)s\n\n        Notes\n        -----\n        Users can specify any arbitrary location for the legend using the\n        *bbox_to_anchor* keyword argument. *bbox_to_anchor* can be a\n        `.BboxBase` (or derived therefrom) or a tuple of 2 or 4 floats.\n        See `set_bbox_to_anchor` for more detail.\n\n        The legend location can be specified by setting *loc* with a tuple of\n        2 floats, which is interpreted as the lower-left corner of the legend\n        in the normalized axes coordinate.\n        \"\"\"\n        # local import only to avoid circularity\n        from matplotlib.axes import Axes\n        from matplotlib.figure import Figure\n\n        Artist.__init__(self)\n\n        if prop is None:\n            if fontsize is not None:\n                self.prop = FontProperties(size=fontsize)\n            else:\n                self.prop = FontProperties(\n                    size=mpl.rcParams[\"legend.fontsize\"])\n        else:\n            self.prop = FontProperties._from_any(prop)\n            if isinstance(prop, dict) and \"size\" not in prop:\n                self.prop.set_size(mpl.rcParams[\"legend.fontsize\"])\n\n        self._fontsize = self.prop.get_size_in_points()\n\n        self.texts = []\n        self.legendHandles = []\n        self._legend_title_box = None\n\n        #: A dictionary with the extra handler mappings for this Legend\n        #: instance.\n        self._custom_handler_map = handler_map\n\n        locals_view = locals()\n        for name in [\"numpoints\", \"markerscale\", \"shadow\", \"columnspacing\",\n                     \"scatterpoints\", \"handleheight\", 'borderpad',\n                     'labelspacing', 'handlelength', 'handletextpad',\n                     'borderaxespad']:\n            if locals_view[name] is None:\n                value = mpl.rcParams[\"legend.\" + name]\n            else:\n                value = locals_view[name]\n            setattr(self, name, value)\n        del locals_view\n        # trim handles and labels if illegal label...\n        _lab, _hand = [], []\n        for label, handle in zip(labels, handles):\n            if isinstance(label, str) and label.startswith('_'):\n                cbook._warn_external('The handle {!r} has a label of {!r} '\n                                     'which cannot be automatically added to'\n                                     ' the legend.'.format(handle, label))\n            else:\n                _lab.append(label)\n                _hand.append(handle)\n        labels, handles = _lab, _hand\n\n        handles = list(handles)\n        if len(handles) < 2:\n            ncol = 1\n        self._ncol = ncol\n\n        if self.numpoints <= 0:\n            raise ValueError(\"numpoints must be > 0; it was %d\" % numpoints)\n\n        # introduce y-offset for handles of the scatter plot\n        if scatteryoffsets is None:\n            self._scatteryoffsets = np.array([3. / 8., 4. / 8., 2.5 / 8.])\n        else:\n            self._scatteryoffsets = np.asarray(scatteryoffsets)\n        reps = self.scatterpoints // len(self._scatteryoffsets) + 1\n        self._scatteryoffsets = np.tile(self._scatteryoffsets,\n                                        reps)[:self.scatterpoints]\n\n        # _legend_box is a VPacker instance that contains all\n        # legend items and will be initialized from _init_legend_box()\n        # method.\n        self._legend_box = None\n\n        if isinstance(parent, Axes):\n            self.isaxes = True\n            self.axes = parent\n            self.set_figure(parent.figure)\n        elif isinstance(parent, Figure):\n            self.isaxes = False\n            self.set_figure(parent)\n        else:\n            raise TypeError(\"Legend needs either Axes or Figure as parent\")\n        self.parent = parent\n\n        self._loc_used_default = loc is None\n        if loc is None:\n            loc = mpl.rcParams[\"legend.loc\"]\n            if not self.isaxes and loc in [0, 'best']:\n                loc = 'upper right'\n        if isinstance(loc, str):\n            if loc not in self.codes:\n                if self.isaxes:\n                    cbook.warn_deprecated(\n                        \"3.1\", message=\"Unrecognized location {!r}. Falling \"\n                        \"back on 'best'; valid locations are\\n\\t{}\\n\"\n                        \"This will raise an exception %(removal)s.\"\n                        .format(loc, '\\n\\t'.join(self.codes)))\n                    loc = 0\n                else:\n                    cbook.warn_deprecated(\n                        \"3.1\", message=\"Unrecognized location {!r}. Falling \"\n                        \"back on 'upper right'; valid locations are\\n\\t{}\\n'\"\n                        \"This will raise an exception %(removal)s.\"\n                        .format(loc, '\\n\\t'.join(self.codes)))\n                    loc = 1\n            else:\n                loc = self.codes[loc]\n        if not self.isaxes and loc == 0:\n            cbook.warn_deprecated(\n                \"3.1\", message=\"Automatic legend placement (loc='best') not \"\n                \"implemented for figure legend. Falling back on 'upper \"\n                \"right'. This will raise an exception %(removal)s.\")\n            loc = 1\n\n        self._mode = mode\n        self.set_bbox_to_anchor(bbox_to_anchor, bbox_transform)\n\n        # We use FancyBboxPatch to draw a legend frame. The location\n        # and size of the box will be updated during the drawing time.\n\n        if facecolor is None:\n            facecolor = mpl.rcParams[\"legend.facecolor\"]\n        if facecolor == 'inherit':\n            facecolor = mpl.rcParams[\"axes.facecolor\"]\n\n        if edgecolor is None:\n            edgecolor = mpl.rcParams[\"legend.edgecolor\"]\n        if edgecolor == 'inherit':\n            edgecolor = mpl.rcParams[\"axes.edgecolor\"]\n\n        if fancybox is None:\n            fancybox = mpl.rcParams[\"legend.fancybox\"]\n\n        self.legendPatch = FancyBboxPatch(\n            xy=(0, 0), width=1, height=1,\n            facecolor=facecolor, edgecolor=edgecolor,\n            # If shadow is used, default to alpha=1 (#8943).\n            alpha=(framealpha if framealpha is not None\n                   else 1 if shadow\n                   else mpl.rcParams[\"legend.framealpha\"]),\n            # The width and height of the legendPatch will be set (in draw())\n            # to the length that includes the padding. Thus we set pad=0 here.\n            boxstyle=(\"round,pad=0,rounding_size=0.2\" if fancybox\n                      else \"square,pad=0\"),\n            mutation_scale=self._fontsize,\n            snap=True,\n        )\n        self._set_artist_props(self.legendPatch)\n\n        self._drawFrame = (frameon if frameon is not None\n                           else mpl.rcParams[\"legend.frameon\"])\n\n        # init with null renderer\n        self._init_legend_box(handles, labels, markerfirst)\n\n        tmp = self._loc_used_default\n        self._set_loc(loc)\n        self._loc_used_default = tmp  # ignore changes done by _set_loc\n\n        # figure out title fontsize:\n        if title_fontsize is None:\n            title_fontsize = mpl.rcParams['legend.title_fontsize']\n        tprop = FontProperties(size=title_fontsize)\n        self.set_title(title, prop=tprop)\n        self._draggable = None",
        "begin_line": 286,
        "end_line": 520,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005431830526887561,
            "pseudo_dstar_susp": 0.0004170141784820684,
            "pseudo_tarantula_susp": 0.0021645021645021645,
            "pseudo_op2_susp": 0.0004170141784820684,
            "pseudo_barinel_susp": 0.0021645021645021645
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend._set_artist_props#522",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend._set_artist_props(self, a)",
        "snippet": "    def _set_artist_props(self, a):\n        \"\"\"\n        Set the boilerplate props for artists added to axes.\n        \"\"\"\n        a.set_figure(self.figure)\n        if self.isaxes:\n            # a.set_axes(self.axes)\n            a.axes = self.axes\n\n        a.set_transform(self.get_transform())",
        "begin_line": 522,
        "end_line": 531,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003728560775540641,
            "pseudo_dstar_susp": 0.0003450655624568668,
            "pseudo_tarantula_susp": 0.0007027406886858749,
            "pseudo_op2_susp": 0.0003450655624568668,
            "pseudo_barinel_susp": 0.0007027406886858749
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend._set_loc#533",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend._set_loc(self, loc)",
        "snippet": "    def _set_loc(self, loc):\n        # find_offset function will be provided to _legend_box and\n        # _legend_box will draw itself at the location of the return\n        # value of the find_offset.\n        self._loc_used_default = False\n        self._loc_real = loc\n        self.stale = True\n        self._legend_box.set_offset(self._findoffset)",
        "begin_line": 533,
        "end_line": 540,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend._get_loc#542",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend._get_loc(self)",
        "snippet": "    def _get_loc(self):\n        return self._loc_real",
        "begin_line": 542,
        "end_line": 543,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend._findoffset#547",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend._findoffset(self, width, height, xdescent, ydescent, renderer)",
        "snippet": "    def _findoffset(self, width, height, xdescent, ydescent, renderer):\n        \"\"\"Helper function to locate the legend.\"\"\"\n\n        if self._loc == 0:  # \"best\".\n            x, y = self._find_best_position(width, height, renderer)\n        elif self._loc in Legend.codes.values():  # Fixed location.\n            bbox = Bbox.from_bounds(0, 0, width, height)\n            x, y = self._get_anchored_bbox(self._loc, bbox,\n                                           self.get_bbox_to_anchor(),\n                                           renderer)\n        else:  # Axes or figure coordinates.\n            fx, fy = self._loc\n            bbox = self.get_bbox_to_anchor()\n            x, y = bbox.x0 + bbox.width * fx, bbox.y0 + bbox.height * fy\n\n        return x + xdescent, y + ydescent",
        "begin_line": 547,
        "end_line": 562,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.draw#565",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        # docstring inherited\n        if not self.get_visible():\n            return\n\n        renderer.open_group('legend', gid=self.get_gid())\n\n        fontsize = renderer.points_to_pixels(self._fontsize)\n\n        # if mode == fill, set the width of the legend_box to the\n        # width of the parent (minus pads)\n        if self._mode in [\"expand\"]:\n            pad = 2 * (self.borderaxespad + self.borderpad) * fontsize\n            self._legend_box.set_width(self.get_bbox_to_anchor().width - pad)\n\n        # update the location and size of the legend. This needs to\n        # be done in any case to clip the figure right.\n        bbox = self._legend_box.get_window_extent(renderer)\n        self.legendPatch.set_bounds(bbox.x0, bbox.y0,\n                                    bbox.width, bbox.height)\n        self.legendPatch.set_mutation_scale(fontsize)\n\n        if self._drawFrame:\n            if self.shadow:\n                shadow = Shadow(self.legendPatch, 2, -2)\n                shadow.draw(renderer)\n\n            self.legendPatch.draw(renderer)\n\n        self._legend_box.draw(renderer)\n\n        renderer.close_group('legend')\n        self.stale = False",
        "begin_line": 565,
        "end_line": 597,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.get_default_handler_map#621",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.get_default_handler_map(cls)",
        "snippet": "    def get_default_handler_map(cls):\n        \"\"\"\n        A class method that returns the default handler map.\n        \"\"\"\n        return cls._default_handler_map",
        "begin_line": 621,
        "end_line": 625,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003728560775540641,
            "pseudo_dstar_susp": 0.0003450655624568668,
            "pseudo_tarantula_susp": 0.0007027406886858749,
            "pseudo_op2_susp": 0.0003450655624568668,
            "pseudo_barinel_susp": 0.0007027406886858749
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.get_legend_handler_map#641",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.get_legend_handler_map(self)",
        "snippet": "    def get_legend_handler_map(self):\n        \"\"\"\n        Return the handler map.\n        \"\"\"\n\n        default_handler_map = self.get_default_handler_map()\n\n        if self._custom_handler_map:\n            hm = default_handler_map.copy()\n            hm.update(self._custom_handler_map)\n            return hm\n        else:\n            return default_handler_map",
        "begin_line": 641,
        "end_line": 653,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000708215297450425,
            "pseudo_dstar_susp": 0.0004268032437046522,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0004268032437046522,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.get_legend_handler#656",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.get_legend_handler(legend_handler_map, orig_handle)",
        "snippet": "    def get_legend_handler(legend_handler_map, orig_handle):\n        \"\"\"\n        Return a legend handler from *legend_handler_map* that\n        corresponds to *orig_handler*.\n\n        *legend_handler_map* should be a dictionary object (that is\n        returned by the get_legend_handler_map method).\n\n        It first checks if the *orig_handle* itself is a key in the\n        *legend_handler_map* and return the associated value.\n        Otherwise, it checks for each of the classes in its\n        method-resolution-order. If no matching key is found, it\n        returns ``None``.\n        \"\"\"\n        try:\n            return legend_handler_map[orig_handle]\n        except (TypeError, KeyError):  # TypeError if unhashable.\n            pass\n        for handle_type in type(orig_handle).mro():\n            try:\n                return legend_handler_map[handle_type]\n            except KeyError:\n                pass\n        return None",
        "begin_line": 656,
        "end_line": 679,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00037037037037037035,
            "pseudo_dstar_susp": 0.00034317089910775565,
            "pseudo_tarantula_susp": 0.0006887052341597796,
            "pseudo_op2_susp": 0.00034317089910775565,
            "pseudo_barinel_susp": 0.0006887052341597796
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend._init_legend_box#681",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend._init_legend_box(self, handles, labels, markerfirst=True)",
        "snippet": "    def _init_legend_box(self, handles, labels, markerfirst=True):\n        \"\"\"\n        Initialize the legend_box. The legend_box is an instance of\n        the OffsetBox, which is packed with legend handles and\n        texts. Once packed, their location is calculated during the\n        drawing time.\n        \"\"\"\n\n        fontsize = self._fontsize\n\n        # legend_box is a HPacker, horizontally packed with\n        # columns. Each column is a VPacker, vertically packed with\n        # legend items. Each legend item is HPacker packed with\n        # legend handleBox and labelBox. handleBox is an instance of\n        # offsetbox.DrawingArea which contains legend handle. labelBox\n        # is an instance of offsetbox.TextArea which contains legend\n        # text.\n\n        text_list = []  # the list of text instances\n        handle_list = []  # the list of text instances\n        handles_and_labels = []\n\n        label_prop = dict(verticalalignment='baseline',\n                          horizontalalignment='left',\n                          fontproperties=self.prop,\n                          )\n\n        # The approximate height and descent of text. These values are\n        # only used for plotting the legend handle.\n        descent = 0.35 * fontsize * (self.handleheight - 0.7)\n        # 0.35 and 0.7 are just heuristic numbers and may need to be improved.\n        height = fontsize * self.handleheight - descent\n        # each handle needs to be drawn inside a box of (x, y, w, h) =\n        # (0, -descent, width, height).  And their coordinates should\n        # be given in the display coordinates.\n\n        # The transformation of each handle will be automatically set\n        # to self.get_transform(). If the artist does not use its\n        # default transform (e.g., Collections), you need to\n        # manually set their transform to the self.get_transform().\n        legend_handler_map = self.get_legend_handler_map()\n\n        for orig_handle, lab in zip(handles, labels):\n            handler = self.get_legend_handler(legend_handler_map, orig_handle)\n            if handler is None:\n                cbook._warn_external(\n                    \"Legend does not support {!r} instances.\\nA proxy artist \"\n                    \"may be used instead.\\nSee: \"\n                    \"http://matplotlib.org/users/legend_guide.html\"\n                    \"#creating-artists-specifically-for-adding-to-the-legend-\"\n                    \"aka-proxy-artists\".format(orig_handle))\n                # We don't have a handle for this artist, so we just defer\n                # to None.\n                handle_list.append(None)\n            else:\n                textbox = TextArea(lab, textprops=label_prop,\n                                   multilinebaseline=True,\n                                   minimumdescent=True)\n                handlebox = DrawingArea(width=self.handlelength * fontsize,\n                                        height=height,\n                                        xdescent=0., ydescent=descent)\n\n                text_list.append(textbox._text)\n                # Create the artist for the legend which represents the\n                # original artist/handle.\n                handle_list.append(handler.legend_artist(self, orig_handle,\n                                                         fontsize, handlebox))\n                handles_and_labels.append((handlebox, textbox))\n\n        if handles_and_labels:\n            # We calculate number of rows in each column. The first\n            # (num_largecol) columns will have (nrows+1) rows, and remaining\n            # (num_smallcol) columns will have (nrows) rows.\n            ncol = min(self._ncol, len(handles_and_labels))\n            nrows, num_largecol = divmod(len(handles_and_labels), ncol)\n            num_smallcol = ncol - num_largecol\n            # starting index of each column and number of rows in it.\n            rows_per_col = [nrows + 1] * num_largecol + [nrows] * num_smallcol\n            start_idxs = np.concatenate([[0], np.cumsum(rows_per_col)[:-1]])\n            cols = zip(start_idxs, rows_per_col)\n        else:\n            cols = []\n\n        columnbox = []\n        for i0, di in cols:\n            # pack handleBox and labelBox into itemBox\n            itemBoxes = [HPacker(pad=0,\n                                 sep=self.handletextpad * fontsize,\n                                 children=[h, t] if markerfirst else [t, h],\n                                 align=\"baseline\")\n                         for h, t in handles_and_labels[i0:i0 + di]]\n            # minimumdescent=False for the text of the last row of the column\n            if markerfirst:\n                itemBoxes[-1].get_children()[1].set_minimumdescent(False)\n            else:\n                itemBoxes[-1].get_children()[0].set_minimumdescent(False)\n\n            # pack columnBox\n            alignment = \"baseline\" if markerfirst else \"right\"\n            columnbox.append(VPacker(pad=0,\n                                     sep=self.labelspacing * fontsize,\n                                     align=alignment,\n                                     children=itemBoxes))\n\n        mode = \"expand\" if self._mode == \"expand\" else \"fixed\"\n        sep = self.columnspacing * fontsize\n        self._legend_handle_box = HPacker(pad=0,\n                                          sep=sep, align=\"baseline\",\n                                          mode=mode,\n                                          children=columnbox)\n        self._legend_title_box = TextArea(\"\")\n        self._legend_box = VPacker(pad=self.borderpad * fontsize,\n                                   sep=self.labelspacing * fontsize,\n                                   align=\"center\",\n                                   children=[self._legend_title_box,\n                                             self._legend_handle_box])\n        self._legend_box.set_figure(self.figure)\n        self.texts = text_list\n        self.legendHandles = handle_list",
        "begin_line": 681,
        "end_line": 799,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038880248833592535,
            "pseudo_dstar_susp": 0.00035816618911174784,
            "pseudo_tarantula_susp": 0.0008305647840531562,
            "pseudo_op2_susp": 0.00035816618911174784,
            "pseudo_barinel_susp": 0.0008305647840531562
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend._auto_legend_data#801",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend._auto_legend_data(self)",
        "snippet": "    def _auto_legend_data(self):\n        \"\"\"\n        Return display coordinates for hit testing for \"best\" positioning.\n\n        Returns\n        -------\n        bboxes\n            List of bounding boxes of all patches.\n        lines\n            List of `.Path` corresponding to each line.\n        offsets\n            List of (x, y) offsets of all collection.\n        \"\"\"\n        assert self.isaxes  # always holds, as this is only called internally\n        ax = self.parent\n        lines = [line.get_transform().transform_path(line.get_path())\n                 for line in ax.lines]\n        bboxes = [patch.get_bbox().transformed(patch.get_data_transform())\n                  if isinstance(patch, Rectangle) else\n                  patch.get_path().get_extents(patch.get_transform())\n                  for patch in ax.patches]\n        offsets = []\n        for handle in ax.collections:\n            _, transOffset, hoffsets, _ = handle._prepare_points()\n            for offset in transOffset.transform(hoffsets):\n                offsets.append(offset)\n        return bboxes, lines, offsets",
        "begin_line": 801,
        "end_line": 827,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.get_children#829",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.get_children(self)",
        "snippet": "    def get_children(self):\n        # docstring inherited\n        return [self._legend_box, self.get_frame()]",
        "begin_line": 829,
        "end_line": 831,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.get_frame#833",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.get_frame(self)",
        "snippet": "    def get_frame(self):\n        \"\"\"Return the `~.patches.Rectangle` used to frame the legend.\"\"\"\n        return self.legendPatch",
        "begin_line": 833,
        "end_line": 835,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.set_title#851",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.set_title(self, title, prop=None)",
        "snippet": "    def set_title(self, title, prop=None):\n        \"\"\"\n        Set the legend title. Fontproperties can be optionally set\n        with *prop* parameter.\n        \"\"\"\n        self._legend_title_box._text.set_text(title)\n        if title:\n            self._legend_title_box._text.set_visible(True)\n            self._legend_title_box.set_visible(True)\n        else:\n            self._legend_title_box._text.set_visible(False)\n            self._legend_title_box.set_visible(False)\n\n        if prop is not None:\n            self._legend_title_box._text.set_fontproperties(prop)\n\n        self.stale = True",
        "begin_line": 851,
        "end_line": 867,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.get_bbox_to_anchor#912",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.get_bbox_to_anchor(self)",
        "snippet": "    def get_bbox_to_anchor(self):\n        \"\"\"Return the bbox that the legend will be anchored to.\"\"\"\n        if self._bbox_to_anchor is None:\n            return self.parent.bbox\n        else:\n            return self._bbox_to_anchor",
        "begin_line": 912,
        "end_line": 917,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend.set_bbox_to_anchor#919",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend.set_bbox_to_anchor(self, bbox, transform=None)",
        "snippet": "    def set_bbox_to_anchor(self, bbox, transform=None):\n        \"\"\"\n        Set the bbox that the legend will be anchored to.\n\n        *bbox* can be\n\n        - A `.BboxBase` instance\n        - A tuple of ``(left, bottom, width, height)`` in the given transform\n          (normalized axes coordinate if None)\n        - A tuple of ``(left, bottom)`` where the width and height will be\n          assumed to be zero.\n        \"\"\"\n        if bbox is None:\n            self._bbox_to_anchor = None\n            return\n        elif isinstance(bbox, BboxBase):\n            self._bbox_to_anchor = bbox\n        else:\n            try:\n                l = len(bbox)\n            except TypeError as err:\n                raise ValueError(\"Invalid argument for bbox : %s\" %\n                                 str(bbox)) from err\n\n            if l == 2:\n                bbox = [bbox[0], bbox[1], 0, 0]\n\n            self._bbox_to_anchor = Bbox.from_bounds(*bbox)\n\n        if transform is None:\n            transform = BboxTransformTo(self.parent.bbox)\n\n        self._bbox_to_anchor = TransformedBbox(self._bbox_to_anchor,\n                                               transform)\n        self.stale = True",
        "begin_line": 919,
        "end_line": 953,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend._get_anchored_bbox#955",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend._get_anchored_bbox(self, loc, bbox, parentbbox, renderer)",
        "snippet": "    def _get_anchored_bbox(self, loc, bbox, parentbbox, renderer):\n        \"\"\"\n        Place the *bbox* inside the *parentbbox* according to a given\n        location code. Return the (x, y) coordinate of the bbox.\n\n        - loc: a location code in range(1, 11).\n          This corresponds to the possible values for self._loc, excluding\n          \"best\".\n\n        - bbox: bbox to be placed, display coordinate units.\n        - parentbbox: a parent box which will contain the bbox. In\n            display coordinates.\n        \"\"\"\n        assert loc in range(1, 11)  # called only internally\n\n        BEST, UR, UL, LL, LR, R, CL, CR, LC, UC, C = range(11)\n\n        anchor_coefs = {UR: \"NE\",\n                        UL: \"NW\",\n                        LL: \"SW\",\n                        LR: \"SE\",\n                        R: \"E\",\n                        CL: \"W\",\n                        CR: \"E\",\n                        LC: \"S\",\n                        UC: \"N\",\n                        C: \"C\"}\n\n        c = anchor_coefs[loc]\n\n        fontsize = renderer.points_to_pixels(self._fontsize)\n        container = parentbbox.padded(-self.borderaxespad * fontsize)\n        anchored_box = bbox.anchored(c, container=container)\n        return anchored_box.x0, anchored_box.y0",
        "begin_line": 955,
        "end_line": 988,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.legend.Legend._find_best_position#990",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend.Legend",
        "signature": "lib.matplotlib.legend.Legend._find_best_position(self, width, height, renderer, consider=None)",
        "snippet": "    def _find_best_position(self, width, height, renderer, consider=None):\n        \"\"\"\n        Determine the best location to place the legend.\n\n        *consider* is a list of ``(x, y)`` pairs to consider as a potential\n        lower-left corner of the legend. All are display coords.\n        \"\"\"\n        assert self.isaxes  # always holds, as this is only called internally\n\n        start_time = time.perf_counter()\n\n        bboxes, lines, offsets = self._auto_legend_data()\n\n        bbox = Bbox.from_bounds(0, 0, width, height)\n        if consider is None:\n            consider = [self._get_anchored_bbox(x, bbox,\n                                                self.get_bbox_to_anchor(),\n                                                renderer)\n                        for x in range(1, len(self.codes))]\n\n        candidates = []\n        for idx, (l, b) in enumerate(consider):\n            legendBox = Bbox.from_bounds(l, b, width, height)\n            badness = 0\n            # XXX TODO: If markers are present, it would be good to take them\n            # into account when checking vertex overlaps in the next line.\n            badness = (sum(legendBox.count_contains(line.vertices)\n                           for line in lines)\n                       + legendBox.count_contains(offsets)\n                       + legendBox.count_overlaps(bboxes)\n                       + sum(line.intersects_bbox(legendBox, filled=False)\n                             for line in lines))\n            if badness == 0:\n                return l, b\n            # Include the index to favor lower codes in case of a tie.\n            candidates.append((badness, idx, (l, b)))\n\n        _, _, (l, b) = min(candidates)\n\n        if self._loc_used_default and time.perf_counter() - start_time > 1:\n            cbook._warn_external(\n                'Creating legend with loc=\"best\" can be slow with large '\n                'amounts of data.')\n\n        return l, b",
        "begin_line": 990,
        "end_line": 1034,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.legend._get_legend_handles#1082",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend",
        "signature": "lib.matplotlib.legend._get_legend_handles(axs, legend_handler_map=None)",
        "snippet": "def _get_legend_handles(axs, legend_handler_map=None):\n    \"\"\"\n    Return a generator of artists that can be used as handles in\n    a legend.\n\n    \"\"\"\n    handles_original = []\n    for ax in axs:\n        handles_original += (ax.lines + ax.patches +\n                             ax.collections + ax.containers)\n        # support parasite axes:\n        if hasattr(ax, 'parasites'):\n            for axx in ax.parasites:\n                handles_original += (axx.lines + axx.patches +\n                                     axx.collections + axx.containers)\n\n    handler_map = Legend.get_default_handler_map()\n\n    if legend_handler_map is not None:\n        handler_map = handler_map.copy()\n        handler_map.update(legend_handler_map)\n\n    has_handler = Legend.get_legend_handler\n\n    for handle in handles_original:\n        label = handle.get_label()\n        if label != '_nolegend_' and has_handler(handler_map, handle):\n            yield handle",
        "begin_line": 1082,
        "end_line": 1109,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005107252298263534,
            "pseudo_dstar_susp": 0.0004073319755600815,
            "pseudo_tarantula_susp": 0.0018726591760299626,
            "pseudo_op2_susp": 0.0004073319755600815,
            "pseudo_barinel_susp": 0.0018726591760299626
        }
    },
    {
        "name": "lib.matplotlib.legend._get_legend_handles_labels#1112",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend",
        "signature": "lib.matplotlib.legend._get_legend_handles_labels(axs, legend_handler_map=None)",
        "snippet": "def _get_legend_handles_labels(axs, legend_handler_map=None):\n    \"\"\"\n    Return handles and labels for legend, internal method.\n\n    \"\"\"\n    handles = []\n    labels = []\n\n    for handle in _get_legend_handles(axs, legend_handler_map):\n        label = handle.get_label()\n        if label and not label.startswith('_'):\n            handles.append(handle)\n            labels.append(label)\n    return handles, labels",
        "begin_line": 1112,
        "end_line": 1125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.legend._parse_legend_args#1128",
        "src_path": "lib/matplotlib/legend.py",
        "class_name": "lib.matplotlib.legend",
        "signature": "lib.matplotlib.legend._parse_legend_args(axs, *args, handles=None, labels=None, **kwargs)",
        "snippet": "def _parse_legend_args(axs, *args, handles=None, labels=None, **kwargs):\n    \"\"\"\n    Get the handles and labels from the calls to either ``figure.legend``\n    or ``axes.legend``.\n\n    ``axs`` is a list of axes (to get legend artists from)\n    \"\"\"\n    log = logging.getLogger(__name__)\n\n    handlers = kwargs.get('handler_map', {}) or {}\n    extra_args = ()\n\n    if (handles is not None or labels is not None) and args:\n        cbook._warn_external(\"You have mixed positional and keyword \"\n                             \"arguments, some input may be discarded.\")\n\n    # if got both handles and labels as kwargs, make same length\n    if handles and labels:\n        handles, labels = zip(*zip(handles, labels))\n\n    elif handles is not None and labels is None:\n        labels = [handle.get_label() for handle in handles]\n\n    elif labels is not None and handles is None:\n        # Get as many handles as there are labels.\n        handles = [handle for handle, label\n                   in zip(_get_legend_handles(axs, handlers), labels)]\n\n    # No arguments - automatically detect labels and handles.\n    elif len(args) == 0:\n        handles, labels = _get_legend_handles_labels(axs, handlers)\n        if not handles:\n            log.warning('No handles with labels found to put in legend.')\n\n    # One argument. User defined labels - automatic handle detection.\n    elif len(args) == 1:\n        labels, = args\n        # Get as many handles as there are labels.\n        handles = [handle for handle, label\n                   in zip(_get_legend_handles(axs, handlers), labels)]\n\n    # Two arguments:\n    #   * user defined handles and labels\n    elif len(args) >= 2:\n        handles, labels = args[:2]\n        extra_args = args[2:]\n\n    else:\n        raise TypeError('Invalid arguments to legend.')\n\n    return handles, labels, extra_args, kwargs",
        "begin_line": 1128,
        "end_line": 1178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000708215297450425,
            "pseudo_dstar_susp": 0.0004268032437046522,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0004268032437046522,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "lib.matplotlib.ticker.TickHelper.create_dummy_axis#225",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.TickHelper",
        "signature": "lib.matplotlib.ticker.TickHelper.create_dummy_axis(self, **kwargs)",
        "snippet": "    def create_dummy_axis(self, **kwargs):\n        if self.axis is None:\n            self.axis = _DummyAxis(**kwargs)",
        "begin_line": 225,
        "end_line": 227,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.876496534341525e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.TickHelper.set_view_interval#229",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.TickHelper",
        "signature": "lib.matplotlib.ticker.TickHelper.set_view_interval(self, vmin, vmax)",
        "snippet": "    def set_view_interval(self, vmin, vmax):\n        self.axis.set_view_interval(vmin, vmax)",
        "begin_line": 229,
        "end_line": 230,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.104980424292088e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.Formatter.format_ticks#255",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.Formatter",
        "signature": "lib.matplotlib.ticker.Formatter.format_ticks(self, values)",
        "snippet": "    def format_ticks(self, values):\n        \"\"\"Return the tick labels for all the ticks at once.\"\"\"\n        self.set_locs(values)\n        return [self(value, i) for i, value in enumerate(values)]",
        "begin_line": 255,
        "end_line": 258,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.73591333973967e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.Formatter.get_offset#275",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.Formatter",
        "signature": "lib.matplotlib.ticker.Formatter.get_offset(self)",
        "snippet": "    def get_offset(self):\n        return ''",
        "begin_line": 275,
        "end_line": 276,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.59762953958365e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.Formatter.set_locs#278",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.Formatter",
        "signature": "lib.matplotlib.ticker.Formatter.set_locs(self, locs)",
        "snippet": "    def set_locs(self, locs):\n        \"\"\"\n        Set the locations of the ticks.\n\n        This method is called before computing the tick labels because some\n        formatters need to know all tick locations to do so.\n        \"\"\"\n        self.locs = locs",
        "begin_line": 278,
        "end_line": 285,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.649770781074301e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter.__init__#482",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter.__init__(self, useOffset=None, useMathText=None, useLocale=None)",
        "snippet": "    def __init__(self, useOffset=None, useMathText=None, useLocale=None):\n        # useOffset allows plotting small data ranges with large offsets: for\n        # example: [1+1e-9, 1+2e-9, 1+3e-9] useMathText will render the offset\n        # and scientific notation in mathtext\n\n        if useOffset is None:\n            useOffset = mpl.rcParams['axes.formatter.useoffset']\n        self._offset_threshold = \\\n            mpl.rcParams['axes.formatter.offset_threshold']\n        self.set_useOffset(useOffset)\n        self._usetex = mpl.rcParams['text.usetex']\n        if useMathText is None:\n            useMathText = mpl.rcParams['axes.formatter.use_mathtext']\n        self.set_useMathText(useMathText)\n        self.orderOfMagnitude = 0\n        self.format = ''\n        self._scientific = True\n        self._powerlimits = mpl.rcParams['axes.formatter.limits']\n        if useLocale is None:\n            useLocale = mpl.rcParams['axes.formatter.use_locale']\n        self._useLocale = useLocale",
        "begin_line": 482,
        "end_line": 502,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001430615164520744,
            "pseudo_dstar_susp": 0.0009285051067780873,
            "pseudo_tarantula_susp": 0.0008305647840531562,
            "pseudo_op2_susp": 0.0009285051067780873,
            "pseudo_barinel_susp": 0.0008305647840531562
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter.__call__#539",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter.__call__(self, x, pos=None)",
        "snippet": "    def __call__(self, x, pos=None):\n        \"\"\"\n        Return the format for tick value *x* at position *pos*.\n        \"\"\"\n        if len(self.locs) == 0:\n            return ''\n        else:\n            xp = (x - self.offset) / (10. ** self.orderOfMagnitude)\n            if abs(xp) < 1e-8:\n                xp = 0\n            if self._useLocale:\n                s = locale.format_string(self.format, (xp,))\n            else:\n                s = self.format % xp\n            return self.fix_minus(s)",
        "begin_line": 539,
        "end_line": 553,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002962962962962963,
            "pseudo_dstar_susp": 0.0002959455460195324,
            "pseudo_tarantula_susp": 0.00030902348578491963,
            "pseudo_op2_susp": 0.0002959455460195324,
            "pseudo_barinel_susp": 0.00030902348578491963
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter.format_data_short#588",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter.format_data_short(self, value)",
        "snippet": "    def format_data_short(self, value):\n        # docstring inherited\n        return (\n            \"\" if isinstance(value, np.ma.MaskedArray) and value.mask else\n            self.fix_minus(\n                locale.format_string(\"%-12g\", (value,)) if self._useLocale else\n                \"%-12g\" % value))",
        "begin_line": 588,
        "end_line": 594,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter.format_data#596",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter.format_data(self, value)",
        "snippet": "    def format_data(self, value):\n        # docstring inherited\n        if self._useLocale:\n            s = locale.format_string('%1.10e', (value,))\n        else:\n            s = '%1.10e' % value\n        s = self._formatSciNotation(s)\n        return self.fix_minus(s)",
        "begin_line": 596,
        "end_line": 603,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter.get_offset#605",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter.get_offset(self)",
        "snippet": "    def get_offset(self):\n        \"\"\"\n        Return scientific notation, plus offset.\n        \"\"\"\n        if len(self.locs) == 0:\n            return ''\n        s = ''\n        if self.orderOfMagnitude or self.offset:\n            offsetStr = ''\n            sciNotStr = ''\n            if self.offset:\n                offsetStr = self.format_data(self.offset)\n                if self.offset > 0:\n                    offsetStr = '+' + offsetStr\n            if self.orderOfMagnitude:\n                if self._usetex or self._useMathText:\n                    sciNotStr = self.format_data(10 ** self.orderOfMagnitude)\n                else:\n                    sciNotStr = '1e%d' % self.orderOfMagnitude\n            if self._useMathText or self._usetex:\n                if sciNotStr != '':\n                    sciNotStr = r'\\times\\mathdefault{%s}' % sciNotStr\n                s = r'$%s\\mathdefault{%s}$' % (sciNotStr, offsetStr)\n            else:\n                s = ''.join((sciNotStr, offsetStr))\n\n        return self.fix_minus(s)",
        "begin_line": 605,
        "end_line": 631,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter.set_locs#633",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter.set_locs(self, locs)",
        "snippet": "    def set_locs(self, locs):\n        # docstring inherited\n        self.locs = locs\n        if len(self.locs) > 0:\n            if self._useOffset:\n                self._compute_offset()\n            self._set_order_of_magnitude()\n            self._set_format()",
        "begin_line": 633,
        "end_line": 640,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003181673560292714,
            "pseudo_dstar_susp": 0.0003116235587410408,
            "pseudo_tarantula_susp": 0.0003636363636363636,
            "pseudo_op2_susp": 0.0003116235587410408,
            "pseudo_barinel_susp": 0.0003636363636363636
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter._compute_offset#642",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter._compute_offset(self)",
        "snippet": "    def _compute_offset(self):\n        locs = self.locs\n        # Restrict to visible ticks.\n        vmin, vmax = sorted(self.axis.get_view_interval())\n        locs = np.asarray(locs)\n        locs = locs[(vmin <= locs) & (locs <= vmax)]\n        if not len(locs):\n            self.offset = 0\n            return\n        lmin, lmax = locs.min(), locs.max()\n        # Only use offset if there are at least two ticks and every tick has\n        # the same sign.\n        if lmin == lmax or lmin <= 0 <= lmax:\n            self.offset = 0\n            return\n        # min, max comparing absolute values (we want division to round towards\n        # zero so we work on absolute values).\n        abs_min, abs_max = sorted([abs(float(lmin)), abs(float(lmax))])\n        sign = math.copysign(1, lmin)\n        # What is the smallest power of ten such that abs_min and abs_max are\n        # equal up to that precision?\n        # Note: Internally using oom instead of 10 ** oom avoids some numerical\n        # accuracy issues.\n        oom_max = np.ceil(math.log10(abs_max))\n        oom = 1 + next(oom for oom in itertools.count(oom_max, -1)\n                       if abs_min // 10 ** oom != abs_max // 10 ** oom)\n        if (abs_max - abs_min) / 10 ** oom <= 1e-2:\n            # Handle the case of straddling a multiple of a large power of ten\n            # (relative to the span).\n            # What is the smallest power of ten such that abs_min and abs_max\n            # are no more than 1 apart at that precision?\n            oom = 1 + next(oom for oom in itertools.count(oom_max, -1)\n                           if abs_max // 10 ** oom - abs_min // 10 ** oom > 1)\n        # Only use offset if it saves at least _offset_threshold digits.\n        n = self._offset_threshold - 1\n        self.offset = (sign * (abs_max // 10 ** oom) * 10 ** oom\n                       if abs_max // 10 ** oom >= 10**n\n                       else 0)",
        "begin_line": 642,
        "end_line": 679,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004752851711026616,
            "pseudo_dstar_susp": 0.00040241448692152917,
            "pseudo_tarantula_susp": 0.0017482517482517483,
            "pseudo_op2_susp": 0.00040241448692152917,
            "pseudo_barinel_susp": 0.0017482517482517483
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter._set_order_of_magnitude#681",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter._set_order_of_magnitude(self)",
        "snippet": "    def _set_order_of_magnitude(self):\n        # if scientific notation is to be used, find the appropriate exponent\n        # if using an numerical offset, find the exponent after applying the\n        # offset. When lower power limit = upper <> 0, use provided exponent.\n        if not self._scientific:\n            self.orderOfMagnitude = 0\n            return\n        if self._powerlimits[0] == self._powerlimits[1] != 0:\n            # fixed scaling when lower power limit = upper <> 0.\n            self.orderOfMagnitude = self._powerlimits[0]\n            return\n        # restrict to visible ticks\n        vmin, vmax = sorted(self.axis.get_view_interval())\n        locs = np.asarray(self.locs)\n        locs = locs[(vmin <= locs) & (locs <= vmax)]\n        locs = np.abs(locs)\n        if not len(locs):\n            self.orderOfMagnitude = 0\n            return\n        if self.offset:\n            oom = math.floor(math.log10(vmax - vmin))\n        else:\n            if locs[0] > locs[-1]:\n                val = locs[0]\n            else:\n                val = locs[-1]\n            if val == 0:\n                oom = 0\n            else:\n                oom = math.floor(math.log10(val))\n        if oom <= self._powerlimits[0]:\n            self.orderOfMagnitude = oom\n        elif oom >= self._powerlimits[1]:\n            self.orderOfMagnitude = oom\n        else:\n            self.orderOfMagnitude = 0",
        "begin_line": 681,
        "end_line": 716,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.ScalarFormatter._set_format#718",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.ScalarFormatter",
        "signature": "lib.matplotlib.ticker.ScalarFormatter._set_format(self)",
        "snippet": "    def _set_format(self):\n        # set the format string to format all the ticklabels\n        if len(self.locs) < 2:\n            # Temporarily augment the locations with the axis end points.\n            _locs = [*self.locs, *self.axis.get_view_interval()]\n        else:\n            _locs = self.locs\n        locs = (np.asarray(_locs) - self.offset) / 10. ** self.orderOfMagnitude\n        loc_range = np.ptp(locs)\n        # Curvilinear coordinates can yield two identical points.\n        if loc_range == 0:\n            loc_range = np.max(np.abs(locs))\n        # Both points might be zero.\n        if loc_range == 0:\n            loc_range = 1\n        if len(self.locs) < 2:\n            # We needed the end points only for the loc_range calculation.\n            locs = locs[:-2]\n        loc_range_oom = int(math.floor(math.log10(loc_range)))\n        # first estimate:\n        sigfigs = max(0, 3 - loc_range_oom)\n        # refined estimate:\n        thresh = 1e-3 * 10 ** loc_range_oom\n        while sigfigs >= 0:\n            if np.abs(locs - np.round(locs, decimals=sigfigs)).max() < thresh:\n                sigfigs -= 1\n            else:\n                break\n        sigfigs += 1\n        self.format = '%1.' + str(sigfigs) + 'f'\n        if self._usetex or self._useMathText:\n            self.format = r'$\\mathdefault{%s}$' % self.format",
        "begin_line": 718,
        "end_line": 749,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.375910880308233e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogFormatter.__init__#839",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogFormatter",
        "signature": "lib.matplotlib.ticker.LogFormatter.__init__(self, base=10.0, labelOnlyBase=False, minor_thresholds=None, linthresh=None)",
        "snippet": "    def __init__(self, base=10.0, labelOnlyBase=False,\n                 minor_thresholds=None,\n                 linthresh=None):\n\n        self._base = float(base)\n        self.labelOnlyBase = labelOnlyBase\n        if minor_thresholds is None:\n            if mpl.rcParams['_internal.classic_mode']:\n                minor_thresholds = (0, 0)\n            else:\n                minor_thresholds = (1, 0.4)\n        self.minor_thresholds = minor_thresholds\n        self._sublabels = None\n        self._linthresh = linthresh",
        "begin_line": 839,
        "end_line": 852,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogFormatter.set_locs#876",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogFormatter",
        "signature": "lib.matplotlib.ticker.LogFormatter.set_locs(self, locs=None)",
        "snippet": "    def set_locs(self, locs=None):\n        \"\"\"\n        Use axis view limits to control which ticks are labeled.\n\n        The *locs* parameter is ignored in the present algorithm.\n\n        \"\"\"\n        if np.isinf(self.minor_thresholds[0]):\n            self._sublabels = None\n            return\n\n        # Handle symlog case:\n        linthresh = self._linthresh\n        if linthresh is None:\n            try:\n                linthresh = self.axis.get_transform().linthresh\n            except AttributeError:\n                pass\n\n        vmin, vmax = self.axis.get_view_interval()\n        if vmin > vmax:\n            vmin, vmax = vmax, vmin\n\n        if linthresh is None and vmin <= 0:\n            # It's probably a colorbar with\n            # a format kwarg setting a LogFormatter in the manner\n            # that worked with 1.5.x, but that doesn't work now.\n            self._sublabels = {1}  # label powers of base\n            return\n\n        b = self._base\n        if linthresh is not None:  # symlog\n            # Only compute the number of decades in the logarithmic part of the\n            # axis\n            numdec = 0\n            if vmin < -linthresh:\n                rhs = min(vmax, -linthresh)\n                numdec += math.log(vmin / rhs) / math.log(b)\n            if vmax > linthresh:\n                lhs = max(vmin, linthresh)\n                numdec += math.log(vmax / lhs) / math.log(b)\n        else:\n            vmin = math.log(vmin) / math.log(b)\n            vmax = math.log(vmax) / math.log(b)\n            numdec = abs(vmax - vmin)\n\n        if numdec > self.minor_thresholds[0]:\n            # Label only bases\n            self._sublabels = {1}\n        elif numdec > self.minor_thresholds[1]:\n            # Add labels between bases at log-spaced coefficients;\n            # include base powers in case the locations include\n            # \"major\" and \"minor\" points, as in colorbar.\n            c = np.geomspace(1, b, int(b)//2 + 1)\n            self._sublabels = set(np.round(c))\n            # For base 10, this yields (1, 2, 3, 4, 6, 10).\n        else:\n            # Label all integer multiples of base**n.\n            self._sublabels = set(np.arange(1, b + 1))",
        "begin_line": 876,
        "end_line": 934,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogFormatter.__call__#945",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogFormatter",
        "signature": "lib.matplotlib.ticker.LogFormatter.__call__(self, x, pos=None)",
        "snippet": "    def __call__(self, x, pos=None):\n        \"\"\"\n        Return the format for tick val *x*.\n        \"\"\"\n        if x == 0.0:  # Symlog\n            return '0'\n\n        x = abs(x)\n        b = self._base\n        # only label the decades\n        fx = math.log(x) / math.log(b)\n        is_x_decade = is_close_to_int(fx)\n        exponent = round(fx) if is_x_decade else np.floor(fx)\n        coeff = round(x / b ** exponent)\n\n        if self.labelOnlyBase and not is_x_decade:\n            return ''\n        if self._sublabels is not None and coeff not in self._sublabels:\n            return ''\n\n        vmin, vmax = self.axis.get_view_interval()\n        vmin, vmax = mtransforms.nonsingular(vmin, vmax, expander=0.05)\n        s = self._num_to_string(x, vmin, vmax)\n        return s",
        "begin_line": 945,
        "end_line": 968,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.154155986818015e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogFormatter._pprint_val#981",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogFormatter",
        "signature": "lib.matplotlib.ticker.LogFormatter._pprint_val(self, x, d)",
        "snippet": "    def _pprint_val(self, x, d):\n        # If the number is not too big and it's an int, format it as an int.\n        if abs(x) < 1e4 and x == int(x):\n            return '%d' % x\n        fmt = ('%1.3e' if d < 1e-2 else\n               '%1.3f' if d <= 1 else\n               '%1.2f' if d <= 10 else\n               '%1.1f' if d <= 1e5 else\n               '%1.1e')\n        s = fmt % x\n        tup = s.split('e')\n        if len(tup) == 2:\n            mantissa = tup[0].rstrip('0').rstrip('.')\n            exponent = int(tup[1])\n            if exponent:\n                s = '%se%d' % (mantissa, exponent)\n            else:\n                s = mantissa\n        else:\n            s = s.rstrip('0').rstrip('.')\n        return s",
        "begin_line": 981,
        "end_line": 1001,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogFormatterExponent._num_to_string#1008",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogFormatterExponent",
        "signature": "lib.matplotlib.ticker.LogFormatterExponent._num_to_string(self, x, vmin, vmax)",
        "snippet": "    def _num_to_string(self, x, vmin, vmax):\n        fx = math.log(x) / math.log(self._base)\n        if abs(fx) > 10000:\n            s = '%1.0g' % fx\n        elif abs(fx) < 1:\n            s = '%1.0g' % fx\n        else:\n            fd = math.log(vmax - vmin) / math.log(self._base)\n            s = self._pprint_val(fx, fd)\n        return s",
        "begin_line": 1008,
        "end_line": 1017,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogFormatterMathtext.__call__#1029",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogFormatterMathtext",
        "signature": "lib.matplotlib.ticker.LogFormatterMathtext.__call__(self, x, pos=None)",
        "snippet": "    def __call__(self, x, pos=None):\n        \"\"\"\n        Return the format for tick value *x*.\n\n        The position *pos* is ignored.\n        \"\"\"\n        usetex = mpl.rcParams['text.usetex']\n        min_exp = mpl.rcParams['axes.formatter.min_exponent']\n\n        if x == 0:  # Symlog\n            return r'$\\mathdefault{0}$'\n\n        sign_string = '-' if x < 0 else ''\n        x = abs(x)\n        b = self._base\n\n        # only label the decades\n        fx = math.log(x) / math.log(b)\n        is_x_decade = is_close_to_int(fx)\n        exponent = round(fx) if is_x_decade else np.floor(fx)\n        coeff = round(x / b ** exponent)\n        if is_x_decade:\n            fx = round(fx)\n\n        if self.labelOnlyBase and not is_x_decade:\n            return ''\n        if self._sublabels is not None and coeff not in self._sublabels:\n            return ''\n\n        # use string formatting of the base if it is not an integer\n        if b % 1 == 0.0:\n            base = '%d' % b\n        else:\n            base = '%s' % b\n\n        if abs(fx) < min_exp:\n            return r'$\\mathdefault{%s%g}$' % (sign_string, x)\n        elif not is_x_decade:\n            return self._non_decade_format(sign_string, base, fx, usetex)\n        else:\n            return r'$\\mathdefault{%s%s^{%d}}$' % (sign_string, base, fx)",
        "begin_line": 1029,
        "end_line": 1069,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogFormatterSciNotation._non_decade_format#1077",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogFormatterSciNotation",
        "signature": "lib.matplotlib.ticker.LogFormatterSciNotation._non_decade_format(self, sign_string, base, fx, usetex)",
        "snippet": "    def _non_decade_format(self, sign_string, base, fx, usetex):\n        \"\"\"Return string for non-decade locations.\"\"\"\n        b = float(base)\n        exponent = math.floor(fx)\n        coeff = b ** fx / b ** exponent\n        if is_close_to_int(coeff):\n            coeff = round(coeff)\n        return r'$\\mathdefault{%s%g\\times%s^{%d}}$' \\\n            % (sign_string, coeff, base, exponent)",
        "begin_line": 1077,
        "end_line": 1085,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitFormatter.set_one_half#1145",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitFormatter",
        "signature": "lib.matplotlib.ticker.LogitFormatter.set_one_half(self, one_half)",
        "snippet": "    def set_one_half(self, one_half):\n        r\"\"\"\n        Set the way one half is displayed.\n\n        one_half : str, default: r\"\\frac{1}{2}\"\n            The string used to represent 1/2.\n        \"\"\"\n        self._one_half = one_half",
        "begin_line": 1145,
        "end_line": 1152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitFormatter.set_locs#1179",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitFormatter",
        "signature": "lib.matplotlib.ticker.LogitFormatter.set_locs(self, locs)",
        "snippet": "    def set_locs(self, locs):\n        self.locs = np.array(locs)\n        self._labelled.clear()\n\n        if not self._minor:\n            return None\n        if all(\n            is_decade(x, rtol=1e-7)\n            or is_decade(1 - x, rtol=1e-7)\n            or (is_close_to_int(2 * x) and int(np.round(2 * x)) == 1)\n            for x in locs\n        ):\n            # minor ticks are subsample from ideal, so no label\n            return None\n        if len(locs) < self._minor_threshold:\n            if len(locs) < self._minor_number:\n                self._labelled.update(locs)\n            else:\n                # we do not have a lot of minor ticks, so only few decades are\n                # displayed, then we choose some (spaced) minor ticks to label.\n                # Only minor ticks are known, we assume it is sufficient to\n                # choice which ticks are displayed.\n                # For each ticks we compute the distance between the ticks and\n                # the previous, and between the ticks and the next one. Ticks\n                # with smallest minimum are chosen. As tiebreak, the ticks\n                # with smallest sum is chosen.\n                diff = np.diff(-np.log(1 / self.locs - 1))\n                space_pessimistic = np.minimum(\n                    np.concatenate(((np.inf,), diff)),\n                    np.concatenate((diff, (np.inf,))),\n                )\n                space_sum = (\n                    np.concatenate(((0,), diff))\n                    + np.concatenate((diff, (0,)))\n                )\n                good_minor = sorted(\n                    range(len(self.locs)),\n                    key=lambda i: (space_pessimistic[i], space_sum[i]),\n                )[-self._minor_number:]\n                self._labelled.update(locs[i] for i in good_minor)",
        "begin_line": 1179,
        "end_line": 1218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitFormatter._format_value#1220",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitFormatter",
        "signature": "lib.matplotlib.ticker.LogitFormatter._format_value(self, x, locs, sci_notation=True)",
        "snippet": "    def _format_value(self, x, locs, sci_notation=True):\n        if sci_notation:\n            exponent = math.floor(np.log10(x))\n            min_precision = 0\n        else:\n            exponent = 0\n            min_precision = 1\n        value = x * 10 ** (-exponent)\n        if len(locs) < 2:\n            precision = min_precision\n        else:\n            diff = np.sort(np.abs(locs - x))[1]\n            precision = -np.log10(diff) + exponent\n            precision = (\n                int(np.round(precision))\n                if is_close_to_int(precision)\n                else math.ceil(precision)\n            )\n            if precision < min_precision:\n                precision = min_precision\n        mantissa = r\"%.*f\" % (precision, value)\n        if not sci_notation:\n            return mantissa\n        s = r\"%s\\cdot10^{%d}\" % (mantissa, exponent)\n        return s",
        "begin_line": 1220,
        "end_line": 1244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitFormatter._one_minus#1246",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitFormatter",
        "signature": "lib.matplotlib.ticker.LogitFormatter._one_minus(self, s)",
        "snippet": "    def _one_minus(self, s):\n        if self._use_overline:\n            return r\"\\overline{%s}\" % s\n        else:\n            return \"1-{}\".format(s)",
        "begin_line": 1246,
        "end_line": 1250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.530162965786715e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitFormatter.__call__#1252",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitFormatter",
        "signature": "lib.matplotlib.ticker.LogitFormatter.__call__(self, x, pos=None)",
        "snippet": "    def __call__(self, x, pos=None):\n        if self._minor and x not in self._labelled:\n            return \"\"\n        if x <= 0 or x >= 1:\n            return \"\"\n        if is_close_to_int(2 * x) and round(2 * x) == 1:\n            s = self._one_half\n        elif x < 0.5 and is_decade(x, rtol=1e-7):\n            exponent = round(np.log10(x))\n            s = \"10^{%d}\" % exponent\n        elif x > 0.5 and is_decade(1 - x, rtol=1e-7):\n            exponent = round(np.log10(1 - x))\n            s = self._one_minus(\"10^{%d}\" % exponent)\n        elif x < 0.1:\n            s = self._format_value(x, self.locs)\n        elif x > 0.9:\n            s = self._one_minus(self._format_value(1-x, 1-self.locs))\n        else:\n            s = self._format_value(x, self.locs, sci_notation=False)\n        return r\"$\\mathdefault{%s}$\" % s",
        "begin_line": 1252,
        "end_line": 1271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitFormatter.format_data_short#1273",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitFormatter",
        "signature": "lib.matplotlib.ticker.LogitFormatter.format_data_short(self, value)",
        "snippet": "    def format_data_short(self, value):\n        \"\"\"\n        Return a short formatted string representation of a number.\n        \"\"\"\n        # thresholds choosen for use scienfic notation if and only if exponent\n        # is less or equal than -2.\n        if value < 0.1:\n            return \"{:e}\".format(value)\n        if value < 0.9:\n            return \"{:f}\".format(value)\n        return \"1-{:e}\".format(1 - value)",
        "begin_line": 1273,
        "end_line": 1283,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.EngFormatter.__init__#1313",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.EngFormatter",
        "signature": "lib.matplotlib.ticker.EngFormatter.__init__(self, unit='', places=None, sep=' ', *, usetex=None, useMathText=None)",
        "snippet": "    def __init__(self, unit=\"\", places=None, sep=\" \", *, usetex=None,\n                 useMathText=None):\n        r\"\"\"\n        Parameters\n        ----------\n        unit : str, default: \"\"\n            Unit symbol to use, suitable for use with single-letter\n            representations of powers of 1000. For example, 'Hz' or 'm'.\n\n        places : int, default: None\n            Precision with which to display the number, specified in\n            digits after the decimal point (there will be between one\n            and three digits before the decimal point). If it is None,\n            the formatting falls back to the floating point format '%g',\n            which displays up to 6 *significant* digits, i.e. the equivalent\n            value for *places* varies between 0 and 5 (inclusive).\n\n        sep : str, default: \" \"\n            Separator used between the value and the prefix/unit. For\n            example, one get '3.14 mV' if ``sep`` is \" \" (default) and\n            '3.14mV' if ``sep`` is \"\". Besides the default behavior, some\n            other useful options may be:\n\n            * ``sep=\"\"`` to append directly the prefix/unit to the value;\n            * ``sep=\"\\N{THIN SPACE}\"`` (``U+2009``);\n            * ``sep=\"\\N{NARROW NO-BREAK SPACE}\"`` (``U+202F``);\n            * ``sep=\"\\N{NO-BREAK SPACE}\"`` (``U+00A0``).\n\n        usetex : bool, default: :rc:`text.usetex`\n            To enable/disable the use of TeX's math mode for rendering the\n            numbers in the formatter.\n\n        useMathText : bool, default: :rc:`axes.formatter.use_mathtext`\n            To enable/disable the use mathtext for rendering the numbers in\n            the formatter.\n        \"\"\"\n        self.unit = unit\n        self.places = places\n        self.sep = sep\n        self.set_usetex(usetex)\n        self.set_useMathText(useMathText)",
        "begin_line": 1313,
        "end_line": 1353,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.872327211427557e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.EngFormatter.set_useMathText#1369",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.EngFormatter",
        "signature": "lib.matplotlib.ticker.EngFormatter.set_useMathText(self, val)",
        "snippet": "    def set_useMathText(self, val):\n        if val is None:\n            self._useMathText = mpl.rcParams['axes.formatter.use_mathtext']\n        else:\n            self._useMathText = val",
        "begin_line": 1369,
        "end_line": 1373,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.EngFormatter.__call__#1377",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.EngFormatter",
        "signature": "lib.matplotlib.ticker.EngFormatter.__call__(self, x, pos=None)",
        "snippet": "    def __call__(self, x, pos=None):\n        s = \"%s%s\" % (self.format_eng(x), self.unit)\n        # Remove the trailing separator when there is neither prefix nor unit\n        if self.sep and s.endswith(self.sep):\n            s = s[:-len(self.sep)]\n        return self.fix_minus(s)",
        "begin_line": 1377,
        "end_line": 1382,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.EngFormatter.format_eng#1384",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.EngFormatter",
        "signature": "lib.matplotlib.ticker.EngFormatter.format_eng(self, num)",
        "snippet": "    def format_eng(self, num):\n        \"\"\"\n        Formats a number in engineering notation, appending a letter\n        representing the power of 1000 of the original number.\n        Some examples:\n\n        >>> format_eng(0)       # for self.places = 0\n        '0'\n\n        >>> format_eng(1000000) # for self.places = 1\n        '1.0 M'\n\n        >>> format_eng(\"-1e-6\") # for self.places = 2\n        '-1.00 \\N{MICRO SIGN}'\n        \"\"\"\n        sign = 1\n        fmt = \"g\" if self.places is None else \".{:d}f\".format(self.places)\n\n        if num < 0:\n            sign = -1\n            num = -num\n\n        if num != 0:\n            pow10 = int(math.floor(math.log10(num) / 3) * 3)\n        else:\n            pow10 = 0\n            # Force num to zero, to avoid inconsistencies like\n            # format_eng(-0) = \"0\" and format_eng(0.0) = \"0\"\n            # but format_eng(-0.0) = \"-0.0\"\n            num = 0.0\n\n        pow10 = np.clip(pow10, min(self.ENG_PREFIXES), max(self.ENG_PREFIXES))\n\n        mant = sign * num / (10.0 ** pow10)\n        # Taking care of the cases like 999.9..., which may be rounded to 1000\n        # instead of 1 k.  Beware of the corner case of values that are beyond\n        # the range of SI prefixes (i.e. > 'Y').\n        if (abs(float(format(mant, fmt))) >= 1000\n                and pow10 < max(self.ENG_PREFIXES)):\n            mant /= 1000\n            pow10 += 3\n\n        prefix = self.ENG_PREFIXES[int(pow10)]\n        if self._usetex or self._useMathText:\n            formatted = \"${mant:{fmt}}${sep}{prefix}\".format(\n                mant=mant, sep=self.sep, prefix=prefix, fmt=fmt)\n        else:\n            formatted = \"{mant:{fmt}}{sep}{prefix}\".format(\n                mant=mant, sep=self.sep, prefix=prefix, fmt=fmt)\n\n        return formatted",
        "begin_line": 1384,
        "end_line": 1434,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.PercentFormatter.format_pct#1478",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.PercentFormatter",
        "signature": "lib.matplotlib.ticker.PercentFormatter.format_pct(self, x, display_range)",
        "snippet": "    def format_pct(self, x, display_range):\n        \"\"\"\n        Formats the number as a percentage number with the correct\n        number of decimals and adds the percent symbol, if any.\n\n        If ``self.decimals`` is `None`, the number of digits after the\n        decimal point is set based on the *display_range* of the axis\n        as follows:\n\n        +---------------+----------+------------------------+\n        | display_range | decimals |          sample        |\n        +---------------+----------+------------------------+\n        | >50           |     0    | ``x = 34.5`` => 35%    |\n        +---------------+----------+------------------------+\n        | >5            |     1    | ``x = 34.5`` => 34.5%  |\n        +---------------+----------+------------------------+\n        | >0.5          |     2    | ``x = 34.5`` => 34.50% |\n        +---------------+----------+------------------------+\n        |      ...      |    ...   |          ...           |\n        +---------------+----------+------------------------+\n\n        This method will not be very good for tiny axis ranges or\n        extremely large ones. It assumes that the values on the chart\n        are percentages displayed on a reasonable scale.\n        \"\"\"\n        x = self.convert_to_pct(x)\n        if self.decimals is None:\n            # conversion works because display_range is a difference\n            scaled_range = self.convert_to_pct(display_range)\n            if scaled_range <= 0:\n                decimals = 0\n            else:\n                # Luckily Python's built-in ceil rounds to +inf, not away from\n                # zero. This is very important since the equation for decimals\n                # starts out as `scaled_range > 0.5 * 10**(2 - decimals)`\n                # and ends up with `decimals > 2 - log10(2 * scaled_range)`.\n                decimals = math.ceil(2.0 - math.log10(2.0 * scaled_range))\n                if decimals > 5:\n                    decimals = 5\n                elif decimals < 0:\n                    decimals = 0\n        else:\n            decimals = self.decimals\n        s = '{x:0.{decimals}f}'.format(x=x, decimals=int(decimals))\n\n        return s + self.symbol",
        "begin_line": 1478,
        "end_line": 1523,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.PercentFormatter.convert_to_pct#1525",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.PercentFormatter",
        "signature": "lib.matplotlib.ticker.PercentFormatter.convert_to_pct(self, x)",
        "snippet": "    def convert_to_pct(self, x):\n        return 100.0 * (x / self.xmax)",
        "begin_line": 1525,
        "end_line": 1526,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.154155986818015e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.PercentFormatter.symbol#1529",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.PercentFormatter",
        "signature": "lib.matplotlib.ticker.PercentFormatter.symbol(self)",
        "snippet": "    def symbol(self):\n        r\"\"\"\n        The configured percent symbol as a string.\n\n        If LaTeX is enabled via :rc:`text.usetex`, the special characters\n        ``{'#', '$', '%', '&', '~', '_', '^', '\\', '{', '}'}`` are\n        automatically escaped in the string.\n        \"\"\"\n        symbol = self._symbol\n        if not symbol:\n            symbol = ''\n        elif mpl.rcParams['text.usetex'] and not self._is_latex:\n            # Source: http://www.personal.ceu.hu/tex/specchar.htm\n            # Backslash must be first for this to work correctly since\n            # it keeps getting added in\n            for spec in r'\\#$%&~_^{}':\n                symbol = symbol.replace(spec, '\\\\' + spec)\n        return symbol",
        "begin_line": 1529,
        "end_line": 1546,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.Locator.raise_if_exceeds#1600",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.Locator",
        "signature": "lib.matplotlib.ticker.Locator.raise_if_exceeds(self, locs)",
        "snippet": "    def raise_if_exceeds(self, locs):\n        \"\"\"\n        Log at WARNING level if *locs* is longer than `Locator.MAXTICKS`.\n\n        This is intended to be called immediately before returning *locs* from\n        ``__call__`` to inform users in case their Locator returns a huge\n        number of ticks, causing Matplotlib to run out of memory.\n\n        The \"strange\" name of this method dates back to when it would raise an\n        exception instead of emitting a log.\n        \"\"\"\n        if len(locs) >= self.MAXTICKS:\n            _log.warning(\n                \"Locator attempting to generate %s ticks ([%s, ..., %s]), \"\n                \"which exceeds Locator.MAXTICKS (%s).\",\n                len(locs), locs[0], locs[-1], self.MAXTICKS)\n        return locs",
        "begin_line": 1600,
        "end_line": 1616,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003812428516965307,
            "pseudo_dstar_susp": 0.00035198873636043646,
            "pseudo_tarantula_susp": 0.0007564296520423601,
            "pseudo_op2_susp": 0.00035198873636043646,
            "pseudo_barinel_susp": 0.0007564296520423601
        }
    },
    {
        "name": "lib.matplotlib.ticker.Locator.nonsingular#1618",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.Locator",
        "signature": "lib.matplotlib.ticker.Locator.nonsingular(self, v0, v1)",
        "snippet": "    def nonsingular(self, v0, v1):\n        \"\"\"\n        Adjust a range as needed to avoid singularities.\n\n        This method gets called during autoscaling, with ``(v0, v1)`` set to\n        the data limits on the axes if the axes contains any data, or\n        ``(-inf, +inf)`` if not.\n\n        - If ``v0 == v1`` (possibly up to some floating point slop), this\n          method returns an expanded interval around this value.\n        - If ``(v0, v1) == (-inf, +inf)``, this method returns appropriate\n          default view limits.\n        - Otherwise, ``(v0, v1)`` is returned without modification.\n        \"\"\"\n        return mtransforms.nonsingular(v0, v1, expander=.05)",
        "begin_line": 1618,
        "end_line": 1632,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004923682914820286,
            "pseudo_dstar_susp": 0.0005402485143165856,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.0005402485143165856,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.ticker.Locator.view_limits#1634",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.Locator",
        "signature": "lib.matplotlib.ticker.Locator.view_limits(self, vmin, vmax)",
        "snippet": "    def view_limits(self, vmin, vmax):\n        \"\"\"\n        Select a scale for the range from vmin to vmax.\n\n        Subclasses should override this method to change locator behaviour.\n        \"\"\"\n        return mtransforms.nonsingular(vmin, vmax)",
        "begin_line": 1634,
        "end_line": 1640,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.IndexLocator.__init__#1687",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.IndexLocator",
        "signature": "lib.matplotlib.ticker.IndexLocator.__init__(self, base, offset)",
        "snippet": "    def __init__(self, base, offset):\n        \"\"\"Place ticks every *base* data point, starting at *offset*.\"\"\"\n        self._base = base\n        self.offset = offset",
        "begin_line": 1687,
        "end_line": 1690,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.IndexLocator.set_params#1692",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.IndexLocator",
        "signature": "lib.matplotlib.ticker.IndexLocator.set_params(self, base=None, offset=None)",
        "snippet": "    def set_params(self, base=None, offset=None):\n        \"\"\"Set parameters within this locator\"\"\"\n        if base is not None:\n            self._base = base\n        if offset is not None:\n            self.offset = offset",
        "begin_line": 1692,
        "end_line": 1697,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.FixedLocator.__init__#1720",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.FixedLocator",
        "signature": "lib.matplotlib.ticker.FixedLocator.__init__(self, locs, nbins=None)",
        "snippet": "    def __init__(self, locs, nbins=None):\n        self.locs = np.asarray(locs)\n        self.nbins = max(nbins, 2) if nbins is not None else None",
        "begin_line": 1720,
        "end_line": 1722,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.FixedLocator.set_params#1724",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.FixedLocator",
        "signature": "lib.matplotlib.ticker.FixedLocator.set_params(self, nbins=None)",
        "snippet": "    def set_params(self, nbins=None):\n        \"\"\"Set parameters within this locator.\"\"\"\n        if nbins is not None:\n            self.nbins = nbins",
        "begin_line": 1724,
        "end_line": 1727,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.FixedLocator.__call__#1729",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.FixedLocator",
        "signature": "lib.matplotlib.ticker.FixedLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        return self.tick_values(None, None)",
        "begin_line": 1729,
        "end_line": 1730,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.FixedLocator.tick_values#1732",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.FixedLocator",
        "signature": "lib.matplotlib.ticker.FixedLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        \"\"\"\n        Return the locations of the ticks.\n\n        .. note::\n\n            Because the values are fixed, vmin and vmax are not used in this\n            method.\n\n        \"\"\"\n        if self.nbins is None:\n            return self.locs\n        step = max(int(np.ceil(len(self.locs) / self.nbins)), 1)\n        ticks = self.locs[::step]\n        for i in range(1, step):\n            ticks1 = self.locs[i::step]\n            if np.abs(ticks1).min() < np.abs(ticks).min():\n                ticks = ticks1\n        return self.raise_if_exceeds(ticks)",
        "begin_line": 1732,
        "end_line": 1750,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.NullLocator.tick_values#1761",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.NullLocator",
        "signature": "lib.matplotlib.ticker.NullLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        \"\"\"\n        Return the locations of the ticks.\n\n        .. note::\n\n            Because the values are Null, vmin and vmax are not used in this\n            method.\n        \"\"\"\n        return []",
        "begin_line": 1761,
        "end_line": 1770,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038880248833592535,
            "pseudo_dstar_susp": 0.00035816618911174784,
            "pseudo_tarantula_susp": 0.0008305647840531562,
            "pseudo_op2_susp": 0.00035816618911174784,
            "pseudo_barinel_susp": 0.0008305647840531562
        }
    },
    {
        "name": "lib.matplotlib.ticker.LinearLocator.__init__#1783",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LinearLocator",
        "signature": "lib.matplotlib.ticker.LinearLocator.__init__(self, numticks=None, presets=None)",
        "snippet": "    def __init__(self, numticks=None, presets=None):\n        \"\"\"\n        Use presets to set locs based on lom.  A dict mapping vmin, vmax->locs\n        \"\"\"\n        self.numticks = numticks\n        if presets is None:\n            self.presets = {}\n        else:\n            self.presets = presets",
        "begin_line": 1783,
        "end_line": 1791,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LinearLocator.numticks#1794",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LinearLocator",
        "signature": "lib.matplotlib.ticker.LinearLocator.numticks(self)",
        "snippet": "    def numticks(self):\n        # Old hard-coded default.\n        return self._numticks if self._numticks is not None else 11",
        "begin_line": 1794,
        "end_line": 1796,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LinearLocator.numticks#1799",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LinearLocator",
        "signature": "lib.matplotlib.ticker.LinearLocator.numticks(self, numticks)",
        "snippet": "    def numticks(self, numticks):\n        self._numticks = numticks",
        "begin_line": 1799,
        "end_line": 1800,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LinearLocator.set_params#1802",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LinearLocator",
        "signature": "lib.matplotlib.ticker.LinearLocator.set_params(self, numticks=None, presets=None)",
        "snippet": "    def set_params(self, numticks=None, presets=None):\n        \"\"\"Set parameters within this locator.\"\"\"\n        if presets is not None:\n            self.presets = presets\n        if numticks is not None:\n            self.numticks = numticks",
        "begin_line": 1802,
        "end_line": 1807,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LinearLocator.__call__#1809",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LinearLocator",
        "signature": "lib.matplotlib.ticker.LinearLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        \"\"\"Return the locations of the ticks.\"\"\"\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)",
        "begin_line": 1809,
        "end_line": 1812,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LinearLocator.tick_values#1814",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LinearLocator",
        "signature": "lib.matplotlib.ticker.LinearLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        vmin, vmax = mtransforms.nonsingular(vmin, vmax, expander=0.05)\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n\n        if (vmin, vmax) in self.presets:\n            return self.presets[(vmin, vmax)]\n\n        if self.numticks == 0:\n            return []\n        ticklocs = np.linspace(vmin, vmax, self.numticks)\n\n        return self.raise_if_exceeds(ticklocs)",
        "begin_line": 1814,
        "end_line": 1826,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LinearLocator.view_limits#1828",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LinearLocator",
        "signature": "lib.matplotlib.ticker.LinearLocator.view_limits(self, vmin, vmax)",
        "snippet": "    def view_limits(self, vmin, vmax):\n        \"\"\"Try to choose the view limits intelligently.\"\"\"\n\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n\n        if vmin == vmax:\n            vmin -= 1\n            vmax += 1\n\n        if mpl.rcParams['axes.autolimit_mode'] == 'round_numbers':\n            exponent, remainder = divmod(\n                math.log10(vmax - vmin), math.log10(max(self.numticks - 1, 1)))\n            exponent -= (remainder < .5)\n            scale = max(self.numticks - 1, 1) ** (-exponent)\n            vmin = math.floor(scale * vmin) / scale\n            vmax = math.ceil(scale * vmax) / scale\n\n        return mtransforms.nonsingular(vmin, vmax)",
        "begin_line": 1828,
        "end_line": 1846,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.MultipleLocator.__init__#1854",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MultipleLocator",
        "signature": "lib.matplotlib.ticker.MultipleLocator.__init__(self, base=1.0)",
        "snippet": "    def __init__(self, base=1.0):\n        self._edge = _Edge_integer(base, 0)",
        "begin_line": 1854,
        "end_line": 1855,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.MultipleLocator.set_params#1857",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MultipleLocator",
        "signature": "lib.matplotlib.ticker.MultipleLocator.set_params(self, base)",
        "snippet": "    def set_params(self, base):\n        \"\"\"Set parameters within this locator.\"\"\"\n        if base is not None:\n            self._edge = _Edge_integer(base, 0)",
        "begin_line": 1857,
        "end_line": 1860,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.MultipleLocator.__call__#1862",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MultipleLocator",
        "signature": "lib.matplotlib.ticker.MultipleLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        \"\"\"Return the locations of the ticks.\"\"\"\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)",
        "begin_line": 1862,
        "end_line": 1865,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.MultipleLocator.tick_values#1867",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MultipleLocator",
        "signature": "lib.matplotlib.ticker.MultipleLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n        step = self._edge.step\n        vmin = self._edge.ge(vmin) * step\n        n = (vmax - vmin + 0.001 * step) // step\n        locs = vmin - step + np.arange(n + 3) * step\n        return self.raise_if_exceeds(locs)",
        "begin_line": 1867,
        "end_line": 1874,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.MultipleLocator.view_limits#1876",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MultipleLocator",
        "signature": "lib.matplotlib.ticker.MultipleLocator.view_limits(self, dmin, dmax)",
        "snippet": "    def view_limits(self, dmin, dmax):\n        \"\"\"\n        Set the view limits to the nearest multiples of base that\n        contain the data.\n        \"\"\"\n        if mpl.rcParams['axes.autolimit_mode'] == 'round_numbers':\n            vmin = self._edge.le(dmin) * self._edge.step\n            vmax = self._edge.ge(dmax) * self._edge.step\n            if vmin == vmax:\n                vmin -= 1\n                vmax += 1\n        else:\n            vmin = dmin\n            vmax = dmax\n\n        return mtransforms.nonsingular(vmin, vmax)",
        "begin_line": 1876,
        "end_line": 1891,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.scale_range#1894",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker",
        "signature": "lib.matplotlib.ticker.scale_range(vmin, vmax, n=1, threshold=100)",
        "snippet": "def scale_range(vmin, vmax, n=1, threshold=100):\n    dv = abs(vmax - vmin)  # > 0 as nonsingular is called before.\n    meanv = (vmax + vmin) / 2\n    if abs(meanv) / dv < threshold:\n        offset = 0\n    else:\n        offset = math.copysign(10 ** (math.log10(abs(meanv)) // 1), meanv)\n    scale = 10 ** (math.log10(dv / n) // 1)\n    return scale, offset",
        "begin_line": 1894,
        "end_line": 1902,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040816326530612246,
            "pseudo_dstar_susp": 0.00037230081906180194,
            "pseudo_tarantula_susp": 0.0009832841691248771,
            "pseudo_op2_susp": 0.00037230081906180194,
            "pseudo_barinel_susp": 0.0009832841691248771
        }
    },
    {
        "name": "lib.matplotlib.ticker._Edge_integer.__init__#1912",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker._Edge_integer",
        "signature": "lib.matplotlib.ticker._Edge_integer.__init__(self, step, offset)",
        "snippet": "    def __init__(self, step, offset):\n        \"\"\"\n        *step* is a positive floating-point interval between ticks.\n        *offset* is the offset subtracted from the data limits\n        prior to calculating tick locations.\n        \"\"\"\n        if step <= 0:\n            raise ValueError(\"'step' must be positive\")\n        self.step = step\n        self._offset = abs(offset)",
        "begin_line": 1912,
        "end_line": 1921,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00030845157310302283,
            "pseudo_dstar_susp": 0.0004938271604938272,
            "pseudo_tarantula_susp": 0.0003076923076923077,
            "pseudo_op2_susp": 0.0004938271604938272,
            "pseudo_barinel_susp": 0.0003076923076923077
        }
    },
    {
        "name": "lib.matplotlib.ticker._Edge_integer.closeto#1923",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker._Edge_integer",
        "signature": "lib.matplotlib.ticker._Edge_integer.closeto(self, ms, edge)",
        "snippet": "    def closeto(self, ms, edge):\n        # Allow more slop when the offset is large compared to the step.\n        if self._offset > 0:\n            digits = np.log10(self._offset / self.step)\n            tol = max(1e-10, 10 ** (digits - 12))\n            tol = min(0.4999, tol)\n        else:\n            tol = 1e-10\n        return abs(ms - edge) < tol",
        "begin_line": 1923,
        "end_line": 1931,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker._Edge_integer.le#1933",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker._Edge_integer",
        "signature": "lib.matplotlib.ticker._Edge_integer.le(self, x)",
        "snippet": "    def le(self, x):\n        \"\"\"Return the largest n: n*step <= x.\"\"\"\n        d, m = divmod(x, self.step)\n        if self.closeto(m / self.step, 1):\n            return d + 1\n        return d",
        "begin_line": 1933,
        "end_line": 1938,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040551500405515005,
            "pseudo_dstar_susp": 0.00037037037037037035,
            "pseudo_tarantula_susp": 0.0009606147934678194,
            "pseudo_op2_susp": 0.00037037037037037035,
            "pseudo_barinel_susp": 0.0009606147934678194
        }
    },
    {
        "name": "lib.matplotlib.ticker._Edge_integer.ge#1940",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker._Edge_integer",
        "signature": "lib.matplotlib.ticker._Edge_integer.ge(self, x)",
        "snippet": "    def ge(self, x):\n        \"\"\"Return the smallest n: n*step >= x.\"\"\"\n        d, m = divmod(x, self.step)\n        if self.closeto(m / self.step, 0):\n            return d\n        return d + 1",
        "begin_line": 1940,
        "end_line": 1945,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003837298541826554,
            "pseudo_dstar_susp": 0.00035398230088495576,
            "pseudo_tarantula_susp": 0.0007751937984496124,
            "pseudo_op2_susp": 0.00035398230088495576,
            "pseudo_barinel_susp": 0.0007757951900698216
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator.__init__#1960",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        nbins : int or 'auto', default: 10\n            Maximum number of intervals; one less than max number of\n            ticks.  If the string 'auto', the number of bins will be\n            automatically determined based on the length of the axis.\n\n        steps : array-like, optional\n            Sequence of nice numbers starting with 1 and ending with 10;\n            e.g., [1, 2, 4, 5, 10], where the values are acceptable\n            tick multiples.  i.e. for the example, 20, 40, 60 would be\n            an acceptable set of ticks, as would 0.4, 0.6, 0.8, because\n            they are multiples of 2.  However, 30, 60, 90 would not\n            be allowed because 3 does not appear in the list of steps.\n\n        integer : bool, default: False\n            If True, ticks will take only integer values, provided at least\n            *min_n_ticks* integers are found within the view limits.\n\n        symmetric : bool, default: False\n            If True, autoscaling will result in a range symmetric about zero.\n\n        prune : {'lower', 'upper', 'both', None}, default: None\n            Remove edge ticks -- useful for stacked or ganged plots where\n            the upper tick of one axes overlaps with the lower tick of the\n            axes above it, primarily when :rc:`axes.autolimit_mode` is\n            ``'round_numbers'``.  If ``prune=='lower'``, the smallest tick will\n            be removed.  If ``prune == 'upper'``, the largest tick will be\n            removed.  If ``prune == 'both'``, the largest and smallest ticks\n            will be removed.  If *prune* is *None*, no ticks will be removed.\n\n        min_n_ticks : int, default: 2\n            Relax *nbins* and *integer* constraints if necessary to obtain\n            this minimum number of ticks.\n        \"\"\"\n        if args:\n            if 'nbins' in kwargs:\n                cbook.deprecated(\"3.1\",\n                                 message='Calling MaxNLocator with positional '\n                                         'and keyword parameter *nbins* is '\n                                         'considered an error and will fail '\n                                         'in future versions of matplotlib.')\n            kwargs['nbins'] = args[0]\n            if len(args) > 1:\n                raise ValueError(\n                    \"Keywords are required for all arguments except 'nbins'\")\n        self.set_params(**{**self.default_params, **kwargs})",
        "begin_line": 1960,
        "end_line": 2008,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008920606601248885,
            "pseudo_dstar_susp": 0.001455604075691412,
            "pseudo_tarantula_susp": 0.00044483985765124553,
            "pseudo_op2_susp": 0.001455604075691412,
            "pseudo_barinel_susp": 0.00044483985765124553
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator._validate_steps#2011",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator._validate_steps(steps)",
        "snippet": "    def _validate_steps(steps):\n        if not np.iterable(steps):\n            raise ValueError('steps argument must be an increasing sequence '\n                             'of numbers between 1 and 10 inclusive')\n        steps = np.asarray(steps)\n        if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:\n            raise ValueError('steps argument must be an increasing sequence '\n                             'of numbers between 1 and 10 inclusive')\n        if steps[0] != 1:\n            steps = np.hstack((1, steps))\n        if steps[-1] != 10:\n            steps = np.hstack((steps, 10))\n        return steps",
        "begin_line": 2011,
        "end_line": 2023,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009293680297397769,
            "pseudo_dstar_susp": 0.0014903129657228018,
            "pseudo_tarantula_susp": 0.0004506534474988734,
            "pseudo_op2_susp": 0.0014903129657228018,
            "pseudo_barinel_susp": 0.0004506534474988734
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator._staircase#2026",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator._staircase(steps)",
        "snippet": "    def _staircase(steps):\n        # Make an extended staircase within which the needed\n        # step will be found.  This is probably much larger\n        # than necessary.\n        flights = (0.1 * steps[:-1], steps, 10 * steps[1])\n        return np.hstack(flights)",
        "begin_line": 2026,
        "end_line": 2031,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018867924528301887,
            "pseudo_dstar_susp": 0.0029585798816568047,
            "pseudo_tarantula_susp": 0.0007087172218284905,
            "pseudo_op2_susp": 0.0029585798816568047,
            "pseudo_barinel_susp": 0.0007087172218284905
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator.set_params#2033",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator.set_params(self, **kwargs)",
        "snippet": "    def set_params(self, **kwargs):\n        \"\"\"\n        Set parameters for this locator.\n\n        Parameters\n        ----------\n        nbins : int or 'auto', optional\n            see `.MaxNLocator`\n        steps : array-like, optional\n            see `.MaxNLocator`\n        integer : bool, optional\n            see `.MaxNLocator`\n        symmetric : bool, optional\n            see `.MaxNLocator`\n        prune : {'lower', 'upper', 'both', None}, optional\n            see `.MaxNLocator`\n        min_n_ticks : int, optional\n            see `.MaxNLocator`\n        \"\"\"\n        if 'nbins' in kwargs:\n            self._nbins = kwargs.pop('nbins')\n            if self._nbins != 'auto':\n                self._nbins = int(self._nbins)\n        if 'symmetric' in kwargs:\n            self._symmetric = kwargs.pop('symmetric')\n        if 'prune' in kwargs:\n            prune = kwargs.pop('prune')\n            cbook._check_in_list(['upper', 'lower', 'both', None], prune=prune)\n            self._prune = prune\n        if 'min_n_ticks' in kwargs:\n            self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))\n        if 'steps' in kwargs:\n            steps = kwargs.pop('steps')\n            if steps is None:\n                self._steps = np.array([1, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10])\n            else:\n                self._steps = self._validate_steps(steps)\n            self._extended_steps = self._staircase(self._steps)\n        if 'integer' in kwargs:\n            self._integer = kwargs.pop('integer')\n        if kwargs:\n            key, _ = kwargs.popitem()\n            cbook.warn_deprecated(\"3.1\",\n                                  message=\"MaxNLocator.set_params got an \"\n                                          f\"unexpected parameter: {key}\")",
        "begin_line": 2033,
        "end_line": 2077,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022371364653243847,
            "pseudo_dstar_susp": 0.0016207455429497568,
            "pseudo_tarantula_susp": 0.0008077544426494346,
            "pseudo_op2_susp": 0.0016207455429497568,
            "pseudo_barinel_susp": 0.0008077544426494346
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator._raw_ticks#2079",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator._raw_ticks(self, vmin, vmax)",
        "snippet": "    def _raw_ticks(self, vmin, vmax):\n        \"\"\"\n        Generate a list of tick locations including the range *vmin* to\n        *vmax*.  In some applications, one or both of the end locations\n        will not be needed, in which case they are trimmed off\n        elsewhere.\n        \"\"\"\n        if self._nbins == 'auto':\n            if self.axis is not None:\n                nbins = np.clip(self.axis.get_tick_space(),\n                                max(1, self._min_n_ticks - 1), 9)\n            else:\n                nbins = 9\n        else:\n            nbins = self._nbins\n\n        scale, offset = scale_range(vmin, vmax, nbins)\n        _vmin = vmin - offset\n        _vmax = vmax - offset\n        raw_step = (_vmax - _vmin) / nbins\n        steps = self._extended_steps * scale\n        if self._integer:\n            # For steps > 1, keep only integer values.\n            igood = (steps < 1) | (np.abs(steps - np.round(steps)) < 0.001)\n            steps = steps[igood]\n\n        istep = np.nonzero(steps >= raw_step)[0][0]\n\n        # Classic round_numbers mode may require a larger step.\n        if mpl.rcParams['axes.autolimit_mode'] == 'round_numbers':\n            for istep in range(istep, len(steps)):\n                step = steps[istep]\n                best_vmin = (_vmin // step) * step\n                best_vmax = best_vmin + step * nbins\n                if best_vmax >= _vmax:\n                    break\n\n        # This is an upper limit; move to smaller steps if necessary.\n        for istep in reversed(range(istep + 1)):\n            step = steps[istep]\n\n            if (self._integer and\n                    np.floor(_vmax) - np.ceil(_vmin) >= self._min_n_ticks - 1):\n                step = max(1, step)\n            best_vmin = (_vmin // step) * step\n\n            # Find tick locations spanning the vmin-vmax range, taking into\n            # account degradation of precision when there is a large offset.\n            # The edge ticks beyond vmin and/or vmax are needed for the\n            # \"round_numbers\" autolimit mode.\n            edge = _Edge_integer(step, offset)\n            low = edge.le(_vmin - best_vmin)\n            high = edge.ge(_vmax - best_vmin)\n            ticks = np.arange(low, high + 1) * step + best_vmin\n            # Count only the ticks that will be displayed.\n            nticks = ((ticks <= _vmax) & (ticks >= _vmin)).sum()\n            if nticks >= self._min_n_ticks:\n                break\n        return ticks + offset",
        "begin_line": 2079,
        "end_line": 2137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002954209748892171,
            "pseudo_dstar_susp": 0.00029507229271171436,
            "pseudo_tarantula_susp": 0.0003075030750307503,
            "pseudo_op2_susp": 0.00029507229271171436,
            "pseudo_barinel_susp": 0.0003075030750307503
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator.__call__#2139",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)",
        "begin_line": 2139,
        "end_line": 2141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002981514609421586,
            "pseudo_dstar_susp": 0.0002977963073257892,
            "pseudo_tarantula_susp": 0.00031210986267166043,
            "pseudo_op2_susp": 0.0002977963073257892,
            "pseudo_barinel_susp": 0.00031210986267166043
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator.tick_values#2143",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        if self._symmetric:\n            vmax = max(abs(vmin), abs(vmax))\n            vmin = -vmax\n        vmin, vmax = mtransforms.nonsingular(\n            vmin, vmax, expander=1e-13, tiny=1e-14)\n        locs = self._raw_ticks(vmin, vmax)\n\n        prune = self._prune\n        if prune == 'lower':\n            locs = locs[1:]\n        elif prune == 'upper':\n            locs = locs[:-1]\n        elif prune == 'both':\n            locs = locs[1:-1]\n        return self.raise_if_exceeds(locs)",
        "begin_line": 2143,
        "end_line": 2158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004152823920265781,
            "pseudo_dstar_susp": 0.00037764350453172205,
            "pseudo_tarantula_susp": 0.0010526315789473684,
            "pseudo_op2_susp": 0.00037764350453172205,
            "pseudo_barinel_susp": 0.0010526315789473684
        }
    },
    {
        "name": "lib.matplotlib.ticker.MaxNLocator.view_limits#2160",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.MaxNLocator",
        "signature": "lib.matplotlib.ticker.MaxNLocator.view_limits(self, dmin, dmax)",
        "snippet": "    def view_limits(self, dmin, dmax):\n        if self._symmetric:\n            dmax = max(abs(dmin), abs(dmax))\n            dmin = -dmax\n\n        dmin, dmax = mtransforms.nonsingular(\n            dmin, dmax, expander=1e-12, tiny=1e-13)\n\n        if mpl.rcParams['axes.autolimit_mode'] == 'round_numbers':\n            return self._raw_ticks(dmin, dmax)[[0, -1]]\n        else:\n            return dmin, dmax",
        "begin_line": 2160,
        "end_line": 2171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040290088638195,
            "pseudo_dstar_susp": 0.00036859565057132326,
            "pseudo_tarantula_susp": 0.000942507068803016,
            "pseudo_op2_susp": 0.00036859565057132326,
            "pseudo_barinel_susp": 0.000942507068803016
        }
    },
    {
        "name": "lib.matplotlib.ticker.is_decade#2174",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker",
        "signature": "lib.matplotlib.ticker.is_decade(x, base=10, *, rtol=1e-10)",
        "snippet": "def is_decade(x, base=10, *, rtol=1e-10):\n    if not np.isfinite(x):\n        return False\n    if x == 0.0:\n        return True\n    lx = np.log(abs(x)) / np.log(base)\n    return is_close_to_int(lx, atol=rtol)",
        "begin_line": 2174,
        "end_line": 2180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.582217645039479e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker._decade_less_equal#2183",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker",
        "signature": "lib.matplotlib.ticker._decade_less_equal(x, base)",
        "snippet": "def _decade_less_equal(x, base):\n    \"\"\"\n    Return the largest integer power of *base* that's less or equal to *x*.\n\n    If *x* is negative, the exponent will be *greater*.\n    \"\"\"\n    return (x if x == 0 else\n            -_decade_greater_equal(-x, base) if x < 0 else\n            base ** np.floor(np.log(x) / np.log(base)))",
        "begin_line": 2183,
        "end_line": 2191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker._decade_greater_equal#2194",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker",
        "signature": "lib.matplotlib.ticker._decade_greater_equal(x, base)",
        "snippet": "def _decade_greater_equal(x, base):\n    \"\"\"\n    Return the smallest integer power of *base* that's greater or equal to *x*.\n\n    If *x* is negative, the exponent will be *smaller*.\n    \"\"\"\n    return (x if x == 0 else\n            -_decade_less_equal(-x, base) if x < 0 else\n            base ** np.ceil(np.log(x) / np.log(base)))",
        "begin_line": 2194,
        "end_line": 2202,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker._decade_less#2205",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker",
        "signature": "lib.matplotlib.ticker._decade_less(x, base)",
        "snippet": "def _decade_less(x, base):\n    \"\"\"\n    Return the largest integer power of *base* that's less than *x*.\n\n    If *x* is negative, the exponent will be *greater*.\n    \"\"\"\n    if x < 0:\n        return -_decade_greater(-x, base)\n    less = _decade_less_equal(x, base)\n    if less == x:\n        less /= base\n    return less",
        "begin_line": 2205,
        "end_line": 2216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker._decade_greater#2219",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker",
        "signature": "lib.matplotlib.ticker._decade_greater(x, base)",
        "snippet": "def _decade_greater(x, base):\n    \"\"\"\n    Return the smallest integer power of *base* that's greater than *x*.\n\n    If *x* is negative, the exponent will be *smaller*.\n    \"\"\"\n    if x < 0:\n        return -_decade_less(-x, base)\n    greater = _decade_greater_equal(x, base)\n    if greater == x:\n        greater *= base\n    return greater",
        "begin_line": 2219,
        "end_line": 2230,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.is_close_to_int#2233",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker",
        "signature": "lib.matplotlib.ticker.is_close_to_int(x, *, atol=1e-10)",
        "snippet": "def is_close_to_int(x, *, atol=1e-10):\n    return abs(x - np.round(x)) < atol",
        "begin_line": 2233,
        "end_line": 2234,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.__init__#2242",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.__init__(self, base=10.0, subs=(1.0,), numdecs=4, numticks=None)",
        "snippet": "    def __init__(self, base=10.0, subs=(1.0,), numdecs=4, numticks=None):\n        \"\"\"\n        Place ticks on the locations : subs[j] * base**i\n\n        Parameters\n        ----------\n        subs : None or str or sequence of float, default: (1.0,)\n            Gives the multiples of integer powers of the base at which\n            to place ticks.  The default places ticks only at\n            integer powers of the base.\n            The permitted string values are ``'auto'`` and ``'all'``,\n            both of which use an algorithm based on the axis view\n            limits to determine whether and how to put ticks between\n            integer powers of the base.  With ``'auto'``, ticks are\n            placed only between integer powers; with ``'all'``, the\n            integer powers are included.  A value of None is\n            equivalent to ``'auto'``.\n\n        \"\"\"\n        if numticks is None:\n            if mpl.rcParams['_internal.classic_mode']:\n                numticks = 15\n            else:\n                numticks = 'auto'\n        self.base(base)\n        self.subs(subs)\n        self.numdecs = numdecs\n        self.numticks = numticks",
        "begin_line": 2242,
        "end_line": 2269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.set_params#2271",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.set_params(self, base=None, subs=None, numdecs=None, numticks=None)",
        "snippet": "    def set_params(self, base=None, subs=None, numdecs=None, numticks=None):\n        \"\"\"Set parameters within this locator.\"\"\"\n        if base is not None:\n            self.base(base)\n        if subs is not None:\n            self.subs(subs)\n        if numdecs is not None:\n            self.numdecs = numdecs\n        if numticks is not None:\n            self.numticks = numticks",
        "begin_line": 2271,
        "end_line": 2280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.base#2285",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.base(self, base)",
        "snippet": "    def base(self, base):\n        \"\"\"Set the log base (major tick every ``base**i``, i integer).\"\"\"\n        self._base = float(base)",
        "begin_line": 2285,
        "end_line": 2287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.subs#2289",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.subs(self, subs)",
        "snippet": "    def subs(self, subs):\n        \"\"\"\n        Set the minor ticks for the log scaling every ``base**i*subs[j]``.\n        \"\"\"\n        if subs is None:  # consistency with previous bad API\n            self._subs = 'auto'\n        elif isinstance(subs, str):\n            cbook._check_in_list(('all', 'auto'), subs=subs)\n            self._subs = subs\n        else:\n            try:\n                self._subs = np.asarray(subs, dtype=float)\n            except ValueError as e:\n                raise ValueError(\"subs must be None, 'all', 'auto' or \"\n                                 \"a sequence of floats, not \"\n                                 \"{}.\".format(subs)) from e\n            if self._subs.ndim != 1:\n                raise ValueError(\"A sequence passed to subs must be \"\n                                 \"1-dimensional, not \"\n                                 \"{}-dimensional.\".format(self._subs.ndim))",
        "begin_line": 2289,
        "end_line": 2308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.__call__#2310",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        \"\"\"Return the locations of the ticks.\"\"\"\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)",
        "begin_line": 2310,
        "end_line": 2313,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.tick_values#2315",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        if self.numticks == 'auto':\n            if self.axis is not None:\n                numticks = np.clip(self.axis.get_tick_space(), 2, 9)\n            else:\n                numticks = 9\n        else:\n            numticks = self.numticks\n\n        b = self._base\n        # dummy axis has no axes attribute\n        if hasattr(self.axis, 'axes') and self.axis.axes.name == 'polar':\n            vmax = math.ceil(math.log(vmax) / math.log(b))\n            decades = np.arange(vmax - self.numdecs, vmax)\n            ticklocs = b ** decades\n\n            return ticklocs\n\n        if vmin <= 0.0:\n            if self.axis is not None:\n                vmin = self.axis.get_minpos()\n\n            if vmin <= 0.0 or not np.isfinite(vmin):\n                raise ValueError(\n                    \"Data has no positive values, and therefore can not be \"\n                    \"log-scaled.\")\n\n        _log.debug('vmin %s vmax %s', vmin, vmax)\n\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n        log_vmin = math.log(vmin) / math.log(b)\n        log_vmax = math.log(vmax) / math.log(b)\n\n        numdec = math.floor(log_vmax) - math.ceil(log_vmin)\n\n        if isinstance(self._subs, str):\n            _first = 2.0 if self._subs == 'auto' else 1.0\n            if numdec > 10 or b < 3:\n                if self._subs == 'auto':\n                    return np.array([])  # no minor or major ticks\n                else:\n                    subs = np.array([1.0])  # major ticks\n            else:\n                subs = np.arange(_first, b)\n        else:\n            subs = self._subs\n\n        # Get decades between major ticks.\n        stride = (max(math.ceil(numdec / (numticks - 1)), 1)\n                  if mpl.rcParams['_internal.classic_mode'] else\n                  (numdec + 1) // numticks + 1)\n\n        # Does subs include anything other than 1?  Essentially a hack to know\n        # whether we're a major or a minor locator.\n        have_subs = len(subs) > 1 or (len(subs) == 1 and subs[0] != 1.0)\n\n        decades = np.arange(math.floor(log_vmin) - stride,\n                            math.ceil(log_vmax) + 2 * stride, stride)\n\n        if hasattr(self, '_transform'):\n            ticklocs = self._transform.inverted().transform(decades)\n            if have_subs:\n                if stride == 1:\n                    ticklocs = np.ravel(np.outer(subs, ticklocs))\n                else:\n                    # No ticklocs if we have >1 decade between major ticks.\n                    ticklocs = np.array([])\n        else:\n            if have_subs:\n                if stride == 1:\n                    ticklocs = np.concatenate(\n                        [subs * decade_start for decade_start in b ** decades])\n                else:\n                    ticklocs = np.array([])\n            else:\n                ticklocs = b ** decades\n\n        _log.debug('ticklocs %r', ticklocs)\n        if (len(subs) > 1\n                and stride == 1\n                and ((vmin <= ticklocs) & (ticklocs <= vmax)).sum() <= 1):\n            # If we're a minor locator *that expects at least two ticks per\n            # decade* and the major locator stride is 1 and there's no more\n            # than one minor tick, switch to AutoLocator.\n            return AutoLocator().tick_values(vmin, vmax)\n        else:\n            return self.raise_if_exceeds(ticklocs)",
        "begin_line": 2315,
        "end_line": 2402,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.view_limits#2404",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.view_limits(self, vmin, vmax)",
        "snippet": "    def view_limits(self, vmin, vmax):\n        \"\"\"Try to choose the view limits intelligently.\"\"\"\n        b = self._base\n\n        vmin, vmax = self.nonsingular(vmin, vmax)\n\n        if self.axis.axes.name == 'polar':\n            vmax = math.ceil(math.log(vmax) / math.log(b))\n            vmin = b ** (vmax - self.numdecs)\n\n        if mpl.rcParams['axes.autolimit_mode'] == 'round_numbers':\n            vmin = _decade_less_equal(vmin, self._base)\n            vmax = _decade_greater_equal(vmax, self._base)\n\n        return vmin, vmax",
        "begin_line": 2404,
        "end_line": 2418,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogLocator.nonsingular#2420",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogLocator",
        "signature": "lib.matplotlib.ticker.LogLocator.nonsingular(self, vmin, vmax)",
        "snippet": "    def nonsingular(self, vmin, vmax):\n        if vmin > vmax:\n            vmin, vmax = vmax, vmin\n        if not np.isfinite(vmin) or not np.isfinite(vmax):\n            vmin, vmax = 1, 10  # Initial range, no data plotted yet.\n        elif vmax <= 0:\n            cbook._warn_external(\n                \"Data has no positive values, and therefore cannot be \"\n                \"log-scaled.\")\n            vmin, vmax = 1, 10\n        else:\n            minpos = self.axis.get_minpos()\n            if not np.isfinite(minpos):\n                minpos = 1e-300  # This should never take effect.\n            if vmin <= 0:\n                vmin = minpos\n            if vmin == vmax:\n                vmin = _decade_less(vmin, self._base)\n                vmax = _decade_greater(vmax, self._base)\n        return vmin, vmax",
        "begin_line": 2420,
        "end_line": 2439,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.SymmetricalLogLocator.__init__#2447",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.SymmetricalLogLocator",
        "signature": "lib.matplotlib.ticker.SymmetricalLogLocator.__init__(self, transform=None, subs=None, linthresh=None, base=None)",
        "snippet": "    def __init__(self, transform=None, subs=None, linthresh=None, base=None):\n        \"\"\"\n        Parameters\n        ----------\n        transform : `~.scale.SymmetricalLogTransform`, optional\n            If set, defines the *base* and *linthresh* of the symlog transform.\n        base, linthresh : float, optional\n            The *base* and *linthresh* of the symlog transform, as documented\n            for `.SymmetricalLogScale`.  These parameters are only used if\n            *transform* is not set.\n        subs : sequence of float, default: [1]\n            The multiples of integer powers of the base where ticks are placed,\n            i.e., ticks are placed at\n            ``[sub * base**i for i in ... for sub in subs]``.\n\n        Notes\n        -----\n        Either *transform*, or both *base* and *linthresh*, must be given.\n        \"\"\"\n        if transform is not None:\n            self._base = transform.base\n            self._linthresh = transform.linthresh\n        elif linthresh is not None and base is not None:\n            self._base = base\n            self._linthresh = linthresh\n        else:\n            raise ValueError(\"Either transform, or both linthresh \"\n                             \"and base, must be provided.\")\n        if subs is None:\n            self._subs = [1.0]\n        else:\n            self._subs = subs\n        self.numticks = 15",
        "begin_line": 2447,
        "end_line": 2479,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.SymmetricalLogLocator.set_params#2481",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.SymmetricalLogLocator",
        "signature": "lib.matplotlib.ticker.SymmetricalLogLocator.set_params(self, subs=None, numticks=None)",
        "snippet": "    def set_params(self, subs=None, numticks=None):\n        \"\"\"Set parameters within this locator.\"\"\"\n        if numticks is not None:\n            self.numticks = numticks\n        if subs is not None:\n            self._subs = subs",
        "begin_line": 2481,
        "end_line": 2486,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.SymmetricalLogLocator.__call__#2488",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.SymmetricalLogLocator",
        "signature": "lib.matplotlib.ticker.SymmetricalLogLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        \"\"\"Return the locations of the ticks.\"\"\"\n        # Note, these are untransformed coordinates\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)",
        "begin_line": 2488,
        "end_line": 2492,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.SymmetricalLogLocator.tick_values#2494",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.SymmetricalLogLocator",
        "signature": "lib.matplotlib.ticker.SymmetricalLogLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        base = self._base\n        linthresh = self._linthresh\n\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n\n        # The domain is divided into three sections, only some of\n        # which may actually be present.\n        #\n        # <======== -t ==0== t ========>\n        # aaaaaaaaa    bbbbb   ccccccccc\n        #\n        # a) and c) will have ticks at integral log positions.  The\n        # number of ticks needs to be reduced if there are more\n        # than self.numticks of them.\n        #\n        # b) has a tick at 0 and only 0 (we assume t is a small\n        # number, and the linear segment is just an implementation\n        # detail and not interesting.)\n        #\n        # We could also add ticks at t, but that seems to usually be\n        # uninteresting.\n        #\n        # \"simple\" mode is when the range falls entirely within (-t,\n        # t) -- it should just display (vmin, 0, vmax)\n        if -linthresh < vmin < vmax < linthresh:\n            # only the linear range is present\n            return [vmin, vmax]\n\n        # Lower log range is present\n        has_a = (vmin < -linthresh)\n        # Upper log range is present\n        has_c = (vmax > linthresh)\n\n        # Check if linear range is present\n        has_b = (has_a and vmax > -linthresh) or (has_c and vmin < linthresh)\n\n        def get_log_range(lo, hi):\n            lo = np.floor(np.log(lo) / np.log(base))\n            hi = np.ceil(np.log(hi) / np.log(base))\n            return lo, hi\n\n        # Calculate all the ranges, so we can determine striding\n        a_lo, a_hi = (0, 0)\n        if has_a:\n            a_upper_lim = min(-linthresh, vmax)\n            a_lo, a_hi = get_log_range(abs(a_upper_lim), abs(vmin) + 1)\n\n        c_lo, c_hi = (0, 0)\n        if has_c:\n            c_lower_lim = max(linthresh, vmin)\n            c_lo, c_hi = get_log_range(c_lower_lim, vmax + 1)\n\n        # Calculate the total number of integer exponents in a and c ranges\n        total_ticks = (a_hi - a_lo) + (c_hi - c_lo)\n        if has_b:\n            total_ticks += 1\n        stride = max(total_ticks // (self.numticks - 1), 1)\n\n        decades = []\n        if has_a:\n            decades.extend(-1 * (base ** (np.arange(a_lo, a_hi,\n                                                    stride)[::-1])))\n\n        if has_b:\n            decades.append(0.0)\n\n        if has_c:\n            decades.extend(base ** (np.arange(c_lo, c_hi, stride)))\n\n        # Add the subticks if requested\n        if self._subs is None:\n            subs = np.arange(2.0, base)\n        else:\n            subs = np.asarray(self._subs)\n\n        if len(subs) > 1 or subs[0] != 1.0:\n            ticklocs = []\n            for decade in decades:\n                if decade == 0:\n                    ticklocs.append(decade)\n                else:\n                    ticklocs.extend(subs * decade)\n        else:\n            ticklocs = decades\n\n        return self.raise_if_exceeds(np.array(ticklocs))",
        "begin_line": 2494,
        "end_line": 2581,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.SymmetricalLogLocator.get_log_range#2532",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.SymmetricalLogLocator",
        "signature": "lib.matplotlib.ticker.SymmetricalLogLocator.get_log_range(lo, hi)",
        "snippet": "        def get_log_range(lo, hi):\n            lo = np.floor(np.log(lo) / np.log(base))\n            hi = np.ceil(np.log(hi) / np.log(base))\n            return lo, hi",
        "begin_line": 2532,
        "end_line": 2535,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.SymmetricalLogLocator.view_limits#2583",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.SymmetricalLogLocator",
        "signature": "lib.matplotlib.ticker.SymmetricalLogLocator.view_limits(self, vmin, vmax)",
        "snippet": "    def view_limits(self, vmin, vmax):\n        \"\"\"Try to choose the view limits intelligently.\"\"\"\n        b = self._base\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n\n        if mpl.rcParams['axes.autolimit_mode'] == 'round_numbers':\n            vmin = _decade_less_equal(vmin, b)\n            vmax = _decade_greater_equal(vmax, b)\n            if vmin == vmax:\n                vmin = _decade_less(vmin, b)\n                vmax = _decade_greater(vmax, b)\n\n        result = mtransforms.nonsingular(vmin, vmax)\n        return result",
        "begin_line": 2583,
        "end_line": 2597,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitLocator.__init__#2605",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitLocator",
        "signature": "lib.matplotlib.ticker.LogitLocator.__init__(self, minor=False, *, nbins='auto')",
        "snippet": "    def __init__(self, minor=False, *, nbins=\"auto\"):\n        \"\"\"\n        Place ticks on the logit locations\n\n        Parameters\n        ----------\n        nbins : int or 'auto', optional\n            Number of ticks. Only used if minor is False.\n        minor : bool, default: False\n            Indicate if this locator is for minor ticks or not.\n        \"\"\"\n\n        self._minor = minor\n        MaxNLocator.__init__(self, nbins=nbins, steps=[1, 2, 5, 10])",
        "begin_line": 2605,
        "end_line": 2618,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitLocator.set_params#2620",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitLocator",
        "signature": "lib.matplotlib.ticker.LogitLocator.set_params(self, minor=None, **kwargs)",
        "snippet": "    def set_params(self, minor=None, **kwargs):\n        \"\"\"Set parameters within this locator.\"\"\"\n        if minor is not None:\n            self._minor = minor\n        MaxNLocator.set_params(self, **kwargs)",
        "begin_line": 2620,
        "end_line": 2624,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitLocator.minor#2627",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitLocator",
        "signature": "lib.matplotlib.ticker.LogitLocator.minor(self)",
        "snippet": "    def minor(self):\n        return self._minor",
        "begin_line": 2627,
        "end_line": 2628,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitLocator.minor#2631",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitLocator",
        "signature": "lib.matplotlib.ticker.LogitLocator.minor(self, value)",
        "snippet": "    def minor(self, value):\n        self.set_params(minor=value)",
        "begin_line": 2631,
        "end_line": 2632,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitLocator.tick_values#2634",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitLocator",
        "signature": "lib.matplotlib.ticker.LogitLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        # dummy axis has no axes attribute\n        if hasattr(self.axis, \"axes\") and self.axis.axes.name == \"polar\":\n            raise NotImplementedError(\"Polar axis cannot be logit scaled yet\")\n\n        if self._nbins == \"auto\":\n            if self.axis is not None:\n                nbins = self.axis.get_tick_space()\n                if nbins < 2:\n                    nbins = 2\n            else:\n                nbins = 9\n        else:\n            nbins = self._nbins\n\n        # We define ideal ticks with their index:\n        # linscale: ... 1e-3 1e-2 1e-1 1/2 1-1e-1 1-1e-2 1-1e-3 ...\n        # b-scale : ... -3   -2   -1   0   1      2      3      ...\n        def ideal_ticks(x):\n            return 10 ** x if x < 0 else 1 - (10 ** (-x)) if x > 0 else 1 / 2\n\n        vmin, vmax = self.nonsingular(vmin, vmax)\n        binf = int(\n            np.floor(np.log10(vmin))\n            if vmin < 0.5\n            else 0\n            if vmin < 0.9\n            else -np.ceil(np.log10(1 - vmin))\n        )\n        bsup = int(\n            np.ceil(np.log10(vmax))\n            if vmax <= 0.5\n            else 1\n            if vmax <= 0.9\n            else -np.floor(np.log10(1 - vmax))\n        )\n        numideal = bsup - binf - 1\n        if numideal >= 2:\n            # have 2 or more wanted ideal ticks, so use them as major ticks\n            if numideal > nbins:\n                # to many ideal ticks, subsampling ideals for major ticks, and\n                # take others for minor ticks\n                subsampling_factor = math.ceil(numideal / nbins)\n                if self._minor:\n                    ticklocs = [\n                        ideal_ticks(b)\n                        for b in range(binf, bsup + 1)\n                        if (b % subsampling_factor) != 0\n                    ]\n                else:\n                    ticklocs = [\n                        ideal_ticks(b)\n                        for b in range(binf, bsup + 1)\n                        if (b % subsampling_factor) == 0\n                    ]\n                return self.raise_if_exceeds(np.array(ticklocs))\n            if self._minor:\n                ticklocs = []\n                for b in range(binf, bsup):\n                    if b < -1:\n                        ticklocs.extend(np.arange(2, 10) * 10 ** b)\n                    elif b == -1:\n                        ticklocs.extend(np.arange(2, 5) / 10)\n                    elif b == 0:\n                        ticklocs.extend(np.arange(6, 9) / 10)\n                    else:\n                        ticklocs.extend(\n                            1 - np.arange(2, 10)[::-1] * 10 ** (-b - 1)\n                        )\n                return self.raise_if_exceeds(np.array(ticklocs))\n            ticklocs = [ideal_ticks(b) for b in range(binf, bsup + 1)]\n            return self.raise_if_exceeds(np.array(ticklocs))\n        # the scale is zoomed so same ticks as linear scale can be used\n        if self._minor:\n            return []\n        return MaxNLocator.tick_values(self, vmin, vmax)",
        "begin_line": 2634,
        "end_line": 2709,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitLocator.ideal_ticks#2652",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitLocator",
        "signature": "lib.matplotlib.ticker.LogitLocator.ideal_ticks(x)",
        "snippet": "        def ideal_ticks(x):\n            return 10 ** x if x < 0 else 1 - (10 ** (-x)) if x > 0 else 1 / 2",
        "begin_line": 2652,
        "end_line": 2653,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.LogitLocator.nonsingular#2711",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.LogitLocator",
        "signature": "lib.matplotlib.ticker.LogitLocator.nonsingular(self, vmin, vmax)",
        "snippet": "    def nonsingular(self, vmin, vmax):\n        standard_minpos = 1e-7\n        initial_range = (standard_minpos, 1 - standard_minpos)\n        if vmin > vmax:\n            vmin, vmax = vmax, vmin\n        if not np.isfinite(vmin) or not np.isfinite(vmax):\n            vmin, vmax = initial_range  # Initial range, no data plotted yet.\n        elif vmax <= 0 or vmin >= 1:\n            # vmax <= 0 occurs when all values are negative\n            # vmin >= 1 occurs when all values are greater than one\n            cbook._warn_external(\n                \"Data has no values between 0 and 1, and therefore cannot be \"\n                \"logit-scaled.\"\n            )\n            vmin, vmax = initial_range\n        else:\n            minpos = (\n                self.axis.get_minpos()\n                if self.axis is not None\n                else standard_minpos\n            )\n            if not np.isfinite(minpos):\n                minpos = standard_minpos  # This should never take effect.\n            if vmin <= 0:\n                vmin = minpos\n            # NOTE: for vmax, we should query a property similar to get_minpos,\n            # but related to the maximal, less-than-one data point.\n            # Unfortunately, Bbox._minpos is defined very deep in the BBox and\n            # updated with data, so for now we use 1 - minpos as a substitute.\n            if vmax >= 1:\n                vmax = 1 - minpos\n            if vmin == vmax:\n                vmin, vmax = 0.1 * vmin, 1 - 0.1 * vmin\n\n        return vmin, vmax",
        "begin_line": 2711,
        "end_line": 2745,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.AutoLocator.__init__#2754",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.AutoLocator",
        "signature": "lib.matplotlib.ticker.AutoLocator.__init__(self)",
        "snippet": "    def __init__(self):\n        \"\"\"\n        To know the values of the non-public parameters, please have a\n        look to the defaults of `~matplotlib.ticker.MaxNLocator`.\n        \"\"\"\n        if mpl.rcParams['_internal.classic_mode']:\n            nbins = 9\n            steps = [1, 2, 5, 10]\n        else:\n            nbins = 'auto'\n            steps = [1, 2, 2.5, 5, 10]\n        MaxNLocator.__init__(self, nbins=nbins, steps=steps)",
        "begin_line": 2754,
        "end_line": 2765,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011904761904761906,
            "pseudo_dstar_susp": 0.002109704641350211,
            "pseudo_tarantula_susp": 0.0007178750897343862,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.0007178750897343862
        }
    },
    {
        "name": "lib.matplotlib.ticker.AutoMinorLocator.__init__#2773",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.AutoMinorLocator",
        "signature": "lib.matplotlib.ticker.AutoMinorLocator.__init__(self, n=None)",
        "snippet": "    def __init__(self, n=None):\n        \"\"\"\n        *n* is the number of subdivisions of the interval between\n        major ticks; e.g., n=2 will place a single minor tick midway\n        between major ticks.\n\n        If *n* is omitted or None, it will be set to 5 or 4.\n        \"\"\"\n        self.ndivs = n",
        "begin_line": 2773,
        "end_line": 2781,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.825346394845998e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.ticker.AutoMinorLocator.__call__#2783",
        "src_path": "lib/matplotlib/ticker.py",
        "class_name": "lib.matplotlib.ticker.AutoMinorLocator",
        "signature": "lib.matplotlib.ticker.AutoMinorLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        \"\"\"Return the locations of the ticks.\"\"\"\n        if self.axis.get_scale() == 'log':\n            cbook._warn_external('AutoMinorLocator does not work with '\n                                 'logarithmic scale')\n            return []\n\n        majorlocs = self.axis.get_majorticklocs()\n        try:\n            majorstep = majorlocs[1] - majorlocs[0]\n        except IndexError:\n            # Need at least two major ticks to find minor tick locations\n            # TODO: Figure out a way to still be able to display minor\n            # ticks without two major ticks visible. For now, just display\n            # no ticks at all.\n            return []\n\n        if self.ndivs is None:\n\n            majorstep_no_exponent = 10 ** (np.log10(majorstep) % 1)\n\n            if np.isclose(majorstep_no_exponent, [1.0, 2.5, 5.0, 10.0]).any():\n                ndivs = 5\n            else:\n                ndivs = 4\n        else:\n            ndivs = self.ndivs\n\n        minorstep = majorstep / ndivs\n\n        vmin, vmax = self.axis.get_view_interval()\n        if vmin > vmax:\n            vmin, vmax = vmax, vmin\n\n        t0 = majorlocs[0]\n        tmin = ((vmin - t0) // minorstep + 1) * minorstep\n        tmax = ((vmax - t0) // minorstep + 1) * minorstep\n        locs = np.arange(tmin, tmax, minorstep) + t0\n\n        return self.raise_if_exceeds(locs)",
        "begin_line": 2783,
        "end_line": 2822,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.__init__#51",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.__init__(self, parent=None, name='', tightwidth=False, tightheight=False, artist=None, lower_left=(0, 0), upper_right=(1, 1), pos=False, subplot=False, h_pad=None, w_pad=None)",
        "snippet": "    def __init__(self, parent=None, name='', tightwidth=False,\n                 tightheight=False, artist=None,\n                 lower_left=(0, 0), upper_right=(1, 1), pos=False,\n                 subplot=False, h_pad=None, w_pad=None):\n        Variable = kiwi.Variable\n        self.parent = parent\n        self.name = name\n        sn = self.name + '_'\n        if parent is None:\n            self.solver = kiwi.Solver()\n            self.constrained_layout_called = 0\n        else:\n            self.solver = parent.solver\n            self.constrained_layout_called = None\n            # parent wants to know about this child!\n            parent.add_child(self)\n        # keep track of artist associated w/ this layout.  Can be none\n        self.artist = artist\n        # keep track if this box is supposed to be a pos that is constrained\n        # by the parent.\n        self.pos = pos\n        # keep track of whether we need to match this subplot up with others.\n        self.subplot = subplot\n\n        self.top = Variable(sn + 'top')\n        self.bottom = Variable(sn + 'bottom')\n        self.left = Variable(sn + 'left')\n        self.right = Variable(sn + 'right')\n\n        self.width = Variable(sn + 'width')\n        self.height = Variable(sn + 'height')\n        self.h_center = Variable(sn + 'h_center')\n        self.v_center = Variable(sn + 'v_center')\n\n        self.min_width = Variable(sn + 'min_width')\n        self.min_height = Variable(sn + 'min_height')\n        self.pref_width = Variable(sn + 'pref_width')\n        self.pref_height = Variable(sn + 'pref_height')\n        # margins are only used for axes-position layout boxes.  maybe should\n        # be a separate subclass:\n        self.left_margin = Variable(sn + 'left_margin')\n        self.right_margin = Variable(sn + 'right_margin')\n        self.bottom_margin = Variable(sn + 'bottom_margin')\n        self.top_margin = Variable(sn + 'top_margin')\n        # mins\n        self.left_margin_min = Variable(sn + 'left_margin_min')\n        self.right_margin_min = Variable(sn + 'right_margin_min')\n        self.bottom_margin_min = Variable(sn + 'bottom_margin_min')\n        self.top_margin_min = Variable(sn + 'top_margin_min')\n\n        right, top = upper_right\n        left, bottom = lower_left\n        self.tightheight = tightheight\n        self.tightwidth = tightwidth\n        self.add_constraints()\n        self.children = []\n        self.subplotspec = None\n        if self.pos:\n            self.constrain_margins()\n        self.h_pad = h_pad\n        self.w_pad = w_pad",
        "begin_line": 51,
        "end_line": 111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.984031936127745e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.constrain_margins#113",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.constrain_margins(self)",
        "snippet": "    def constrain_margins(self):\n        \"\"\"\n        Only do this for pos.  This sets a variable distance\n        margin between the position of the axes and the outer edge of\n        the axes.\n\n        Margins are variable because they change with the figure size.\n\n        Margin minimums are set to make room for axes decorations.  However,\n        the margins can be larger if we are mathicng the position size to\n        other axes.\n        \"\"\"\n        sol = self.solver\n\n        # left\n        if not sol.hasEditVariable(self.left_margin_min):\n            sol.addEditVariable(self.left_margin_min, 'strong')\n            sol.suggestValue(self.left_margin_min, 0.0001)\n        c = (self.left_margin == self.left - self.parent.left)\n        self.solver.addConstraint(c | 'required')\n        c = (self.left_margin >= self.left_margin_min)\n        self.solver.addConstraint(c | 'strong')\n\n        # right\n        if not sol.hasEditVariable(self.right_margin_min):\n            sol.addEditVariable(self.right_margin_min, 'strong')\n            sol.suggestValue(self.right_margin_min, 0.0001)\n        c = (self.right_margin == self.parent.right - self.right)\n        self.solver.addConstraint(c | 'required')\n        c = (self.right_margin >= self.right_margin_min)\n        self.solver.addConstraint(c | 'required')\n        # bottom\n        if not sol.hasEditVariable(self.bottom_margin_min):\n            sol.addEditVariable(self.bottom_margin_min, 'strong')\n            sol.suggestValue(self.bottom_margin_min, 0.0001)\n        c = (self.bottom_margin == self.bottom - self.parent.bottom)\n        self.solver.addConstraint(c | 'required')\n        c = (self.bottom_margin >= self.bottom_margin_min)\n        self.solver.addConstraint(c | 'required')\n        # top\n        if not sol.hasEditVariable(self.top_margin_min):\n            sol.addEditVariable(self.top_margin_min, 'strong')\n            sol.suggestValue(self.top_margin_min, 0.0001)\n        c = (self.top_margin == self.parent.top - self.top)\n        self.solver.addConstraint(c | 'required')\n        c = (self.top_margin >= self.top_margin_min)\n        self.solver.addConstraint(c | 'required')",
        "begin_line": 113,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.098477486232588e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.add_child#161",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.add_child(self, child)",
        "snippet": "    def add_child(self, child):\n        self.children += [child]",
        "begin_line": 161,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.757350089209525e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.hard_constraints#192",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.hard_constraints(self)",
        "snippet": "    def hard_constraints(self):\n        hc = [self.width == self.right - self.left,\n              self.height == self.top - self.bottom,\n              self.h_center == (self.left + self.right) * 0.5,\n              self.v_center == (self.top + self.bottom) * 0.5,\n              self.width >= self.min_width,\n              self.height >= self.min_height]\n        for c in hc:\n            self.solver.addConstraint(c | 'required')",
        "begin_line": 192,
        "end_line": 200,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.805182641273806e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.constrain_geometry#229",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.constrain_geometry(self, left, bottom, right, top, strength='strong')",
        "snippet": "    def constrain_geometry(self, left, bottom, right, top, strength='strong'):\n        hc = [self.left == left,\n              self.right == right,\n              self.bottom == bottom,\n              self.top == top]\n        for c in hc:\n            self.solver.addConstraint(c | strength)",
        "begin_line": 229,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.90076637433831e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.constrain_right_margin#256",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.constrain_right_margin(self, margin, strength='strong')",
        "snippet": "    def constrain_right_margin(self, margin, strength='strong'):\n        c = (self.right == self.parent.right - margin)\n        self.solver.addConstraint(c | strength)",
        "begin_line": 256,
        "end_line": 258,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.000090000900009e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.edit_right_margin_min#260",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.edit_right_margin_min(self, margin)",
        "snippet": "    def edit_right_margin_min(self, margin):\n        self.solver.suggestValue(self.right_margin_min, margin)",
        "begin_line": 260,
        "end_line": 261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.000090000900009e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.constrain_bottom_margin#263",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.constrain_bottom_margin(self, margin, strength='strong')",
        "snippet": "    def constrain_bottom_margin(self, margin, strength='strong'):\n        c = (self.bottom == self.parent.bottom + margin)\n        self.solver.addConstraint(c | strength)",
        "begin_line": 263,
        "end_line": 265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.edit_bottom_margin_min#267",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.edit_bottom_margin_min(self, margin)",
        "snippet": "    def edit_bottom_margin_min(self, margin):\n        self.solver.suggestValue(self.bottom_margin_min, margin)",
        "begin_line": 267,
        "end_line": 268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.000090000900009e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.constrain_top_margin#270",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.constrain_top_margin(self, margin, strength='strong')",
        "snippet": "    def constrain_top_margin(self, margin, strength='strong'):\n        c = (self.top == self.parent.top - margin)\n        self.solver.addConstraint(c | strength)",
        "begin_line": 270,
        "end_line": 272,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.000090000900009e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.edit_top_margin_min#274",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.edit_top_margin_min(self, margin)",
        "snippet": "    def edit_top_margin_min(self, margin):\n        self.solver.suggestValue(self.top_margin_min, margin)",
        "begin_line": 274,
        "end_line": 275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.get_rect#277",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.get_rect(self)",
        "snippet": "    def get_rect(self):\n        return (self.left.value(), self.bottom.value(),\n                self.width.value(), self.height.value())",
        "begin_line": 277,
        "end_line": 279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.update_variables#281",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.update_variables(self)",
        "snippet": "    def update_variables(self):\n        \"\"\"\n        Update *all* the variables that are part of the solver this LayoutBox\n        is created with.\n        \"\"\"\n        self.solver.updateVariables()",
        "begin_line": 281,
        "end_line": 286,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox.constrain_height_min#309",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox.constrain_height_min(self, height, strength='strong')",
        "snippet": "    def constrain_height_min(self, height, strength='strong'):\n        c = (self.height >= height)\n        self.solver.addConstraint(c | strength)",
        "begin_line": 309,
        "end_line": 311,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.000090000900009e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox._is_subplotspec_layoutbox#348",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox._is_subplotspec_layoutbox(self)",
        "snippet": "    def _is_subplotspec_layoutbox(self):\n        \"\"\"\n        Helper to check if this layoutbox is the layoutbox of a subplotspec.\n        \"\"\"\n        name = self.name.split('.')[-1]\n        return name[:2] == 'ss'",
        "begin_line": 348,
        "end_line": 353,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.LayoutBox._is_gridspec_layoutbox#355",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox.LayoutBox",
        "signature": "lib.matplotlib._layoutbox.LayoutBox._is_gridspec_layoutbox(self)",
        "snippet": "    def _is_gridspec_layoutbox(self):\n        \"\"\"\n        Helper to check if this layoutbox is the layoutbox of a gridspec.\n        \"\"\"\n        name = self.name.split('.')[-1]\n        return name[:8] == 'gridspec'",
        "begin_line": 355,
        "end_line": 360,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.000090000900009e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.seq_id#611",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox",
        "signature": "lib.matplotlib._layoutbox.seq_id()",
        "snippet": "def seq_id():\n    \"\"\"Generate a short sequential id for layoutbox objects.\"\"\"\n    return '%06d' % next(_layoutboxobjnum)",
        "begin_line": 611,
        "end_line": 613,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.946144211844694e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._layoutbox.nonetree#623",
        "src_path": "lib/matplotlib/_layoutbox.py",
        "class_name": "lib.matplotlib._layoutbox",
        "signature": "lib.matplotlib._layoutbox.nonetree(lb)",
        "snippet": "def nonetree(lb):\n    \"\"\"\n    Make all elements in this tree None, signalling not to do any more layout.\n    \"\"\"\n    if lb is not None:\n        if lb.parent is None:\n            # Clear the solver.  Hopefully this garbage collects.\n            lb.solver.reset()\n            nonechildren(lb)\n        else:\n            nonetree(lb.parent)",
        "begin_line": 623,
        "end_line": 633,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.stackplot.stackplot#16",
        "src_path": "lib/matplotlib/stackplot.py",
        "class_name": "lib.matplotlib.stackplot",
        "signature": "lib.matplotlib.stackplot.stackplot(axes, x, *args, labels=(), colors=None, baseline='zero', **kwargs)",
        "snippet": "def stackplot(axes, x, *args,\n              labels=(), colors=None, baseline='zero',\n              **kwargs):\n    \"\"\"\n    Draw a stacked area plot.\n\n    Parameters\n    ----------\n    x : 1d array of dimension N\n\n    y : 2d array (dimension MxN), or sequence of 1d arrays (each dimension 1xN)\n\n        The data is assumed to be unstacked. Each of the following\n        calls is legal::\n\n            stackplot(x, y)               # where y is MxN\n            stackplot(x, y1, y2, y3, y4)  # where y1, y2, y3, y4, are all 1xNm\n\n    baseline : {'zero', 'sym', 'wiggle', 'weighted_wiggle'}\n        Method used to calculate the baseline:\n\n        - ``'zero'``: Constant zero baseline, i.e. a simple stacked plot.\n        - ``'sym'``:  Symmetric around zero and is sometimes called\n          'ThemeRiver'.\n        - ``'wiggle'``: Minimizes the sum of the squared slopes.\n        - ``'weighted_wiggle'``: Does the same but weights to account for\n          size of each layer. It is also called 'Streamgraph'-layout. More\n          details can be found at http://leebyron.com/streamgraph/.\n\n    labels : Length N sequence of strings\n        Labels to assign to each data series.\n\n    colors : Length N sequence of colors\n        A list or tuple of colors. These will be cycled through and used to\n        colour the stacked areas.\n\n    **kwargs\n        All other keyword arguments are passed to `.Axes.fill_between`.\n\n    Returns\n    -------\n    list : list of `.PolyCollection`\n        A list of `.PolyCollection` instances, one for each element in the\n        stacked area plot.\n    \"\"\"\n\n    y = np.row_stack(args)\n\n    labels = iter(labels)\n    if colors is not None:\n        axes.set_prop_cycle(color=colors)\n\n    # Assume data passed has not been 'stacked', so stack it here.\n    # We'll need a float buffer for the upcoming calculations.\n    stack = np.cumsum(y, axis=0, dtype=np.promote_types(y.dtype, np.float32))\n\n    cbook._check_in_list(['zero', 'sym', 'wiggle', 'weighted_wiggle'],\n                         baseline=baseline)\n    if baseline == 'zero':\n        first_line = 0.\n\n    elif baseline == 'sym':\n        first_line = -np.sum(y, 0) * 0.5\n        stack += first_line[None, :]\n\n    elif baseline == 'wiggle':\n        m = y.shape[0]\n        first_line = (y * (m - 0.5 - np.arange(m)[:, None])).sum(0)\n        first_line /= -m\n        stack += first_line\n\n    elif baseline == 'weighted_wiggle':\n        total = np.sum(y, 0)\n        # multiply by 1/total (or zero) to avoid infinities in the division:\n        inv_total = np.zeros_like(total)\n        mask = total > 0\n        inv_total[mask] = 1.0 / total[mask]\n        increase = np.hstack((y[:, 0:1], np.diff(y)))\n        below_size = total - stack\n        below_size += 0.5 * y\n        move_up = below_size * inv_total\n        move_up[:, 0] = 0.5\n        center = (move_up - 0.5) * increase\n        center = np.cumsum(center.sum(0))\n        first_line = center - 0.5 * total\n        stack += first_line\n\n    # Color between x = 0 and the first array.\n    color = axes._get_lines.get_next_color()\n    coll = axes.fill_between(x, first_line, stack[0, :],\n                             facecolor=color, label=next(labels, None),\n                             **kwargs)\n    coll.sticky_edges.y[:] = [0]\n    r = [coll]\n\n    # Color between array i-1 and array i\n    for i in range(len(y) - 1):\n        color = axes._get_lines.get_next_color()\n        r.append(axes.fill_between(x, stack[i, :], stack[i + 1, :],\n                                   facecolor=color, label=next(labels, None),\n                                   **kwargs))\n    return r",
        "begin_line": 16,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.textpath.TextToPath.__init__#24",
        "src_path": "lib/matplotlib/textpath.py",
        "class_name": "lib.matplotlib.textpath.TextToPath",
        "signature": "lib.matplotlib.textpath.TextToPath.__init__(self)",
        "snippet": "    def __init__(self):\n        self.mathtext_parser = MathTextParser('path')\n        self._texmanager = None",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.114907084313884e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.get_registered_canvas_class#104",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases",
        "signature": "lib.matplotlib.backend_bases.get_registered_canvas_class(format)",
        "snippet": "def get_registered_canvas_class(format):\n    \"\"\"\n    Return the registered default canvas for given file format.\n    Handles deferred import of required backend.\n    \"\"\"\n    if format not in _default_backends:\n        return None\n    backend_class = _default_backends[format]\n    if isinstance(backend_class, str):\n        backend_class = importlib.import_module(backend_class).FigureCanvas\n        _default_backends[format] = backend_class\n    return backend_class",
        "begin_line": 104,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003205128205128205,
            "pseudo_dstar_susp": 0.0007012622720897616,
            "pseudo_tarantula_susp": 0.0018115942028985507,
            "pseudo_op2_susp": 0.0006983240223463687,
            "pseudo_barinel_susp": 0.0018115942028985507
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase.__init__#138",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase.__init__(self)",
        "snippet": "    def __init__(self):\n        super().__init__()\n        self._texmanager = None\n        self._text2path = textpath.TextToPath()",
        "begin_line": 138,
        "end_line": 141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003713330857779428,
            "pseudo_dstar_susp": 0.0006934812760055479,
            "pseudo_tarantula_susp": 0.0003091190108191654,
            "pseudo_op2_susp": 0.0006934812760055479,
            "pseudo_barinel_susp": 0.0003091190108191654
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase.open_group#143",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase.open_group(self, s, gid=None)",
        "snippet": "    def open_group(self, s, gid=None):\n        \"\"\"\n        Open a grouping element with label *s* and *gid* (if set) as id.\n\n        Only used by the SVG renderer.\n        \"\"\"",
        "begin_line": 143,
        "end_line": 148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003091190108191654,
            "pseudo_dstar_susp": 0.000643915003219575,
            "pseudo_tarantula_susp": 0.0002794076557697681,
            "pseudo_op2_susp": 0.000643915003219575,
            "pseudo_barinel_susp": 0.0002794076557697681
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase.close_group#150",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase.close_group(self, s)",
        "snippet": "    def close_group(self, s):\n        \"\"\"\n        Close a grouping element with label *s*.\n\n        Only used by the SVG renderer.\n        \"\"\"",
        "begin_line": 150,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00033500837520938025,
            "pseudo_dstar_susp": 0.000758150113722517,
            "pseudo_tarantula_susp": 0.0002808988764044944,
            "pseudo_op2_susp": 0.000758150113722517,
            "pseudo_barinel_susp": 0.0002808988764044944
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase.draw_path_collection#195",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase.draw_path_collection(self, gc, master_transform, paths, all_transforms, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls, offset_position)",
        "snippet": "    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offsetTrans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        \"\"\"\n        Draw a collection of paths selecting drawing properties from\n        the lists *facecolors*, *edgecolors*, *linewidths*,\n        *linestyles* and *antialiaseds*. *offsets* is a list of\n        offsets to apply to each of the paths.  The offsets in\n        *offsets* are first transformed by *offsetTrans* before being\n        applied.  *offset_position* may be either \"screen\" or \"data\"\n        depending on the space that the offsets are in.\n\n        This provides a fallback implementation of\n        :meth:`draw_path_collection` that makes multiple calls to\n        :meth:`draw_path`.  Some backends may want to override this in\n        order to render each set of path data only once, and then\n        reference that path multiple times with the different offsets,\n        colors, styles etc.  The generator methods\n        :meth:`_iter_collection_raw_paths` and\n        :meth:`_iter_collection` are provided to help with (and\n        standardize) the implementation across backends.  It is highly\n        recommended to use those generators, so that changes to the\n        behavior of :meth:`draw_path_collection` can be made globally.\n        \"\"\"\n        path_ids = [\n            (path, transforms.Affine2D(transform))\n            for path, transform in self._iter_collection_raw_paths(\n                    master_transform, paths, all_transforms)]\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, master_transform, all_transforms, path_ids, offsets,\n                offsetTrans, facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n            path, transform = path_id\n            transform = transforms.Affine2D(\n                            transform.get_matrix()).translate(xo, yo)\n            self.draw_path(gc0, path, transform, rgbFace)",
        "begin_line": 195,
        "end_line": 232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.058823529411764705,
            "pseudo_dstar_susp": 0.0007639419404125286,
            "pseudo_tarantula_susp": 0.006756756756756757,
            "pseudo_op2_susp": 0.0007639419404125286,
            "pseudo_barinel_susp": 0.006756756756756757
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase._iter_collection_raw_paths#296",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase._iter_collection_raw_paths(self, master_transform, paths, all_transforms)",
        "snippet": "    def _iter_collection_raw_paths(self, master_transform, paths,\n                                   all_transforms):\n        \"\"\"\n        This is a helper method (along with :meth:`_iter_collection`) to make\n        it easier to write a space-efficient :meth:`draw_path_collection`\n        implementation in a backend.\n\n        This method yields all of the base path/transform\n        combinations, given a master transform, a list of paths and\n        list of transforms.\n\n        The arguments should be exactly what is passed in to\n        :meth:`draw_path_collection`.\n\n        The backend should take each yielded path and transform and\n        create an object that can be referenced (reused) later.\n        \"\"\"\n        Npaths = len(paths)\n        Ntransforms = len(all_transforms)\n        N = max(Npaths, Ntransforms)\n\n        if Npaths == 0:\n            return\n\n        transform = transforms.IdentityTransform()\n        for i in range(N):\n            path = paths[i % Npaths]\n            if Ntransforms:\n                transform = Affine2D(all_transforms[i % Ntransforms])\n            yield path, transform + master_transform",
        "begin_line": 296,
        "end_line": 325,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase._iter_collection_uses_per_path#327",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase._iter_collection_uses_per_path(self, paths, all_transforms, offsets, facecolors, edgecolors)",
        "snippet": "    def _iter_collection_uses_per_path(self, paths, all_transforms,\n                                       offsets, facecolors, edgecolors):\n        \"\"\"\n        Compute how many times each raw path object returned by\n        _iter_collection_raw_paths would be used when calling\n        _iter_collection. This is intended for the backend to decide\n        on the tradeoff between using the paths in-line and storing\n        them once and reusing. Rounds up in case the number of uses\n        is not the same for every path.\n        \"\"\"\n        Npaths = len(paths)\n        if Npaths == 0 or len(facecolors) == len(edgecolors) == 0:\n            return 0\n        Npath_ids = max(Npaths, len(all_transforms))\n        N = max(Npath_ids, len(offsets))\n        return (N + Npath_ids - 1) // Npath_ids",
        "begin_line": 327,
        "end_line": 342,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase._iter_collection#344",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase._iter_collection(self, gc, master_transform, all_transforms, path_ids, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls, offset_position)",
        "snippet": "    def _iter_collection(self, gc, master_transform, all_transforms,\n                         path_ids, offsets, offsetTrans, facecolors,\n                         edgecolors, linewidths, linestyles,\n                         antialiaseds, urls, offset_position):\n        \"\"\"\n        This is a helper method (along with\n        :meth:`_iter_collection_raw_paths`) to make it easier to write\n        a space-efficient :meth:`draw_path_collection` implementation in a\n        backend.\n\n        This method yields all of the path, offset and graphics\n        context combinations to draw the path collection.  The caller\n        should already have looped over the results of\n        :meth:`_iter_collection_raw_paths` to draw this collection.\n\n        The arguments should be the same as that passed into\n        :meth:`draw_path_collection`, with the exception of\n        *path_ids*, which is a list of arbitrary objects that the\n        backend will use to reference one of the paths created in the\n        :meth:`_iter_collection_raw_paths` stage.\n\n        Each yielded result is of the form::\n\n           xo, yo, path_id, gc, rgbFace\n\n        where *xo*, *yo* is an offset; *path_id* is one of the elements of\n        *path_ids*; *gc* is a graphics context and *rgbFace* is a color to\n        use for filling the path.\n        \"\"\"\n        Ntransforms = len(all_transforms)\n        Npaths = len(path_ids)\n        Noffsets = len(offsets)\n        N = max(Npaths, Noffsets)\n        Nfacecolors = len(facecolors)\n        Nedgecolors = len(edgecolors)\n        Nlinewidths = len(linewidths)\n        Nlinestyles = len(linestyles)\n        Naa = len(antialiaseds)\n        Nurls = len(urls)\n\n        if (Nfacecolors == 0 and Nedgecolors == 0) or Npaths == 0:\n            return\n        if Noffsets:\n            toffsets = offsetTrans.transform(offsets)\n\n        gc0 = self.new_gc()\n        gc0.copy_properties(gc)\n\n        if Nfacecolors == 0:\n            rgbFace = None\n\n        if Nedgecolors == 0:\n            gc0.set_linewidth(0.0)\n\n        xo, yo = 0, 0\n        for i in range(N):\n            path_id = path_ids[i % Npaths]\n            if Noffsets:\n                xo, yo = toffsets[i % Noffsets]\n                if offset_position == 'data':\n                    if Ntransforms:\n                        transform = (\n                            Affine2D(all_transforms[i % Ntransforms]) +\n                            master_transform)\n                    else:\n                        transform = master_transform\n                    (xo, yo), (xp, yp) = transform.transform(\n                        [(xo, yo), (0, 0)])\n                    xo = -(xp - xo)\n                    yo = -(yp - yo)\n            if not (np.isfinite(xo) and np.isfinite(yo)):\n                continue\n            if Nfacecolors:\n                rgbFace = facecolors[i % Nfacecolors]\n            if Nedgecolors:\n                if Nlinewidths:\n                    gc0.set_linewidth(linewidths[i % Nlinewidths])\n                if Nlinestyles:\n                    gc0.set_dashes(*linestyles[i % Nlinestyles])\n                fg = edgecolors[i % Nedgecolors]\n                if len(fg) == 4:\n                    if fg[3] == 0.0:\n                        gc0.set_linewidth(0)\n                    else:\n                        gc0.set_foreground(fg)\n                else:\n                    gc0.set_foreground(fg)\n            if rgbFace is not None and len(rgbFace) == 4:\n                if rgbFace[3] == 0:\n                    rgbFace = None\n            gc0.set_antialiased(antialiaseds[i % Naa])\n            if Nurls:\n                gc0.set_url(urls[i % Nurls])\n\n            yield xo, yo, path_id, gc0, rgbFace\n        gc0.restore()",
        "begin_line": 344,
        "end_line": 439,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase.get_image_magnification#441",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase.get_image_magnification(self)",
        "snippet": "    def get_image_magnification(self):\n        \"\"\"\n        Get the factor by which to magnify images passed to :meth:`draw_image`.\n        Allows a backend to have images at a different resolution to other\n        artists.\n        \"\"\"\n        return 1.0",
        "begin_line": 441,
        "end_line": 447,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase.draw_text#504",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase.draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None)",
        "snippet": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        \"\"\"\n        Draw the text instance.\n\n        Parameters\n        ----------\n        gc : `.GraphicsContextBase`\n            The graphics context.\n        x : float\n            The x location of the text in display coords.\n        y : float\n            The y location of the text baseline in display coords.\n        s : str\n            The text string.\n        prop : `matplotlib.font_manager.FontProperties`\n            The font properties.\n        angle : float\n            The rotation angle in degrees anti-clockwise.\n        mtext : `matplotlib.text.Text`\n            The original text object to be rendered.\n\n        Notes\n        -----\n        **Note for backend implementers:**\n\n        When you are trying to determine if you have gotten your bounding box\n        right (which is what enables the text layout/alignment to work\n        properly), it helps to change the line in text.py::\n\n            if 0: bbox_artist(self, renderer)\n\n        to if 1, and then the actual bounding box will be plotted along with\n        your text.\n        \"\"\"\n\n        self._draw_text_as_path(gc, x, y, s, prop, angle, ismath)",
        "begin_line": 504,
        "end_line": 539,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase._get_text_path_transform#541",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase._get_text_path_transform(self, x, y, s, prop, angle, ismath)",
        "snippet": "    def _get_text_path_transform(self, x, y, s, prop, angle, ismath):\n        \"\"\"\n        Return the text path and transform.\n\n        Parameters\n        ----------\n        prop : `matplotlib.font_manager.FontProperties`\n            The font property.\n        s : str\n            The text to be converted.\n        ismath : bool or \"TeX\"\n            If True, use mathtext parser. If \"TeX\", use *usetex* mode.\n        \"\"\"\n\n        text2path = self._text2path\n        fontsize = self.points_to_pixels(prop.get_size_in_points())\n        verts, codes = text2path.get_text_path(prop, s, ismath=ismath)\n\n        path = Path(verts, codes)\n        angle = np.deg2rad(angle)\n        if self.flipy():\n            width, height = self.get_canvas_width_height()\n            transform = (Affine2D()\n                         .scale(fontsize / text2path.FONT_SCALE)\n                         .rotate(angle)\n                         .translate(x, height - y))\n        else:\n            transform = (Affine2D()\n                         .scale(fontsize / text2path.FONT_SCALE)\n                         .rotate(angle)\n                         .translate(x, y))\n\n        return path, transform",
        "begin_line": 541,
        "end_line": 573,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase.flipy#628",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase.flipy(self)",
        "snippet": "    def flipy(self):\n        \"\"\"\n        Return whether y values increase from top to bottom.\n\n        Note that this only affects drawing of texts and images.\n        \"\"\"\n        return True",
        "begin_line": 628,
        "end_line": 634,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043271311120726956,
            "pseudo_dstar_susp": 0.00038580246913580245,
            "pseudo_tarantula_susp": 0.001392757660167131,
            "pseudo_op2_susp": 0.00038580246913580245,
            "pseudo_barinel_susp": 0.001392757660167131
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase.new_gc#647",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase.new_gc(self)",
        "snippet": "    def new_gc(self):\n        \"\"\"Return an instance of a `.GraphicsContextBase`.\"\"\"\n        return GraphicsContextBase()",
        "begin_line": 647,
        "end_line": 649,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041050903119868636,
            "pseudo_dstar_susp": 0.00037425149700598805,
            "pseudo_tarantula_susp": 0.001004016064257028,
            "pseudo_op2_susp": 0.00037425149700598805,
            "pseudo_barinel_susp": 0.0010030090270812437
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase.points_to_pixels#651",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase.points_to_pixels(self, points)",
        "snippet": "    def points_to_pixels(self, points):\n        \"\"\"\n        Convert points to display units.\n\n        You need to override this function (unless your backend\n        doesn't have a dpi, e.g., postscript or svg).  Some imaging\n        systems assume some value for pixels per inch::\n\n            points to pixels = points * pixels_per_inch/72 * dpi/72\n\n        Parameters\n        ----------\n        points : float or array-like\n            a float or a numpy array of float\n\n        Returns\n        -------\n        Points converted to pixels\n        \"\"\"\n        return points",
        "begin_line": 651,
        "end_line": 670,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase.start_rasterizing#672",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase.start_rasterizing(self)",
        "snippet": "    def start_rasterizing(self):\n        \"\"\"\n        Switch to the raster renderer.\n\n        Used by `.MixedModeRenderer`.\n        \"\"\"",
        "begin_line": 672,
        "end_line": 677,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.RendererBase.stop_rasterizing#679",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.RendererBase",
        "signature": "lib.matplotlib.backend_bases.RendererBase.stop_rasterizing(self)",
        "snippet": "    def stop_rasterizing(self):\n        \"\"\"\n        Switch back to the vector renderer and draw the contents of the raster\n        renderer as an image on the vector renderer.\n\n        Used by `.MixedModeRenderer`.\n        \"\"\"",
        "begin_line": 679,
        "end_line": 685,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.__init__#707",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.__init__(self)",
        "snippet": "    def __init__(self):\n        self._alpha = 1.0\n        self._forced_alpha = False  # if True, _alpha overrides A from RGBA\n        self._antialiased = 1  # use 0, 1 not True, False for extension code\n        self._capstyle = 'butt'\n        self._cliprect = None\n        self._clippath = None\n        self._dashes = 0, None\n        self._joinstyle = 'round'\n        self._linestyle = 'solid'\n        self._linewidth = 1\n        self._rgb = (0.0, 0.0, 0.0, 1.0)\n        self._hatch = None\n        self._hatch_color = colors.to_rgba(rcParams['hatch.color'])\n        self._hatch_linewidth = rcParams['hatch.linewidth']\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = None",
        "begin_line": 707,
        "end_line": 725,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040551500405515005,
            "pseudo_dstar_susp": 0.00037037037037037035,
            "pseudo_tarantula_susp": 0.0009606147934678194,
            "pseudo_op2_susp": 0.00037037037037037035,
            "pseudo_barinel_susp": 0.0009606147934678194
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.copy_properties#727",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.copy_properties(self, gc)",
        "snippet": "    def copy_properties(self, gc):\n        \"\"\"Copy properties from *gc* to self.\"\"\"\n        self._alpha = gc._alpha\n        self._forced_alpha = gc._forced_alpha\n        self._antialiased = gc._antialiased\n        self._capstyle = gc._capstyle\n        self._cliprect = gc._cliprect\n        self._clippath = gc._clippath\n        self._dashes = gc._dashes\n        self._joinstyle = gc._joinstyle\n        self._linestyle = gc._linestyle\n        self._linewidth = gc._linewidth\n        self._rgb = gc._rgb\n        self._hatch = gc._hatch\n        self._hatch_color = gc._hatch_color\n        self._hatch_linewidth = gc._hatch_linewidth\n        self._url = gc._url\n        self._gid = gc._gid\n        self._snap = gc._snap\n        self._sketch = gc._sketch",
        "begin_line": 727,
        "end_line": 746,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.restore#748",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.restore(self)",
        "snippet": "    def restore(self):\n        \"\"\"\n        Restore the graphics context from the stack - needed only\n        for backends that save graphics contexts on a stack.\n        \"\"\"",
        "begin_line": 748,
        "end_line": 752,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040551500405515005,
            "pseudo_dstar_susp": 0.00037037037037037035,
            "pseudo_tarantula_susp": 0.0009606147934678194,
            "pseudo_op2_susp": 0.00037037037037037035,
            "pseudo_barinel_susp": 0.0009606147934678194
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_alpha#754",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_alpha(self)",
        "snippet": "    def get_alpha(self):\n        \"\"\"\n        Return the alpha value used for blending - not supported on\n        all backends.\n        \"\"\"\n        return self._alpha",
        "begin_line": 754,
        "end_line": 759,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_capstyle#765",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_capstyle(self)",
        "snippet": "    def get_capstyle(self):\n        \"\"\"\n        Return the capstyle as a string in ('butt', 'round', 'projecting').\n        \"\"\"\n        return self._capstyle",
        "begin_line": 765,
        "end_line": 769,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_clip_rectangle#771",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_clip_rectangle(self)",
        "snippet": "    def get_clip_rectangle(self):\n        \"\"\"\n        Return the clip rectangle as a `~matplotlib.transforms.Bbox` instance.\n        \"\"\"\n        return self._cliprect",
        "begin_line": 771,
        "end_line": 775,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_clip_path#777",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_clip_path(self)",
        "snippet": "    def get_clip_path(self):\n        \"\"\"\n        Return the clip path in the form (path, transform), where path\n        is a `~.path.Path` instance, and transform is\n        an affine transform to apply to the path before clipping.\n        \"\"\"\n        if self._clippath is not None:\n            return self._clippath.get_transformed_path_and_affine()\n        return None, None",
        "begin_line": 777,
        "end_line": 785,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_dashes#787",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_dashes(self)",
        "snippet": "    def get_dashes(self):\n        \"\"\"\n        Return the dash style as an (offset, dash-list) pair.\n\n        The dash list is a even-length list that gives the ink on, ink off in\n        points.  See p. 107 of to PostScript `blue book`_ for more info.\n\n        Default value is (None, None).\n\n        .. _blue book: https://www-cdf.fnal.gov/offline/PostScript/BLUEBOOK.PDF\n        \"\"\"\n        return self._dashes",
        "begin_line": 787,
        "end_line": 798,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040816326530612246,
            "pseudo_dstar_susp": 0.00037230081906180194,
            "pseudo_tarantula_susp": 0.0009832841691248771,
            "pseudo_op2_susp": 0.00037230081906180194,
            "pseudo_barinel_susp": 0.0009832841691248771
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_forced_alpha#800",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_forced_alpha(self)",
        "snippet": "    def get_forced_alpha(self):\n        \"\"\"\n        Return whether the value given by get_alpha() should be used to\n        override any other alpha-channel values.\n        \"\"\"\n        return self._forced_alpha",
        "begin_line": 800,
        "end_line": 805,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_joinstyle#807",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_joinstyle(self)",
        "snippet": "    def get_joinstyle(self):\n        \"\"\"Return the line join style as one of ('miter', 'round', 'bevel').\"\"\"\n        return self._joinstyle",
        "begin_line": 807,
        "end_line": 809,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_linewidth#811",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_linewidth(self)",
        "snippet": "    def get_linewidth(self):\n        \"\"\"Return the line width in points.\"\"\"\n        return self._linewidth",
        "begin_line": 811,
        "end_line": 813,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_rgb#815",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_rgb(self)",
        "snippet": "    def get_rgb(self):\n        \"\"\"Return a tuple of three or four floats from 0-1.\"\"\"\n        return self._rgb",
        "begin_line": 815,
        "end_line": 817,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_url#819",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_url(self)",
        "snippet": "    def get_url(self):\n        \"\"\"Return a url if one is set, None otherwise.\"\"\"\n        return self._url",
        "begin_line": 819,
        "end_line": 821,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_gid#823",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_gid(self)",
        "snippet": "    def get_gid(self):\n        \"\"\"Return the object identifier if one is set, None otherwise.\"\"\"\n        return self._gid",
        "begin_line": 823,
        "end_line": 825,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_snap#827",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_snap(self)",
        "snippet": "    def get_snap(self):\n        \"\"\"\n        Returns the snap setting, which can be:\n\n        * True: snap vertices to the nearest pixel center\n        * False: leave vertices as-is\n        * None: (auto) If the path contains only rectilinear line segments,\n          round to the nearest pixel center\n        \"\"\"\n        return self._snap",
        "begin_line": 827,
        "end_line": 836,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003861003861003861,
            "pseudo_dstar_susp": 0.000355998576005696,
            "pseudo_tarantula_susp": 0.0008077544426494346,
            "pseudo_op2_susp": 0.000355998576005696,
            "pseudo_barinel_susp": 0.0008077544426494346
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_alpha#838",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_alpha(self, alpha)",
        "snippet": "    def set_alpha(self, alpha):\n        \"\"\"\n        Set the alpha value used for blending - not supported on all backends.\n\n        If ``alpha=None`` (the default), the alpha components of the\n        foreground and fill colors will be used to set their respective\n        transparencies (where applicable); otherwise, ``alpha`` will override\n        them.\n        \"\"\"\n        if alpha is not None:\n            self._alpha = alpha\n            self._forced_alpha = True\n        else:\n            self._alpha = 1.0\n            self._forced_alpha = False\n        self.set_foreground(self._rgb, isRGBA=True)",
        "begin_line": 838,
        "end_line": 853,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040816326530612246,
            "pseudo_dstar_susp": 0.00037230081906180194,
            "pseudo_tarantula_susp": 0.0009832841691248771,
            "pseudo_op2_susp": 0.00037230081906180194,
            "pseudo_barinel_susp": 0.0009832841691248771
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_antialiased#855",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_antialiased(self, b)",
        "snippet": "    def set_antialiased(self, b):\n        \"\"\"Set whether object should be drawn with antialiased rendering.\"\"\"\n        # Use ints to make life easier on extension code trying to read the gc.\n        self._antialiased = int(bool(b))",
        "begin_line": 855,
        "end_line": 858,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040551500405515005,
            "pseudo_dstar_susp": 0.00037037037037037035,
            "pseudo_tarantula_susp": 0.0009606147934678194,
            "pseudo_op2_susp": 0.00037037037037037035,
            "pseudo_barinel_susp": 0.0009606147934678194
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_capstyle#860",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_capstyle(self, cs)",
        "snippet": "    def set_capstyle(self, cs):\n        \"\"\"Set the capstyle to be one of ('butt', 'round', 'projecting').\"\"\"\n        cbook._check_in_list(['butt', 'round', 'projecting'], cs=cs)\n        self._capstyle = cs",
        "begin_line": 860,
        "end_line": 863,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040816326530612246,
            "pseudo_dstar_susp": 0.00037230081906180194,
            "pseudo_tarantula_susp": 0.0009832841691248771,
            "pseudo_op2_susp": 0.00037230081906180194,
            "pseudo_barinel_susp": 0.0009832841691248771
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_clip_rectangle#865",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_clip_rectangle(self, rectangle)",
        "snippet": "    def set_clip_rectangle(self, rectangle):\n        \"\"\"\n        Set the clip rectangle with sequence (left, bottom, width, height)\n        \"\"\"\n        self._cliprect = rectangle",
        "begin_line": 865,
        "end_line": 869,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004246284501061571,
            "pseudo_dstar_susp": 0.00038255547054322876,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.00038255547054322876,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_clip_path#871",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_clip_path(self, path)",
        "snippet": "    def set_clip_path(self, path):\n        \"\"\"\n        Set the clip path and transformation.\n\n        Parameters\n        ----------\n        path : `~matplotlib.transforms.TransformedPath` or None\n        \"\"\"\n        cbook._check_isinstance((transforms.TransformedPath, None), path=path)\n        self._clippath = path",
        "begin_line": 871,
        "end_line": 880,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040816326530612246,
            "pseudo_dstar_susp": 0.00037230081906180194,
            "pseudo_tarantula_susp": 0.0009832841691248771,
            "pseudo_op2_susp": 0.00037230081906180194,
            "pseudo_barinel_susp": 0.0009832841691248771
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_dashes#882",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_dashes(self, dash_offset, dash_list)",
        "snippet": "    def set_dashes(self, dash_offset, dash_list):\n        \"\"\"\n        Set the dash style for the gc.\n\n        Parameters\n        ----------\n        dash_offset : float or None\n            The offset (usually 0).\n        dash_list : array-like or None\n            The on-off sequence as points.\n\n        Notes\n        -----\n        ``(None, None)`` specifies a solid line.\n\n        See p. 107 of to PostScript `blue book`_ for more info.\n\n        .. _blue book: https://www-cdf.fnal.gov/offline/PostScript/BLUEBOOK.PDF\n        \"\"\"\n        if dash_list is not None:\n            dl = np.asarray(dash_list)\n            if np.any(dl < 0.0):\n                raise ValueError(\n                    \"All values in the dash list must be positive\")\n        self._dashes = dash_offset, dash_list",
        "begin_line": 882,
        "end_line": 906,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_foreground#908",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_foreground(self, fg, isRGBA=False)",
        "snippet": "    def set_foreground(self, fg, isRGBA=False):\n        \"\"\"\n        Set the foreground color.\n\n        Parameters\n        ----------\n        fg : color\n        isRGBA : bool\n            If *fg* is known to be an ``(r, g, b, a)`` tuple, *isRGBA* can be\n            set to True to improve performance.\n        \"\"\"\n        if self._forced_alpha and isRGBA:\n            self._rgb = fg[:3] + (self._alpha,)\n        elif self._forced_alpha:\n            self._rgb = colors.to_rgba(fg, self._alpha)\n        elif isRGBA:\n            self._rgb = fg\n        else:\n            self._rgb = colors.to_rgba(fg)",
        "begin_line": 908,
        "end_line": 926,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003812428516965307,
            "pseudo_dstar_susp": 0.00035198873636043646,
            "pseudo_tarantula_susp": 0.0007564296520423601,
            "pseudo_op2_susp": 0.00035198873636043646,
            "pseudo_barinel_susp": 0.0007564296520423601
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_joinstyle#928",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_joinstyle(self, js)",
        "snippet": "    def set_joinstyle(self, js):\n        \"\"\"Set the join style to be one of ('miter', 'round', 'bevel').\"\"\"\n        cbook._check_in_list(['miter', 'round', 'bevel'], js=js)\n        self._joinstyle = js",
        "begin_line": 928,
        "end_line": 931,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040816326530612246,
            "pseudo_dstar_susp": 0.00037230081906180194,
            "pseudo_tarantula_susp": 0.0009832841691248771,
            "pseudo_op2_susp": 0.00037230081906180194,
            "pseudo_barinel_susp": 0.0009832841691248771
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_linewidth#933",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_linewidth(self, w)",
        "snippet": "    def set_linewidth(self, w):\n        \"\"\"Set the linewidth in points.\"\"\"\n        self._linewidth = float(w)",
        "begin_line": 933,
        "end_line": 935,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040551500405515005,
            "pseudo_dstar_susp": 0.00037037037037037035,
            "pseudo_tarantula_susp": 0.0009606147934678194,
            "pseudo_op2_susp": 0.00037037037037037035,
            "pseudo_barinel_susp": 0.0009606147934678194
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_url#937",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_url(self, url)",
        "snippet": "    def set_url(self, url):\n        \"\"\"Set the url for links in compatible backends.\"\"\"\n        self._url = url",
        "begin_line": 937,
        "end_line": 939,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041356492969396195,
            "pseudo_dstar_susp": 0.00037650602409638556,
            "pseudo_tarantula_susp": 0.001037344398340249,
            "pseudo_op2_susp": 0.00037650602409638556,
            "pseudo_barinel_susp": 0.001037344398340249
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_gid#941",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_gid(self, id)",
        "snippet": "    def set_gid(self, id):\n        \"\"\"Set the id.\"\"\"\n        self._gid = id",
        "begin_line": 941,
        "end_line": 943,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_snap#945",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_snap(self, snap)",
        "snippet": "    def set_snap(self, snap):\n        \"\"\"\n        Set the snap setting which may be:\n\n        * True: snap vertices to the nearest pixel center\n        * False: leave vertices as-is\n        * None: (auto) If the path contains only rectilinear line segments,\n          round to the nearest pixel center\n        \"\"\"\n        self._snap = snap",
        "begin_line": 945,
        "end_line": 954,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040816326530612246,
            "pseudo_dstar_susp": 0.00037230081906180194,
            "pseudo_tarantula_susp": 0.0009832841691248771,
            "pseudo_op2_susp": 0.00037230081906180194,
            "pseudo_barinel_susp": 0.0009832841691248771
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch#960",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch(self)",
        "snippet": "    def get_hatch(self):\n        \"\"\"Get the current hatch style.\"\"\"\n        return self._hatch",
        "begin_line": 960,
        "end_line": 962,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041356492969396195,
            "pseudo_dstar_susp": 0.00037650602409638556,
            "pseudo_tarantula_susp": 0.001037344398340249,
            "pseudo_op2_susp": 0.00037650602409638556,
            "pseudo_barinel_susp": 0.001037344398340249
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch_path#964",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch_path(self, density=6.0)",
        "snippet": "    def get_hatch_path(self, density=6.0):\n        \"\"\"Return a `.Path` for the current hatch.\"\"\"\n        hatch = self.get_hatch()\n        if hatch is None:\n            return None\n        return Path.hatch(hatch, density)",
        "begin_line": 964,
        "end_line": 969,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041356492969396195,
            "pseudo_dstar_susp": 0.00037650602409638556,
            "pseudo_tarantula_susp": 0.001037344398340249,
            "pseudo_op2_susp": 0.00037650602409638556,
            "pseudo_barinel_susp": 0.001037344398340249
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch_color#971",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch_color(self)",
        "snippet": "    def get_hatch_color(self):\n        \"\"\"Get the hatch color.\"\"\"\n        return self._hatch_color",
        "begin_line": 971,
        "end_line": 973,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004152823920265781,
            "pseudo_dstar_susp": 0.00037764350453172205,
            "pseudo_tarantula_susp": 0.0010526315789473684,
            "pseudo_op2_susp": 0.00037764350453172205,
            "pseudo_barinel_susp": 0.0010526315789473684
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.set_hatch_color#975",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.set_hatch_color(self, hatch_color)",
        "snippet": "    def set_hatch_color(self, hatch_color):\n        \"\"\"Set the hatch color.\"\"\"\n        self._hatch_color = hatch_color",
        "begin_line": 975,
        "end_line": 977,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch_linewidth#979",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_hatch_linewidth(self)",
        "snippet": "    def get_hatch_linewidth(self):\n        \"\"\"Get the hatch linewidth.\"\"\"\n        return self._hatch_linewidth",
        "begin_line": 979,
        "end_line": 981,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041050903119868636,
            "pseudo_dstar_susp": 0.00037425149700598805,
            "pseudo_tarantula_susp": 0.001004016064257028,
            "pseudo_op2_susp": 0.00037425149700598805,
            "pseudo_barinel_susp": 0.0010030090270812437
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.GraphicsContextBase.get_sketch_params#983",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.GraphicsContextBase",
        "signature": "lib.matplotlib.backend_bases.GraphicsContextBase.get_sketch_params(self)",
        "snippet": "    def get_sketch_params(self):\n        \"\"\"\n        Return the sketch parameters for the artist.\n\n        Returns\n        -------\n        sketch_params : tuple or `None`\n\n            A 3-tuple with the following elements:\n\n            * ``scale``: The amplitude of the wiggle perpendicular to the\n              source line.\n            * ``length``: The length of the wiggle along the line.\n            * ``randomness``: The scale factor by which the length is\n              shrunken or expanded.\n\n            May return `None` if no sketch parameters were set.\n        \"\"\"\n        return self._sketch",
        "begin_line": 983,
        "end_line": 1001,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041050903119868636,
            "pseudo_dstar_susp": 0.00037425149700598805,
            "pseudo_tarantula_susp": 0.001004016064257028,
            "pseudo_op2_susp": 0.00037425149700598805,
            "pseudo_barinel_susp": 0.0010030090270812437
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.TimerBase.__init__#1049",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.TimerBase",
        "signature": "lib.matplotlib.backend_bases.TimerBase.__init__(self, interval=None, callbacks=None)",
        "snippet": "    def __init__(self, interval=None, callbacks=None):\n        \"\"\"\n        Parameters\n        ----------\n        interval : int, default: 1000ms\n            The time between timer events in milliseconds.  Will be stored as\n            ``timer.interval``.\n        callbacks : List[Tuple[callable, Tuple, Dict]]\n            List of (func, args, kwargs) tuples that will be called upon\n            timer events.  This list is accessible as ``timer.callbacks`` and\n            can be manipulated directly, or the functions `add_callback` and\n            `remove_callback` can be used.\n        \"\"\"\n        self.callbacks = [] if callbacks is None else callbacks.copy()\n        self._interval = 1000 if interval is None else interval\n        self._single = False\n        # Default attribute for holding the GUI-specific timer object\n        self._timer = None",
        "begin_line": 1049,
        "end_line": 1066,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.TimerBase.__del__#1068",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.TimerBase",
        "signature": "lib.matplotlib.backend_bases.TimerBase.__del__(self)",
        "snippet": "    def __del__(self):\n        \"\"\"Need to stop timer and possibly disconnect timer.\"\"\"\n        self._timer_stop()",
        "begin_line": 1068,
        "end_line": 1070,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.TimerBase._timer_stop#1093",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.TimerBase",
        "signature": "lib.matplotlib.backend_bases.TimerBase._timer_stop(self)",
        "snippet": "    def _timer_stop(self):\n        pass",
        "begin_line": 1093,
        "end_line": 1094,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.Event.__init__#1194",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.Event",
        "signature": "lib.matplotlib.backend_bases.Event.__init__(self, name, canvas, guiEvent=None)",
        "snippet": "    def __init__(self, name, canvas, guiEvent=None):\n        self.name = name\n        self.canvas = canvas\n        self.guiEvent = guiEvent",
        "begin_line": 1194,
        "end_line": 1197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003837298541826554,
            "pseudo_dstar_susp": 0.00035398230088495576,
            "pseudo_tarantula_susp": 0.0007751937984496124,
            "pseudo_op2_susp": 0.00035398230088495576,
            "pseudo_barinel_susp": 0.0007757951900698216
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.DrawEvent.__init__#1222",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.DrawEvent",
        "signature": "lib.matplotlib.backend_bases.DrawEvent.__init__(self, name, canvas, renderer)",
        "snippet": "    def __init__(self, name, canvas, renderer):\n        Event.__init__(self, name, canvas)\n        self.renderer = renderer",
        "begin_line": 1222,
        "end_line": 1224,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040816326530612246,
            "pseudo_dstar_susp": 0.00037230081906180194,
            "pseudo_tarantula_susp": 0.0009832841691248771,
            "pseudo_op2_susp": 0.00037230081906180194,
            "pseudo_barinel_susp": 0.0009832841691248771
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.LocationEvent.__init__#1276",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.LocationEvent",
        "signature": "lib.matplotlib.backend_bases.LocationEvent.__init__(self, name, canvas, x, y, guiEvent=None)",
        "snippet": "    def __init__(self, name, canvas, x, y, guiEvent=None):\n        \"\"\"\n        (*x*, *y*) in figure coords ((0, 0) = bottom left).\n        \"\"\"\n        Event.__init__(self, name, canvas, guiEvent=guiEvent)\n        # x position - pixels from left of canvas\n        self.x = int(x) if x is not None else x\n        # y position - pixels from right of canvas\n        self.y = int(y) if y is not None else y\n        self.inaxes = None  # the Axes instance if mouse us over axes\n        self.xdata = None   # x coord of mouse in data coords\n        self.ydata = None   # y coord of mouse in data coords\n\n        if x is None or y is None:\n            # cannot check if event was in axes if no (x, y) info\n            self._update_enter_leave()\n            return\n\n        if self.canvas.mouse_grabber is None:\n            self.inaxes = self.canvas.inaxes((x, y))\n        else:\n            self.inaxes = self.canvas.mouse_grabber\n\n        if self.inaxes is not None:\n            try:\n                trans = self.inaxes.transData.inverted()\n                xdata, ydata = trans.transform((x, y))\n            except ValueError:\n                pass\n            else:\n                self.xdata = xdata\n                self.ydata = ydata\n\n        self._update_enter_leave()",
        "begin_line": 1276,
        "end_line": 1309,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.LocationEvent._update_enter_leave#1311",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.LocationEvent",
        "signature": "lib.matplotlib.backend_bases.LocationEvent._update_enter_leave(self)",
        "snippet": "    def _update_enter_leave(self):\n        \"\"\"Process the figure/axes enter leave events.\"\"\"\n        if LocationEvent.lastevent is not None:\n            last = LocationEvent.lastevent\n            if last.inaxes != self.inaxes:\n                # process axes enter/leave events\n                try:\n                    if last.inaxes is not None:\n                        last.canvas.callbacks.process('axes_leave_event', last)\n                except Exception:\n                    pass\n                    # See ticket 2901582.\n                    # I think this is a valid exception to the rule\n                    # against catching all exceptions; if anything goes\n                    # wrong, we simply want to move on and process the\n                    # current event.\n                if self.inaxes is not None:\n                    self.canvas.callbacks.process('axes_enter_event', self)\n\n        else:\n            # process a figure enter event\n            if self.inaxes is not None:\n                self.canvas.callbacks.process('axes_enter_event', self)\n\n        LocationEvent.lastevent = self",
        "begin_line": 1311,
        "end_line": 1335,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.MouseEvent.__init__#1391",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.MouseEvent",
        "signature": "lib.matplotlib.backend_bases.MouseEvent.__init__(self, name, canvas, x, y, button=None, key=None, step=0, dblclick=False, guiEvent=None)",
        "snippet": "    def __init__(self, name, canvas, x, y, button=None, key=None,\n                 step=0, dblclick=False, guiEvent=None):\n        \"\"\"\n        (*x*, *y*) in figure coords ((0, 0) = bottom left)\n        button pressed None, 1, 2, 3, 'up', 'down'\n        \"\"\"\n        LocationEvent.__init__(self, name, canvas, x, y, guiEvent=guiEvent)\n        if button in MouseButton.__members__.values():\n            button = MouseButton(button)\n        self.button = button\n        self.key = key\n        self.step = step\n        self.dblclick = dblclick",
        "begin_line": 1391,
        "end_line": 1403,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases._get_renderer#1492",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases",
        "signature": "lib.matplotlib.backend_bases._get_renderer(figure, print_method, *, draw_disabled=False)",
        "snippet": "def _get_renderer(figure, print_method, *, draw_disabled=False):\n    \"\"\"\n    Get the renderer that would be used to save a `~.Figure`, and cache it on\n    the figure.\n\n    If *draw_disabled* is True, additionally replace draw_foo methods on\n    *renderer* by no-ops.  This is used by the tight-bbox-saving renderer,\n    which needs to walk through the artist tree to compute the tight-bbox, but\n    for which the output file may be closed early.\n    \"\"\"\n    # This is implemented by triggering a draw, then immediately jumping out of\n    # Figure.draw() by raising an exception.\n\n    class Done(Exception):\n        pass\n\n    def _draw(renderer): raise Done(renderer)\n\n    with cbook._setattr_cm(figure, draw=_draw):\n        try:\n            print_method(io.BytesIO())\n        except Done as exc:\n            renderer, = figure._cachedRenderer, = exc.args\n\n    if draw_disabled:\n        for meth_name in dir(RendererBase):\n            if meth_name.startswith(\"draw_\"):\n                setattr(renderer, meth_name, lambda *args, **kwargs: None)\n\n    return renderer",
        "begin_line": 1492,
        "end_line": 1521,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.Done._get_renderer#1492",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.Done",
        "signature": "lib.matplotlib.backend_bases.Done._get_renderer(figure, print_method, *, draw_disabled=False)",
        "snippet": "def _get_renderer(figure, print_method, *, draw_disabled=False):\n    \"\"\"\n    Get the renderer that would be used to save a `~.Figure`, and cache it on\n    the figure.\n\n    If *draw_disabled* is True, additionally replace draw_foo methods on\n    *renderer* by no-ops.  This is used by the tight-bbox-saving renderer,\n    which needs to walk through the artist tree to compute the tight-bbox, but\n    for which the output file may be closed early.\n    \"\"\"\n    # This is implemented by triggering a draw, then immediately jumping out of\n    # Figure.draw() by raising an exception.\n\n    class Done(Exception):\n        pass\n\n    def _draw(renderer): raise Done(renderer)\n\n    with cbook._setattr_cm(figure, draw=_draw):\n        try:\n            print_method(io.BytesIO())\n        except Done as exc:\n            renderer, = figure._cachedRenderer, = exc.args\n\n    if draw_disabled:\n        for meth_name in dir(RendererBase):\n            if meth_name.startswith(\"draw_\"):\n                setattr(renderer, meth_name, lambda *args, **kwargs: None)\n\n    return renderer",
        "begin_line": 1492,
        "end_line": 1521,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases._draw#1508",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases",
        "signature": "lib.matplotlib.backend_bases._draw(renderer)",
        "snippet": "    def _draw(renderer): raise Done(renderer)",
        "begin_line": 1508,
        "end_line": 1508,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.supports_blit#1575",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.supports_blit(cls)",
        "snippet": "    def supports_blit(cls):\n        return (hasattr(cls, \"copy_from_bbox\")\n                and hasattr(cls, \"restore_region\"))",
        "begin_line": 1575,
        "end_line": 1577,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.__init__#1579",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.__init__(self, figure)",
        "snippet": "    def __init__(self, figure):\n        self._fix_ipython_backend2gui()\n        self._is_idle_drawing = True\n        self._is_saving = False\n        figure.set_canvas(self)\n        self.figure = figure\n        self.manager = None\n        # a dictionary from event name to a dictionary that maps cid->func\n        self.callbacks = cbook.CallbackRegistry()\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self._lastx, self._lasty = None, None\n        self.button_pick_id = self.mpl_connect('button_press_event', self.pick)\n        self.scroll_pick_id = self.mpl_connect('scroll_event', self.pick)\n        self.mouse_grabber = None  # the axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False",
        "begin_line": 1579,
        "end_line": 1596,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006510416666666666,
            "pseudo_dstar_susp": 0.0012690355329949238,
            "pseudo_tarantula_susp": 0.001128668171557562,
            "pseudo_op2_susp": 0.0012690355329949238,
            "pseudo_barinel_susp": 0.001128668171557562
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase._fix_ipython_backend2gui#1600",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase._fix_ipython_backend2gui(cls)",
        "snippet": "    def _fix_ipython_backend2gui(cls):\n        # Fix hard-coded module -> toolkit mapping in IPython (used for\n        # `ipython --auto`).  This cannot be done at import time due to\n        # ordering issues, so we do it when creating a canvas, and should only\n        # be done once per class (hence the `lru_cache(1)`).\n        if \"IPython\" not in sys.modules:\n            return\n        import IPython\n        ip = IPython.get_ipython()\n        if not ip:\n            return\n        from IPython.core import pylabtools as pt\n        if (not hasattr(pt, \"backend2gui\")\n                or not hasattr(ip, \"enable_matplotlib\")):\n            # In case we ever move the patch to IPython and remove these APIs,\n            # don't break on our side.\n            return\n        rif = getattr(cls, \"required_interactive_framework\", None)\n        backend2gui_rif = {\"qt5\": \"qt\", \"qt4\": \"qt\", \"gtk3\": \"gtk3\",\n                           \"wx\": \"wx\", \"macosx\": \"osx\"}.get(rif)\n        if backend2gui_rif:\n            if _is_non_interactive_terminal_ipython(ip):\n                ip.enable_gui(backend2gui_rif)",
        "begin_line": 1600,
        "end_line": 1622,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase._idle_draw_cntx#1625",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase._idle_draw_cntx(self)",
        "snippet": "    def _idle_draw_cntx(self):\n        self._is_idle_drawing = True\n        try:\n            yield\n        finally:\n            self._is_idle_drawing = False",
        "begin_line": 1625,
        "end_line": 1630,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.910273545397844e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.is_saving#1632",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.is_saving(self)",
        "snippet": "    def is_saving(self):\n        \"\"\"\n        Return whether the renderer is in the process of saving\n        to a file, rather than rendering for an on-screen buffer.\n        \"\"\"\n        return self._is_saving",
        "begin_line": 1632,
        "end_line": 1637,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041050903119868636,
            "pseudo_dstar_susp": 0.00037425149700598805,
            "pseudo_tarantula_susp": 0.001004016064257028,
            "pseudo_op2_susp": 0.00037425149700598805,
            "pseudo_barinel_susp": 0.0010030090270812437
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.blit#1643",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.blit(self, bbox=None)",
        "snippet": "    def blit(self, bbox=None):\n        \"\"\"Blit the canvas in bbox (default entire canvas).\"\"\"",
        "begin_line": 1643,
        "end_line": 1644,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.draw_event#1649",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.draw_event(self, renderer)",
        "snippet": "    def draw_event(self, renderer):\n        \"\"\"Pass a `DrawEvent` to all functions connected to ``draw_event``.\"\"\"\n        s = 'draw_event'\n        event = DrawEvent(s, self, renderer)\n        self.callbacks.process(s, event)",
        "begin_line": 1649,
        "end_line": 1653,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040816326530612246,
            "pseudo_dstar_susp": 0.00037230081906180194,
            "pseudo_tarantula_susp": 0.0009832841691248771,
            "pseudo_op2_susp": 0.00037230081906180194,
            "pseudo_barinel_susp": 0.0009832841691248771
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.inaxes#1842",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.inaxes(self, xy)",
        "snippet": "    def inaxes(self, xy):\n        \"\"\"\n        Return the topmost visible `~.axes.Axes` containing the point *xy*.\n\n        Parameters\n        ----------\n        xy : (float, float)\n            (x, y) pixel positions from left/bottom of the canvas.\n\n        Returns\n        -------\n        axes : `~matplotlib.axes.Axes` or None\n            The topmost visible axes containing the point, or None if no axes.\n        \"\"\"\n        axes_list = [a for a in self.figure.get_axes()\n                     if a.patch.contains_point(xy) and a.get_visible()]\n        if axes_list:\n            axes = cbook._topmost_artist(axes_list)\n        else:\n            axes = None\n\n        return axes",
        "begin_line": 1842,
        "end_line": 1863,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.draw#1886",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.draw(self, *args, **kwargs)",
        "snippet": "    def draw(self, *args, **kwargs):\n        \"\"\"Render the `.Figure`.\"\"\"",
        "begin_line": 1886,
        "end_line": 1887,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002707092582566324,
            "pseudo_dstar_susp": 0.0002707092582566324,
            "pseudo_tarantula_susp": 0.0002707092582566324,
            "pseudo_op2_susp": 0.0002707092582566324,
            "pseudo_barinel_susp": 0.0002707092582566324
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.draw_idle#1889",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.draw_idle(self, *args, **kwargs)",
        "snippet": "    def draw_idle(self, *args, **kwargs):\n        \"\"\"\n        Request a widget redraw once control returns to the GUI event loop.\n\n        Even if multiple calls to `draw_idle` occur before control returns\n        to the GUI event loop, the figure will only be rendered once.\n\n        Notes\n        -----\n        Backends may choose to override the method and implement their own\n        strategy to prevent multiple renderings.\n\n        \"\"\"\n        if not self._is_idle_drawing:\n            with self._idle_draw_cntx():\n                self.draw(*args, **kwargs)",
        "begin_line": 1889,
        "end_line": 1904,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.86679822397632e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase._get_output_canvas#1939",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase._get_output_canvas(self, backend, fmt)",
        "snippet": "    def _get_output_canvas(self, backend, fmt):\n        \"\"\"\n        Set the canvas in preparation for saving the figure.\n\n        Parameters\n        ----------\n        backend : str or None\n            If not None, switch the figure canvas to the ``FigureCanvas`` class\n            of the given backend.\n        fmt : str\n            If *backend* is None, then determine a suitable canvas class for\n            saving to format *fmt* -- either the current canvas class, if it\n            supports *fmt*, or whatever `get_registered_canvas_class` returns;\n            switch the figure canvas to that canvas class.\n        \"\"\"\n        if backend is not None:\n            # Return a specific canvas class, if requested.\n            canvas_class = (\n                importlib.import_module(cbook._backend_module_name(backend))\n                .FigureCanvas)\n            if not hasattr(canvas_class, f\"print_{fmt}\"):\n                raise ValueError(\n                    f\"The {backend!r} backend does not support {fmt} output\")\n        elif hasattr(self, f\"print_{fmt}\"):\n            # Return the current canvas if it supports the requested format.\n            return self\n        else:\n            # Return a default canvas for the requested format, if it exists.\n            canvas_class = get_registered_canvas_class(fmt)\n        if canvas_class:\n            return self.switch_backends(canvas_class)\n        # Else report error for unsupported format.\n        raise ValueError(\n            \"Format {!r} is not supported (supported formats: {})\"\n            .format(fmt, \", \".join(sorted(self.get_supported_filetypes()))))",
        "begin_line": 1939,
        "end_line": 1973,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004589261128958238,
            "pseudo_dstar_susp": 0.0003966679888932963,
            "pseudo_tarantula_susp": 0.0016181229773462784,
            "pseudo_op2_susp": 0.0003966679888932963,
            "pseudo_barinel_susp": 0.0016181229773462784
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.print_figure#1975",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.print_figure(self, filename, dpi=None, facecolor=None, edgecolor=None, orientation='portrait', format=None, *, bbox_inches=None, backend=None, **kwargs)",
        "snippet": "    def print_figure(self, filename, dpi=None, facecolor=None, edgecolor=None,\n                     orientation='portrait', format=None,\n                     *, bbox_inches=None, backend=None, **kwargs):\n        \"\"\"\n        Render the figure to hardcopy. Set the figure patch face and edge\n        colors.  This is useful because some of the GUIs have a gray figure\n        face color background and you'll probably want to override this on\n        hardcopy.\n\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            The file where the figure is saved.\n\n        dpi : float, default: :rc:`savefig.dpi`\n            The dots per inch to save the figure in.\n\n        facecolor : color, default: :rc:`savefig.facecolor`\n            The facecolor of the figure.\n\n        edgecolor : color, default: :rc:`savefig.edgecolor`\n            The edgecolor of the figure.\n\n        orientation : {'landscape', 'portrait'}, default: 'portrait'\n            Only currently applies to PostScript printing.\n\n        format : str, optional\n            Force a specific file format. If not given, the format is inferred\n            from the *filename* extension, and if that fails from\n            :rc:`savefig.format`.\n\n        bbox_inches : 'tight' or `.Bbox`, default: :rc:`savefig.bbox`\n            Bounding box in inches: only the given portion of the figure is\n            saved.  If 'tight', try to figure out the tight bbox of the figure.\n\n        pad_inches : float, default: :rc:`savefig.pad_inches`\n            Amount of padding around the figure when *bbox_inches* is 'tight'.\n\n        bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional\n            A list of extra artists that will be considered when the\n            tight bbox is calculated.\n\n        backend : str, optional\n            Use a non-default backend to render the file, e.g. to render a\n            png file with the \"cairo\" backend rather than the default \"agg\",\n            or a pdf file with the \"pgf\" backend rather than the default\n            \"pdf\".  Note that the default backend is normally sufficient.  See\n            :ref:`the-builtin-backends` for a list of valid backends for each\n            file format.  Custom backends can be referenced as \"module://...\".\n        \"\"\"\n        if format is None:\n            # get format from filename, or from backend's default filetype\n            if isinstance(filename, os.PathLike):\n                filename = os.fspath(filename)\n            if isinstance(filename, str):\n                format = os.path.splitext(filename)[1][1:]\n            if format is None or format == '':\n                format = self.get_default_filetype()\n                if isinstance(filename, str):\n                    filename = filename.rstrip('.') + '.' + format\n        format = format.lower()\n\n        # get canvas object and print method for format\n        canvas = self._get_output_canvas(backend, format)\n        print_method = getattr(canvas, 'print_%s' % format)\n\n        if dpi is None:\n            dpi = rcParams['savefig.dpi']\n        if dpi == 'figure':\n            dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n\n        # Remove the figure manager, if any, to avoid resizing the GUI widget.\n        # Some code (e.g. Figure.show) differentiates between having *no*\n        # manager and a *None* manager, which should be fixed at some point,\n        # but this should be fine.\n        with cbook._setattr_cm(self, _is_saving=True, manager=None), \\\n                cbook._setattr_cm(self.figure, dpi=dpi):\n\n            if facecolor is None:\n                facecolor = rcParams['savefig.facecolor']\n            if edgecolor is None:\n                edgecolor = rcParams['savefig.edgecolor']\n\n            origfacecolor = self.figure.get_facecolor()\n            origedgecolor = self.figure.get_edgecolor()\n\n            self.figure.set_facecolor(facecolor)\n            self.figure.set_edgecolor(edgecolor)\n\n            if bbox_inches is None:\n                bbox_inches = rcParams['savefig.bbox']\n\n            if bbox_inches:\n                if bbox_inches == \"tight\":\n                    renderer = _get_renderer(\n                        self.figure,\n                        functools.partial(\n                            print_method, dpi=dpi, orientation=orientation),\n                        draw_disabled=True)\n                    self.figure.draw(renderer)\n                    bbox_artists = kwargs.pop(\"bbox_extra_artists\", None)\n                    bbox_inches = self.figure.get_tightbbox(\n                        renderer, bbox_extra_artists=bbox_artists)\n                    pad = kwargs.pop(\"pad_inches\", None)\n                    if pad is None:\n                        pad = rcParams['savefig.pad_inches']\n\n                    bbox_inches = bbox_inches.padded(pad)\n\n                # call adjust_bbox to save only the given area\n                restore_bbox = tight_bbox.adjust_bbox(self.figure, bbox_inches,\n                                                      canvas.fixed_dpi)\n\n                _bbox_inches_restore = (bbox_inches, restore_bbox)\n            else:\n                _bbox_inches_restore = None\n\n            try:\n                result = print_method(\n                    filename,\n                    dpi=dpi,\n                    facecolor=facecolor,\n                    edgecolor=edgecolor,\n                    orientation=orientation,\n                    bbox_inches_restore=_bbox_inches_restore,\n                    **kwargs)\n            finally:\n                if bbox_inches and restore_bbox:\n                    restore_bbox()\n\n                self.figure.set_facecolor(origfacecolor)\n                self.figure.set_edgecolor(origedgecolor)\n                self.figure.set_canvas(self)\n            return result",
        "begin_line": 1975,
        "end_line": 2108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038880248833592535,
            "pseudo_dstar_susp": 0.00035816618911174784,
            "pseudo_tarantula_susp": 0.0008305647840531562,
            "pseudo_op2_susp": 0.00035816618911174784,
            "pseudo_barinel_susp": 0.0008305647840531562
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.get_default_filetype#2111",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.get_default_filetype(cls)",
        "snippet": "    def get_default_filetype(cls):\n        \"\"\"\n        Return the default savefig file format as specified in\n        :rc:`savefig.format`.\n\n        The returned string does not include a period. This method is\n        overridden in backends that only support a single file type.\n        \"\"\"\n        return rcParams['savefig.format']",
        "begin_line": 2111,
        "end_line": 2119,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.get_window_title#2121",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.get_window_title(self)",
        "snippet": "    def get_window_title(self):\n        \"\"\"\n        Return the title text of the window containing the figure, or None\n        if there is no window (e.g., a PS backend).\n        \"\"\"\n        if self.manager:\n            return self.manager.get_window_title()",
        "begin_line": 2121,
        "end_line": 2127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.get_default_filename#2137",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.get_default_filename(self)",
        "snippet": "    def get_default_filename(self):\n        \"\"\"\n        Return a string, which includes extension, suitable for use as\n        a default filename.\n        \"\"\"\n        default_basename = self.get_window_title() or 'image'\n        default_basename = default_basename.replace(' ', '_')\n        default_filetype = self.get_default_filetype()\n        default_filename = default_basename + '.' + default_filetype\n        return default_filename",
        "begin_line": 2137,
        "end_line": 2146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.switch_backends#2148",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.switch_backends(self, FigureCanvasClass)",
        "snippet": "    def switch_backends(self, FigureCanvasClass):\n        \"\"\"\n        Instantiate an instance of FigureCanvasClass\n\n        This is used for backend switching, e.g., to instantiate a\n        FigureCanvasPS from a FigureCanvasGTK.  Note, deep copying is\n        not done, so any changes to one of the instances (e.g., setting\n        figure size or line props), will be reflected in the other\n        \"\"\"\n        newCanvas = FigureCanvasClass(self.figure)\n        newCanvas._is_saving = self._is_saving\n        return newCanvas",
        "begin_line": 2148,
        "end_line": 2159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.mpl_connect#2161",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.mpl_connect(self, s, func)",
        "snippet": "    def mpl_connect(self, s, func):\n        \"\"\"\n        Bind function *func* to event *s*.\n\n        Parameters\n        ----------\n        s : str\n            One of the following events ids:\n\n            - 'button_press_event'\n            - 'button_release_event'\n            - 'draw_event'\n            - 'key_press_event'\n            - 'key_release_event'\n            - 'motion_notify_event'\n            - 'pick_event'\n            - 'resize_event'\n            - 'scroll_event'\n            - 'figure_enter_event',\n            - 'figure_leave_event',\n            - 'axes_enter_event',\n            - 'axes_leave_event'\n            - 'close_event'.\n\n        func : callable\n            The callback function to be executed, which must have the\n            signature::\n\n                def func(event: Event) -> Any\n\n            For the location events (button and key press/release), if the\n            mouse is over the axes, the ``inaxes`` attribute of the event will\n            be set to the `~matplotlib.axes.Axes` the event occurs is over, and\n            additionally, the variables ``xdata`` and ``ydata`` attributes will\n            be set to the mouse location in data coordinates.  See `.KeyEvent`\n            and `.MouseEvent` for more info.\n\n        Returns\n        -------\n        cid\n            A connection id that can be used with\n            `.FigureCanvasBase.mpl_disconnect`.\n\n        Examples\n        --------\n        ::\n\n            def on_press(event):\n                print('you pressed', event.button, event.xdata, event.ydata)\n\n            cid = canvas.mpl_connect('button_press_event', on_press)\n        \"\"\"\n\n        return self.callbacks.connect(s, func)",
        "begin_line": 2161,
        "end_line": 2214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006510416666666666,
            "pseudo_dstar_susp": 0.0012690355329949238,
            "pseudo_tarantula_susp": 0.001128668171557562,
            "pseudo_op2_susp": 0.0012690355329949238,
            "pseudo_barinel_susp": 0.001128668171557562
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.mpl_disconnect#2216",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.mpl_disconnect(self, cid)",
        "snippet": "    def mpl_disconnect(self, cid):\n        \"\"\"\n        Disconnect the callback with id *cid*.\n\n        Examples\n        --------\n        ::\n\n            cid = canvas.mpl_connect('button_press_event', on_press)\n            # ... later\n            canvas.mpl_disconnect(cid)\n        \"\"\"\n        return self.callbacks.disconnect(cid)",
        "begin_line": 2216,
        "end_line": 2228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006510416666666666,
            "pseudo_dstar_susp": 0.0012690355329949238,
            "pseudo_tarantula_susp": 0.001128668171557562,
            "pseudo_op2_susp": 0.0012690355329949238,
            "pseudo_barinel_susp": 0.001128668171557562
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureCanvasBase.new_timer#2234",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureCanvasBase",
        "signature": "lib.matplotlib.backend_bases.FigureCanvasBase.new_timer(self, interval=None, callbacks=None)",
        "snippet": "    def new_timer(self, interval=None, callbacks=None):\n        \"\"\"\n        Create a new backend-specific subclass of `.Timer`.\n\n        This is useful for getting periodic events through the backend's native\n        event loop.  Implemented only for backends with GUIs.\n\n        Parameters\n        ----------\n        interval : int\n            Timer interval in milliseconds.\n\n        callbacks : List[Tuple[callable, Tuple, Dict]]\n            Sequence of (func, args, kwargs) where ``func(*args, **kwargs)``\n            will be executed by the timer every *interval*.\n\n            Callbacks which return ``False`` or ``0`` will be removed from the\n            timer.\n\n        Examples\n        --------\n        >>> timer = fig.canvas.new_timer(callbacks=[(f1, (1,), {'a': 3})])\n        \"\"\"\n        return self._timer_cls(interval=interval, callbacks=callbacks)",
        "begin_line": 2234,
        "end_line": 2257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureManagerBase.__init__#2553",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureManagerBase",
        "signature": "lib.matplotlib.backend_bases.FigureManagerBase.__init__(self, canvas, num)",
        "snippet": "    def __init__(self, canvas, num):\n        self.canvas = canvas\n        canvas.manager = self  # store a pointer to parent\n        self.num = num\n\n        self.key_press_handler_id = None\n        self.button_press_handler_id = None\n        if rcParams['toolbar'] != 'toolmanager':\n            self.key_press_handler_id = self.canvas.mpl_connect(\n                'key_press_event',\n                self.key_press)\n            self.button_press_handler_id = self.canvas.mpl_connect(\n                'button_press_event',\n                self.button_press)\n\n        self.toolmanager = None\n        self.toolbar = None\n\n        @self.canvas.figure.add_axobserver\n        def notify_axes_change(fig):\n            # Called whenever the current axes is changed.\n            if self.toolmanager is None and self.toolbar is not None:\n                self.toolbar.update()",
        "begin_line": 2553,
        "end_line": 2575,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006640106241699867,
            "pseudo_dstar_susp": 0.0013157894736842105,
            "pseudo_tarantula_susp": 0.001128668171557562,
            "pseudo_op2_susp": 0.0013157894736842105,
            "pseudo_barinel_susp": 0.001128668171557562
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureManagerBase.notify_axes_change#2572",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureManagerBase",
        "signature": "lib.matplotlib.backend_bases.FigureManagerBase.notify_axes_change(fig)",
        "snippet": "        def notify_axes_change(fig):\n            # Called whenever the current axes is changed.\n            if self.toolmanager is None and self.toolbar is not None:\n                self.toolbar.update()",
        "begin_line": 2572,
        "end_line": 2575,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011862396204033216,
            "pseudo_dstar_susp": 0.0021008403361344537,
            "pseudo_tarantula_susp": 0.0005232862375719519,
            "pseudo_op2_susp": 0.0021008403361344537,
            "pseudo_barinel_susp": 0.0005232862375719519
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureManagerBase.show#2577",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureManagerBase",
        "signature": "lib.matplotlib.backend_bases.FigureManagerBase.show(self)",
        "snippet": "    def show(self):\n        \"\"\"\n        For GUI backends, show the figure window and redraw.\n        For non-GUI backends, raise an exception, unless running headless (i.e.\n        on Linux with an unset DISPLAY); this exception is converted to a\n        warning in `.Figure.show`.\n        \"\"\"\n        # This should be overridden in GUI backends.\n        if cbook._get_running_interactive_framework() != \"headless\":\n            raise NonGuiException(\n                f\"Matplotlib is currently using {get_backend()}, which is \"\n                f\"a non-GUI backend, so cannot show the figure.\")",
        "begin_line": 2577,
        "end_line": 2588,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureManagerBase.destroy#2590",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureManagerBase",
        "signature": "lib.matplotlib.backend_bases.FigureManagerBase.destroy(self)",
        "snippet": "    def destroy(self):\n        pass",
        "begin_line": 2590,
        "end_line": 2591,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006565988181221273,
            "pseudo_dstar_susp": 0.0012903225806451613,
            "pseudo_tarantula_susp": 0.001128668171557562,
            "pseudo_op2_susp": 0.0012903225806451613,
            "pseudo_barinel_susp": 0.001128668171557562
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureManagerBase.resize#2596",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureManagerBase",
        "signature": "lib.matplotlib.backend_bases.FigureManagerBase.resize(self, w, h)",
        "snippet": "    def resize(self, w, h):\n        \"\"\"For GUI backends, resize the window (in pixels).\"\"\"",
        "begin_line": 2596,
        "end_line": 2597,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.FigureManagerBase.set_window_title#2619",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.FigureManagerBase",
        "signature": "lib.matplotlib.backend_bases.FigureManagerBase.set_window_title(self, title)",
        "snippet": "    def set_window_title(self, title):\n        \"\"\"\n        Set the title text of the window containing the figure.\n\n        This has no effect for non-GUI (e.g., PS) backends.\n        \"\"\"",
        "begin_line": 2619,
        "end_line": 2624,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.074935400516796e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases._Backend.new_figure_manager#3333",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases._Backend",
        "signature": "lib.matplotlib.backend_bases._Backend.new_figure_manager(cls, num, *args, **kwargs)",
        "snippet": "    def new_figure_manager(cls, num, *args, **kwargs):\n        \"\"\"Create a new figure manager instance.\"\"\"\n        # This import needs to happen here due to circular imports.\n        from matplotlib.figure import Figure\n        fig_cls = kwargs.pop('FigureClass', Figure)\n        fig = fig_cls(*args, **kwargs)\n        return cls.new_figure_manager_given_figure(num, fig)",
        "begin_line": 3333,
        "end_line": 3339,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006640106241699867,
            "pseudo_dstar_susp": 0.0013157894736842105,
            "pseudo_tarantula_susp": 0.00038095238095238096,
            "pseudo_op2_susp": 0.0013157894736842105,
            "pseudo_barinel_susp": 0.00038095238095238096
        }
    },
    {
        "name": "lib.matplotlib.backend_bases._Backend.new_figure_manager_given_figure#3342",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases._Backend",
        "signature": "lib.matplotlib.backend_bases._Backend.new_figure_manager_given_figure(cls, num, figure)",
        "snippet": "    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        canvas = cls.FigureCanvas(figure)\n        manager = cls.FigureManager(canvas, num)\n        return manager",
        "begin_line": 3342,
        "end_line": 3346,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006640106241699867,
            "pseudo_dstar_susp": 0.0013157894736842105,
            "pseudo_tarantula_susp": 0.00038095238095238096,
            "pseudo_op2_susp": 0.0013157894736842105,
            "pseudo_barinel_susp": 0.00038095238095238096
        }
    },
    {
        "name": "lib.matplotlib.backend_bases._Backend.draw_if_interactive#3349",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases._Backend",
        "signature": "lib.matplotlib.backend_bases._Backend.draw_if_interactive(cls)",
        "snippet": "    def draw_if_interactive(cls):\n        if cls.trigger_manager_draw is not None and is_interactive():\n            manager = Gcf.get_active()\n            if manager:\n                cls.trigger_manager_draw(manager)",
        "begin_line": 3349,
        "end_line": 3353,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases._Backend.show#3356",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases._Backend",
        "signature": "lib.matplotlib.backend_bases._Backend.show(cls, *, block=None)",
        "snippet": "    def show(cls, *, block=None):\n        \"\"\"\n        Show all figures.\n\n        `show` blocks by calling `mainloop` if *block* is ``True``, or if it\n        is ``None`` and we are neither in IPython's ``%pylab`` mode, nor in\n        `interactive` mode.\n        \"\"\"\n        managers = Gcf.get_all_fig_managers()\n        if not managers:\n            return\n        for manager in managers:\n            try:\n                manager.show()  # Emits a warning for non-interactive backend.\n            except NonGuiException as exc:\n                cbook._warn_external(str(exc))\n        if cls.mainloop is None:\n            return\n        if block is None:\n            # Hack: Are we in IPython's pylab mode?\n            from matplotlib import pyplot\n            try:\n                # IPython versions >= 0.10 tack the _needmain attribute onto\n                # pyplot.show, and always set it to False, when in %pylab mode.\n                ipython_pylab = not pyplot.show._needmain\n            except AttributeError:\n                ipython_pylab = False\n            block = not ipython_pylab and not is_interactive()\n            # TODO: The above is a hack to get the WebAgg backend working with\n            # ipython's `%pylab` mode until proper integration is implemented.\n            if get_backend() == \"WebAgg\":\n                block = True\n        if block:\n            cls.mainloop()",
        "begin_line": 3356,
        "end_line": 3389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases._Backend.export#3394",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases._Backend",
        "signature": "lib.matplotlib.backend_bases._Backend.export(cls)",
        "snippet": "    def export(cls):\n        for name in [\n                \"backend_version\",\n                \"FigureCanvas\",\n                \"FigureManager\",\n                \"new_figure_manager\",\n                \"new_figure_manager_given_figure\",\n                \"draw_if_interactive\",\n                \"show\",\n        ]:\n            setattr(sys.modules[cls.__module__], name, getattr(cls, name))\n\n        # For back-compatibility, generate a shim `Show` class.\n\n        class Show(ShowBase):\n            def mainloop(self):\n                return cls.mainloop()\n\n        setattr(sys.modules[cls.__module__], \"Show\", Show)\n        return cls",
        "begin_line": 3394,
        "end_line": 3413,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.Show.export#3394",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.Show",
        "signature": "lib.matplotlib.backend_bases.Show.export(cls)",
        "snippet": "    def export(cls):\n        for name in [\n                \"backend_version\",\n                \"FigureCanvas\",\n                \"FigureManager\",\n                \"new_figure_manager\",\n                \"new_figure_manager_given_figure\",\n                \"draw_if_interactive\",\n                \"show\",\n        ]:\n            setattr(sys.modules[cls.__module__], name, getattr(cls, name))\n\n        # For back-compatibility, generate a shim `Show` class.\n\n        class Show(ShowBase):\n            def mainloop(self):\n                return cls.mainloop()\n\n        setattr(sys.modules[cls.__module__], \"Show\", Show)\n        return cls",
        "begin_line": 3394,
        "end_line": 3413,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backend_bases.Show.mainloop#3409",
        "src_path": "lib/matplotlib/backend_bases.py",
        "class_name": "lib.matplotlib.backend_bases.Show",
        "signature": "lib.matplotlib.backend_bases.Show.mainloop(self)",
        "snippet": "            def mainloop(self):\n                return cls.mainloop()",
        "begin_line": 3409,
        "end_line": 3410,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser.parse#119",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser",
        "signature": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser.parse(self, pattern)",
        "snippet": "    def parse(self, pattern):\n        \"\"\"\n        Parse the given fontconfig *pattern* and return a dictionary\n        of key/value pairs useful for initializing a\n        `.font_manager.FontProperties` object.\n        \"\"\"\n        props = self._properties = {}\n        try:\n            self._parser.parseString(pattern)\n        except self.ParseException as e:\n            raise ValueError(\n                \"Could not parse font string: '%s'\\n%s\" % (pattern, e)) from e\n\n        self._properties = None\n\n        self._parser.resetCache()\n\n        return props",
        "begin_line": 119,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._family#138",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser",
        "signature": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._family(self, s, loc, tokens)",
        "snippet": "    def _family(self, s, loc, tokens):\n        return [family_unescape(r'\\1', str(tokens[0]))]",
        "begin_line": 138,
        "end_line": 139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._name#144",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser",
        "signature": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._name(self, s, loc, tokens)",
        "snippet": "    def _name(self, s, loc, tokens):\n        return [str(tokens[0])]",
        "begin_line": 144,
        "end_line": 145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._value#147",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser",
        "signature": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._value(self, s, loc, tokens)",
        "snippet": "    def _value(self, s, loc, tokens):\n        return [value_unescape(r'\\1', str(tokens[0]))]",
        "begin_line": 147,
        "end_line": 148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._families#150",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser",
        "signature": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._families(self, s, loc, tokens)",
        "snippet": "    def _families(self, s, loc, tokens):\n        self._properties['family'] = [str(x) for x in tokens]\n        return []",
        "begin_line": 150,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._property#158",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser",
        "signature": "lib.matplotlib.fontconfig_pattern.FontconfigPatternParser._property(self, s, loc, tokens)",
        "snippet": "    def _property(self, s, loc, tokens):\n        if len(tokens) == 1:\n            if tokens[0] in self._constants:\n                key, val = self._constants[tokens[0]]\n                self._properties.setdefault(key, []).append(val)\n        else:\n            key = tokens[0]\n            val = tokens[1:]\n            self._properties.setdefault(key, []).extend(val)\n        return []",
        "begin_line": 158,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern._escape_val#177",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern",
        "signature": "lib.matplotlib.fontconfig_pattern._escape_val(val, escape_func)",
        "snippet": "def _escape_val(val, escape_func):\n    \"\"\"\n    Given a string value or a list of string values, run each value through\n    the input escape function to make the values into legal font config\n    strings.  The result is returned as a string.\n    \"\"\"\n    if not np.iterable(val) or isinstance(val, str):\n        val = [val]\n\n    return ','.join(escape_func(r'\\\\\\1', str(x)) for x in val\n                    if x is not None)",
        "begin_line": 177,
        "end_line": 187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.fontconfig_pattern.generate_fontconfig_pattern#190",
        "src_path": "lib/matplotlib/fontconfig_pattern.py",
        "class_name": "lib.matplotlib.fontconfig_pattern",
        "signature": "lib.matplotlib.fontconfig_pattern.generate_fontconfig_pattern(d)",
        "snippet": "def generate_fontconfig_pattern(d):\n    \"\"\"\n    Given a dictionary of key/value pairs, generates a fontconfig\n    pattern string.\n    \"\"\"\n    props = []\n\n    # Family is added first w/o a keyword\n    family = d.get_family()\n    if family is not None and family != []:\n        props.append(_escape_val(family, family_escape))\n\n    # The other keys are added as key=value\n    for key in ['style', 'variant', 'weight', 'stretch', 'file', 'size']:\n        val = getattr(d, 'get_' + key)()\n        # Don't use 'if not val' because 0 is a valid input.\n        if val is not None and val != []:\n            props.append(\":%s=%s\" % (key, _escape_val(val, value_escape)))\n\n    return ''.join(props)",
        "begin_line": 190,
        "end_line": 209,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier.get_intersection#19",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.get_intersection(cx1, cy1, cos_t1, sin_t1, cx2, cy2, cos_t2, sin_t2)",
        "snippet": "def get_intersection(cx1, cy1, cos_t1, sin_t1,\n                     cx2, cy2, cos_t2, sin_t2):\n    \"\"\"\n    Return the intersection between the line through (*cx1*, *cy1*) at angle\n    *t1* and the line through (*cx2*, *cy2*) at angle *t2*.\n    \"\"\"\n\n    # line1 => sin_t1 * (x - cx1) - cos_t1 * (y - cy1) = 0.\n    # line1 => sin_t1 * x + cos_t1 * y = sin_t1*cx1 - cos_t1*cy1\n\n    line1_rhs = sin_t1 * cx1 - cos_t1 * cy1\n    line2_rhs = sin_t2 * cx2 - cos_t2 * cy2\n\n    # rhs matrix\n    a, b = sin_t1, -cos_t1\n    c, d = sin_t2, -cos_t2\n\n    ad_bc = a * d - b * c\n    if abs(ad_bc) < 1e-12:\n        raise ValueError(\"Given lines do not intersect. Please verify that \"\n                         \"the angles are not equal or differ by 180 degrees.\")\n\n    # rhs_inverse\n    a_, b_ = d, -b\n    c_, d_ = -c, a\n    a_, b_, c_, d_ = [k / ad_bc for k in [a_, b_, c_, d_]]\n\n    x = a_ * line1_rhs + b_ * line2_rhs\n    y = c_ * line1_rhs + d_ * line2_rhs\n\n    return x, y",
        "begin_line": 19,
        "end_line": 49,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.910273545397844e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier.get_normal_points#52",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.get_normal_points(cx, cy, cos_t, sin_t, length)",
        "snippet": "def get_normal_points(cx, cy, cos_t, sin_t, length):\n    \"\"\"\n    For a line passing through (*cx*, *cy*) and having an angle *t*, return\n    locations of the two points located along its perpendicular line at the\n    distance of *length*.\n    \"\"\"\n\n    if length == 0.:\n        return cx, cy, cx, cy\n\n    cos_t1, sin_t1 = sin_t, -cos_t\n    cos_t2, sin_t2 = -sin_t, cos_t\n\n    x1, y1 = length * cos_t1 + cx, length * sin_t1 + cy\n    x2, y2 = length * cos_t2 + cx, length * sin_t2 + cy\n\n    return x1, y1, x2, y2",
        "begin_line": 52,
        "end_line": 68,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.970667941973537e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier._de_casteljau1#77",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier._de_casteljau1(beta, t)",
        "snippet": "def _de_casteljau1(beta, t):\n    next_beta = beta[:-1] * (1 - t) + beta[1:] * t\n    return next_beta",
        "begin_line": 77,
        "end_line": 79,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.741136398823347e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier.split_de_casteljau#82",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.split_de_casteljau(beta, t)",
        "snippet": "def split_de_casteljau(beta, t):\n    \"\"\"\n    Split a Bezier segment defined by its control points *beta* into two\n    separate segments divided at *t* and return their control points.\n    \"\"\"\n    beta = np.asarray(beta)\n    beta_list = [beta]\n    while True:\n        beta = _de_casteljau1(beta, t)\n        beta_list.append(beta)\n        if len(beta) == 1:\n            break\n    left_beta = [beta[0] for beta in beta_list]\n    right_beta = [beta[-1] for beta in reversed(beta_list)]\n\n    return left_beta, right_beta",
        "begin_line": 82,
        "end_line": 97,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.675775253300584e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier.find_bezier_t_intersecting_with_closedpath#100",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.find_bezier_t_intersecting_with_closedpath(bezier_point_at_t, inside_closedpath, t0=0.0, t1=1.0, tolerance=0.01)",
        "snippet": "def find_bezier_t_intersecting_with_closedpath(\n        bezier_point_at_t, inside_closedpath, t0=0., t1=1., tolerance=0.01):\n    \"\"\"\n    Find the intersection of the Bezier curve with a closed path.\n\n    The intersection point *t* is approximated by two parameters *t0*, *t1*\n    such that *t0* <= *t* <= *t1*.\n\n    Search starts from *t0* and *t1* and uses a simple bisecting algorithm\n    therefore one of the end points must be inside the path while the other\n    doesn't. The search stops when the distance of the points parametrized by\n    *t0* and *t1* gets smaller than the given *tolerance*.\n\n    Parameters\n    ----------\n    bezier_point_at_t : callable\n        A function returning x, y coordinates of the Bezier at parameter *t*.\n        It must have the signature::\n\n            bezier_point_at_t(t: float) -> Tuple[float, float]\n\n    inside_closedpath : callable\n        A function returning True if a given point (x, y) is inside the\n        closed path. It must have the signature::\n\n            inside_closedpath(point: Tuple[float, float]) -> bool\n\n    t0, t1 : float\n        Start parameters for the search.\n\n    tolerance : float\n        Maximal allowed distance between the final points.\n\n    Returns\n    -------\n    t0, t1 : float\n        The Bezier path parameters.\n    \"\"\"\n    start = bezier_point_at_t(t0)\n    end = bezier_point_at_t(t1)\n\n    start_inside = inside_closedpath(start)\n    end_inside = inside_closedpath(end)\n\n    if start_inside == end_inside and start != end:\n        raise NonIntersectingPathException(\n            \"Both points are on the same side of the closed path\")\n\n    while True:\n\n        # return if the distance is smaller than the tolerance\n        if np.hypot(start[0] - end[0], start[1] - end[1]) < tolerance:\n            return t0, t1\n\n        # calculate the middle point\n        middle_t = 0.5 * (t0 + t1)\n        middle = bezier_point_at_t(middle_t)\n        middle_inside = inside_closedpath(middle)\n\n        if start_inside ^ middle_inside:\n            t1 = middle_t\n            end = middle\n            end_inside = middle_inside\n        else:\n            t0 = middle_t\n            start = middle\n            start_inside = middle_inside",
        "begin_line": 100,
        "end_line": 166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.225713580653122e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier.BezierSegment.point_at_t#187",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier.BezierSegment",
        "signature": "lib.matplotlib.bezier.BezierSegment.point_at_t(self, t)",
        "snippet": "    def point_at_t(self, t):\n        \"\"\"Return the point on the Bezier curve for parameter *t*.\"\"\"\n        return tuple(\n            self._px @ (((1 - t) ** self._orders)[::-1] * t ** self._orders))",
        "begin_line": 187,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.703566751405901e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier.split_bezier_intersecting_with_closedpath#193",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.split_bezier_intersecting_with_closedpath(bezier, inside_closedpath, tolerance=0.01)",
        "snippet": "def split_bezier_intersecting_with_closedpath(\n        bezier, inside_closedpath, tolerance=0.01):\n    \"\"\"\n    Split a Bezier curve into two at the intersection with a closed path.\n\n    Parameters\n    ----------\n    bezier : array-like(N, 2)\n        Control points of the Bezier segment. See `.BezierSegment`.\n    inside_closedpath : callable\n        A function returning True if a given point (x, y) is inside the\n        closed path. See also `.find_bezier_t_intersecting_with_closedpath`.\n    tolerance : float\n        The tolerance for the intersection. See also\n        `.find_bezier_t_intersecting_with_closedpath`.\n\n    Returns\n    -------\n    left, right\n        Lists of control points for the two Bezier segments.\n    \"\"\"\n\n    bz = BezierSegment(bezier)\n    bezier_point_at_t = bz.point_at_t\n\n    t0, t1 = find_bezier_t_intersecting_with_closedpath(\n        bezier_point_at_t, inside_closedpath, tolerance=tolerance)\n\n    _left, _right = split_de_casteljau(bezier, (t0 + t1) / 2.)\n    return _left, _right",
        "begin_line": 193,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.808839606434484e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier.split_path_inout#228",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.split_path_inout(path, inside, tolerance=0.01, reorder_inout=False)",
        "snippet": "def split_path_inout(path, inside, tolerance=0.01, reorder_inout=False):\n    \"\"\"\n    Divide a path into two segments at the point where ``inside(x, y)`` becomes\n    False.\n    \"\"\"\n    path_iter = path.iter_segments()\n\n    ctl_points, command = next(path_iter)\n    begin_inside = inside(ctl_points[-2:])  # true if begin point is inside\n\n    ctl_points_old = ctl_points\n\n    concat = np.concatenate\n\n    iold = 0\n    i = 1\n\n    for ctl_points, command in path_iter:\n        iold = i\n        i += len(ctl_points) // 2\n        if inside(ctl_points[-2:]) != begin_inside:\n            bezier_path = concat([ctl_points_old[-2:], ctl_points])\n            break\n        ctl_points_old = ctl_points\n    else:\n        raise ValueError(\"The path does not intersect with the patch\")\n\n    bp = bezier_path.reshape((-1, 2))\n    left, right = split_bezier_intersecting_with_closedpath(\n        bp, inside, tolerance)\n    if len(left) == 2:\n        codes_left = [Path.LINETO]\n        codes_right = [Path.MOVETO, Path.LINETO]\n    elif len(left) == 3:\n        codes_left = [Path.CURVE3, Path.CURVE3]\n        codes_right = [Path.MOVETO, Path.CURVE3, Path.CURVE3]\n    elif len(left) == 4:\n        codes_left = [Path.CURVE4, Path.CURVE4, Path.CURVE4]\n        codes_right = [Path.MOVETO, Path.CURVE4, Path.CURVE4, Path.CURVE4]\n    else:\n        raise AssertionError(\"This should never be reached\")\n\n    verts_left = left[1:]\n    verts_right = right[:]\n\n    if path.codes is None:\n        path_in = Path(concat([path.vertices[:i], verts_left]))\n        path_out = Path(concat([verts_right, path.vertices[i:]]))\n\n    else:\n        path_in = Path(concat([path.vertices[:iold], verts_left]),\n                       concat([path.codes[:iold], codes_left]))\n\n        path_out = Path(concat([verts_right, path.vertices[i:]]),\n                        concat([codes_right, path.codes[i:]]))\n\n    if reorder_inout and not begin_inside:\n        path_in, path_out = path_out, path_in\n\n    return path_in, path_out",
        "begin_line": 228,
        "end_line": 287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.3905531035778e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier.inside_circle#290",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.inside_circle(cx, cy, r)",
        "snippet": "def inside_circle(cx, cy, r):\n    \"\"\"\n    Return a function that checks whether a point is in a circle with center\n    (*cx*, *cy*) and radius *r*.\n\n    The returned function has the signature::\n\n        f(xy: Tuple[float, float]) -> bool\n    \"\"\"\n    r2 = r ** 2\n\n    def _f(xy):\n        x, y = xy\n        return (x - cx) ** 2 + (y - cy) ** 2 < r2\n    return _f",
        "begin_line": 290,
        "end_line": 304,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier._f#301",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier._f(xy)",
        "snippet": "    def _f(xy):\n        x, y = xy\n        return (x - cx) ** 2 + (y - cy) ** 2 < r2",
        "begin_line": 301,
        "end_line": 303,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier.get_cos_sin#309",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.get_cos_sin(x0, y0, x1, y1)",
        "snippet": "def get_cos_sin(x0, y0, x1, y1):\n    dx, dy = x1 - x0, y1 - y0\n    d = (dx * dx + dy * dy) ** .5\n    # Account for divide by zero\n    if d == 0:\n        return 0.0, 0.0\n    return dx / d, dy / d",
        "begin_line": 309,
        "end_line": 315,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier.check_if_parallel#318",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.check_if_parallel(dx1, dy1, dx2, dy2, tolerance=1e-05)",
        "snippet": "def check_if_parallel(dx1, dy1, dx2, dy2, tolerance=1.e-5):\n    \"\"\"\n    Check if two lines are parallel.\n\n    Parameters\n    ----------\n    dx1, dy1, dx2, dy2 : float\n        The gradients *dy*/*dx* of the two lines.\n    tolerance : float\n        The angular tolerance in radians up to which the lines are considered\n        parallel.\n\n    Returns\n    -------\n    is_parallel\n        - 1 if two lines are parallel in same direction.\n        - -1 if two lines are parallel in opposite direction.\n        - False otherwise.\n    \"\"\"\n    theta1 = np.arctan2(dx1, dy1)\n    theta2 = np.arctan2(dx2, dy2)\n    dtheta = abs(theta1 - theta2)\n    if dtheta < tolerance:\n        return 1\n    elif abs(dtheta - np.pi) < tolerance:\n        return -1\n    else:\n        return False",
        "begin_line": 318,
        "end_line": 345,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier.get_parallels#348",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.get_parallels(bezier2, width)",
        "snippet": "def get_parallels(bezier2, width):\n    \"\"\"\n    Given the quadratic Bezier control points *bezier2*, returns\n    control points of quadratic Bezier lines roughly parallel to given\n    one separated by *width*.\n    \"\"\"\n\n    # The parallel Bezier lines are constructed by following ways.\n    #  c1 and c2 are control points representing the begin and end of the\n    #  Bezier line.\n    #  cm is the middle point\n\n    c1x, c1y = bezier2[0]\n    cmx, cmy = bezier2[1]\n    c2x, c2y = bezier2[2]\n\n    parallel_test = check_if_parallel(c1x - cmx, c1y - cmy,\n                                      cmx - c2x, cmy - c2y)\n\n    if parallel_test == -1:\n        cbook._warn_external(\n            \"Lines do not intersect. A straight line is used instead.\")\n        cos_t1, sin_t1 = get_cos_sin(c1x, c1y, c2x, c2y)\n        cos_t2, sin_t2 = cos_t1, sin_t1\n    else:\n        # t1 and t2 is the angle between c1 and cm, cm, c2.  They are\n        # also a angle of the tangential line of the path at c1 and c2\n        cos_t1, sin_t1 = get_cos_sin(c1x, c1y, cmx, cmy)\n        cos_t2, sin_t2 = get_cos_sin(cmx, cmy, c2x, c2y)\n\n    # find c1_left, c1_right which are located along the lines\n    # through c1 and perpendicular to the tangential lines of the\n    # Bezier path at a distance of width. Same thing for c2_left and\n    # c2_right with respect to c2.\n    c1x_left, c1y_left, c1x_right, c1y_right = (\n        get_normal_points(c1x, c1y, cos_t1, sin_t1, width)\n    )\n    c2x_left, c2y_left, c2x_right, c2y_right = (\n        get_normal_points(c2x, c2y, cos_t2, sin_t2, width)\n    )\n\n    # find cm_left which is the intersecting point of a line through\n    # c1_left with angle t1 and a line through c2_left with angle\n    # t2. Same with cm_right.\n    try:\n        cmx_left, cmy_left = get_intersection(c1x_left, c1y_left, cos_t1,\n                                              sin_t1, c2x_left, c2y_left,\n                                              cos_t2, sin_t2)\n        cmx_right, cmy_right = get_intersection(c1x_right, c1y_right, cos_t1,\n                                                sin_t1, c2x_right, c2y_right,\n                                                cos_t2, sin_t2)\n    except ValueError:\n        # Special case straight lines, i.e., angle between two lines is\n        # less than the threshold used by get_intersection (we don't use\n        # check_if_parallel as the threshold is not the same).\n        cmx_left, cmy_left = (\n            0.5 * (c1x_left + c2x_left), 0.5 * (c1y_left + c2y_left)\n        )\n        cmx_right, cmy_right = (\n            0.5 * (c1x_right + c2x_right), 0.5 * (c1y_right + c2y_right)\n        )\n\n    # the parallel Bezier lines are created with control points of\n    # [c1_left, cm_left, c2_left] and [c1_right, cm_right, c2_right]\n    path_left = [(c1x_left, c1y_left),\n                 (cmx_left, cmy_left),\n                 (c2x_left, c2y_left)]\n    path_right = [(c1x_right, c1y_right),\n                  (cmx_right, cmy_right),\n                  (c2x_right, c2y_right)]\n\n    return path_left, path_right",
        "begin_line": 348,
        "end_line": 419,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier.find_control_points#422",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.find_control_points(c1x, c1y, mmx, mmy, c2x, c2y)",
        "snippet": "def find_control_points(c1x, c1y, mmx, mmy, c2x, c2y):\n    \"\"\"\n    Find control points of the Bezier curve passing through (*c1x*, *c1y*),\n    (*mmx*, *mmy*), and (*c2x*, *c2y*), at parametric values 0, 0.5, and 1.\n    \"\"\"\n    cmx = .5 * (4 * mmx - (c1x + c2x))\n    cmy = .5 * (4 * mmy - (c1y + c2y))\n    return [(c1x, c1y), (cmx, cmy), (c2x, c2y)]",
        "begin_line": 422,
        "end_line": 429,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier.make_wedged_bezier2#432",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.make_wedged_bezier2(bezier2, width, w1=1.0, wm=0.5, w2=0.0)",
        "snippet": "def make_wedged_bezier2(bezier2, width, w1=1., wm=0.5, w2=0.):\n    \"\"\"\n    Being similar to get_parallels, returns control points of two quadratic\n    Bezier lines having a width roughly parallel to given one separated by\n    *width*.\n    \"\"\"\n\n    # c1, cm, c2\n    c1x, c1y = bezier2[0]\n    cmx, cmy = bezier2[1]\n    c3x, c3y = bezier2[2]\n\n    # t1 and t2 is the angle between c1 and cm, cm, c3.\n    # They are also a angle of the tangential line of the path at c1 and c3\n    cos_t1, sin_t1 = get_cos_sin(c1x, c1y, cmx, cmy)\n    cos_t2, sin_t2 = get_cos_sin(cmx, cmy, c3x, c3y)\n\n    # find c1_left, c1_right which are located along the lines\n    # through c1 and perpendicular to the tangential lines of the\n    # Bezier path at a distance of width. Same thing for c3_left and\n    # c3_right with respect to c3.\n    c1x_left, c1y_left, c1x_right, c1y_right = (\n        get_normal_points(c1x, c1y, cos_t1, sin_t1, width * w1)\n    )\n    c3x_left, c3y_left, c3x_right, c3y_right = (\n        get_normal_points(c3x, c3y, cos_t2, sin_t2, width * w2)\n    )\n\n    # find c12, c23 and c123 which are middle points of c1-cm, cm-c3 and\n    # c12-c23\n    c12x, c12y = (c1x + cmx) * .5, (c1y + cmy) * .5\n    c23x, c23y = (cmx + c3x) * .5, (cmy + c3y) * .5\n    c123x, c123y = (c12x + c23x) * .5, (c12y + c23y) * .5\n\n    # tangential angle of c123 (angle between c12 and c23)\n    cos_t123, sin_t123 = get_cos_sin(c12x, c12y, c23x, c23y)\n\n    c123x_left, c123y_left, c123x_right, c123y_right = (\n        get_normal_points(c123x, c123y, cos_t123, sin_t123, width * wm)\n    )\n\n    path_left = find_control_points(c1x_left, c1y_left,\n                                    c123x_left, c123y_left,\n                                    c3x_left, c3y_left)\n    path_right = find_control_points(c1x_right, c1y_right,\n                                     c123x_right, c123y_right,\n                                     c3x_right, c3y_right)\n\n    return path_left, path_right",
        "begin_line": 432,
        "end_line": 480,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier.make_path_regular#483",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.make_path_regular(p)",
        "snippet": "def make_path_regular(p):\n    \"\"\"\n    If the ``codes`` attribute of `.Path` *p* is None, return a copy of *p*\n    with ``codes`` set to (MOVETO, LINETO, LINETO, ..., LINETO); otherwise\n    return *p* itself.\n    \"\"\"\n    c = p.codes\n    if c is None:\n        c = np.full(len(p.vertices), Path.LINETO, dtype=Path.code_type)\n        c[0] = Path.MOVETO\n        return Path(p.vertices, c)\n    else:\n        return p",
        "begin_line": 483,
        "end_line": 495,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.bezier.concatenate_paths#498",
        "src_path": "lib/matplotlib/bezier.py",
        "class_name": "lib.matplotlib.bezier",
        "signature": "lib.matplotlib.bezier.concatenate_paths(paths)",
        "snippet": "def concatenate_paths(paths):\n    \"\"\"Concatenate a list of paths into a single path.\"\"\"\n    vertices = np.concatenate([p.vertices for p in paths])\n    codes = np.concatenate([make_path_regular(p).codes for p in paths])\n    return Path(vertices, codes)",
        "begin_line": 498,
        "end_line": 502,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._get_running_interactive_framework#38",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._get_running_interactive_framework()",
        "snippet": "def _get_running_interactive_framework():\n    \"\"\"\n    Return the interactive framework whose event loop is currently running, if\n    any, or \"headless\" if no event loop can be started, or None.\n\n    Returns\n    -------\n    Optional[str]\n        One of the following values: \"qt5\", \"qt4\", \"gtk3\", \"wx\", \"tk\",\n        \"macosx\", \"headless\", ``None``.\n    \"\"\"\n    QtWidgets = (sys.modules.get(\"PyQt5.QtWidgets\")\n                 or sys.modules.get(\"PySide2.QtWidgets\"))\n    if QtWidgets and QtWidgets.QApplication.instance():\n        return \"qt5\"\n    QtGui = (sys.modules.get(\"PyQt4.QtGui\")\n             or sys.modules.get(\"PySide.QtGui\"))\n    if QtGui and QtGui.QApplication.instance():\n        return \"qt4\"\n    Gtk = sys.modules.get(\"gi.repository.Gtk\")\n    if Gtk and Gtk.main_level():\n        return \"gtk3\"\n    wx = sys.modules.get(\"wx\")\n    if wx and wx.GetApp():\n        return \"wx\"\n    tkinter = sys.modules.get(\"tkinter\")\n    if tkinter:\n        for frame in sys._current_frames().values():\n            while frame:\n                if frame.f_code == tkinter.mainloop.__code__:\n                    return \"tk\"\n                frame = frame.f_back\n    if 'matplotlib.backends._macosx' in sys.modules:\n        if sys.modules[\"matplotlib.backends._macosx\"].event_loop_is_running():\n            return \"macosx\"\n    if sys.platform.startswith(\"linux\") and not os.environ.get(\"DISPLAY\"):\n        return \"headless\"\n    return None",
        "begin_line": 38,
        "end_line": 75,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.714396735962697e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._StrongRef.__init__#90",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__._StrongRef",
        "signature": "lib.matplotlib.cbook.__init__._StrongRef.__init__(self, obj)",
        "snippet": "    def __init__(self, obj):\n        self._obj = obj",
        "begin_line": 90,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009345794392523364,
            "pseudo_dstar_susp": 0.05555555555555555,
            "pseudo_tarantula_susp": 0.0004084967320261438,
            "pseudo_op2_susp": 0.05555555555555555,
            "pseudo_barinel_susp": 0.0004084967320261438
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._StrongRef.__call__#93",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__._StrongRef",
        "signature": "lib.matplotlib.cbook.__init__._StrongRef.__call__(self)",
        "snippet": "    def __call__(self):\n        return self._obj",
        "begin_line": 93,
        "end_line": 94,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.024390243902439025,
            "pseudo_dstar_susp": 0.03225806451612903,
            "pseudo_tarantula_susp": 0.0005567928730512249,
            "pseudo_op2_susp": 0.027777777777777776,
            "pseudo_barinel_susp": 0.0005567928730512249
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._StrongRef.__hash__#99",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__._StrongRef",
        "signature": "lib.matplotlib.cbook.__init__._StrongRef.__hash__(self)",
        "snippet": "    def __hash__(self):\n        return hash(self._obj)",
        "begin_line": 99,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0625,
            "pseudo_dstar_susp": 1.0,
            "pseudo_tarantula_susp": 0.00055005500550055,
            "pseudo_op2_susp": 1.0,
            "pseudo_barinel_susp": 0.00055005500550055
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.CallbackRegistry.__init__#156",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.CallbackRegistry",
        "signature": "lib.matplotlib.cbook.__init__.CallbackRegistry.__init__(self, exception_handler=_exception_printer)",
        "snippet": "    def __init__(self, exception_handler=_exception_printer):\n        self.exception_handler = exception_handler\n        self.callbacks = {}\n        self._cid_gen = itertools.count()\n        self._func_cid_map = {}",
        "begin_line": 156,
        "end_line": 160,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012658227848101266,
            "pseudo_dstar_susp": 0.024390243902439025,
            "pseudo_tarantula_susp": 0.0005506607929515419,
            "pseudo_op2_susp": 0.02040816326530612,
            "pseudo_barinel_susp": 0.0005506607929515419
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.CallbackRegistry.__getstate__#162",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.CallbackRegistry",
        "signature": "lib.matplotlib.cbook.__init__.CallbackRegistry.__getstate__(self)",
        "snippet": "    def __getstate__(self):\n        # In general, callbacks may not be pickled, so we just drop them.\n        return {**vars(self), \"callbacks\": {}, \"_func_cid_map\": {}}",
        "begin_line": 162,
        "end_line": 164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.649770781074301e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.CallbackRegistry.connect#166",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.CallbackRegistry",
        "signature": "lib.matplotlib.cbook.__init__.CallbackRegistry.connect(self, s, func)",
        "snippet": "    def connect(self, s, func):\n        \"\"\"Register *func* to be called when signal *s* is generated.\n        \"\"\"\n        self._func_cid_map.setdefault(s, {})\n        try:\n            proxy = weakref.WeakMethod(func, self._remove_proxy)\n        except TypeError:\n            proxy = _StrongRef(func)\n        if proxy in self._func_cid_map[s]:\n            return self._func_cid_map[s][proxy]\n\n        cid = next(self._cid_gen)\n        self._func_cid_map[s][proxy] = cid\n        self.callbacks.setdefault(s, {})\n        self.callbacks[s][cid] = proxy\n        return cid",
        "begin_line": 166,
        "end_line": 181,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.041666666666666664,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.0005561735261401557,
            "pseudo_op2_susp": 0.16666666666666666,
            "pseudo_barinel_susp": 0.0005561735261401557
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.CallbackRegistry._remove_proxy#185",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.CallbackRegistry",
        "signature": "lib.matplotlib.cbook.__init__.CallbackRegistry._remove_proxy(self, proxy, *, _is_finalizing=sys.is_finalizing)",
        "snippet": "    def _remove_proxy(self, proxy, *, _is_finalizing=sys.is_finalizing):\n        if _is_finalizing():\n            # Weakrefs can't be properly torn down at that point anymore.\n            return\n        for signal, proxies in list(self._func_cid_map.items()):\n            try:\n                del self.callbacks[signal][proxies[proxy]]\n            except KeyError:\n                pass\n            if len(self.callbacks[signal]) == 0:\n                del self.callbacks[signal]\n                del self._func_cid_map[signal]",
        "begin_line": 185,
        "end_line": 196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.037037037037037035,
            "pseudo_dstar_susp": 0.07692307692307693,
            "pseudo_tarantula_susp": 0.0005685048322910744,
            "pseudo_op2_susp": 0.0625,
            "pseudo_barinel_susp": 0.0005685048322910744
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.CallbackRegistry.disconnect#198",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.CallbackRegistry",
        "signature": "lib.matplotlib.cbook.__init__.CallbackRegistry.disconnect(self, cid)",
        "snippet": "    def disconnect(self, cid):\n        \"\"\"Disconnect the callback registered with callback id *cid*.\n        \"\"\"\n        for eventname, callbackd in list(self.callbacks.items()):\n            try:\n                del callbackd[cid]\n            except KeyError:\n                continue\n            else:\n                for signal, functions in list(self._func_cid_map.items()):\n                    for function, value in list(functions.items()):\n                        if value == cid:\n                            del functions[function]\n                return",
        "begin_line": 198,
        "end_line": 211,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.04,
            "pseudo_dstar_susp": 0.14285714285714285,
            "pseudo_tarantula_susp": 0.0005467468562055768,
            "pseudo_op2_susp": 0.08333333333333333,
            "pseudo_barinel_susp": 0.0005467468562055768
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.CallbackRegistry.process#213",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.CallbackRegistry",
        "signature": "lib.matplotlib.cbook.__init__.CallbackRegistry.process(self, s, *args, **kwargs)",
        "snippet": "    def process(self, s, *args, **kwargs):\n        \"\"\"\n        Process signal *s*.\n\n        All of the functions registered to receive callbacks on *s* will be\n        called with ``*args`` and ``**kwargs``.\n        \"\"\"\n        for cid, ref in list(self.callbacks.get(s, {}).items()):\n            func = ref()\n            if func is not None:\n                try:\n                    func(*args, **kwargs)\n                # this does not capture KeyboardInterrupt, SystemExit,\n                # and GeneratorExit\n                except Exception as exc:\n                    if self.exception_handler is not None:\n                        self.exception_handler(exc)\n                    else:\n                        raise",
        "begin_line": 213,
        "end_line": 231,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02857142857142857,
            "pseudo_dstar_susp": 0.25,
            "pseudo_tarantula_susp": 0.0004508566275924256,
            "pseudo_op2_susp": 0.125,
            "pseudo_barinel_susp": 0.0004508566275924256
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.silent_list.__init__#251",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.silent_list",
        "signature": "lib.matplotlib.cbook.__init__.silent_list.__init__(self, type, seq=None)",
        "snippet": "    def __init__(self, type, seq=None):\n        self.type = type\n        if seq is not None:\n            self.extend(seq)",
        "begin_line": 251,
        "end_line": 254,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.480325644504748e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.silent_list.__setstate__#265",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.silent_list",
        "signature": "lib.matplotlib.cbook.__init__.silent_list.__setstate__(self, state)",
        "snippet": "    def __setstate__(self, state):\n        self.type = state['type']\n        self.extend(state['seq'])",
        "begin_line": 265,
        "end_line": 267,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.is_hashable#366",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.is_hashable(obj)",
        "snippet": "def is_hashable(obj):\n    \"\"\"Returns true if *obj* can be hashed\"\"\"\n    try:\n        hash(obj)\n    except TypeError:\n        return False\n    return True",
        "begin_line": 366,
        "end_line": 372,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.is_writable_file_like#375",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.is_writable_file_like(obj)",
        "snippet": "def is_writable_file_like(obj):\n    \"\"\"Return whether *obj* looks like a file object with a *write* method.\"\"\"\n    return callable(getattr(obj, 'write', None))",
        "begin_line": 375,
        "end_line": 377,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.999000099990002e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.file_requires_unicode#380",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.file_requires_unicode(x)",
        "snippet": "def file_requires_unicode(x):\n    \"\"\"\n    Return whether the given writable file-like object requires Unicode to be\n    written to it.\n    \"\"\"\n    try:\n        x.write(b'')\n    except TypeError:\n        return True\n    else:\n        return False",
        "begin_line": 380,
        "end_line": 390,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004664179104477612,
            "pseudo_dstar_susp": 0.00039888312724371757,
            "pseudo_tarantula_susp": 0.0016666666666666668,
            "pseudo_op2_susp": 0.00039888312724371757,
            "pseudo_barinel_susp": 0.0016666666666666668
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.to_filehandle#393",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.to_filehandle(fname, flag='r', return_opened=False, encoding=None)",
        "snippet": "def to_filehandle(fname, flag='r', return_opened=False, encoding=None):\n    \"\"\"\n    Convert a path to an open file handle or pass-through a file-like object.\n\n    Consider using `open_file_cm` instead, as it allows one to properly close\n    newly created file objects more easily.\n\n    Parameters\n    ----------\n    fname : str or path-like or file-like object\n        If `str` or `os.PathLike`, the file is opened using the flags specified\n        by *flag* and *encoding*.  If a file-like object, it is passed through.\n    flag : str, default 'r'\n        Passed as the *mode* argument to `open` when *fname* is `str` or\n        `os.PathLike`; ignored if *fname* is file-like.\n    return_opened : bool, default False\n        If True, return both the file object and a boolean indicating whether\n        this was a new file (that the caller needs to close).  If False, return\n        only the new file.\n    encoding : str or None, default None\n        Passed as the *mode* argument to `open` when *fname* is `str` or\n        `os.PathLike`; ignored if *fname* is file-like.\n\n    Returns\n    -------\n    fh : file-like\n    opened : bool\n        *opened* is only returned if *return_opened* is True.\n    \"\"\"\n    if isinstance(fname, os.PathLike):\n        fname = os.fspath(fname)\n    if \"U\" in flag:\n        warn_deprecated(\"3.3\", message=\"Passing a flag containing 'U' to \"\n                        \"to_filehandle() is deprecated since %(since)s and \"\n                        \"will be removed %(removal)s.\")\n        flag = flag.replace(\"U\", \"\")\n    if isinstance(fname, str):\n        if fname.endswith('.gz'):\n            fh = gzip.open(fname, flag)\n        elif fname.endswith('.bz2'):\n            # python may not be complied with bz2 support,\n            # bury import until we need it\n            import bz2\n            fh = bz2.BZ2File(fname, flag)\n        else:\n            fh = open(fname, flag, encoding=encoding)\n        opened = True\n    elif hasattr(fname, 'seek'):\n        fh = fname\n        opened = False\n    else:\n        raise ValueError('fname must be a PathLike or file handle')\n    if return_opened:\n        return fh, opened\n    return fh",
        "begin_line": 393,
        "end_line": 447,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.open_file_cm#451",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.open_file_cm(path_or_file, mode='r', encoding=None)",
        "snippet": "def open_file_cm(path_or_file, mode=\"r\", encoding=None):\n    r\"\"\"Pass through file objects and context-manage path-likes.\"\"\"\n    fh, opened = to_filehandle(path_or_file, mode, True, encoding)\n    if opened:\n        with fh:\n            yield fh\n    else:\n        yield fh",
        "begin_line": 451,
        "end_line": 458,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.is_scalar_or_string#461",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.is_scalar_or_string(val)",
        "snippet": "def is_scalar_or_string(val):\n    \"\"\"Return whether the given object is a scalar or string like.\"\"\"\n    return isinstance(val, str) or not np.iterable(val)",
        "begin_line": 461,
        "end_line": 463,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000708215297450425,
            "pseudo_dstar_susp": 0.0005,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0005,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.flatten#499",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.flatten(seq, scalarp=is_scalar_or_string)",
        "snippet": "def flatten(seq, scalarp=is_scalar_or_string):\n    \"\"\"\n    Return a generator of flattened nested containers.\n\n    For example:\n\n        >>> from matplotlib.cbook import flatten\n        >>> l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]])\n        >>> print(list(flatten(l)))\n        ['John', 'Hunter', 1, 23, 42, 5, 23]\n\n    By: Composite of Holger Krekel and Luther Blissett\n    From: https://code.activestate.com/recipes/121294/\n    and Recipe 1.12 in cookbook\n    \"\"\"\n    for item in seq:\n        if scalarp(item) or item is None:\n            yield item\n        else:\n            yield from flatten(item, scalarp)",
        "begin_line": 499,
        "end_line": 518,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.maxdict.__setitem__#593",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.maxdict",
        "signature": "lib.matplotlib.cbook.__init__.maxdict.__setitem__(self, k, v)",
        "snippet": "    def __setitem__(self, k, v):\n        if k not in self:\n            if len(self) >= self.maxsize:\n                del self[self._killkeys[0]]\n                del self._killkeys[0]\n            self._killkeys.append(k)\n        dict.__setitem__(self, k, v)",
        "begin_line": 593,
        "end_line": 599,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004280821917808219,
            "pseudo_dstar_susp": 0.0003837298541826554,
            "pseudo_tarantula_susp": 0.0012987012987012987,
            "pseudo_op2_susp": 0.0003837298541826554,
            "pseudo_barinel_susp": 0.0012987012987012987
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Stack.__init__#609",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Stack",
        "signature": "lib.matplotlib.cbook.__init__.Stack.__init__(self, default=None)",
        "snippet": "    def __init__(self, default=None):\n        self.clear()\n        self._default = default",
        "begin_line": 609,
        "end_line": 611,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006591957811470006,
            "pseudo_dstar_susp": 0.0012970168612191958,
            "pseudo_tarantula_susp": 0.001128668171557562,
            "pseudo_op2_susp": 0.0012970168612191958,
            "pseudo_barinel_susp": 0.001128668171557562
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Stack.push#637",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Stack",
        "signature": "lib.matplotlib.cbook.__init__.Stack.push(self, o)",
        "snippet": "    def push(self, o):\n        \"\"\"\n        Push *o* to the stack at current position.  Discard all later elements.\n\n        *o* is returned.\n        \"\"\"\n        self._elements = self._elements[:self._pos + 1] + [o]\n        self._pos = len(self._elements) - 1\n        return self()",
        "begin_line": 637,
        "end_line": 645,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001736111111111111,
            "pseudo_dstar_susp": 0.002881844380403458,
            "pseudo_tarantula_susp": 0.0012610340479192938,
            "pseudo_op2_susp": 0.002881844380403458,
            "pseudo_barinel_susp": 0.0012626262626262627
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Stack.clear#662",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Stack",
        "signature": "lib.matplotlib.cbook.__init__.Stack.clear(self)",
        "snippet": "    def clear(self):\n        \"\"\"Empty the stack.\"\"\"\n        self._pos = -1\n        self._elements = []",
        "begin_line": 662,
        "end_line": 665,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015527950310559005,
            "pseudo_dstar_susp": 0.0026954177897574125,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0026954177897574125,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Stack.bubble#667",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Stack",
        "signature": "lib.matplotlib.cbook.__init__.Stack.bubble(self, o)",
        "snippet": "    def bubble(self, o):\n        \"\"\"\n        Raise all references of *o* to the top of the stack, and return it.\n\n        Raises\n        ------\n        ValueError\n            If *o* is not in the stack.\n        \"\"\"\n        if o not in self._elements:\n            raise ValueError('Given element not contained in the stack')\n        old_elements = self._elements.copy()\n        self.clear()\n        top_elements = []\n        for elem in old_elements:\n            if elem == o:\n                top_elements.append(elem)\n            else:\n                self.push(elem)\n        for _ in top_elements:\n            self.push(o)\n        return o",
        "begin_line": 667,
        "end_line": 688,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017211703958691911,
            "pseudo_dstar_susp": 0.0028653295128939827,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0028653295128939827,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Stack.remove#690",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Stack",
        "signature": "lib.matplotlib.cbook.__init__.Stack.remove(self, o)",
        "snippet": "    def remove(self, o):\n        \"\"\"\n        Remove *o* from the stack.\n\n        Raises\n        ------\n        ValueError\n            If *o* is not in the stack.\n        \"\"\"\n        if o not in self._elements:\n            raise ValueError('Given element not contained in the stack')\n        old_elements = self._elements.copy()\n        self.clear()\n        for elem in old_elements:\n            if elem != o:\n                self.push(elem)",
        "begin_line": 690,
        "end_line": 705,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.safe_masked_invalid#751",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.safe_masked_invalid(x, copy=False)",
        "snippet": "def safe_masked_invalid(x, copy=False):\n    x = np.array(x, subok=True, copy=copy)\n    if not x.dtype.isnative:\n        # If we have already made a copy, do the byteswap in place, else make a\n        # copy with the byte order swapped.\n        x = x.byteswap(inplace=copy).newbyteorder('N')  # Swap to native order.\n    try:\n        xm = np.ma.masked_invalid(x, copy=False)\n        xm.shrink_mask()\n    except TypeError:\n        return x\n    return xm",
        "begin_line": 751,
        "end_line": 762,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005243838489774515,
            "pseudo_dstar_susp": 0.00041203131437989287,
            "pseudo_tarantula_susp": 0.002,
            "pseudo_op2_susp": 0.00041203131437989287,
            "pseudo_barinel_susp": 0.002
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Grouper.__init__#870",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Grouper",
        "signature": "lib.matplotlib.cbook.__init__.Grouper.__init__(self, init=())",
        "snippet": "    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}",
        "begin_line": 870,
        "end_line": 871,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004752851711026616,
            "pseudo_dstar_susp": 0.0005219206680584551,
            "pseudo_tarantula_susp": 0.001422475106685633,
            "pseudo_op2_susp": 0.0005219206680584551,
            "pseudo_barinel_susp": 0.001422475106685633
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Grouper.__contains__#873",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Grouper",
        "signature": "lib.matplotlib.cbook.__init__.Grouper.__contains__(self, item)",
        "snippet": "    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping",
        "begin_line": 873,
        "end_line": 874,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005431830526887561,
            "pseudo_dstar_susp": 0.0004170141784820684,
            "pseudo_tarantula_susp": 0.0021645021645021645,
            "pseudo_op2_susp": 0.0004170141784820684,
            "pseudo_barinel_susp": 0.0021645021645021645
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Grouper.clean#876",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Grouper",
        "signature": "lib.matplotlib.cbook.__init__.Grouper.clean(self)",
        "snippet": "    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)",
        "begin_line": 876,
        "end_line": 882,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0014992503748125937,
            "pseudo_tarantula_susp": 0.001455604075691412,
            "pseudo_op2_susp": 0.0014992503748125937,
            "pseudo_barinel_susp": 0.001455604075691412
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Grouper.join#884",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Grouper",
        "signature": "lib.matplotlib.cbook.__init__.Grouper.join(self, a, *args)",
        "snippet": "    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()",
        "begin_line": 884,
        "end_line": 900,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000708215297450425,
            "pseudo_dstar_susp": 0.0004268032437046522,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0004268032437046522,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Grouper.joined#902",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Grouper",
        "signature": "lib.matplotlib.cbook.__init__.Grouper.joined(self, a, b)",
        "snippet": "    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))",
        "begin_line": 902,
        "end_line": 906,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Grouper.remove#908",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Grouper",
        "signature": "lib.matplotlib.cbook.__init__.Grouper.remove(self, a)",
        "snippet": "    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))",
        "begin_line": 908,
        "end_line": 912,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Grouper.__iter__#914",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Grouper",
        "signature": "lib.matplotlib.cbook.__init__.Grouper.__iter__(self)",
        "snippet": "    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]",
        "begin_line": 914,
        "end_line": 923,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.Grouper.get_siblings#925",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__.Grouper",
        "signature": "lib.matplotlib.cbook.__init__.Grouper.get_siblings(self, a)",
        "snippet": "    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]",
        "begin_line": 925,
        "end_line": 929,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001841620626151013,
            "pseudo_dstar_susp": 0.0014947683109118087,
            "pseudo_tarantula_susp": 0.001422475106685633,
            "pseudo_op2_susp": 0.0014947683109118087,
            "pseudo_barinel_susp": 0.001422475106685633
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.delete_masked_points#956",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.delete_masked_points(*args)",
        "snippet": "def delete_masked_points(*args):\n    \"\"\"\n    Find all masked and/or non-finite points in a set of arguments,\n    and return the arguments with only the unmasked points remaining.\n\n    Arguments can be in any of 5 categories:\n\n    1) 1-D masked arrays\n    2) 1-D ndarrays\n    3) ndarrays with more than one dimension\n    4) other non-string iterables\n    5) anything else\n\n    The first argument must be in one of the first four categories;\n    any argument with a length differing from that of the first\n    argument (and hence anything in category 5) then will be\n    passed through unchanged.\n\n    Masks are obtained from all arguments of the correct length\n    in categories 1, 2, and 4; a point is bad if masked in a masked\n    array or if it is a nan or inf.  No attempt is made to\n    extract a mask from categories 2, 3, and 4 if `numpy.isfinite`\n    does not yield a Boolean array.\n\n    All input arguments that are not passed unchanged are returned\n    as ndarrays after removing the points or rows corresponding to\n    masks in any of the arguments.\n\n    A vastly simpler version of this function was originally\n    written as a helper for Axes.scatter().\n\n    \"\"\"\n    if not len(args):\n        return ()\n    if is_scalar_or_string(args[0]):\n        raise ValueError(\"First argument must be a sequence\")\n    nrecs = len(args[0])\n    margs = []\n    seqlist = [False] * len(args)\n    for i, x in enumerate(args):\n        if not isinstance(x, str) and np.iterable(x) and len(x) == nrecs:\n            seqlist[i] = True\n            if isinstance(x, np.ma.MaskedArray):\n                if x.ndim > 1:\n                    raise ValueError(\"Masked arrays must be 1-D\")\n            else:\n                x = np.asarray(x)\n        margs.append(x)\n    masks = []    # list of masks that are True where good\n    for i, x in enumerate(margs):\n        if seqlist[i]:\n            if x.ndim > 1:\n                continue  # Don't try to get nan locations unless 1-D.\n            if isinstance(x, np.ma.MaskedArray):\n                masks.append(~np.ma.getmaskarray(x))  # invert the mask\n                xd = x.data\n            else:\n                xd = x\n            try:\n                mask = np.isfinite(xd)\n                if isinstance(mask, np.ndarray):\n                    masks.append(mask)\n            except Exception:  # Fixme: put in tuple of possible exceptions?\n                pass\n    if len(masks):\n        mask = np.logical_and.reduce(masks)\n        igood = mask.nonzero()[0]\n        if len(igood) < nrecs:\n            for i, x in enumerate(margs):\n                if seqlist[i]:\n                    margs[i] = x[igood]\n    for i, x in enumerate(margs):\n        if seqlist[i] and isinstance(x, np.ma.MaskedArray):\n            margs[i] = x.filled()\n    return margs",
        "begin_line": 956,
        "end_line": 1030,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._combine_masks#1033",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._combine_masks(*args)",
        "snippet": "def _combine_masks(*args):\n    \"\"\"\n    Find all masked and/or non-finite points in a set of arguments,\n    and return the arguments as masked arrays with a common mask.\n\n    Arguments can be in any of 5 categories:\n\n    1) 1-D masked arrays\n    2) 1-D ndarrays\n    3) ndarrays with more than one dimension\n    4) other non-string iterables\n    5) anything else\n\n    The first argument must be in one of the first four categories;\n    any argument with a length differing from that of the first\n    argument (and hence anything in category 5) then will be\n    passed through unchanged.\n\n    Masks are obtained from all arguments of the correct length\n    in categories 1, 2, and 4; a point is bad if masked in a masked\n    array or if it is a nan or inf.  No attempt is made to\n    extract a mask from categories 2 and 4 if :meth:`np.isfinite`\n    does not yield a Boolean array.  Category 3 is included to\n    support RGB or RGBA ndarrays, which are assumed to have only\n    valid values and which are passed through unchanged.\n\n    All input arguments that are not passed unchanged are returned\n    as masked arrays if any masked points are found, otherwise as\n    ndarrays.\n\n    \"\"\"\n    if not len(args):\n        return ()\n    if is_scalar_or_string(args[0]):\n        raise ValueError(\"First argument must be a sequence\")\n    nrecs = len(args[0])\n    margs = []  # Output args; some may be modified.\n    seqlist = [False] * len(args)  # Flags: True if output will be masked.\n    masks = []    # List of masks.\n    for i, x in enumerate(args):\n        if is_scalar_or_string(x) or len(x) != nrecs:\n            margs.append(x)  # Leave it unmodified.\n        else:\n            if isinstance(x, np.ma.MaskedArray) and x.ndim > 1:\n                raise ValueError(\"Masked arrays must be 1-D\")\n            x = np.asanyarray(x)\n            if x.ndim == 1:\n                x = safe_masked_invalid(x)\n                seqlist[i] = True\n                if np.ma.is_masked(x):\n                    masks.append(np.ma.getmaskarray(x))\n            margs.append(x)  # Possibly modified.\n    if len(masks):\n        mask = np.logical_or.reduce(masks)\n        for i, x in enumerate(margs):\n            if seqlist[i]:\n                margs[i] = np.ma.array(x, mask=mask)\n    return margs",
        "begin_line": 1033,
        "end_line": 1090,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000554016620498615,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000554016620498615,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.boxplot_stats#1093",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.boxplot_stats(X, whis=1.5, bootstrap=None, labels=None, autorange=False)",
        "snippet": "def boxplot_stats(X, whis=1.5, bootstrap=None, labels=None,\n                  autorange=False):\n    r\"\"\"\n    Return a list of dictionaries of statistics used to draw a series of box\n    and whisker plots using `~.Axes.bxp`.\n\n    Parameters\n    ----------\n    X : array-like\n        Data that will be represented in the boxplots. Should have 2 or\n        fewer dimensions.\n\n    whis : float or (float, float), default: 1.5\n        The position of the whiskers.\n\n        If a float, the lower whisker is at the lowest datum above\n        ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum below\n        ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and third\n        quartiles.  The default value of ``whis = 1.5`` corresponds to Tukey's\n        original definition of boxplots.\n\n        If a pair of floats, they indicate the percentiles at which to draw the\n        whiskers (e.g., (5, 95)).  In particular, setting this to (0, 100)\n        results in whiskers covering the whole range of the data.  \"range\" is\n        a deprecated synonym for (0, 100).\n\n        In the edge case where ``Q1 == Q3``, *whis* is automatically set to\n        (0, 100) (cover the whole range of the data) if *autorange* is True.\n\n        Beyond the whiskers, data are considered outliers and are plotted as\n        individual points.\n\n    bootstrap : int, optional\n        Number of times the confidence intervals around the median\n        should be bootstrapped (percentile method).\n\n    labels : array-like, optional\n        Labels for each dataset. Length must be compatible with\n        dimensions of *X*.\n\n    autorange : bool, optional (False)\n        When `True` and the data are distributed such that the 25th and 75th\n        percentiles are equal, ``whis`` is set to (0, 100) such that the\n        whisker ends are at the minimum and maximum of the data.\n\n    Returns\n    -------\n    bxpstats : list of dict\n        A list of dictionaries containing the results for each column\n        of data. Keys of each dictionary are the following:\n\n        ========   ===================================\n        Key        Value Description\n        ========   ===================================\n        label      tick label for the boxplot\n        mean       arithmetic mean value\n        med        50th percentile\n        q1         first quartile (25th percentile)\n        q3         third quartile (75th percentile)\n        cilo       lower notch around the median\n        cihi       upper notch around the median\n        whislo     end of the lower whisker\n        whishi     end of the upper whisker\n        fliers     outliers\n        ========   ===================================\n\n    Notes\n    -----\n    Non-bootstrapping approach to confidence interval uses Gaussian-based\n    asymptotic approximation:\n\n    .. math::\n\n        \\mathrm{med} \\pm 1.57 \\times \\frac{\\mathrm{iqr}}{\\sqrt{N}}\n\n    General approach from:\n    McGill, R., Tukey, J.W., and Larsen, W.A. (1978) \"Variations of\n    Boxplots\", The American Statistician, 32:12-16.\n    \"\"\"\n\n    def _bootstrap_median(data, N=5000):\n        # determine 95% confidence intervals of the median\n        M = len(data)\n        percentiles = [2.5, 97.5]\n\n        bs_index = np.random.randint(M, size=(N, M))\n        bsData = data[bs_index]\n        estimate = np.median(bsData, axis=1, overwrite_input=True)\n\n        CI = np.percentile(estimate, percentiles)\n        return CI\n\n    def _compute_conf_interval(data, med, iqr, bootstrap):\n        if bootstrap is not None:\n            # Do a bootstrap estimate of notch locations.\n            # get conf. intervals around median\n            CI = _bootstrap_median(data, N=bootstrap)\n            notch_min = CI[0]\n            notch_max = CI[1]\n        else:\n\n            N = len(data)\n            notch_min = med - 1.57 * iqr / np.sqrt(N)\n            notch_max = med + 1.57 * iqr / np.sqrt(N)\n\n        return notch_min, notch_max\n\n    # output is a list of dicts\n    bxpstats = []\n\n    # convert X to a list of lists\n    X = _reshape_2D(X, \"X\")\n\n    ncols = len(X)\n    if labels is None:\n        labels = itertools.repeat(None)\n    elif len(labels) != ncols:\n        raise ValueError(\"Dimensions of labels and X must be compatible\")\n\n    input_whis = whis\n    for ii, (x, label) in enumerate(zip(X, labels)):\n\n        # empty dict\n        stats = {}\n        if label is not None:\n            stats['label'] = label\n\n        # restore whis to the input values in case it got changed in the loop\n        whis = input_whis\n\n        # note tricksiness, append up here and then mutate below\n        bxpstats.append(stats)\n\n        # if empty, bail\n        if len(x) == 0:\n            stats['fliers'] = np.array([])\n            stats['mean'] = np.nan\n            stats['med'] = np.nan\n            stats['q1'] = np.nan\n            stats['q3'] = np.nan\n            stats['cilo'] = np.nan\n            stats['cihi'] = np.nan\n            stats['whislo'] = np.nan\n            stats['whishi'] = np.nan\n            stats['med'] = np.nan\n            continue\n\n        # up-convert to an array, just to be safe\n        x = np.asarray(x)\n\n        # arithmetic mean\n        stats['mean'] = np.mean(x)\n\n        # medians and quartiles\n        q1, med, q3 = np.percentile(x, [25, 50, 75])\n\n        # interquartile range\n        stats['iqr'] = q3 - q1\n        if stats['iqr'] == 0 and autorange:\n            whis = (0, 100)\n\n        # conf. interval around median\n        stats['cilo'], stats['cihi'] = _compute_conf_interval(\n            x, med, stats['iqr'], bootstrap\n        )\n\n        # lowest/highest non-outliers\n        if np.isscalar(whis):\n            if np.isreal(whis):\n                loval = q1 - whis * stats['iqr']\n                hival = q3 + whis * stats['iqr']\n            elif whis in ['range', 'limit', 'limits', 'min/max']:\n                warn_deprecated(\n                    \"3.2\", message=f\"Setting whis to {whis!r} is deprecated \"\n                    \"since %(since)s and support for it will be removed \"\n                    \"%(removal)s; set it to [0, 100] to achieve the same \"\n                    \"effect.\")\n                loval = np.min(x)\n                hival = np.max(x)\n            else:\n                raise ValueError('whis must be a float or list of percentiles')\n        else:\n            loval, hival = np.percentile(x, whis)\n\n        # get high extreme\n        wiskhi = x[x <= hival]\n        if len(wiskhi) == 0 or np.max(wiskhi) < q3:\n            stats['whishi'] = q3\n        else:\n            stats['whishi'] = np.max(wiskhi)\n\n        # get low extreme\n        wisklo = x[x >= loval]\n        if len(wisklo) == 0 or np.min(wisklo) > q1:\n            stats['whislo'] = q1\n        else:\n            stats['whislo'] = np.min(wisklo)\n\n        # compute a single array of outliers\n        stats['fliers'] = np.hstack([\n            x[x < stats['whislo']],\n            x[x > stats['whishi']],\n        ])\n\n        # add in the remaining stats\n        stats['q1'], stats['med'], stats['q3'] = q1, med, q3\n\n    return bxpstats",
        "begin_line": 1093,
        "end_line": 1300,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003572704537334762,
            "pseudo_dstar_susp": 0.0003324468085106383,
            "pseudo_tarantula_susp": 0.0005543237250554324,
            "pseudo_op2_susp": 0.0003324468085106383,
            "pseudo_barinel_susp": 0.0005543237250554324
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._bootstrap_median#1173",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._bootstrap_median(data, N=5000)",
        "snippet": "    def _bootstrap_median(data, N=5000):\n        # determine 95% confidence intervals of the median\n        M = len(data)\n        percentiles = [2.5, 97.5]\n\n        bs_index = np.random.randint(M, size=(N, M))\n        bsData = data[bs_index]\n        estimate = np.median(bsData, axis=1, overwrite_input=True)\n\n        CI = np.percentile(estimate, percentiles)\n        return CI",
        "begin_line": 1173,
        "end_line": 1183,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._compute_conf_interval#1185",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._compute_conf_interval(data, med, iqr, bootstrap)",
        "snippet": "    def _compute_conf_interval(data, med, iqr, bootstrap):\n        if bootstrap is not None:\n            # Do a bootstrap estimate of notch locations.\n            # get conf. intervals around median\n            CI = _bootstrap_median(data, N=bootstrap)\n            notch_min = CI[0]\n            notch_max = CI[1]\n        else:\n\n            N = len(data)\n            notch_min = med - 1.57 * iqr / np.sqrt(N)\n            notch_max = med + 1.57 * iqr / np.sqrt(N)\n\n        return notch_min, notch_max",
        "begin_line": 1185,
        "end_line": 1198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00035842293906810036,
            "pseudo_dstar_susp": 0.00033344448149383126,
            "pseudo_tarantula_susp": 0.000564652738565782,
            "pseudo_op2_susp": 0.00033344448149383126,
            "pseudo_barinel_susp": 0.000564334085778781
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.contiguous_regions#1309",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.contiguous_regions(mask)",
        "snippet": "def contiguous_regions(mask):\n    \"\"\"\n    Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is\n    True and we cover all such regions.\n    \"\"\"\n    mask = np.asarray(mask, dtype=bool)\n\n    if not mask.size:\n        return []\n\n    # Find the indices of region changes, and correct offset\n    idx, = np.nonzero(mask[:-1] != mask[1:])\n    idx += 1\n\n    # List operations are faster for moderately sized arrays\n    idx = idx.tolist()\n\n    # Add first and/or last index if needed\n    if mask[0]:\n        idx = [0] + idx\n    if mask[-1]:\n        idx.append(len(mask))\n\n    return list(zip(idx[::2], idx[1::2]))",
        "begin_line": 1309,
        "end_line": 1332,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.is_math_text#1335",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.is_math_text(s)",
        "snippet": "def is_math_text(s):\n    \"\"\"\n    Returns whether the string *s* contains math expressions.\n\n    This is done by checking whether *s* contains an even number of\n    non-escaped dollar signs.\n    \"\"\"\n    s = str(s)\n    dollar_count = s.count(r'$') - s.count(r'\\$')\n    even_dollars = (dollar_count > 0 and dollar_count % 2 == 0)\n    return even_dollars",
        "begin_line": 1335,
        "end_line": 1345,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006447453255963894,
            "pseudo_dstar_susp": 0.0012453300124533001,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0012453300124533001,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._to_unmasked_float_array#1348",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._to_unmasked_float_array(x)",
        "snippet": "def _to_unmasked_float_array(x):\n    \"\"\"\n    Convert a sequence to a float array; if input was a masked array, masked\n    values are converted to nans.\n    \"\"\"\n    if hasattr(x, 'mask'):\n        return np.ma.asarray(x, float).filled(np.nan)\n    else:\n        return np.asarray(x, float)",
        "begin_line": 1348,
        "end_line": 1356,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010277492291880781,
            "pseudo_dstar_susp": 0.0030120481927710845,
            "pseudo_tarantula_susp": 0.001584786053882726,
            "pseudo_op2_susp": 0.003003003003003003,
            "pseudo_barinel_susp": 0.001584786053882726
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._check_1d#1359",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._check_1d(x)",
        "snippet": "def _check_1d(x):\n    \"\"\"\n    Converts a sequence of less than 1 dimension, to an array of 1\n    dimension; leaves everything else untouched.\n    \"\"\"\n    if not hasattr(x, 'shape') or len(x.shape) < 1:\n        return np.atleast_1d(x)\n    else:\n        try:\n            # work around\n            # https://github.com/pandas-dev/pandas/issues/27775 which\n            # means the shape of multi-dimensional slicing is not as\n            # expected.  That this ever worked was an unintentional\n            # quirk of pandas and will raise an exception in the\n            # future.  This slicing warns in pandas >= 1.0rc0 via\n            # https://github.com/pandas-dev/pandas/pull/30588\n            #\n            # < 1.0rc0 : x[:, None].ndim == 1, no warning, custom type\n            # >= 1.0rc1 : x[:, None].ndim == 2, warns, numpy array\n            # future : x[:, None] -> raises\n            #\n            # This code should correctly identify and coerce to a\n            # numpy array all pandas versions.\n            with warnings.catch_warnings(record=True) as w:\n                warnings.filterwarnings(\n                    \"always\",\n                    category=DeprecationWarning,\n                    message='Support for multi-dimensional indexing')\n\n                ndim = x[:, None].ndim\n                # we have definitely hit a pandas index or series object\n                # cast to a numpy array.\n                if len(w) > 0:\n                    return np.asanyarray(x)\n            # We have likely hit a pandas object, or at least\n            # something where 2D slicing does not result in a 2D\n            # object.\n            if ndim < 2:\n                return np.atleast_1d(x)\n            return x\n        except (IndexError, TypeError):\n            return np.atleast_1d(x)",
        "begin_line": 1359,
        "end_line": 1400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.5,
            "pseudo_dstar_susp": 0.000663129973474801,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.000663129973474801,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._reshape_2D#1403",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._reshape_2D(X, name)",
        "snippet": "def _reshape_2D(X, name):\n    \"\"\"\n    Use Fortran ordering to convert ndarrays and lists of iterables to lists of\n    1D arrays.\n\n    Lists of iterables are converted by applying `np.asarray` to each of their\n    elements.  1D ndarrays are returned in a singleton list containing them.\n    2D ndarrays are converted to the list of their *columns*.\n\n    *name* is used to generate the error message for invalid inputs.\n    \"\"\"\n    # Iterate over columns for ndarrays, over rows otherwise.\n    X = np.atleast_1d(X.T if isinstance(X, np.ndarray) else np.asarray(X))\n    if len(X) == 0:\n        return [[]]\n    elif X.ndim == 1 and np.ndim(X[0]) == 0:\n        # 1D array of scalars: directly return it.\n        return [X]\n    elif X.ndim in [1, 2]:\n        # 2D array, or 1D array of iterables: flatten them first.\n        return [np.reshape(x, -1) for x in X]\n    else:\n        raise ValueError(\"{} must have 2 or fewer dimensions\".format(name))",
        "begin_line": 1403,
        "end_line": 1425,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0005042864346949068,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0005042864346949068,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.violin_stats#1428",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.violin_stats(X, method, points=100, quantiles=None)",
        "snippet": "def violin_stats(X, method, points=100, quantiles=None):\n    \"\"\"\n    Returns a list of dictionaries of data which can be used to draw a series\n    of violin plots.\n\n    See the Returns section below to view the required keys of the dictionary.\n\n    Users can skip this function and pass a user-defined set of dictionaries\n    with the same keys to `~.axes.Axes.violinplot` instead of using Matplotlib\n    to do the calculations. See the *Returns* section below for the keys\n    that must be present in the dictionaries.\n\n    Parameters\n    ----------\n    X : array-like\n        Sample data that will be used to produce the gaussian kernel density\n        estimates. Must have 2 or fewer dimensions.\n\n    method : callable\n        The method used to calculate the kernel density estimate for each\n        column of data. When called via ``method(v, coords)``, it should\n        return a vector of the values of the KDE evaluated at the values\n        specified in coords.\n\n    points : int, default: 100\n        Defines the number of points to evaluate each of the gaussian kernel\n        density estimates at.\n\n    quantiles : array-like, default: None\n        Defines (if not None) a list of floats in interval [0, 1] for each\n        column of data, which represents the quantiles that will be rendered\n        for that column of data. Must have 2 or fewer dimensions. 1D array will\n        be treated as a singleton list containing them.\n\n    Returns\n    -------\n    vpstats : list of dict\n        A list of dictionaries containing the results for each column of data.\n        The dictionaries contain at least the following:\n\n        - coords: A list of scalars containing the coordinates this particular\n          kernel density estimate was evaluated at.\n        - vals: A list of scalars containing the values of the kernel density\n          estimate at each of the coordinates given in *coords*.\n        - mean: The mean value for this column of data.\n        - median: The median value for this column of data.\n        - min: The minimum value for this column of data.\n        - max: The maximum value for this column of data.\n        - quantiles: The quantile values for this column of data.\n    \"\"\"\n\n    # List of dictionaries describing each of the violins.\n    vpstats = []\n\n    # Want X to be a list of data sequences\n    X = _reshape_2D(X, \"X\")\n\n    # Want quantiles to be as the same shape as data sequences\n    if quantiles is not None and len(quantiles) != 0:\n        quantiles = _reshape_2D(quantiles, \"quantiles\")\n    # Else, mock quantiles if is none or empty\n    else:\n        quantiles = [[]] * np.shape(X)[0]\n\n    # quantiles should has the same size as dataset\n    if np.shape(X)[:1] != np.shape(quantiles)[:1]:\n        raise ValueError(\"List of violinplot statistics and quantiles values\"\n                         \" must have the same length\")\n\n    # Zip x and quantiles\n    for (x, q) in zip(X, quantiles):\n        # Dictionary of results for this distribution\n        stats = {}\n\n        # Calculate basic stats for the distribution\n        min_val = np.min(x)\n        max_val = np.max(x)\n        quantile_val = np.percentile(x, 100 * q)\n\n        # Evaluate the kernel density estimate\n        coords = np.linspace(min_val, max_val, points)\n        stats['vals'] = method(x, coords)\n        stats['coords'] = coords\n\n        # Store additional statistics for this distribution\n        stats['mean'] = np.mean(x)\n        stats['median'] = np.median(x)\n        stats['min'] = min_val\n        stats['max'] = max_val\n        stats['quantiles'] = np.atleast_1d(quantile_val)\n\n        # Append to output\n        vpstats.append(stats)\n\n    return vpstats",
        "begin_line": 1428,
        "end_line": 1522,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.28332714444857e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.pts_to_prestep#1525",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.pts_to_prestep(x, *args)",
        "snippet": "def pts_to_prestep(x, *args):\n    \"\"\"\n    Convert continuous line to pre-steps.\n\n    Given a set of ``N`` points, convert to ``2N - 1`` points, which when\n    connected linearly give a step function which changes values at the\n    beginning of the intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as ``x``.\n\n    Returns\n    -------\n    out : array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N + 1``. For\n        ``N=0``, the length will be 0.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), max(2 * len(x) - 1, 0)))\n    # In all `pts_to_*step` functions, only assign once using *x* and *args*,\n    # as converting to an array may be expensive.\n    steps[0, 0::2] = x\n    steps[0, 1::2] = steps[0, 0:-2:2]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 2::2]\n    return steps",
        "begin_line": 1525,
        "end_line": 1560,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.pts_to_poststep#1563",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.pts_to_poststep(x, *args)",
        "snippet": "def pts_to_poststep(x, *args):\n    \"\"\"\n    Convert continuous line to post-steps.\n\n    Given a set of ``N`` points convert to ``2N + 1`` points, which when\n    connected linearly give a step function which changes values at the end of\n    the intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as ``x``.\n\n    Returns\n    -------\n    out : array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N + 1``. For\n        ``N=0``, the length will be 0.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_poststep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), max(2 * len(x) - 1, 0)))\n    steps[0, 0::2] = x\n    steps[0, 1::2] = steps[0, 2::2]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 0:-2:2]\n    return steps",
        "begin_line": 1563,
        "end_line": 1596,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.pts_to_midstep#1599",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.pts_to_midstep(x, *args)",
        "snippet": "def pts_to_midstep(x, *args):\n    \"\"\"\n    Convert continuous line to mid-steps.\n\n    Given a set of ``N`` points convert to ``2N`` points which when connected\n    linearly give a step function which changes values at the middle of the\n    intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as\n        ``x``.\n\n    Returns\n    -------\n    out : array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N``.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_midstep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), 2 * len(x)))\n    x = np.asanyarray(x)\n    steps[0, 1:-1:2] = steps[0, 2::2] = (x[:-1] + x[1:]) / 2\n    steps[0, :1] = x[:1]  # Also works for zero-sized input.\n    steps[0, -1:] = x[-1:]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 0::2]\n    return steps",
        "begin_line": 1599,
        "end_line": 1634,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.index_of#1644",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.index_of(y)",
        "snippet": "def index_of(y):\n    \"\"\"\n    A helper function to create reasonable x values for the given *y*.\n\n    This is used for plotting (x, y) if x values are not explicitly given.\n\n    First try ``y.index`` (assuming *y* is a `pandas.Series`), if that\n    fails, use ``range(len(y))``.\n\n    This will be extended in the future to deal with more types of\n    labeled data.\n\n    Parameters\n    ----------\n    y : scalar or array-like\n\n    Returns\n    -------\n    x, y : ndarray\n       The x and y values to plot.\n    \"\"\"\n    try:\n        return y.index.values, y.values\n    except AttributeError:\n        y = _check_1d(y)\n        return np.arange(y.shape[0], dtype=float), y",
        "begin_line": 1644,
        "end_line": 1669,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005194805194805195,
            "pseudo_dstar_susp": 0.0004106776180698152,
            "pseudo_tarantula_susp": 0.0019569471624266144,
            "pseudo_op2_susp": 0.0004106776180698152,
            "pseudo_barinel_susp": 0.0019569471624266144
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.safe_first_element#1672",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.safe_first_element(obj)",
        "snippet": "def safe_first_element(obj):\n    \"\"\"\n    Return the first element in *obj*.\n\n    This is an type-independent way of obtaining the first element, supporting\n    both index access and the iterator protocol.\n    \"\"\"\n    if isinstance(obj, collections.abc.Iterator):\n        # needed to accept `array.flat` as input.\n        # np.flatiter reports as an instance of collections.Iterator\n        # but can still be indexed via [].\n        # This has the side effect of re-setting the iterator, but\n        # that is acceptable.\n        try:\n            return obj[0]\n        except TypeError:\n            pass\n        raise RuntimeError(\"matplotlib does not support generators \"\n                           \"as input\")\n    return next(iter(obj))",
        "begin_line": 1672,
        "end_line": 1691,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008733624454148472,
            "pseudo_dstar_susp": 0.0014326647564469914,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.0014326647564469914,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.sanitize_sequence#1694",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.sanitize_sequence(data)",
        "snippet": "def sanitize_sequence(data):\n    \"\"\"\n    Convert dictview objects to list. Other inputs are returned unchanged.\n    \"\"\"\n    return (list(data) if isinstance(data, collections.abc.MappingView)\n            else data)",
        "begin_line": 1694,
        "end_line": 1699,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003067484662576687,
            "pseudo_dstar_susp": 0.000779423226812159,
            "pseudo_tarantula_susp": 0.002,
            "pseudo_op2_susp": 0.000779423226812159,
            "pseudo_barinel_susp": 0.002
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.normalize_kwargs#1705",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.normalize_kwargs(kw, alias_mapping=None, required=(), forbidden=(), allowed=None)",
        "snippet": "def normalize_kwargs(kw, alias_mapping=None, required=(), forbidden=(),\n                     allowed=None):\n    \"\"\"\n    Helper function to normalize kwarg inputs.\n\n    The order they are resolved are:\n\n    1. aliasing\n    2. required\n    3. forbidden\n    4. allowed\n\n    This order means that only the canonical names need appear in\n    *allowed*, *forbidden*, *required*.\n\n    Parameters\n    ----------\n    kw : dict\n        A dict of keyword arguments.\n\n    alias_mapping : dict or Artist subclass or Artist instance, optional\n        A mapping between a canonical name to a list of\n        aliases, in order of precedence from lowest to highest.\n\n        If the canonical value is not in the list it is assumed to have\n        the highest priority.\n\n        If an Artist subclass or instance is passed, use its properties alias\n        mapping.\n\n    required : list of str, optional\n        A list of keys that must be in *kws*.  This parameter is deprecated.\n\n    forbidden : list of str, optional\n        A list of keys which may not be in *kw*.  This parameter is deprecated.\n\n    allowed : list of str, optional\n        A list of allowed fields.  If this not None, then raise if\n        *kw* contains any keys not in the union of *required*\n        and *allowed*.  To allow only the required fields pass in\n        an empty tuple ``allowed=()``.  This parameter is deprecated.\n\n    Raises\n    ------\n    TypeError\n        To match what python raises if invalid args/kwargs are passed to\n        a callable.\n    \"\"\"\n    from matplotlib.artist import Artist\n\n    # deal with default value of alias_mapping\n    if alias_mapping is None:\n        alias_mapping = dict()\n    elif (isinstance(alias_mapping, type) and issubclass(alias_mapping, Artist)\n          or isinstance(alias_mapping, Artist)):\n        alias_mapping = getattr(alias_mapping, \"_alias_map\", {})\n\n    # make a local so we can pop\n    kw = dict(kw)\n    # output dictionary\n    ret = dict()\n\n    # hit all alias mappings\n    for canonical, alias_list in alias_mapping.items():\n\n        # the alias lists are ordered from lowest to highest priority\n        # so we know to use the last value in this list\n        tmp = []\n        seen = []\n        for a in alias_list:\n            try:\n                tmp.append(kw.pop(a))\n                seen.append(a)\n            except KeyError:\n                pass\n        # if canonical is not in the alias_list assume highest priority\n        if canonical not in alias_list:\n            try:\n                tmp.append(kw.pop(canonical))\n                seen.append(canonical)\n            except KeyError:\n                pass\n        # if we found anything in this set of aliases put it in the return\n        # dict\n        if tmp:\n            ret[canonical] = tmp[-1]\n            if len(tmp) > 1:\n                raise TypeError(\"Got the following keyword arguments which \"\n                                \"are aliases of one another: {}\"\n                                .format(\", \".join(map(repr, seen))))\n\n    # at this point we know that all keys which are aliased are removed, update\n    # the return dictionary from the cleaned local copy of the input\n    ret.update(kw)\n\n    fail_keys = [k for k in required if k not in ret]\n    if fail_keys:\n        raise TypeError(\"The required keys {keys!r} \"\n                        \"are not in kwargs\".format(keys=fail_keys))\n\n    fail_keys = [k for k in forbidden if k in ret]\n    if fail_keys:\n        raise TypeError(\"The forbidden keys {keys!r} \"\n                        \"are in kwargs\".format(keys=fail_keys))\n\n    if allowed is not None:\n        allowed_set = {*required, *allowed}\n        fail_keys = [k for k in ret if k not in allowed_set]\n        if fail_keys:\n            raise TypeError(\n                \"kwargs contains {keys!r} which are not in the required \"\n                \"{req!r} or allowed {allow!r} keys\".format(\n                    keys=fail_keys, req=required, allow=allowed))\n\n    return ret",
        "begin_line": 1705,
        "end_line": 1819,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012547051442910915,
            "pseudo_dstar_susp": 0.0022988505747126436,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0022988505747126436,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._str_equal#1881",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._str_equal(obj, s)",
        "snippet": "def _str_equal(obj, s):\n    \"\"\"Return whether *obj* is a string equal to string *s*.\n\n    This helper solely exists to handle the case where *obj* is a numpy array,\n    because in such cases, a naive ``obj == s`` would yield an array, which\n    cannot be used in a boolean context.\n    \"\"\"\n    return isinstance(obj, str) and obj == s",
        "begin_line": 1881,
        "end_line": 1888,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003861003861003861,
            "pseudo_dstar_susp": 0.000355998576005696,
            "pseudo_tarantula_susp": 0.0008077544426494346,
            "pseudo_op2_susp": 0.000355998576005696,
            "pseudo_barinel_susp": 0.0008077544426494346
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._str_lower_equal#1891",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._str_lower_equal(obj, s)",
        "snippet": "def _str_lower_equal(obj, s):\n    \"\"\"Return whether *obj* is a string equal, when lowercased, to string *s*.\n\n    This helper solely exists to handle the case where *obj* is a numpy array,\n    because in such cases, a naive ``obj == s`` would yield an array, which\n    cannot be used in a boolean context.\n    \"\"\"\n    return isinstance(obj, str) and obj.lower() == s",
        "begin_line": 1891,
        "end_line": 1898,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000500751126690035,
            "pseudo_dstar_susp": 0.0006222775357809583,
            "pseudo_tarantula_susp": 0.001282051282051282,
            "pseudo_op2_susp": 0.0006222775357809583,
            "pseudo_barinel_susp": 0.001282051282051282
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.make_alias#1921",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.make_alias(name)",
        "snippet": "    def make_alias(name):  # Enforce a closure over *name*.\n        @functools.wraps(getattr(cls, name))\n        def method(self, *args, **kwargs):\n            return getattr(self, name)(*args, **kwargs)\n        return method",
        "begin_line": 1921,
        "end_line": 1925,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004361098996947231,
            "pseudo_dstar_susp": 0.0003875968992248062,
            "pseudo_tarantula_susp": 0.001422475106685633,
            "pseudo_op2_susp": 0.0003875968992248062,
            "pseudo_barinel_susp": 0.001422475106685633
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.method#1923",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.method(self, *args, **kwargs)",
        "snippet": "        def method(self, *args, **kwargs):\n            return getattr(self, name)(*args, **kwargs)",
        "begin_line": 1923,
        "end_line": 1924,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031191515907673113,
            "pseudo_dstar_susp": 0.00030721966205837174,
            "pseudo_tarantula_susp": 0.00034818941504178273,
            "pseudo_op2_susp": 0.00030721966205837174,
            "pseudo_barinel_susp": 0.00034818941504178273
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._array_perimeter#1955",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._array_perimeter(arr)",
        "snippet": "def _array_perimeter(arr):\n    \"\"\"\n    Get the elements on the perimeter of ``arr``,\n\n    Parameters\n    ----------\n    arr : ndarray, shape (M, N)\n        The input array\n\n    Returns\n    -------\n    perimeter : ndarray, shape (2*(M - 1) + 2*(N - 1),)\n        The elements on the perimeter of the array::\n\n           [arr[0, 0], ..., arr[0, -1], ..., arr[-1, -1], ..., arr[-1, 0], ...]\n\n    Examples\n    --------\n    >>> i, j = np.ogrid[:3,:4]\n    >>> a = i*10 + j\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [10, 11, 12, 13],\n           [20, 21, 22, 23]])\n    >>> _array_perimeter(a)\n    array([ 0,  1,  2,  3, 13, 23, 22, 21, 20, 10])\n    \"\"\"\n    # note we use Python's half-open ranges to avoid repeating\n    # the corners\n    forward = np.s_[0:-1]      # [0 ... -1)\n    backward = np.s_[-1:0:-1]  # [-1 ... 0)\n    return np.concatenate((\n        arr[0, forward],\n        arr[forward, -1],\n        arr[-1, backward],\n        arr[backward, 0],\n    ))",
        "begin_line": 1955,
        "end_line": 1991,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._unfold#1994",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._unfold(arr, axis, size, step)",
        "snippet": "def _unfold(arr, axis, size, step):\n    \"\"\"\n    Append an extra dimension containing sliding windows along *axis*.\n\n    All windows are of size *size* and begin with every *step* elements.\n\n    Parameters\n    ----------\n    arr : ndarray, shape (N_1, ..., N_k)\n        The input array\n    axis : int\n        Axis along which the windows are extracted\n    size : int\n        Size of the windows\n    step : int\n        Stride between first elements of subsequent windows.\n\n    Returns\n    -------\n    windows : ndarray, shape (N_1, ..., 1 + (N_axis-size)/step, ..., N_k, size)\n\n    Examples\n    --------\n    >>> i, j = np.ogrid[:3,:7]\n    >>> a = i*10 + j\n    >>> a\n    array([[ 0,  1,  2,  3,  4,  5,  6],\n           [10, 11, 12, 13, 14, 15, 16],\n           [20, 21, 22, 23, 24, 25, 26]])\n    >>> _unfold(a, axis=1, size=3, step=2)\n    array([[[ 0,  1,  2],\n            [ 2,  3,  4],\n            [ 4,  5,  6]],\n\n           [[10, 11, 12],\n            [12, 13, 14],\n            [14, 15, 16]],\n\n           [[20, 21, 22],\n            [22, 23, 24],\n            [24, 25, 26]]])\n    \"\"\"\n    new_shape = [*arr.shape, size]\n    new_strides = [*arr.strides, arr.strides[axis]]\n    new_shape[axis] = (new_shape[axis] - size) // step + 1\n    new_strides[axis] = new_strides[axis] * step\n    return np.lib.stride_tricks.as_strided(arr,\n                                           shape=new_shape,\n                                           strides=new_strides,\n                                           writeable=False)",
        "begin_line": 1994,
        "end_line": 2043,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._array_patch_perimeters#2046",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._array_patch_perimeters(x, rstride, cstride)",
        "snippet": "def _array_patch_perimeters(x, rstride, cstride):\n    \"\"\"\n    Extract perimeters of patches from *arr*.\n\n    Extracted patches are of size (*rstride* + 1) x (*cstride* + 1) and\n    share perimeters with their neighbors. The ordering of the vertices matches\n    that returned by ``_array_perimeter``.\n\n    Parameters\n    ----------\n    x : ndarray, shape (N, M)\n        Input array\n    rstride : int\n        Vertical (row) stride between corresponding elements of each patch\n    cstride : int\n        Horizontal (column) stride between corresponding elements of each patch\n\n    Returns\n    -------\n    patches : ndarray, shape (N/rstride * M/cstride, 2 * (rstride + cstride))\n    \"\"\"\n    assert rstride > 0 and cstride > 0\n    assert (x.shape[0] - 1) % rstride == 0\n    assert (x.shape[1] - 1) % cstride == 0\n    # We build up each perimeter from four half-open intervals. Here is an\n    # illustrated explanation for rstride == cstride == 3\n    #\n    #       T T T R\n    #       L     R\n    #       L     R\n    #       L B B B\n    #\n    # where T means that this element will be in the top array, R for right,\n    # B for bottom and L for left. Each of the arrays below has a shape of:\n    #\n    #    (number of perimeters that can be extracted vertically,\n    #     number of perimeters that can be extracted horizontally,\n    #     cstride for top and bottom and rstride for left and right)\n    #\n    # Note that _unfold doesn't incur any memory copies, so the only costly\n    # operation here is the np.concatenate.\n    top = _unfold(x[:-1:rstride, :-1], 1, cstride, cstride)\n    bottom = _unfold(x[rstride::rstride, 1:], 1, cstride, cstride)[..., ::-1]\n    right = _unfold(x[:-1, cstride::cstride], 0, rstride, rstride)\n    left = _unfold(x[1:, :-1:cstride], 0, rstride, rstride)[..., ::-1]\n    return (np.concatenate((top, right, bottom, left), axis=2)\n              .reshape(-1, 2 * (rstride + cstride)))",
        "begin_line": 2046,
        "end_line": 2092,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._setattr_cm#2096",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._setattr_cm(obj, **kwargs)",
        "snippet": "def _setattr_cm(obj, **kwargs):\n    \"\"\"Temporarily set some attributes; restore original state at context exit.\n    \"\"\"\n    sentinel = object()\n    origs = [(attr, getattr(obj, attr, sentinel)) for attr in kwargs]\n    try:\n        for attr, val in kwargs.items():\n            setattr(obj, attr, val)\n        yield\n    finally:\n        for attr, orig in origs:\n            if orig is sentinel:\n                delattr(obj, attr)\n            else:\n                setattr(obj, attr, orig)",
        "begin_line": 2096,
        "end_line": 2110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003424657534246575,
            "pseudo_dstar_susp": 0.004784688995215311,
            "pseudo_tarantula_susp": 0.001392757660167131,
            "pseudo_op2_susp": 0.004784688995215311,
            "pseudo_barinel_susp": 0.001392757660167131
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._warn_external#2113",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._warn_external(message, category=None)",
        "snippet": "def _warn_external(message, category=None):\n    \"\"\"\n    `warnings.warn` wrapper that sets *stacklevel* to \"outside Matplotlib\".\n\n    The original emitter of the warning can be obtained by patching this\n    function back to `warnings.warn`, i.e. ``cbook._warn_external =\n    warnings.warn`` (or ``functools.partial(warnings.warn, stacklevel=2)``,\n    etc.).\n    \"\"\"\n    frame = sys._getframe()\n    for stacklevel in itertools.count(1):  # lgtm[py/unused-loop-variable]\n        if frame is None:\n            # when called in embedded context may hit frame is None\n            break\n        if not re.match(r\"\\A(matplotlib|mpl_toolkits)(\\Z|\\.(?!tests\\.))\",\n                        # Work around sphinx-gallery not setting __name__.\n                        frame.f_globals.get(\"__name__\", \"\")):\n            break\n        frame = frame.f_back\n    warnings.warn(message, category, stacklevel)",
        "begin_line": 2113,
        "end_line": 2132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007936507936507936,
            "pseudo_dstar_susp": 0.004149377593360996,
            "pseudo_tarantula_susp": 0.002320185614849188,
            "pseudo_op2_susp": 0.004166666666666667,
            "pseudo_barinel_susp": 0.002320185614849188
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._OrderedSet.__init__#2136",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__._OrderedSet",
        "signature": "lib.matplotlib.cbook.__init__._OrderedSet.__init__(self)",
        "snippet": "    def __init__(self):\n        self._od = collections.OrderedDict()",
        "begin_line": 2136,
        "end_line": 2137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001379310344827586,
            "pseudo_dstar_susp": 0.0025380710659898475,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.0025380710659898475,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._OrderedSet.add#2148",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__._OrderedSet",
        "signature": "lib.matplotlib.cbook.__init__._OrderedSet.add(self, key)",
        "snippet": "    def add(self, key):\n        self._od.pop(key, None)\n        self._od[key] = None",
        "begin_line": 2148,
        "end_line": 2150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003418803418803419,
            "pseudo_dstar_susp": 0.0003234152652005175,
            "pseudo_tarantula_susp": 0.000434593654932638,
            "pseudo_op2_susp": 0.0003234152652005175,
            "pseudo_barinel_susp": 0.000434593654932638
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._OrderedSet.discard#2152",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__._OrderedSet",
        "signature": "lib.matplotlib.cbook.__init__._OrderedSet.discard(self, key)",
        "snippet": "    def discard(self, key):\n        self._od.pop(key, None)",
        "begin_line": 2152,
        "end_line": 2153,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._pformat_subprocess#2198",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._pformat_subprocess(command)",
        "snippet": "def _pformat_subprocess(command):\n    \"\"\"Pretty-format a subprocess command for printing/logging purposes.\"\"\"\n    return (command if isinstance(command, str)\n            else \" \".join(shlex.quote(os.fspath(arg)) for arg in command))",
        "begin_line": 2198,
        "end_line": 2201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._check_isinstance#2235",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._check_isinstance(_types, **kwargs)",
        "snippet": "def _check_isinstance(_types, **kwargs):\n    \"\"\"\n    For each *key, value* pair in *kwargs*, check that *value* is an instance\n    of one of *_types*; if not, raise an appropriate TypeError.\n\n    As a special case, a ``None`` entry in *_types* is treated as NoneType.\n\n    Examples\n    --------\n    >>> cbook._check_isinstance((SomeClass, None), arg=arg)\n    \"\"\"\n    types = _types\n    if isinstance(types, type) or types is None:\n        types = (types,)\n    none_allowed = None in types\n    types = tuple(tp for tp in types if tp is not None)\n\n    def type_name(tp):\n        return (tp.__qualname__ if tp.__module__ == \"builtins\"\n                else f\"{tp.__module__}.{tp.__qualname__}\")\n\n    names = [*map(type_name, types)]\n    if none_allowed:\n        types = (*types, type(None))\n        names.append(\"None\")\n    for k, v in kwargs.items():\n        if not isinstance(v, types):\n            raise TypeError(\n                \"{!r} must be an instance of {}, not a {}\".format(\n                    k,\n                    \", \".join(names[:-1]) + \" or \" + names[-1]\n                    if len(names) > 1 else names[0],\n                    type_name(type(v))))",
        "begin_line": 2235,
        "end_line": 2267,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006230529595015577,
            "pseudo_dstar_susp": 0.0011862396204033216,
            "pseudo_tarantula_susp": 0.001128668171557562,
            "pseudo_op2_susp": 0.0011862396204033216,
            "pseudo_barinel_susp": 0.001128668171557562
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__.type_name#2252",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__.type_name(tp)",
        "snippet": "    def type_name(tp):\n        return (tp.__qualname__ if tp.__module__ == \"builtins\"\n                else f\"{tp.__module__}.{tp.__qualname__}\")",
        "begin_line": 2252,
        "end_line": 2254,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006226650062266501,
            "pseudo_dstar_susp": 0.001184834123222749,
            "pseudo_tarantula_susp": 0.001128668171557562,
            "pseudo_op2_susp": 0.001184834123222749,
            "pseudo_barinel_susp": 0.001128668171557562
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._check_in_list#2270",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._check_in_list(_values, **kwargs)",
        "snippet": "def _check_in_list(_values, **kwargs):\n    \"\"\"\n    For each *key, value* pair in *kwargs*, check that *value* is in *_values*;\n    if not, raise an appropriate ValueError.\n\n    Examples\n    --------\n    >>> cbook._check_in_list([\"foo\", \"bar\"], arg=arg, other_arg=other_arg)\n    \"\"\"\n    values = _values\n    for k, v in kwargs.items():\n        if v not in values:\n            raise ValueError(\n                \"{!r} is not a valid value for {}; supported values are {}\"\n                .format(v, k, ', '.join(map(repr, values))))",
        "begin_line": 2270,
        "end_line": 2284,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007936507936507936,
            "pseudo_dstar_susp": 0.005952380952380952,
            "pseudo_tarantula_susp": 0.002320185614849188,
            "pseudo_op2_susp": 0.006211180124223602,
            "pseudo_barinel_susp": 0.002320185614849188
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._check_getitem#2287",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._check_getitem(_mapping, **kwargs)",
        "snippet": "def _check_getitem(_mapping, **kwargs):\n    \"\"\"\n    *kwargs* must consist of a single *key, value* pair.  If *key* is in\n    *_mapping*, return ``_mapping[value]``; else, raise an appropriate\n    ValueError.\n\n    Examples\n    --------\n    >>> cbook._check_getitem({\"foo\": \"bar\"}, arg=arg)\n    \"\"\"\n    mapping = _mapping\n    if len(kwargs) != 1:\n        raise ValueError(\"_check_getitem takes a single keyword argument\")\n    (k, v), = kwargs.items()\n    try:\n        return mapping[v]\n    except KeyError:\n        raise ValueError(\n            \"{!r} is not a valid value for {}; supported values are {}\"\n            .format(v, k, ', '.join(map(repr, mapping)))) from None",
        "begin_line": 2287,
        "end_line": 2306,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040551500405515005,
            "pseudo_dstar_susp": 0.00037037037037037035,
            "pseudo_tarantula_susp": 0.0009606147934678194,
            "pseudo_op2_susp": 0.00037037037037037035,
            "pseudo_barinel_susp": 0.0009606147934678194
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._classproperty.__get__#2329",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__._classproperty",
        "signature": "lib.matplotlib.cbook.__init__._classproperty.__get__(self, instance, owner)",
        "snippet": "    def __get__(self, instance, owner):\n        return self._fget(owner)",
        "begin_line": 2329,
        "end_line": 2330,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.__init__._backend_module_name#2333",
        "src_path": "lib/matplotlib/cbook/__init__.py",
        "class_name": "lib.matplotlib.cbook.__init__",
        "signature": "lib.matplotlib.cbook.__init__._backend_module_name(name)",
        "snippet": "def _backend_module_name(name):\n    \"\"\"\n    Convert a backend name (either a standard backend -- \"Agg\", \"TkAgg\", ... --\n    or a custom backend -- \"module://...\") to the corresponding module name).\n    \"\"\"\n    return (name[9:] if name.startswith(\"module://\")\n            else \"matplotlib.backends.backend_{}\".format(name.lower()))",
        "begin_line": 2333,
        "end_line": 2339,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patheffects.PathEffectRenderer._draw_text_as_path#141",
        "src_path": "lib/matplotlib/patheffects.py",
        "class_name": "lib.matplotlib.patheffects.PathEffectRenderer",
        "signature": "lib.matplotlib.patheffects.PathEffectRenderer._draw_text_as_path(self, gc, x, y, s, prop, angle, ismath)",
        "snippet": "    def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath):\n        # Implements the naive text drawing as is found in RendererBase.\n        path, transform = self._get_text_path_transform(x, y, s, prop,\n                                                        angle, ismath)\n        color = gc.get_rgb()\n        gc.set_linewidth(0.0)\n        self.draw_path(gc, path, transform, rgbFace=color)",
        "begin_line": 141,
        "end_line": 147,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.910273545397844e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patheffects.Stroke.__init__#198",
        "src_path": "lib/matplotlib/patheffects.py",
        "class_name": "lib.matplotlib.patheffects.Stroke",
        "signature": "lib.matplotlib.patheffects.Stroke.__init__(self, offset=(0, 0), **kwargs)",
        "snippet": "    def __init__(self, offset=(0, 0), **kwargs):\n        \"\"\"\n        The path will be stroked with its gc updated with the given\n        keyword arguments, i.e., the keyword arguments should be valid\n        gc parameter values.\n        \"\"\"\n        super().__init__(offset)\n        self._gc = kwargs",
        "begin_line": 198,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.get_unicode_index#48",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext",
        "signature": "lib.matplotlib.mathtext.get_unicode_index(symbol, math=True)",
        "snippet": "def get_unicode_index(symbol, math=True):\n    r\"\"\"\n    Return the integer index (from the Unicode table) of *symbol*.\n\n    Parameters\n    ----------\n    symbol : str\n        A single unicode character, a TeX command (e.g. r'\\pi') or a Type1\n        symbol name (e.g. 'phi').\n    math : bool, default: True\n        If False, always treat as a single unicode character.\n    \"\"\"\n    # for a non-math symbol, simply return its unicode index\n    if not math:\n        return ord(symbol)\n    # From UTF #25: U+2212 minus sign is the preferred\n    # representation of the unary and binary minus sign rather than\n    # the ASCII-derived U+002D hyphen-minus, because minus sign is\n    # unambiguous and because it is rendered with a more desirable\n    # length, usually longer than a hyphen.\n    if symbol == '-':\n        return 0x2212\n    try:  # This will succeed if symbol is a single unicode char\n        return ord(symbol)\n    except TypeError:\n        pass\n    try:  # Is symbol a TeX symbol (i.e. \\alpha)\n        return tex2uni[symbol.strip(\"\\\\\")]\n    except KeyError as err:\n        raise ValueError(\n            \"'{}' is not a valid Unicode character or TeX/Type1 symbol\"\n            .format(symbol)) from err",
        "begin_line": 48,
        "end_line": 79,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.28332714444857e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackend.__init__#98",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackend",
        "signature": "lib.matplotlib.mathtext.MathtextBackend.__init__(self)",
        "snippet": "    def __init__(self):\n        self.width = 0\n        self.height = 0\n        self.depth = 0",
        "begin_line": 98,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.895152376440866e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackend.set_canvas_size#103",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackend",
        "signature": "lib.matplotlib.mathtext.MathtextBackend.set_canvas_size(self, w, h, d)",
        "snippet": "    def set_canvas_size(self, w, h, d):\n        \"\"\"Set the dimension of the drawing canvas.\"\"\"\n        self.width  = w\n        self.height = h\n        self.depth  = d",
        "begin_line": 103,
        "end_line": 107,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.807010695604653e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackendAgg.__init__#142",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackendAgg",
        "signature": "lib.matplotlib.mathtext.MathtextBackendAgg.__init__(self)",
        "snippet": "    def __init__(self):\n        self.ox = 0\n        self.oy = 0\n        self.image = None\n        self.mode = 'bbox'\n        self.bbox = [0, 0, 0, 0]\n        MathtextBackend.__init__(self)",
        "begin_line": 142,
        "end_line": 148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.284912945290303e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackendAgg._update_bbox#150",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackendAgg",
        "signature": "lib.matplotlib.mathtext.MathtextBackendAgg._update_bbox(self, x1, y1, x2, y2)",
        "snippet": "    def _update_bbox(self, x1, y1, x2, y2):\n        self.bbox = [min(self.bbox[0], x1),\n                     min(self.bbox[1], y1),\n                     max(self.bbox[2], x2),\n                     max(self.bbox[3], y2)]",
        "begin_line": 150,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.242178447276941e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackendAgg.render_glyph#161",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackendAgg",
        "signature": "lib.matplotlib.mathtext.MathtextBackendAgg.render_glyph(self, ox, oy, info)",
        "snippet": "    def render_glyph(self, ox, oy, info):\n        if self.mode == 'bbox':\n            self._update_bbox(ox + info.metrics.xmin,\n                              oy - info.metrics.ymax,\n                              ox + info.metrics.xmax,\n                              oy - info.metrics.ymin)\n        else:\n            info.font.draw_glyph_to_bitmap(\n                self.image, ox, oy - info.metrics.iceberg, info.glyph,\n                antialiased=rcParams['text.antialiased'])",
        "begin_line": 161,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.166598611678236e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackendAgg.get_results#184",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackendAgg",
        "signature": "lib.matplotlib.mathtext.MathtextBackendAgg.get_results(self, box, used_characters)",
        "snippet": "    def get_results(self, box, used_characters):\n        self.mode = 'bbox'\n        orig_height = box.height\n        orig_depth  = box.depth\n        ship(0, 0, box)\n        bbox = self.bbox\n        bbox = [bbox[0] - 1, bbox[1] - 1, bbox[2] + 1, bbox[3] + 1]\n        self.mode = 'render'\n        self.set_canvas_size(\n            bbox[2] - bbox[0],\n            (bbox[3] - bbox[1]) - orig_depth,\n            (bbox[3] - bbox[1]) - orig_height)\n        ship(-bbox[0], -bbox[1], box)\n        result = (self.ox,\n                  self.oy,\n                  self.width,\n                  self.height + self.depth,\n                  self.depth,\n                  self.image,\n                  used_characters)\n        self.image = None\n        return result",
        "begin_line": 184,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.098477486232588e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathtextBackendPs.render_glyph#231",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathtextBackendPs",
        "signature": "lib.matplotlib.mathtext.MathtextBackendPs.render_glyph(self, ox, oy, info)",
        "snippet": "    def render_glyph(self, ox, oy, info):\n        oy = self.height - oy + info.offset\n        postscript_name = info.postscript_name\n        fontsize        = info.fontsize\n        symbol_name     = info.symbol_name\n\n        if (postscript_name, fontsize) != self.lastfont:\n            self.lastfont = postscript_name, fontsize\n            self.pswriter.write(\n                f\"/{postscript_name} findfont\\n\"\n                f\"{fontsize} scalefont\\n\"\n                f\"setfont\\n\")\n\n        self.pswriter.write(\n            f\"{ox:f} {oy:f} moveto\\n\"\n            f\"/{symbol_name} glyphshow\\n\")",
        "begin_line": 231,
        "end_line": 246,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Fonts.__init__#388",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Fonts",
        "signature": "lib.matplotlib.mathtext.Fonts.__init__(self, default_font_prop, mathtext_backend)",
        "snippet": "    def __init__(self, default_font_prop, mathtext_backend):\n        \"\"\"\n        Parameters\n        ----------\n        default_font_prop: `~.font_manager.FontProperties`\n            The default non-math font, or the base font for Unicode (generic)\n            font rendering.\n        mathtext_backend: `MathtextBackend` subclass\n            Backend to which rendering is actually delegated.\n        \"\"\"\n        self.default_font_prop = default_font_prop\n        self.mathtext_backend = mathtext_backend\n        self.used_characters = {}",
        "begin_line": 388,
        "end_line": 400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Fonts.get_metrics#428",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Fonts",
        "signature": "lib.matplotlib.mathtext.Fonts.get_metrics(self, font, font_class, sym, fontsize, dpi, math=True)",
        "snippet": "    def get_metrics(self, font, font_class, sym, fontsize, dpi, math=True):\n        r\"\"\"\n        *font*: one of the TeX font names::\n\n          tt, it, rm, cal, sf, bf or default/regular (non-math)\n\n        *font_class*: TODO\n\n        *sym*:  a symbol in raw TeX form. e.g., '1', 'x' or '\\sigma'\n\n        *fontsize*: font size in points\n\n        *dpi*: current dots-per-inch\n\n        *math*: whether sym is a math character\n\n        Returns an object with the following attributes:\n\n          - *advance*: The advance distance (in points) of the glyph.\n\n          - *height*: The height of the glyph in points.\n\n          - *width*: The width of the glyph in points.\n\n          - *xmin*, *xmax*, *ymin*, *ymax* - the ink rectangle of the glyph\n\n          - *iceberg* - the distance from the baseline to the top of\n            the glyph.  This corresponds to TeX's definition of\n            \"height\".\n        \"\"\"\n        info = self._get_info(font, font_class, sym, fontsize, dpi, math)\n        return info.metrics",
        "begin_line": 428,
        "end_line": 459,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Fonts.set_canvas_size#461",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Fonts",
        "signature": "lib.matplotlib.mathtext.Fonts.set_canvas_size(self, w, h, d)",
        "snippet": "    def set_canvas_size(self, w, h, d):\n        \"\"\"\n        Set the size of the buffer used to render the math expression.\n        Only really necessary for the bitmap backends.\n        \"\"\"\n        self.width, self.height, self.depth = np.ceil([w, h, d])\n        self.mathtext_backend.set_canvas_size(\n            self.width, self.height, self.depth)",
        "begin_line": 461,
        "end_line": 468,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Fonts.render_glyph#470",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Fonts",
        "signature": "lib.matplotlib.mathtext.Fonts.render_glyph(self, ox, oy, facename, font_class, sym, fontsize, dpi)",
        "snippet": "    def render_glyph(self, ox, oy, facename, font_class, sym, fontsize, dpi):\n        \"\"\"\n        Draw a glyph at\n\n          - *ox*, *oy*: position\n\n          - *facename*: One of the TeX face names\n\n          - *font_class*:\n\n          - *sym*: TeX symbol name or single character\n\n          - *fontsize*: fontsize in points\n\n          - *dpi*: The dpi to draw at.\n        \"\"\"\n        info = self._get_info(facename, font_class, sym, fontsize, dpi)\n        self.used_characters.setdefault(info.font.fname, set()).add(info.num)\n        self.mathtext_backend.render_glyph(ox, oy, info)",
        "begin_line": 470,
        "end_line": 488,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Fonts.get_results#517",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Fonts",
        "signature": "lib.matplotlib.mathtext.Fonts.get_results(self, box)",
        "snippet": "    def get_results(self, box):\n        \"\"\"\n        Get the data needed by the backend to render the math\n        expression.  The return value is backend-specific.\n        \"\"\"\n        result = self.mathtext_backend.get_results(\n            box, self.get_used_characters())\n        self.destroy()\n        return result",
        "begin_line": 517,
        "end_line": 525,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts.__init__#542",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts.__init__(self, default_font_prop, mathtext_backend)",
        "snippet": "    def __init__(self, default_font_prop, mathtext_backend):\n        Fonts.__init__(self, default_font_prop, mathtext_backend)\n        self.glyphd = {}\n        self._fonts = {}\n\n        filename = findfont(default_font_prop)\n        default_font = get_font(filename)\n        self._fonts['default'] = default_font\n        self._fonts['regular'] = default_font",
        "begin_line": 542,
        "end_line": 550,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts.destroy#552",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts.destroy(self)",
        "snippet": "    def destroy(self):\n        self.glyphd = None\n        Fonts.destroy(self)",
        "begin_line": 552,
        "end_line": 554,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts._get_font#556",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts._get_font(self, font)",
        "snippet": "    def _get_font(self, font):\n        if font in self.fontmap:\n            basename = self.fontmap[font]\n        else:\n            basename = font\n        cached_font = self._fonts.get(basename)\n        if cached_font is None and os.path.exists(basename):\n            cached_font = get_font(basename)\n            self._fonts[basename] = cached_font\n            self._fonts[cached_font.postscript_name] = cached_font\n            self._fonts[cached_font.postscript_name.lower()] = cached_font\n        return cached_font",
        "begin_line": 556,
        "end_line": 567,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts._get_offset#569",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts._get_offset(self, font, glyph, fontsize, dpi)",
        "snippet": "    def _get_offset(self, font, glyph, fontsize, dpi):\n        if font.postscript_name == 'Cmex10':\n            return (glyph.height / 64 / 2) + (fontsize/3 * dpi/72)\n        return 0.",
        "begin_line": 569,
        "end_line": 572,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts._get_info#574",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts._get_info(self, fontname, font_class, sym, fontsize, dpi, math=True)",
        "snippet": "    def _get_info(self, fontname, font_class, sym, fontsize, dpi, math=True):\n        key = fontname, font_class, sym, fontsize, dpi\n        bunch = self.glyphd.get(key)\n        if bunch is not None:\n            return bunch\n\n        font, num, symbol_name, fontsize, slanted = \\\n            self._get_glyph(fontname, font_class, sym, fontsize, math)\n\n        font.set_size(fontsize, dpi)\n        glyph = font.load_char(\n            num,\n            flags=self.mathtext_backend.get_hinting_type())\n\n        xmin, ymin, xmax, ymax = [val/64.0 for val in glyph.bbox]\n        offset = self._get_offset(font, glyph, fontsize, dpi)\n        metrics = types.SimpleNamespace(\n            advance = glyph.linearHoriAdvance/65536.0,\n            height  = glyph.height/64.0,\n            width   = glyph.width/64.0,\n            xmin    = xmin,\n            xmax    = xmax,\n            ymin    = ymin+offset,\n            ymax    = ymax+offset,\n            # iceberg is the equivalent of TeX's \"height\"\n            iceberg = glyph.horiBearingY/64.0 + offset,\n            slanted = slanted\n            )\n\n        result = self.glyphd[key] = types.SimpleNamespace(\n            font            = font,\n            fontsize        = fontsize,\n            postscript_name = font.postscript_name,\n            metrics         = metrics,\n            symbol_name     = symbol_name,\n            num             = num,\n            glyph           = glyph,\n            offset          = offset\n            )\n        return result",
        "begin_line": 574,
        "end_line": 613,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts.get_xheight#615",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts.get_xheight(self, fontname, fontsize, dpi)",
        "snippet": "    def get_xheight(self, fontname, fontsize, dpi):\n        font = self._get_font(fontname)\n        font.set_size(fontsize, dpi)\n        pclt = font.get_sfnt_table('pclt')\n        if pclt is None:\n            # Some fonts don't store the xHeight, so we do a poor man's xHeight\n            metrics = self.get_metrics(\n                fontname, rcParams['mathtext.default'], 'x', fontsize, dpi)\n            return metrics.iceberg\n        xHeight = (pclt['xHeight'] / 64.0) * (fontsize / 12.0) * (dpi / 100.0)\n        return xHeight",
        "begin_line": 615,
        "end_line": 625,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts.get_underline_thickness#627",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts.get_underline_thickness(self, font, fontsize, dpi)",
        "snippet": "    def get_underline_thickness(self, font, fontsize, dpi):\n        # This function used to grab underline thickness from the font\n        # metrics, but that information is just too un-reliable, so it\n        # is now hardcoded.\n        return ((0.75 / 12.0) * fontsize * dpi) / 72.0",
        "begin_line": 627,
        "end_line": 631,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.TruetypeFonts.get_kern#633",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.TruetypeFonts",
        "signature": "lib.matplotlib.mathtext.TruetypeFonts.get_kern(self, font1, fontclass1, sym1, fontsize1, font2, fontclass2, sym2, fontsize2, dpi)",
        "snippet": "    def get_kern(self, font1, fontclass1, sym1, fontsize1,\n                 font2, fontclass2, sym2, fontsize2, dpi):\n        if font1 == font2 and fontsize1 == fontsize2:\n            info1 = self._get_info(font1, fontclass1, sym1, fontsize1, dpi)\n            info2 = self._get_info(font2, fontclass2, sym2, fontsize2, dpi)\n            font = info1.font\n            return font.get_kerning(info1.num, info2.num, KERNING_DEFAULT) / 64\n        return Fonts.get_kern(self, font1, fontclass1, sym1, fontsize1,\n                              font2, fontclass2, sym2, fontsize2, dpi)",
        "begin_line": 633,
        "end_line": 641,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.BakomaFonts.__init__#661",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.BakomaFonts",
        "signature": "lib.matplotlib.mathtext.BakomaFonts.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self._stix_fallback = StixFonts(*args, **kwargs)\n\n        TruetypeFonts.__init__(self, *args, **kwargs)\n        self.fontmap = {}\n        for key, val in self._fontmap.items():\n            fullpath = findfont(val)\n            self.fontmap[key] = fullpath\n            self.fontmap[val] = fullpath",
        "begin_line": 661,
        "end_line": 669,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.41399762752076e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.BakomaFonts._get_glyph#673",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.BakomaFonts",
        "signature": "lib.matplotlib.mathtext.BakomaFonts._get_glyph(self, fontname, font_class, sym, fontsize, math=True)",
        "snippet": "    def _get_glyph(self, fontname, font_class, sym, fontsize, math=True):\n        symbol_name = None\n        font = None\n        if fontname in self.fontmap and sym in latex_to_bakoma:\n            basename, num = latex_to_bakoma[sym]\n            slanted = (basename == \"cmmi10\") or sym in self._slanted_symbols\n            font = self._get_font(basename)\n        elif len(sym) == 1:\n            slanted = (fontname == \"it\")\n            font = self._get_font(fontname)\n            if font is not None:\n                num = ord(sym)\n\n        if font is not None:\n            gid = font.get_char_index(num)\n            if gid != 0:\n                symbol_name = font.get_glyph_name(gid)\n\n        if symbol_name is None:\n            return self._stix_fallback._get_glyph(\n                fontname, font_class, sym, fontsize, math)\n\n        return font, num, symbol_name, fontsize, slanted",
        "begin_line": 673,
        "end_line": 695,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.UnicodeFonts._get_glyph#813",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.UnicodeFonts",
        "signature": "lib.matplotlib.mathtext.UnicodeFonts._get_glyph(self, fontname, font_class, sym, fontsize, math=True)",
        "snippet": "    def _get_glyph(self, fontname, font_class, sym, fontsize, math=True):\n        found_symbol = False\n\n        if self.use_cmex:\n            uniindex = latex_to_cmex.get(sym)\n            if uniindex is not None:\n                fontname = 'ex'\n                found_symbol = True\n\n        if not found_symbol:\n            try:\n                uniindex = get_unicode_index(sym, math)\n                found_symbol = True\n            except ValueError:\n                uniindex = ord('?')\n                _log.warning(\n                    \"No TeX to unicode mapping for {!a}.\".format(sym))\n\n        fontname, uniindex = self._map_virtual_font(\n            fontname, font_class, uniindex)\n\n        new_fontname = fontname\n\n        # Only characters in the \"Letter\" class should be italicized in 'it'\n        # mode.  Greek capital letters should be Roman.\n        if found_symbol:\n            if fontname == 'it' and uniindex < 0x10000:\n                char = chr(uniindex)\n                if (unicodedata.category(char)[0] != \"L\"\n                        or unicodedata.name(char).startswith(\"GREEK CAPITAL\")):\n                    new_fontname = 'rm'\n\n            slanted = (new_fontname == 'it') or sym in self._slanted_symbols\n            found_symbol = False\n            font = self._get_font(new_fontname)\n            if font is not None:\n                glyphindex = font.get_char_index(uniindex)\n                if glyphindex != 0:\n                    found_symbol = True\n\n        if not found_symbol:\n            if self.cm_fallback:\n                if (fontname in ('it', 'regular')\n                        and isinstance(self.cm_fallback, StixFonts)):\n                    fontname = 'rm'\n\n                g = self.cm_fallback._get_glyph(fontname, font_class,\n                                                sym, fontsize)\n                fname = g[0].family_name\n                if fname in list(BakomaFonts._fontmap.values()):\n                    fname = \"Computer Modern\"\n                _log.warning(\"Substituting symbol {} \"\n                             \"from {}\".format(sym, fname))\n                return g\n\n            else:\n                if (fontname in ('it', 'regular')\n                        and isinstance(self, StixFonts)):\n                    return self._get_glyph('rm', font_class, sym, fontsize)\n                _log.warning(\"Font {!r} does not have a glyph for {!a} \"\n                             \"[U+{:x}], substituting with a dummy \"\n                             \"symbol.\".format(new_fontname, sym, uniindex))\n                fontname = 'rm'\n                font = self._get_font(fontname)\n                uniindex = 0xA4  # currency char, for lack of anything better\n                glyphindex = font.get_char_index(uniindex)\n                slanted = False\n\n        symbol_name = font.get_glyph_name(glyphindex)\n        return font, uniindex, symbol_name, fontsize, slanted",
        "begin_line": 813,
        "end_line": 882,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.UnicodeFonts.get_sized_alternatives_for_symbol#884",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.UnicodeFonts",
        "signature": "lib.matplotlib.mathtext.UnicodeFonts.get_sized_alternatives_for_symbol(self, fontname, sym)",
        "snippet": "    def get_sized_alternatives_for_symbol(self, fontname, sym):\n        if self.cm_fallback:\n            return self.cm_fallback.get_sized_alternatives_for_symbol(\n                fontname, sym)\n        return [(fontname, sym)]",
        "begin_line": 884,
        "end_line": 888,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.DejaVuFonts.__init__#894",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.DejaVuFonts",
        "signature": "lib.matplotlib.mathtext.DejaVuFonts.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        # This must come first so the backend's owner is set correctly\n        if isinstance(self, DejaVuSerifFonts):\n            self.cm_fallback = StixFonts(*args, **kwargs)\n        else:\n            self.cm_fallback = StixSansFonts(*args, **kwargs)\n        self.bakoma = BakomaFonts(*args, **kwargs)\n        TruetypeFonts.__init__(self, *args, **kwargs)\n        self.fontmap = {}\n        # Include Stix sized alternatives for glyphs\n        self._fontmap.update({\n            1: 'STIXSizeOneSym',\n            2: 'STIXSizeTwoSym',\n            3: 'STIXSizeThreeSym',\n            4: 'STIXSizeFourSym',\n            5: 'STIXSizeFiveSym',\n        })\n        for key, name in self._fontmap.items():\n            fullpath = findfont(name)\n            self.fontmap[key] = fullpath\n            self.fontmap[name] = fullpath",
        "begin_line": 894,
        "end_line": 914,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.DejaVuFonts._get_glyph#916",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.DejaVuFonts",
        "signature": "lib.matplotlib.mathtext.DejaVuFonts._get_glyph(self, fontname, font_class, sym, fontsize, math=True)",
        "snippet": "    def _get_glyph(self, fontname, font_class, sym, fontsize, math=True):\n        # Override prime symbol to use Bakoma.\n        if sym == r'\\prime':\n            return self.bakoma._get_glyph(\n                fontname, font_class, sym, fontsize, math)\n        else:\n            # check whether the glyph is available in the display font\n            uniindex = get_unicode_index(sym)\n            font = self._get_font('ex')\n            if font is not None:\n                glyphindex = font.get_char_index(uniindex)\n                if glyphindex != 0:\n                    return super()._get_glyph(\n                        'ex', font_class, sym, fontsize, math)\n            # otherwise return regular glyph\n            return super()._get_glyph(\n                fontname, font_class, sym, fontsize, math)",
        "begin_line": 916,
        "end_line": 932,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.StixFonts.__init__#999",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.StixFonts",
        "signature": "lib.matplotlib.mathtext.StixFonts.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        TruetypeFonts.__init__(self, *args, **kwargs)\n        self.fontmap = {}\n        for key, name in self._fontmap.items():\n            fullpath = findfont(name)\n            self.fontmap[key] = fullpath\n            self.fontmap[name] = fullpath",
        "begin_line": 999,
        "end_line": 1005,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.StixFonts._map_virtual_font#1007",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.StixFonts",
        "signature": "lib.matplotlib.mathtext.StixFonts._map_virtual_font(self, fontname, font_class, uniindex)",
        "snippet": "    def _map_virtual_font(self, fontname, font_class, uniindex):\n        # Handle these \"fonts\" that are actually embedded in\n        # other fonts.\n        mapping = stix_virtual_fonts.get(fontname)\n        if (self._sans and mapping is None\n                and fontname not in ('regular', 'default')):\n            mapping = stix_virtual_fonts['sf']\n            doing_sans_conversion = True\n        else:\n            doing_sans_conversion = False\n\n        if mapping is not None:\n            if isinstance(mapping, dict):\n                try:\n                    mapping = mapping[font_class]\n                except KeyError:\n                    mapping = mapping['rm']\n\n            # Binary search for the source glyph\n            lo = 0\n            hi = len(mapping)\n            while lo < hi:\n                mid = (lo+hi)//2\n                range = mapping[mid]\n                if uniindex < range[0]:\n                    hi = mid\n                elif uniindex <= range[1]:\n                    break\n                else:\n                    lo = mid + 1\n\n            if range[0] <= uniindex <= range[1]:\n                uniindex = uniindex - range[0] + range[3]\n                fontname = range[2]\n            elif not doing_sans_conversion:\n                # This will generate a dummy character\n                uniindex = 0x1\n                fontname = rcParams['mathtext.default']\n\n        # Handle private use area glyphs\n        if fontname in ('it', 'rm', 'bf') and 0xe000 <= uniindex <= 0xf8ff:\n            fontname = 'nonuni' + fontname\n\n        return fontname, uniindex",
        "begin_line": 1007,
        "end_line": 1050,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.StandardPsFonts.__init__#1100",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.StandardPsFonts",
        "signature": "lib.matplotlib.mathtext.StandardPsFonts.__init__(self, default_font_prop)",
        "snippet": "    def __init__(self, default_font_prop):\n        Fonts.__init__(self, default_font_prop, MathtextBackendPs())\n        self.glyphd = {}\n        self.fonts = {}\n\n        filename = findfont(default_font_prop, fontext='afm',\n                            directory=self.basepath)\n        if filename is None:\n            filename = findfont('Helvetica', fontext='afm',\n                                directory=self.basepath)\n        with open(filename, 'rb') as fd:\n            default_font = AFM(fd)\n        default_font.fname = filename\n\n        self.fonts['default'] = default_font\n        self.fonts['regular'] = default_font\n        self.pswriter = StringIO()",
        "begin_line": 1100,
        "end_line": 1116,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.StandardPsFonts._get_font#1118",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.StandardPsFonts",
        "signature": "lib.matplotlib.mathtext.StandardPsFonts._get_font(self, font)",
        "snippet": "    def _get_font(self, font):\n        if font in self.fontmap:\n            basename = self.fontmap[font]\n        else:\n            basename = font\n\n        cached_font = self.fonts.get(basename)\n        if cached_font is None:\n            fname = os.path.join(self.basepath, basename + \".afm\")\n            with open(fname, 'rb') as fd:\n                cached_font = AFM(fd)\n            cached_font.fname = fname\n            self.fonts[basename] = cached_font\n            self.fonts[cached_font.get_fontname()] = cached_font\n        return cached_font",
        "begin_line": 1118,
        "end_line": 1132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.StandardPsFonts._get_info#1134",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.StandardPsFonts",
        "signature": "lib.matplotlib.mathtext.StandardPsFonts._get_info(self, fontname, font_class, sym, fontsize, dpi, math=True)",
        "snippet": "    def _get_info(self, fontname, font_class, sym, fontsize, dpi, math=True):\n        \"\"\"Load the cmfont, metrics and glyph with caching.\"\"\"\n        key = fontname, sym, fontsize, dpi\n        tup = self.glyphd.get(key)\n\n        if tup is not None:\n            return tup\n\n        # Only characters in the \"Letter\" class should really be italicized.\n        # This class includes greek letters, so we're ok\n        if (fontname == 'it' and\n                (len(sym) > 1\n                 or not unicodedata.category(sym).startswith(\"L\"))):\n            fontname = 'rm'\n\n        found_symbol = False\n\n        if sym in latex_to_standard:\n            fontname, num = latex_to_standard[sym]\n            glyph = chr(num)\n            found_symbol = True\n        elif len(sym) == 1:\n            glyph = sym\n            num = ord(glyph)\n            found_symbol = True\n        else:\n            _log.warning(\n                \"No TeX to built-in Postscript mapping for {!r}\".format(sym))\n\n        slanted = (fontname == 'it')\n        font = self._get_font(fontname)\n\n        if found_symbol:\n            try:\n                symbol_name = font.get_name_char(glyph)\n            except KeyError:\n                _log.warning(\n                    \"No glyph in standard Postscript font {!r} for {!r}\"\n                    .format(font.get_fontname(), sym))\n                found_symbol = False\n\n        if not found_symbol:\n            glyph = '?'\n            num = ord(glyph)\n            symbol_name = font.get_name_char(glyph)\n\n        offset = 0\n\n        scale = 0.001 * fontsize\n\n        xmin, ymin, xmax, ymax = [val * scale\n                                  for val in font.get_bbox_char(glyph)]\n        metrics = types.SimpleNamespace(\n            advance  = font.get_width_char(glyph) * scale,\n            width    = font.get_width_char(glyph) * scale,\n            height   = font.get_height_char(glyph) * scale,\n            xmin = xmin,\n            xmax = xmax,\n            ymin = ymin+offset,\n            ymax = ymax+offset,\n            # iceberg is the equivalent of TeX's \"height\"\n            iceberg = ymax + offset,\n            slanted = slanted\n            )\n\n        self.glyphd[key] = types.SimpleNamespace(\n            font            = font,\n            fontsize        = fontsize,\n            postscript_name = font.get_fontname(),\n            metrics         = metrics,\n            symbol_name     = symbol_name,\n            num             = num,\n            glyph           = glyph,\n            offset          = offset\n            )\n\n        return self.glyphd[key]",
        "begin_line": 1134,
        "end_line": 1210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.StandardPsFonts.get_xheight#1223",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.StandardPsFonts",
        "signature": "lib.matplotlib.mathtext.StandardPsFonts.get_xheight(self, font, fontsize, dpi)",
        "snippet": "    def get_xheight(self, font, fontsize, dpi):\n        font = self._get_font(font)\n        return font.get_xheight() * 0.001 * fontsize",
        "begin_line": 1223,
        "end_line": 1225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext._get_font_constant_set#1361",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext",
        "signature": "lib.matplotlib.mathtext._get_font_constant_set(state)",
        "snippet": "def _get_font_constant_set(state):\n    constants = _font_constant_mapping.get(\n        state.font_output._get_font(state.font).family_name,\n        FontConstantsBase)\n    # STIX sans isn't really its own fonts, just different code points\n    # in the STIX fonts, so we have to detect this one separately.\n    if (constants is STIXFontConstants and\n            isinstance(state.font_output, StixSansFonts)):\n        return STIXSansFontConstants\n    return constants",
        "begin_line": 1361,
        "end_line": 1370,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Node.__init__#1380",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Node",
        "signature": "lib.matplotlib.mathtext.Node.__init__(self)",
        "snippet": "    def __init__(self):\n        self.size = 0",
        "begin_line": 1380,
        "end_line": 1381,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.86679822397632e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Node.get_kerning#1386",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Node",
        "signature": "lib.matplotlib.mathtext.Node.get_kerning(self, next)",
        "snippet": "    def get_kerning(self, next):\n        return 0.0",
        "begin_line": 1386,
        "end_line": 1387,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Node.shrink#1389",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Node",
        "signature": "lib.matplotlib.mathtext.Node.shrink(self)",
        "snippet": "    def shrink(self):\n        \"\"\"\n        Shrinks one level smaller.  There are only three levels of\n        sizes, after which things will no longer get smaller.\n        \"\"\"\n        self.size += 1",
        "begin_line": 1389,
        "end_line": 1394,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Box.__init__#1410",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Box",
        "signature": "lib.matplotlib.mathtext.Box.__init__(self, width, height, depth)",
        "snippet": "    def __init__(self, width, height, depth):\n        Node.__init__(self)\n        self.width  = width\n        self.height = height\n        self.depth  = depth",
        "begin_line": 1410,
        "end_line": 1414,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Box.shrink#1416",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Box",
        "signature": "lib.matplotlib.mathtext.Box.shrink(self)",
        "snippet": "    def shrink(self):\n        Node.shrink(self)\n        if self.size < NUM_SIZE_LEVELS:\n            self.width  *= SHRINK_FACTOR\n            self.height *= SHRINK_FACTOR\n            self.depth  *= SHRINK_FACTOR",
        "begin_line": 1416,
        "end_line": 1421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Box.render#1429",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Box",
        "signature": "lib.matplotlib.mathtext.Box.render(self, x1, y1, x2, y2)",
        "snippet": "    def render(self, x1, y1, x2, y2):\n        pass",
        "begin_line": 1429,
        "end_line": 1430,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Vbox.__init__#1436",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Vbox",
        "signature": "lib.matplotlib.mathtext.Vbox.__init__(self, height, depth)",
        "snippet": "    def __init__(self, height, depth):\n        Box.__init__(self, 0., height, depth)",
        "begin_line": 1436,
        "end_line": 1437,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Hbox.__init__#1443",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Hbox",
        "signature": "lib.matplotlib.mathtext.Hbox.__init__(self, width)",
        "snippet": "    def __init__(self, width):\n        Box.__init__(self, width, 0., 0.)",
        "begin_line": 1443,
        "end_line": 1444,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Char.__init__#1460",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Char",
        "signature": "lib.matplotlib.mathtext.Char.__init__(self, c, state, math=True)",
        "snippet": "    def __init__(self, c, state, math=True):\n        Node.__init__(self)\n        self.c = c\n        self.font_output = state.font_output\n        self.font = state.font\n        self.font_class = state.font_class\n        self.fontsize = state.fontsize\n        self.dpi = state.dpi\n        self.math = math\n        # The real width, height and depth will be set during the\n        # pack phase, after we know the real fontsize\n        self._update_metrics()",
        "begin_line": 1460,
        "end_line": 1471,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.714396735962697e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Char._update_metrics#1476",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Char",
        "signature": "lib.matplotlib.mathtext.Char._update_metrics(self)",
        "snippet": "    def _update_metrics(self):\n        metrics = self._metrics = self.font_output.get_metrics(\n            self.font, self.font_class, self.c, self.fontsize, self.dpi,\n            self.math)\n        if self.c == ' ':\n            self.width = metrics.advance\n        else:\n            self.width = metrics.width\n        self.height = metrics.iceberg\n        self.depth = -(metrics.iceberg - metrics.height)",
        "begin_line": 1476,
        "end_line": 1485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Char.is_slanted#1487",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Char",
        "signature": "lib.matplotlib.mathtext.Char.is_slanted(self)",
        "snippet": "    def is_slanted(self):\n        return self._metrics.slanted",
        "begin_line": 1487,
        "end_line": 1488,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Char.get_kerning#1490",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Char",
        "signature": "lib.matplotlib.mathtext.Char.get_kerning(self, next)",
        "snippet": "    def get_kerning(self, next):\n        \"\"\"\n        Return the amount of kerning between this and the given character.\n\n        This method is called when characters are strung together into `Hlist`\n        to create `Kern` nodes.\n        \"\"\"\n        advance = self._metrics.advance - self.width\n        kern = 0.\n        if isinstance(next, Char):\n            kern = self.font_output.get_kern(\n                self.font, self.font_class, self.c, self.fontsize,\n                next.font, next.font_class, next.c, next.fontsize,\n                self.dpi)\n        return advance + kern",
        "begin_line": 1490,
        "end_line": 1504,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Char.render#1506",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Char",
        "signature": "lib.matplotlib.mathtext.Char.render(self, x, y)",
        "snippet": "    def render(self, x, y):\n        \"\"\"\n        Render the character to the canvas\n        \"\"\"\n        self.font_output.render_glyph(\n            x, y,\n            self.font, self.font_class, self.c, self.fontsize, self.dpi)",
        "begin_line": 1506,
        "end_line": 1512,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.86679822397632e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Char.shrink#1514",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Char",
        "signature": "lib.matplotlib.mathtext.Char.shrink(self)",
        "snippet": "    def shrink(self):\n        Node.shrink(self)\n        if self.size < NUM_SIZE_LEVELS:\n            self.fontsize *= SHRINK_FACTOR\n            self.width    *= SHRINK_FACTOR\n            self.height   *= SHRINK_FACTOR\n            self.depth    *= SHRINK_FACTOR",
        "begin_line": 1514,
        "end_line": 1520,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Accent._update_metrics#1536",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Accent",
        "signature": "lib.matplotlib.mathtext.Accent._update_metrics(self)",
        "snippet": "    def _update_metrics(self):\n        metrics = self._metrics = self.font_output.get_metrics(\n            self.font, self.font_class, self.c, self.fontsize, self.dpi)\n        self.width = metrics.xmax - metrics.xmin\n        self.height = metrics.ymax - metrics.ymin\n        self.depth = 0",
        "begin_line": 1536,
        "end_line": 1541,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.340283569641368e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Accent.render#1551",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Accent",
        "signature": "lib.matplotlib.mathtext.Accent.render(self, x, y)",
        "snippet": "    def render(self, x, y):\n        \"\"\"\n        Render the character to the canvas.\n        \"\"\"\n        self.font_output.render_glyph(\n            x - self._metrics.xmin, y + self._metrics.ymin,\n            self.font, self.font_class, self.c, self.fontsize, self.dpi)",
        "begin_line": 1551,
        "end_line": 1557,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.340283569641368e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.List.__init__#1563",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.List",
        "signature": "lib.matplotlib.mathtext.List.__init__(self, elements)",
        "snippet": "    def __init__(self, elements):\n        Box.__init__(self, 0., 0., 0.)\n        self.shift_amount = 0.   # An arbitrary offset\n        self.children     = elements  # The child nodes of this list\n        # The following parameters are set in the vpack and hpack functions\n        self.glue_set     = 0.   # The glue setting of this list\n        self.glue_sign    = 0    # 0: normal, -1: shrinking, 1: stretching\n        self.glue_order   = 0    # The order of infinity (0 - 3) for the glue",
        "begin_line": 1563,
        "end_line": 1570,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.List._determine_order#1580",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.List",
        "signature": "lib.matplotlib.mathtext.List._determine_order(totals)",
        "snippet": "    def _determine_order(totals):\n        \"\"\"\n        Determine the highest order of glue used by the members of this list.\n\n        Helper function used by vpack and hpack.\n        \"\"\"\n        for i in range(len(totals))[::-1]:\n            if totals[i] != 0:\n                return i\n        return 0",
        "begin_line": 1580,
        "end_line": 1589,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.530687551773477e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.List.shrink#1605",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.List",
        "signature": "lib.matplotlib.mathtext.List.shrink(self)",
        "snippet": "    def shrink(self):\n        for child in self.children:\n            child.shrink()\n        Box.shrink(self)\n        if self.size < NUM_SIZE_LEVELS:\n            self.shift_amount *= SHRINK_FACTOR\n            self.glue_set     *= SHRINK_FACTOR",
        "begin_line": 1605,
        "end_line": 1611,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Hlist.__init__#1624",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Hlist",
        "signature": "lib.matplotlib.mathtext.Hlist.__init__(self, elements, w=0.0, m='additional', do_kern=True)",
        "snippet": "    def __init__(self, elements, w=0., m='additional', do_kern=True):\n        List.__init__(self, elements)\n        if do_kern:\n            self.kern()\n        self.hpack()",
        "begin_line": 1624,
        "end_line": 1628,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Hlist.kern#1630",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Hlist",
        "signature": "lib.matplotlib.mathtext.Hlist.kern(self)",
        "snippet": "    def kern(self):\n        \"\"\"\n        Insert `Kern` nodes between `Char` nodes to set kerning.\n\n        The `Char` nodes themselves determine the amount of kerning they need\n        (in `~Char.get_kerning`), and this function just creates the correct\n        linked list.\n        \"\"\"\n        new_children = []\n        num_children = len(self.children)\n        if num_children:\n            for i in range(num_children):\n                elem = self.children[i]\n                if i < num_children - 1:\n                    next = self.children[i + 1]\n                else:\n                    next = None\n\n                new_children.append(elem)\n                kerning_distance = elem.get_kerning(next)\n                if kerning_distance != 0.:\n                    kern = Kern(kerning_distance)\n                    new_children.append(kern)\n            self.children = new_children",
        "begin_line": 1630,
        "end_line": 1653,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Hlist.hpack#1669",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Hlist",
        "signature": "lib.matplotlib.mathtext.Hlist.hpack(self, w=0.0, m='additional')",
        "snippet": "    def hpack(self, w=0., m='additional'):\n        r\"\"\"\n        Compute the dimensions of the resulting boxes, and adjust the glue if\n        one of those dimensions is pre-specified.  The computed sizes normally\n        enclose all of the material inside the new box; but some items may\n        stick out if negative glue is used, if the box is overfull, or if a\n        ``\\vbox`` includes other boxes that have been shifted left.\n\n        Parameters\n        ----------\n        w : float, default: 0\n            A width.\n        m : {'exactly', 'additional'}, default: 'additional'\n            Whether to produce a box whose width is 'exactly' *w*; or a box\n            with the natural width of the contents, plus *w* ('additional').\n\n        Notes\n        -----\n        The defaults produce a box with the natural width of the contents.\n        \"\"\"\n        # I don't know why these get reset in TeX.  Shift_amount is pretty\n        # much useless if we do.\n        # self.shift_amount = 0.\n        h = 0.\n        d = 0.\n        x = 0.\n        total_stretch = [0.] * 4\n        total_shrink = [0.] * 4\n        for p in self.children:\n            if isinstance(p, Char):\n                x += p.width\n                h = max(h, p.height)\n                d = max(d, p.depth)\n            elif isinstance(p, Box):\n                x += p.width\n                if not np.isinf(p.height) and not np.isinf(p.depth):\n                    s = getattr(p, 'shift_amount', 0.)\n                    h = max(h, p.height - s)\n                    d = max(d, p.depth + s)\n            elif isinstance(p, Glue):\n                glue_spec = p.glue_spec\n                x += glue_spec.width\n                total_stretch[glue_spec.stretch_order] += glue_spec.stretch\n                total_shrink[glue_spec.shrink_order] += glue_spec.shrink\n            elif isinstance(p, Kern):\n                x += p.width\n        self.height = h\n        self.depth = d\n\n        if m == 'additional':\n            w += x\n        self.width = w\n        x = w - x\n\n        if x == 0.:\n            self.glue_sign = 0\n            self.glue_order = 0\n            self.glue_ratio = 0.\n            return\n        if x > 0.:\n            self._set_glue(x, 1, total_stretch, \"Overfull\")\n        else:\n            self._set_glue(x, -1, total_shrink, \"Underfull\")",
        "begin_line": 1669,
        "end_line": 1731,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Vlist.__init__#1737",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Vlist",
        "signature": "lib.matplotlib.mathtext.Vlist.__init__(self, elements, h=0.0, m='additional')",
        "snippet": "    def __init__(self, elements, h=0., m='additional'):\n        List.__init__(self, elements)\n        self.vpack()",
        "begin_line": 1737,
        "end_line": 1739,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Vlist.vpack#1741",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Vlist",
        "signature": "lib.matplotlib.mathtext.Vlist.vpack(self, h=0.0, m='additional', l=np.inf)",
        "snippet": "    def vpack(self, h=0., m='additional', l=np.inf):\n        \"\"\"\n        Compute the dimensions of the resulting boxes, and to adjust the glue\n        if one of those dimensions is pre-specified.\n\n        Parameters\n        ----------\n        h : float, default: 0\n            A height.\n        m : {'exactly', 'additional'}, default: 'additional'\n            Whether to produce a box whose height is 'exactly' *w*; or a box\n            with the natural height of the contents, plus *w* ('additional').\n        l : float, default: np.inf\n            The maximum height.\n\n        Notes\n        -----\n        The defaults produce a box with the natural height of the contents.\n        \"\"\"\n        # I don't know why these get reset in TeX.  Shift_amount is pretty\n        # much useless if we do.\n        # self.shift_amount = 0.\n        w = 0.\n        d = 0.\n        x = 0.\n        total_stretch = [0.] * 4\n        total_shrink = [0.] * 4\n        for p in self.children:\n            if isinstance(p, Box):\n                x += d + p.height\n                d = p.depth\n                if not np.isinf(p.width):\n                    s = getattr(p, 'shift_amount', 0.)\n                    w = max(w, p.width + s)\n            elif isinstance(p, Glue):\n                x += d\n                d = 0.\n                glue_spec = p.glue_spec\n                x += glue_spec.width\n                total_stretch[glue_spec.stretch_order] += glue_spec.stretch\n                total_shrink[glue_spec.shrink_order] += glue_spec.shrink\n            elif isinstance(p, Kern):\n                x += d + p.width\n                d = 0.\n            elif isinstance(p, Char):\n                raise RuntimeError(\n                    \"Internal mathtext error: Char node found in Vlist\")\n\n        self.width = w\n        if d > l:\n            x += d - l\n            self.depth = l\n        else:\n            self.depth = d\n\n        if m == 'additional':\n            h += x\n        self.height = h\n        x = h - x\n\n        if x == 0:\n            self.glue_sign = 0\n            self.glue_order = 0\n            self.glue_ratio = 0.\n            return\n\n        if x > 0.:\n            self._set_glue(x, 1, total_stretch, \"Overfull\")\n        else:\n            self._set_glue(x, -1, total_shrink, \"Underfull\")",
        "begin_line": 1741,
        "end_line": 1810,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Rule.__init__#1824",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Rule",
        "signature": "lib.matplotlib.mathtext.Rule.__init__(self, width, height, depth, state)",
        "snippet": "    def __init__(self, width, height, depth, state):\n        Box.__init__(self, width, height, depth)\n        self.font_output = state.font_output",
        "begin_line": 1824,
        "end_line": 1826,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Rule.render#1828",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Rule",
        "signature": "lib.matplotlib.mathtext.Rule.render(self, x, y, w, h)",
        "snippet": "    def render(self, x, y, w, h):\n        self.font_output.render_rect_filled(x, y, x + w, y + h)",
        "begin_line": 1828,
        "end_line": 1829,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Glue.__init__#1880",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Glue",
        "signature": "lib.matplotlib.mathtext.Glue.__init__(self, glue_type, copy=False)",
        "snippet": "    def __init__(self, glue_type, copy=False):\n        Node.__init__(self)\n        if isinstance(glue_type, str):\n            glue_spec = _GlueSpec._named[glue_type]\n        elif isinstance(glue_type, _GlueSpec):\n            glue_spec = glue_type\n        else:\n            raise ValueError(\"glue_type must be a glue spec name or instance\")\n        self.glue_spec = glue_spec",
        "begin_line": 1880,
        "end_line": 1888,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.530687551773477e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Glue.shrink#1890",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Glue",
        "signature": "lib.matplotlib.mathtext.Glue.shrink(self)",
        "snippet": "    def shrink(self):\n        Node.shrink(self)\n        if self.size < NUM_SIZE_LEVELS:\n            g = self.glue_spec\n            self.glue_spec = g._replace(width=g.width * SHRINK_FACTOR)",
        "begin_line": 1890,
        "end_line": 1894,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Fill.__init__#1941",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Fill",
        "signature": "lib.matplotlib.mathtext.Fill.__init__(self)",
        "snippet": "    def __init__(self):\n        Glue.__init__(self, 'fill')",
        "begin_line": 1941,
        "end_line": 1942,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.SsGlue.__init__#1966",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.SsGlue",
        "signature": "lib.matplotlib.mathtext.SsGlue.__init__(self)",
        "snippet": "    def __init__(self):\n        Glue.__init__(self, 'ss')",
        "begin_line": 1966,
        "end_line": 1967,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.547739452034116e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.HCentered.__init__#1976",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.HCentered",
        "signature": "lib.matplotlib.mathtext.HCentered.__init__(self, elements)",
        "snippet": "    def __init__(self, elements):\n        Hlist.__init__(self, [SsGlue()] + elements + [SsGlue()],\n                       do_kern=False)",
        "begin_line": 1976,
        "end_line": 1978,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Kern.__init__#2005",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Kern",
        "signature": "lib.matplotlib.mathtext.Kern.__init__(self, width)",
        "snippet": "    def __init__(self, width):\n        Node.__init__(self)\n        self.width = width",
        "begin_line": 2005,
        "end_line": 2007,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Kern.shrink#2012",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Kern",
        "signature": "lib.matplotlib.mathtext.Kern.shrink(self)",
        "snippet": "    def shrink(self):\n        Node.shrink(self)\n        if self.size < NUM_SIZE_LEVELS:\n            self.width *= SHRINK_FACTOR",
        "begin_line": 2012,
        "end_line": 2015,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.AutoHeightChar.__init__#2046",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.AutoHeightChar",
        "signature": "lib.matplotlib.mathtext.AutoHeightChar.__init__(self, c, height, depth, state, always=False, factor=None)",
        "snippet": "    def __init__(self, c, height, depth, state, always=False, factor=None):\n        alternatives = state.font_output.get_sized_alternatives_for_symbol(\n            state.font, c)\n\n        xHeight = state.font_output.get_xheight(\n            state.font, state.fontsize, state.dpi)\n\n        state = state.copy()\n        target_total = height + depth\n        for fontname, sym in alternatives:\n            state.font = fontname\n            char = Char(sym, state)\n            # Ensure that size 0 is chosen when the text is regular sized but\n            # with descender glyphs by subtracting 0.2 * xHeight\n            if char.height + char.depth >= target_total - 0.2 * xHeight:\n                break\n\n        shift = 0\n        if state.font != 0:\n            if factor is None:\n                factor = target_total / (char.height + char.depth)\n            state.fontsize *= factor\n            char = Char(sym, state)\n\n            shift = (depth - char.depth)\n\n        Hlist.__init__(self, [char])\n        self.shift_amount = shift",
        "begin_line": 2046,
        "end_line": 2073,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.AutoWidthChar.__init__#2085",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.AutoWidthChar",
        "signature": "lib.matplotlib.mathtext.AutoWidthChar.__init__(self, c, width, state, always=False, char_class=Char)",
        "snippet": "    def __init__(self, c, width, state, always=False, char_class=Char):\n        alternatives = state.font_output.get_sized_alternatives_for_symbol(\n            state.font, c)\n\n        state = state.copy()\n        for fontname, sym in alternatives:\n            state.font = fontname\n            char = char_class(sym, state)\n            if char.width >= width:\n                break\n\n        factor = width / char.width\n        state.fontsize *= factor\n        char = char_class(sym, state)\n\n        Hlist.__init__(self, [char])\n        self.width = char.width",
        "begin_line": 2085,
        "end_line": 2101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Ship.__call__#2115",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Ship",
        "signature": "lib.matplotlib.mathtext.Ship.__call__(self, ox, oy, box)",
        "snippet": "    def __call__(self, ox, oy, box):\n        self.max_push    = 0  # Deepest nesting of push commands so far\n        self.cur_s       = 0\n        self.cur_v       = 0.\n        self.cur_h       = 0.\n        self.off_h       = ox\n        self.off_v       = oy + box.height\n        self.hlist_out(box)",
        "begin_line": 2115,
        "end_line": 2122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Ship.hlist_out#2132",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Ship",
        "signature": "lib.matplotlib.mathtext.Ship.hlist_out(self, box)",
        "snippet": "    def hlist_out(self, box):\n        cur_g         = 0\n        cur_glue      = 0.\n        glue_order    = box.glue_order\n        glue_sign     = box.glue_sign\n        base_line     = self.cur_v\n        left_edge     = self.cur_h\n        self.cur_s    += 1\n        self.max_push = max(self.cur_s, self.max_push)\n        clamp         = self.clamp\n\n        for p in box.children:\n            if isinstance(p, Char):\n                p.render(self.cur_h + self.off_h, self.cur_v + self.off_v)\n                self.cur_h += p.width\n            elif isinstance(p, Kern):\n                self.cur_h += p.width\n            elif isinstance(p, List):\n                # node623\n                if len(p.children) == 0:\n                    self.cur_h += p.width\n                else:\n                    edge = self.cur_h\n                    self.cur_v = base_line + p.shift_amount\n                    if isinstance(p, Hlist):\n                        self.hlist_out(p)\n                    else:\n                        # p.vpack(box.height + box.depth, 'exactly')\n                        self.vlist_out(p)\n                    self.cur_h = edge + p.width\n                    self.cur_v = base_line\n            elif isinstance(p, Box):\n                # node624\n                rule_height = p.height\n                rule_depth  = p.depth\n                rule_width  = p.width\n                if np.isinf(rule_height):\n                    rule_height = box.height\n                if np.isinf(rule_depth):\n                    rule_depth = box.depth\n                if rule_height > 0 and rule_width > 0:\n                    self.cur_v = base_line + rule_depth\n                    p.render(self.cur_h + self.off_h,\n                             self.cur_v + self.off_v,\n                             rule_width, rule_height)\n                    self.cur_v = base_line\n                self.cur_h += rule_width\n            elif isinstance(p, Glue):\n                # node625\n                glue_spec = p.glue_spec\n                rule_width = glue_spec.width - cur_g\n                if glue_sign != 0:  # normal\n                    if glue_sign == 1:  # stretching\n                        if glue_spec.stretch_order == glue_order:\n                            cur_glue += glue_spec.stretch\n                            cur_g = round(clamp(box.glue_set * cur_glue))\n                    elif glue_spec.shrink_order == glue_order:\n                        cur_glue += glue_spec.shrink\n                        cur_g = round(clamp(box.glue_set * cur_glue))\n                rule_width += cur_g\n                self.cur_h += rule_width\n        self.cur_s -= 1",
        "begin_line": 2132,
        "end_line": 2193,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Ship.vlist_out#2195",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Ship",
        "signature": "lib.matplotlib.mathtext.Ship.vlist_out(self, box)",
        "snippet": "    def vlist_out(self, box):\n        cur_g         = 0\n        cur_glue      = 0.\n        glue_order    = box.glue_order\n        glue_sign     = box.glue_sign\n        self.cur_s    += 1\n        self.max_push = max(self.max_push, self.cur_s)\n        left_edge     = self.cur_h\n        self.cur_v    -= box.height\n        top_edge      = self.cur_v\n        clamp         = self.clamp\n\n        for p in box.children:\n            if isinstance(p, Kern):\n                self.cur_v += p.width\n            elif isinstance(p, List):\n                if len(p.children) == 0:\n                    self.cur_v += p.height + p.depth\n                else:\n                    self.cur_v += p.height\n                    self.cur_h = left_edge + p.shift_amount\n                    save_v = self.cur_v\n                    p.width = box.width\n                    if isinstance(p, Hlist):\n                        self.hlist_out(p)\n                    else:\n                        self.vlist_out(p)\n                    self.cur_v = save_v + p.depth\n                    self.cur_h = left_edge\n            elif isinstance(p, Box):\n                rule_height = p.height\n                rule_depth = p.depth\n                rule_width = p.width\n                if np.isinf(rule_width):\n                    rule_width = box.width\n                rule_height += rule_depth\n                if rule_height > 0 and rule_depth > 0:\n                    self.cur_v += rule_height\n                    p.render(self.cur_h + self.off_h,\n                             self.cur_v + self.off_v,\n                             rule_width, rule_height)\n            elif isinstance(p, Glue):\n                glue_spec = p.glue_spec\n                rule_height = glue_spec.width - cur_g\n                if glue_sign != 0:  # normal\n                    if glue_sign == 1:  # stretching\n                        if glue_spec.stretch_order == glue_order:\n                            cur_glue += glue_spec.stretch\n                            cur_g = round(clamp(box.glue_set * cur_glue))\n                    elif glue_spec.shrink_order == glue_order:  # shrinking\n                        cur_glue += glue_spec.shrink\n                        cur_g = round(clamp(box.glue_set * cur_glue))\n                rule_height += cur_g\n                self.cur_v += rule_height\n            elif isinstance(p, Char):\n                raise RuntimeError(\n                    \"Internal mathtext error: Char node found in vlist\")\n        self.cur_s -= 1",
        "begin_line": 2195,
        "end_line": 2252,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Error#2262",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext",
        "signature": "lib.matplotlib.mathtext.Error(msg)",
        "snippet": "def Error(msg):\n    \"\"\"Helper class to raise parser errors.\"\"\"\n    def raise_error(s, loc, toks):\n        raise ParseFatalException(s, loc, msg)\n\n    empty = Empty()\n    empty.setParseAction(raise_error)\n    return empty",
        "begin_line": 2262,
        "end_line": 2269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.raise_error#2264",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext",
        "signature": "lib.matplotlib.mathtext.raise_error(s, loc, toks)",
        "snippet": "    def raise_error(s, loc, toks):\n        raise ParseFatalException(s, loc, msg)",
        "begin_line": 2264,
        "end_line": 2265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.__init__#2354",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.__init__(self)",
        "snippet": "    def __init__(self):\n        p = types.SimpleNamespace()\n        # All forward declarations are here\n        p.accent           = Forward()\n        p.ambi_delim       = Forward()\n        p.apostrophe       = Forward()\n        p.auto_delim       = Forward()\n        p.binom            = Forward()\n        p.bslash           = Forward()\n        p.c_over_c         = Forward()\n        p.customspace      = Forward()\n        p.end_group        = Forward()\n        p.float_literal    = Forward()\n        p.font             = Forward()\n        p.frac             = Forward()\n        p.dfrac            = Forward()\n        p.function         = Forward()\n        p.genfrac          = Forward()\n        p.group            = Forward()\n        p.int_literal      = Forward()\n        p.latexfont        = Forward()\n        p.lbracket         = Forward()\n        p.left_delim       = Forward()\n        p.lbrace           = Forward()\n        p.main             = Forward()\n        p.math             = Forward()\n        p.math_string      = Forward()\n        p.non_math         = Forward()\n        p.operatorname     = Forward()\n        p.overline         = Forward()\n        p.placeable        = Forward()\n        p.rbrace           = Forward()\n        p.rbracket         = Forward()\n        p.required_group   = Forward()\n        p.right_delim      = Forward()\n        p.right_delim_safe = Forward()\n        p.simple           = Forward()\n        p.simple_group     = Forward()\n        p.single_symbol    = Forward()\n        p.accentprefixed   = Forward()\n        p.space            = Forward()\n        p.sqrt             = Forward()\n        p.stackrel         = Forward()\n        p.start_group      = Forward()\n        p.subsuper         = Forward()\n        p.subsuperop       = Forward()\n        p.symbol           = Forward()\n        p.symbol_name      = Forward()\n        p.token            = Forward()\n        p.unknown_symbol   = Forward()\n\n        # Set names on everything -- very useful for debugging\n        for key, val in vars(p).items():\n            if not key.startswith('_'):\n                val.setName(key)\n\n        p.float_literal <<= Regex(r\"[-+]?([0-9]+\\.?[0-9]*|\\.[0-9]+)\")\n        p.int_literal   <<= Regex(\"[-+]?[0-9]+\")\n\n        p.lbrace        <<= Literal('{').suppress()\n        p.rbrace        <<= Literal('}').suppress()\n        p.lbracket      <<= Literal('[').suppress()\n        p.rbracket      <<= Literal(']').suppress()\n        p.bslash        <<= Literal('\\\\')\n\n        p.space         <<= oneOf(list(self._space_widths))\n        p.customspace   <<= (\n            Suppress(Literal(r'\\hspace'))\n            - ((p.lbrace + p.float_literal + p.rbrace)\n               | Error(r\"Expected \\hspace{n}\"))\n        )\n\n        unicode_range = \"\\U00000080-\\U0001ffff\"\n        p.single_symbol <<= Regex(\n            r\"([a-zA-Z0-9 +\\-*/<>=:,.;!\\?&'@()\\[\\]|%s])|(\\\\[%%${}\\[\\]_|])\" %\n            unicode_range)\n        p.accentprefixed <<= Suppress(p.bslash) + oneOf(self._accentprefixed)\n        p.symbol_name   <<= (\n            Combine(p.bslash + oneOf(list(tex2uni)))\n            + FollowedBy(Regex(\"[^A-Za-z]\").leaveWhitespace() | StringEnd())\n        )\n        p.symbol        <<= (p.single_symbol | p.symbol_name).leaveWhitespace()\n\n        p.apostrophe    <<= Regex(\"'+\")\n\n        p.c_over_c      <<= (\n            Suppress(p.bslash)\n            + oneOf(list(self._char_over_chars))\n        )\n\n        p.accent        <<= Group(\n            Suppress(p.bslash)\n            + oneOf([*self._accent_map, *self._wide_accents])\n            - p.placeable\n        )\n\n        p.function      <<= (\n            Suppress(p.bslash)\n            + oneOf(list(self._function_names))\n        )\n\n        p.start_group    <<= Optional(p.latexfont) + p.lbrace\n        p.end_group      <<= p.rbrace.copy()\n        p.simple_group   <<= Group(p.lbrace + ZeroOrMore(p.token) + p.rbrace)\n        p.required_group <<= Group(p.lbrace + OneOrMore(p.token) + p.rbrace)\n        p.group          <<= Group(\n            p.start_group + ZeroOrMore(p.token) + p.end_group\n        )\n\n        p.font          <<= Suppress(p.bslash) + oneOf(list(self._fontnames))\n        p.latexfont     <<= (\n            Suppress(p.bslash)\n            + oneOf(['math' + x for x in self._fontnames])\n        )\n\n        p.frac          <<= Group(\n            Suppress(Literal(r\"\\frac\"))\n            - ((p.required_group + p.required_group)\n               | Error(r\"Expected \\frac{num}{den}\"))\n        )\n\n        p.dfrac         <<= Group(\n            Suppress(Literal(r\"\\dfrac\"))\n            - ((p.required_group + p.required_group)\n               | Error(r\"Expected \\dfrac{num}{den}\"))\n        )\n\n        p.stackrel      <<= Group(\n            Suppress(Literal(r\"\\stackrel\"))\n            - ((p.required_group + p.required_group)\n               | Error(r\"Expected \\stackrel{num}{den}\"))\n        )\n\n        p.binom         <<= Group(\n            Suppress(Literal(r\"\\binom\"))\n            - ((p.required_group + p.required_group)\n               | Error(r\"Expected \\binom{num}{den}\"))\n        )\n\n        p.ambi_delim    <<= oneOf(list(self._ambi_delim))\n        p.left_delim    <<= oneOf(list(self._left_delim))\n        p.right_delim   <<= oneOf(list(self._right_delim))\n        p.right_delim_safe <<= oneOf([*(self._right_delim - {'}'}), r'\\}'])\n\n        p.genfrac <<= Group(\n            Suppress(Literal(r\"\\genfrac\"))\n            - (((p.lbrace\n                 + Optional(p.ambi_delim | p.left_delim, default='')\n                 + p.rbrace)\n                + (p.lbrace\n                   + Optional(p.ambi_delim | p.right_delim_safe, default='')\n                   + p.rbrace)\n                + (p.lbrace + p.float_literal + p.rbrace)\n                + p.simple_group + p.required_group + p.required_group)\n               | Error(\"Expected \"\n                       r\"\\genfrac{ldelim}{rdelim}{rulesize}{style}{num}{den}\"))\n        )\n\n        p.sqrt <<= Group(\n            Suppress(Literal(r\"\\sqrt\"))\n            - ((Optional(p.lbracket + p.int_literal + p.rbracket, default=None)\n                + p.required_group)\n               | Error(\"Expected \\\\sqrt{value}\"))\n        )\n\n        p.overline <<= Group(\n            Suppress(Literal(r\"\\overline\"))\n            - (p.required_group | Error(\"Expected \\\\overline{value}\"))\n        )\n\n        p.unknown_symbol <<= Combine(p.bslash + Regex(\"[A-Za-z]*\"))\n\n        p.operatorname <<= Group(\n            Suppress(Literal(r\"\\operatorname\"))\n            - ((p.lbrace + ZeroOrMore(p.simple | p.unknown_symbol) + p.rbrace)\n               | Error(\"Expected \\\\operatorname{value}\"))\n        )\n\n        p.placeable     <<= (\n            p.accentprefixed  # Must be before accent so named symbols that are\n                              # prefixed with an accent name work\n            | p.accent   # Must be before symbol as all accents are symbols\n            | p.symbol   # Must be third to catch all named symbols and single\n                         # chars not in a group\n            | p.c_over_c\n            | p.function\n            | p.group\n            | p.frac\n            | p.dfrac\n            | p.stackrel\n            | p.binom\n            | p.genfrac\n            | p.sqrt\n            | p.overline\n            | p.operatorname\n        )\n\n        p.simple        <<= (\n            p.space\n            | p.customspace\n            | p.font\n            | p.subsuper\n        )\n\n        p.subsuperop    <<= oneOf([\"_\", \"^\"])\n\n        p.subsuper      <<= Group(\n            (Optional(p.placeable)\n             + OneOrMore(p.subsuperop - p.placeable)\n             + Optional(p.apostrophe))\n            | (p.placeable + Optional(p.apostrophe))\n            | p.apostrophe\n        )\n\n        p.token         <<= (\n            p.simple\n            | p.auto_delim\n            | p.unknown_symbol  # Must be last\n        )\n\n        p.auto_delim    <<= (\n            Suppress(Literal(r\"\\left\"))\n            - ((p.left_delim | p.ambi_delim)\n               | Error(\"Expected a delimiter\"))\n            + Group(ZeroOrMore(p.simple | p.auto_delim))\n            + Suppress(Literal(r\"\\right\"))\n            - ((p.right_delim | p.ambi_delim)\n               | Error(\"Expected a delimiter\"))\n        )\n\n        p.math          <<= OneOrMore(p.token)\n\n        p.math_string   <<= QuotedString('$', '\\\\', unquoteResults=False)\n\n        p.non_math      <<= Regex(r\"(?:(?:\\\\[$])|[^$])*\").leaveWhitespace()\n\n        p.main          <<= (\n            p.non_math + ZeroOrMore(p.math_string + p.non_math) + StringEnd()\n        )\n\n        # Set actions\n        for key, val in vars(p).items():\n            if not key.startswith('_'):\n                if hasattr(self, key):\n                    val.setParseAction(getattr(self, key))\n\n        self._expression = p.main\n        self._math_expression = p.math",
        "begin_line": 2354,
        "end_line": 2601,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.parse#2603",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.parse(self, s, fonts_object, fontsize, dpi)",
        "snippet": "    def parse(self, s, fonts_object, fontsize, dpi):\n        \"\"\"\n        Parse expression *s* using the given *fonts_object* for\n        output, at the given *fontsize* and *dpi*.\n\n        Returns the parse tree of `Node` instances.\n        \"\"\"\n        self._state_stack = [\n            self.State(fonts_object, 'default', 'rm', fontsize, dpi)]\n        self._em_width_cache = {}\n        try:\n            result = self._expression.parseString(s)\n        except ParseBaseException as err:\n            raise ValueError(\"\\n\".join([\"\",\n                                        err.line,\n                                        \" \" * (err.column - 1) + \"^\",\n                                        str(err)])) from err\n        self._state_stack = None\n        self._em_width_cache = {}\n        self._expression.resetCache()\n        return result[0]",
        "begin_line": 2603,
        "end_line": 2623,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.State.__init__#2636",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.State",
        "signature": "lib.matplotlib.mathtext.State.__init__(self, font_output, font, font_class, fontsize, dpi)",
        "snippet": "        def __init__(self, font_output, font, font_class, fontsize, dpi):\n            self.font_output = font_output\n            self._font = font\n            self.font_class = font_class\n            self.fontsize = fontsize\n            self.dpi = dpi",
        "begin_line": 2636,
        "end_line": 2641,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.State.copy#2643",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.State",
        "signature": "lib.matplotlib.mathtext.State.copy(self)",
        "snippet": "        def copy(self):\n            return Parser.State(\n                self.font_output,\n                self.font,\n                self.font_class,\n                self.fontsize,\n                self.dpi)",
        "begin_line": 2643,
        "end_line": 2649,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.State.font#2652",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.State",
        "signature": "lib.matplotlib.mathtext.State.font(self)",
        "snippet": "        def font(self):\n            return self._font",
        "begin_line": 2652,
        "end_line": 2653,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.315824127587973e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.State.font#2656",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.State",
        "signature": "lib.matplotlib.mathtext.State.font(self, name)",
        "snippet": "        def font(self, name):\n            if name in ('rm', 'it', 'bf'):\n                self.font_class = name\n            self._font = name",
        "begin_line": 2656,
        "end_line": 2659,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.32493407559332e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.get_state#2661",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.get_state(self)",
        "snippet": "    def get_state(self):\n        \"\"\"Get the current `State` of the parser.\"\"\"\n        return self._state_stack[-1]",
        "begin_line": 2661,
        "end_line": 2663,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.pop_state#2665",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.pop_state(self)",
        "snippet": "    def pop_state(self):\n        \"\"\"Pop a `State` off of the stack.\"\"\"\n        self._state_stack.pop()",
        "begin_line": 2665,
        "end_line": 2667,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.714396735962697e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.push_state#2669",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.push_state(self)",
        "snippet": "    def push_state(self):\n        \"\"\"Push a new `State` onto the stack, copying the current state.\"\"\"\n        self._state_stack.append(self.get_state().copy())",
        "begin_line": 2669,
        "end_line": 2671,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.main#2673",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.main(self, s, loc, toks)",
        "snippet": "    def main(self, s, loc, toks):\n        return [Hlist(toks)]",
        "begin_line": 2673,
        "end_line": 2674,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.714396735962697e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.math_string#2676",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.math_string(self, s, loc, toks)",
        "snippet": "    def math_string(self, s, loc, toks):\n        return self._math_expression.parseString(toks[0][1:-1])",
        "begin_line": 2676,
        "end_line": 2677,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.math#2679",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.math(self, s, loc, toks)",
        "snippet": "    def math(self, s, loc, toks):\n        hlist = Hlist(toks)\n        self.pop_state()\n        return [hlist]",
        "begin_line": 2679,
        "end_line": 2682,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.non_math#2684",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.non_math(self, s, loc, toks)",
        "snippet": "    def non_math(self, s, loc, toks):\n        s = toks[0].replace(r'\\$', '$')\n        symbols = [Char(c, self.get_state(), math=False) for c in s]\n        hlist = Hlist(symbols)\n        # We're going into math now, so set font to 'it'\n        self.push_state()\n        self.get_state().font = rcParams['mathtext.default']\n        return [hlist]",
        "begin_line": 2684,
        "end_line": 2691,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser._make_space#2693",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser._make_space(self, percentage)",
        "snippet": "    def _make_space(self, percentage):\n        # All spaces are relative to em width\n        state = self.get_state()\n        key = (state.font, state.fontsize, state.dpi)\n        width = self._em_width_cache.get(key)\n        if width is None:\n            metrics = state.font_output.get_metrics(\n                state.font, rcParams['mathtext.default'], 'm', state.fontsize,\n                state.dpi)\n            width = metrics.advance\n            self._em_width_cache[key] = width\n        return Kern(width * percentage)",
        "begin_line": 2693,
        "end_line": 2704,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.space#2721",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.space(self, s, loc, toks)",
        "snippet": "    def space(self, s, loc, toks):\n        assert len(toks) == 1\n        num = self._space_widths[toks[0]]\n        box = self._make_space(num)\n        return [box]",
        "begin_line": 2721,
        "end_line": 2725,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.customspace#2727",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.customspace(self, s, loc, toks)",
        "snippet": "    def customspace(self, s, loc, toks):\n        return [self._make_space(float(toks[0]))]",
        "begin_line": 2727,
        "end_line": 2728,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.symbol#2730",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.symbol(self, s, loc, toks)",
        "snippet": "    def symbol(self, s, loc, toks):\n        c = toks[0]\n        try:\n            char = Char(c, self.get_state())\n        except ValueError as err:\n            raise ParseFatalException(s, loc,\n                                      \"Unknown symbol: %s\" % c) from err\n\n        if c in self._spaced_symbols:\n            # iterate until we find previous character, needed for cases\n            # such as ${ -2}$, $ -2$, or $   -2$.\n            prev_char = next((c for c in s[:loc][::-1] if c != ' '), '')\n            # Binary operators at start of string should not be spaced\n            if (c in self._binary_operators and\n                    (len(s[:loc].split()) == 0 or prev_char == '{' or\n                     prev_char in self._left_delim)):\n                return [char]\n            else:\n                return [Hlist([self._make_space(0.2),\n                               char,\n                               self._make_space(0.2)],\n                              do_kern=True)]\n        elif c in self._punctuation_symbols:\n\n            # Do not space commas between brackets\n            if c == ',':\n                prev_char = next((c for c in s[:loc][::-1] if c != ' '), '')\n                next_char = next((c for c in s[loc + 1:] if c != ' '), '')\n                if prev_char == '{' and next_char == '}':\n                    return [char]\n\n            # Do not space dots as decimal separators\n            if c == '.' and s[loc - 1].isdigit() and s[loc + 1].isdigit():\n                return [char]\n            else:\n                return [Hlist([char, self._make_space(0.2)], do_kern=True)]\n        return [char]",
        "begin_line": 2730,
        "end_line": 2766,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.unknown_symbol#2770",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.unknown_symbol(self, s, loc, toks)",
        "snippet": "    def unknown_symbol(self, s, loc, toks):\n        c = toks[0]\n        raise ParseFatalException(s, loc, \"Unknown symbol: %s\" % c)",
        "begin_line": 2770,
        "end_line": 2772,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.accent#2847",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.accent(self, s, loc, toks)",
        "snippet": "    def accent(self, s, loc, toks):\n        assert len(toks) == 1\n        state = self.get_state()\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n        if len(toks[0]) != 2:\n            raise ParseFatalException(\"Error parsing accent\")\n        accent, sym = toks[0]\n        if accent in self._wide_accents:\n            accent_box = AutoWidthChar(\n                '\\\\' + accent, sym.width, state, char_class=Accent)\n        else:\n            accent_box = Accent(self._accent_map[accent], state)\n        if accent == 'mathring':\n            accent_box.shrink()\n            accent_box.shrink()\n        centered = HCentered([Hbox(sym.width / 4.0), accent_box])\n        centered.hpack(sym.width, 'exactly')\n        return Vlist([\n                centered,\n                Vbox(0., thickness * 2.0),\n                Hlist([sym])\n                ])",
        "begin_line": 2847,
        "end_line": 2869,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.function#2871",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.function(self, s, loc, toks)",
        "snippet": "    def function(self, s, loc, toks):\n        self.push_state()\n        state = self.get_state()\n        state.font = 'rm'\n        hlist = Hlist([Char(c, state) for c in toks[0]])\n        self.pop_state()\n        hlist.function_name = toks[0]\n        return hlist",
        "begin_line": 2871,
        "end_line": 2878,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.operatorname#2880",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.operatorname(self, s, loc, toks)",
        "snippet": "    def operatorname(self, s, loc, toks):\n        self.push_state()\n        state = self.get_state()\n        state.font = 'rm'\n        # Change the font of Chars, but leave Kerns alone\n        for c in toks[0]:\n            if isinstance(c, Char):\n                c.font = 'rm'\n                c._update_metrics()\n        self.pop_state()\n        return Hlist(toks[0])",
        "begin_line": 2880,
        "end_line": 2890,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.start_group#2892",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.start_group(self, s, loc, toks)",
        "snippet": "    def start_group(self, s, loc, toks):\n        self.push_state()\n        # Deal with LaTeX-style font tokens\n        if len(toks):\n            self.get_state().font = toks[0][4:]\n        return []",
        "begin_line": 2892,
        "end_line": 2897,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.86679822397632e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.group#2899",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.group(self, s, loc, toks)",
        "snippet": "    def group(self, s, loc, toks):\n        grp = Hlist(toks[0])\n        return [grp]",
        "begin_line": 2899,
        "end_line": 2901,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.86679822397632e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.end_group#2904",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.end_group(self, s, loc, toks)",
        "snippet": "    def end_group(self, s, loc, toks):\n        self.pop_state()\n        return []",
        "begin_line": 2904,
        "end_line": 2906,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.86679822397632e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.font#2908",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.font(self, s, loc, toks)",
        "snippet": "    def font(self, s, loc, toks):\n        assert len(toks) == 1\n        name = toks[0]\n        self.get_state().font = name\n        return []",
        "begin_line": 2908,
        "end_line": 2912,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.is_overunder#2914",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.is_overunder(self, nucleus)",
        "snippet": "    def is_overunder(self, nucleus):\n        if isinstance(nucleus, Char):\n            return nucleus.c in self._overunder_symbols\n        elif isinstance(nucleus, Hlist) and hasattr(nucleus, 'function_name'):\n            return nucleus.function_name in self._overunder_functions\n        return False",
        "begin_line": 2914,
        "end_line": 2919,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.is_dropsub#2921",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.is_dropsub(self, nucleus)",
        "snippet": "    def is_dropsub(self, nucleus):\n        if isinstance(nucleus, Char):\n            return nucleus.c in self._dropsub_symbols\n        return False",
        "begin_line": 2921,
        "end_line": 2924,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.86679822397632e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.is_slanted#2926",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.is_slanted(self, nucleus)",
        "snippet": "    def is_slanted(self, nucleus):\n        if isinstance(nucleus, Char):\n            return nucleus.is_slanted()\n        return False",
        "begin_line": 2926,
        "end_line": 2929,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.86679822397632e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.subsuper#2934",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.subsuper(self, s, loc, toks)",
        "snippet": "    def subsuper(self, s, loc, toks):\n        assert len(toks) == 1\n\n        nucleus = None\n        sub = None\n        super = None\n\n        # Pick all of the apostrophes out, including first apostrophes that\n        # have been parsed as characters\n        napostrophes = 0\n        new_toks = []\n        for tok in toks[0]:\n            if isinstance(tok, str) and tok not in ('^', '_'):\n                napostrophes += len(tok)\n            elif isinstance(tok, Char) and tok.c == \"'\":\n                napostrophes += 1\n            else:\n                new_toks.append(tok)\n        toks = new_toks\n\n        if len(toks) == 0:\n            assert napostrophes\n            nucleus = Hbox(0.0)\n        elif len(toks) == 1:\n            if not napostrophes:\n                return toks[0]  # .asList()\n            else:\n                nucleus = toks[0]\n        elif len(toks) in (2, 3):\n            # single subscript or superscript\n            nucleus = toks[0] if len(toks) == 3 else Hbox(0.0)\n            op, next = toks[-2:]\n            if op == '_':\n                sub = next\n            else:\n                super = next\n        elif len(toks) in (4, 5):\n            # subscript and superscript\n            nucleus = toks[0] if len(toks) == 5 else Hbox(0.0)\n            op1, next1, op2, next2 = toks[-4:]\n            if op1 == op2:\n                if op1 == '_':\n                    raise ParseFatalException(\"Double subscript\")\n                else:\n                    raise ParseFatalException(\"Double superscript\")\n            if op1 == '_':\n                sub = next1\n                super = next2\n            else:\n                super = next1\n                sub = next2\n        else:\n            raise ParseFatalException(\n                \"Subscript/superscript sequence is too long. \"\n                \"Use braces { } to remove ambiguity.\")\n\n        state = self.get_state()\n        rule_thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n        xHeight = state.font_output.get_xheight(\n            state.font, state.fontsize, state.dpi)\n\n        if napostrophes:\n            if super is None:\n                super = Hlist([])\n            for i in range(napostrophes):\n                super.children.extend(self.symbol(s, loc, ['\\\\prime']))\n            # kern() and hpack() needed to get the metrics right after\n            # extending\n            super.kern()\n            super.hpack()\n\n        # Handle over/under symbols, such as sum or integral\n        if self.is_overunder(nucleus):\n            vlist = []\n            shift = 0.\n            width = nucleus.width\n            if super is not None:\n                super.shrink()\n                width = max(width, super.width)\n            if sub is not None:\n                sub.shrink()\n                width = max(width, sub.width)\n\n            if super is not None:\n                hlist = HCentered([super])\n                hlist.hpack(width, 'exactly')\n                vlist.extend([hlist, Kern(rule_thickness * 3.0)])\n            hlist = HCentered([nucleus])\n            hlist.hpack(width, 'exactly')\n            vlist.append(hlist)\n            if sub is not None:\n                hlist = HCentered([sub])\n                hlist.hpack(width, 'exactly')\n                vlist.extend([Kern(rule_thickness * 3.0), hlist])\n                shift = hlist.height\n            vlist = Vlist(vlist)\n            vlist.shift_amount = shift + nucleus.depth\n            result = Hlist([vlist])\n            return [result]\n\n        # We remove kerning on the last character for consistency (otherwise\n        # it will compute kerning based on non-shrunk characters and may put\n        # them too close together when superscripted)\n        # We change the width of the last character to match the advance to\n        # consider some fonts with weird metrics: e.g. stix's f has a width of\n        # 7.75 and a kerning of -4.0 for an advance of 3.72, and we want to put\n        # the superscript at the advance\n        last_char = nucleus\n        if isinstance(nucleus, Hlist):\n            new_children = nucleus.children\n            if len(new_children):\n                # remove last kern\n                if (isinstance(new_children[-1], Kern) and\n                        hasattr(new_children[-2], '_metrics')):\n                    new_children = new_children[:-1]\n                last_char = new_children[-1]\n                if hasattr(last_char, '_metrics'):\n                    last_char.width = last_char._metrics.advance\n            # create new Hlist without kerning\n            nucleus = Hlist(new_children, do_kern=False)\n        else:\n            if isinstance(nucleus, Char):\n                last_char.width = last_char._metrics.advance\n            nucleus = Hlist([nucleus])\n\n        # Handle regular sub/superscripts\n        constants = _get_font_constant_set(state)\n        lc_height   = last_char.height\n        lc_baseline = 0\n        if self.is_dropsub(last_char):\n            lc_baseline = last_char.depth\n\n        # Compute kerning for sub and super\n        superkern = constants.delta * xHeight\n        subkern = constants.delta * xHeight\n        if self.is_slanted(last_char):\n            superkern += constants.delta * xHeight\n            superkern += (constants.delta_slanted *\n                          (lc_height - xHeight * 2. / 3.))\n            if self.is_dropsub(last_char):\n                subkern = (3 * constants.delta -\n                           constants.delta_integral) * lc_height\n                superkern = (3 * constants.delta +\n                             constants.delta_integral) * lc_height\n            else:\n                subkern = 0\n\n        if super is None:\n            # node757\n            x = Hlist([Kern(subkern), sub])\n            x.shrink()\n            if self.is_dropsub(last_char):\n                shift_down = lc_baseline + constants.subdrop * xHeight\n            else:\n                shift_down = constants.sub1 * xHeight\n            x.shift_amount = shift_down\n        else:\n            x = Hlist([Kern(superkern), super])\n            x.shrink()\n            if self.is_dropsub(last_char):\n                shift_up = lc_height - constants.subdrop * xHeight\n            else:\n                shift_up = constants.sup1 * xHeight\n            if sub is None:\n                x.shift_amount = -shift_up\n            else:  # Both sub and superscript\n                y = Hlist([Kern(subkern), sub])\n                y.shrink()\n                if self.is_dropsub(last_char):\n                    shift_down = lc_baseline + constants.subdrop * xHeight\n                else:\n                    shift_down = constants.sub2 * xHeight\n                # If sub and superscript collide, move super up\n                clr = (2.0 * rule_thickness -\n                       ((shift_up - x.depth) - (y.height - shift_down)))\n                if clr > 0.:\n                    shift_up += clr\n                x = Vlist([\n                    x,\n                    Kern((shift_up - x.depth) - (y.height - shift_down)),\n                    y])\n                x.shift_amount = shift_down\n\n        if not self.is_dropsub(last_char):\n            x.width += constants.script_space * xHeight\n        result = Hlist([nucleus, x])\n\n        return [result]",
        "begin_line": 2934,
        "end_line": 3122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser._genfrac#3124",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser._genfrac(self, ldelim, rdelim, rule, style, num, den)",
        "snippet": "    def _genfrac(self, ldelim, rdelim, rule, style, num, den):\n        state = self.get_state()\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n\n        rule = float(rule)\n\n        # If style != displaystyle == 0, shrink the num and den\n        if style != self._math_style_dict['displaystyle']:\n            num.shrink()\n            den.shrink()\n        cnum = HCentered([num])\n        cden = HCentered([den])\n        width = max(num.width, den.width)\n        cnum.hpack(width, 'exactly')\n        cden.hpack(width, 'exactly')\n        vlist = Vlist([cnum,                      # numerator\n                       Vbox(0, thickness * 2.0),  # space\n                       Hrule(state, rule),        # rule\n                       Vbox(0, thickness * 2.0),  # space\n                       cden                       # denominator\n                       ])\n\n        # Shift so the fraction line sits in the middle of the\n        # equals sign\n        metrics = state.font_output.get_metrics(\n            state.font, rcParams['mathtext.default'],\n            '=', state.fontsize, state.dpi)\n        shift = (cden.height -\n                 ((metrics.ymax + metrics.ymin) / 2 -\n                  thickness * 3.0))\n        vlist.shift_amount = shift\n\n        result = [Hlist([vlist, Hbox(thickness * 2.)])]\n        if ldelim or rdelim:\n            if ldelim == '':\n                ldelim = '.'\n            if rdelim == '':\n                rdelim = '.'\n            return self._auto_sized_delimiter(ldelim, result, rdelim)\n        return result",
        "begin_line": 3124,
        "end_line": 3164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.genfrac#3166",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.genfrac(self, s, loc, toks)",
        "snippet": "    def genfrac(self, s, loc, toks):\n        assert len(toks) == 1\n        assert len(toks[0]) == 6\n\n        return self._genfrac(*tuple(toks[0]))",
        "begin_line": 3166,
        "end_line": 3170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.frac#3172",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.frac(self, s, loc, toks)",
        "snippet": "    def frac(self, s, loc, toks):\n        assert len(toks) == 1\n        assert len(toks[0]) == 2\n        state = self.get_state()\n\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n        num, den = toks[0]\n\n        return self._genfrac('', '', thickness,\n                             self._math_style_dict['textstyle'], num, den)",
        "begin_line": 3172,
        "end_line": 3182,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.dfrac#3184",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.dfrac(self, s, loc, toks)",
        "snippet": "    def dfrac(self, s, loc, toks):\n        assert len(toks) == 1\n        assert len(toks[0]) == 2\n        state = self.get_state()\n\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n        num, den = toks[0]\n\n        return self._genfrac('', '', thickness,\n                             self._math_style_dict['displaystyle'], num, den)",
        "begin_line": 3184,
        "end_line": 3194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.binom#3196",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.binom(self, s, loc, toks)",
        "snippet": "    def binom(self, s, loc, toks):\n        assert len(toks) == 1\n        assert len(toks[0]) == 2\n        num, den = toks[0]\n\n        return self._genfrac('(', ')', 0.0,\n                             self._math_style_dict['textstyle'], num, den)",
        "begin_line": 3196,
        "end_line": 3202,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.sqrt#3204",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.sqrt(self, s, loc, toks)",
        "snippet": "    def sqrt(self, s, loc, toks):\n        root, body = toks[0]\n        state = self.get_state()\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n\n        # Determine the height of the body, and add a little extra to\n        # the height so it doesn't seem cramped\n        height = body.height - body.shift_amount + thickness * 5.0\n        depth = body.depth + body.shift_amount\n        check = AutoHeightChar(r'\\__sqrt__', height, depth, state, always=True)\n        height = check.height - check.shift_amount\n        depth = check.depth + check.shift_amount\n\n        # Put a little extra space to the left and right of the body\n        padded_body = Hlist([Hbox(thickness * 2.0),\n                             body,\n                             Hbox(thickness * 2.0)])\n        rightside = Vlist([Hrule(state),\n                           Fill(),\n                           padded_body])\n        # Stretch the glue between the hrule and the body\n        rightside.vpack(height + (state.fontsize * state.dpi) / (100.0 * 12.0),\n                        'exactly', depth)\n\n        # Add the root and shift it upward so it is above the tick.\n        # The value of 0.6 is a hard-coded hack ;)\n        if root is None:\n            root = Box(check.width * 0.5, 0., 0.)\n        else:\n            root = Hlist([Char(x, state) for x in root])\n            root.shrink()\n            root.shrink()\n\n        root_vlist = Vlist([Hlist([root])])\n        root_vlist.shift_amount = -height * 0.6\n\n        hlist = Hlist([root_vlist,               # Root\n                       # Negative kerning to put root over tick\n                       Kern(-check.width * 0.5),\n                       check,                    # Check\n                       rightside])               # Body\n        return [hlist]",
        "begin_line": 3204,
        "end_line": 3246,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.overline#3248",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.overline(self, s, loc, toks)",
        "snippet": "    def overline(self, s, loc, toks):\n        assert len(toks) == 1\n        assert len(toks[0]) == 1\n\n        body = toks[0][0]\n\n        state = self.get_state()\n        thickness = state.font_output.get_underline_thickness(\n            state.font, state.fontsize, state.dpi)\n\n        height = body.height - body.shift_amount + thickness * 3.0\n        depth = body.depth + body.shift_amount\n\n        # Place overline above body\n        rightside = Vlist([Hrule(state),\n                           Fill(),\n                           Hlist([body])])\n\n        # Stretch the glue between the hrule and the body\n        rightside.vpack(height + (state.fontsize * state.dpi) / (100.0 * 12.0),\n                        'exactly', depth)\n\n        hlist = Hlist([rightside])\n        return [hlist]",
        "begin_line": 3248,
        "end_line": 3271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser._auto_sized_delimiter#3273",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser._auto_sized_delimiter(self, front, middle, back)",
        "snippet": "    def _auto_sized_delimiter(self, front, middle, back):\n        state = self.get_state()\n        if len(middle):\n            height = max(x.height for x in middle)\n            depth = max(x.depth for x in middle)\n            factor = None\n        else:\n            height = 0\n            depth = 0\n            factor = 1.0\n        parts = []\n        # \\left. and \\right. aren't supposed to produce any symbols\n        if front != '.':\n            parts.append(\n                AutoHeightChar(front, height, depth, state, factor=factor))\n        parts.extend(middle)\n        if back != '.':\n            parts.append(\n                AutoHeightChar(back, height, depth, state, factor=factor))\n        hlist = Hlist(parts)\n        return hlist",
        "begin_line": 3273,
        "end_line": 3293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.Parser.auto_delim#3295",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.Parser",
        "signature": "lib.matplotlib.mathtext.Parser.auto_delim(self, s, loc, toks)",
        "snippet": "    def auto_delim(self, s, loc, toks):\n        front, middle, back = toks\n\n        return self._auto_sized_delimiter(front, middle.asList(), back)",
        "begin_line": 3295,
        "end_line": 3298,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.85052598524101e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathTextParser.__init__#3327",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathTextParser",
        "signature": "lib.matplotlib.mathtext.MathTextParser.__init__(self, output)",
        "snippet": "    def __init__(self, output):\n        \"\"\"Create a MathTextParser for the given backend *output*.\"\"\"\n        self._output = output.lower()",
        "begin_line": 3327,
        "end_line": 3329,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003749531308586427,
            "pseudo_dstar_susp": 0.000346860908775581,
            "pseudo_tarantula_susp": 0.0007178750897343862,
            "pseudo_op2_susp": 0.000346860908775581,
            "pseudo_barinel_susp": 0.0007178750897343862
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathTextParser.parse#3331",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathTextParser",
        "signature": "lib.matplotlib.mathtext.MathTextParser.parse(self, s, dpi=72, prop=None)",
        "snippet": "    def parse(self, s, dpi=72, prop=None):\n        \"\"\"\n        Parse the given math expression *s* at the given *dpi*.  If *prop* is\n        provided, it is a `.FontProperties` object specifying the \"default\"\n        font to use in the math expression, used for all non-math text.\n\n        The results are cached, so multiple calls to `parse`\n        with the same expression should be fast.\n        \"\"\"\n        # lru_cache can't decorate parse() directly because the ps.useafm and\n        # mathtext.fontset rcParams also affect the parse (e.g. by affecting\n        # the glyph metrics).\n        return self._parse_cached(\n            s, dpi, prop, rcParams['ps.useafm'], rcParams['mathtext.fontset'])",
        "begin_line": 3331,
        "end_line": 3344,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mathtext.MathTextParser._parse_cached#3347",
        "src_path": "lib/matplotlib/mathtext.py",
        "class_name": "lib.matplotlib.mathtext.MathTextParser",
        "signature": "lib.matplotlib.mathtext.MathTextParser._parse_cached(self, s, dpi, prop, ps_useafm, fontset)",
        "snippet": "    def _parse_cached(self, s, dpi, prop, ps_useafm, fontset):\n\n        if prop is None:\n            prop = FontProperties()\n\n        if self._output == 'ps' and ps_useafm:\n            font_output = StandardPsFonts(prop)\n        else:\n            backend = self._backend_mapping[self._output]()\n            fontset_class = cbook._check_getitem(\n                self._font_type_mapping, fontset=fontset)\n            font_output = fontset_class(prop, backend)\n\n        fontsize = prop.get_size_in_points()\n\n        # This is a class variable so we don't rebuild the parser\n        # with each request.\n        if self._parser is None:\n            self.__class__._parser = Parser()\n\n        box = self._parser.parse(s, font_output, fontsize, dpi)\n        font_output.set_canvas_size(box.width, box.height, box.depth)\n        return font_output.get_results(box)",
        "begin_line": 3347,
        "end_line": 3369,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter.__call__#15",
        "src_path": "lib/matplotlib/testing/jpl_units/UnitDblFormatter.py",
        "class_name": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter",
        "signature": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter.__call__(self, x, pos=None)",
        "snippet": "    def __call__(self, x, pos=None):\n        # docstring inherited\n        if len(self.locs) == 0:\n            return ''\n        else:\n            return '{:.12}'.format(x)",
        "begin_line": 15,
        "end_line": 20,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triplot.triplot#5",
        "src_path": "lib/matplotlib/tri/triplot.py",
        "class_name": "lib.matplotlib.tri.triplot",
        "signature": "lib.matplotlib.tri.triplot.triplot(ax, *args, **kwargs)",
        "snippet": "def triplot(ax, *args, **kwargs):\n    \"\"\"\n    Draw a unstructured triangular grid as lines and/or markers.\n\n    The triangulation to plot can be specified in one of two ways;\n    either::\n\n      triplot(triangulation, ...)\n\n    where triangulation is a :class:`matplotlib.tri.Triangulation`\n    object, or\n\n    ::\n\n      triplot(x, y, ...)\n      triplot(x, y, triangles, ...)\n      triplot(x, y, triangles=triangles, ...)\n      triplot(x, y, mask=mask, ...)\n      triplot(x, y, triangles, mask=mask, ...)\n\n    in which case a Triangulation object will be created.  See\n    :class:`~matplotlib.tri.Triangulation` for a explanation of these\n    possibilities.\n\n    The remaining args and kwargs are the same as for\n    :meth:`~matplotlib.axes.Axes.plot`.\n\n    Return a list of 2 :class:`~matplotlib.lines.Line2D` containing\n    respectively:\n\n        - the lines plotted for triangles edges\n        - the markers plotted for triangles nodes\n    \"\"\"\n    import matplotlib.axes\n\n    tri, args, kwargs = Triangulation.get_from_args_and_kwargs(*args, **kwargs)\n    x, y, edges = (tri.x, tri.y, tri.edges)\n\n    # Decode plot format string, e.g., 'ro-'\n    fmt = args[0] if args else \"\"\n    linestyle, marker, color = matplotlib.axes._base._process_plot_format(fmt)\n\n    # Insert plot format string into a copy of kwargs (kwargs values prevail).\n    kw = kwargs.copy()\n    for key, val in zip(('linestyle', 'marker', 'color'),\n                        (linestyle, marker, color)):\n        if val is not None:\n            kw[key] = kwargs.get(key, val)\n\n    # Draw lines without markers.\n    # Note 1: If we drew markers here, most markers would be drawn more than\n    #         once as they belong to several edges.\n    # Note 2: We insert nan values in the flattened edges arrays rather than\n    #         plotting directly (triang.x[edges].T, triang.y[edges].T)\n    #         as it considerably speeds-up code execution.\n    linestyle = kw['linestyle']\n    kw_lines = {\n        **kw,\n        'marker': 'None',  # No marker to draw.\n        'zorder': kw.get('zorder', 1),  # Path default zorder is used.\n    }\n    if linestyle not in [None, 'None', '', ' ']:\n        tri_lines_x = np.insert(x[edges], 2, np.nan, axis=1)\n        tri_lines_y = np.insert(y[edges], 2, np.nan, axis=1)\n        tri_lines = ax.plot(tri_lines_x.ravel(), tri_lines_y.ravel(),\n                            **kw_lines)\n    else:\n        tri_lines = ax.plot([], [], **kw_lines)\n\n    # Draw markers separately.\n    marker = kw['marker']\n    kw_markers = {\n        **kw,\n        'linestyle': 'None',  # No line to draw.\n    }\n    if marker not in [None, 'None', '', ' ']:\n        tri_markers = ax.plot(x, y, **kw_markers)\n    else:\n        tri_markers = ax.plot([], [], **kw_markers)\n\n    return tri_lines + tri_markers",
        "begin_line": 5,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.jpl_units.UnitDblConverter.rad_fn#15",
        "src_path": "lib/matplotlib/testing/jpl_units/UnitDblConverter.py",
        "class_name": "lib.matplotlib.testing.jpl_units.UnitDblConverter",
        "signature": "lib.matplotlib.testing.jpl_units.UnitDblConverter.rad_fn(x, pos=None)",
        "snippet": "def rad_fn(x, pos=None):\n    \"\"\"Radian function formatter.\"\"\"\n    n = int((x / np.pi) * 2.0 + 0.25)\n    if n == 0:\n        return str(x)\n    elif n == 1:\n        return r'$\\pi/2$'\n    elif n == 2:\n        return r'$\\pi$'\n    elif n % 2 == 0:\n        return fr'${n//2}\\pi$'\n    else:\n        return fr'${n}\\pi/2$'",
        "begin_line": 15,
        "end_line": 27,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.__init__#65",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.__init__(self, xy, width, height, edgecolor='k', facecolor='w', fill=True, text='', loc=None, fontproperties=None)",
        "snippet": "    def __init__(self, xy, width, height,\n                 edgecolor='k', facecolor='w',\n                 fill=True,\n                 text='',\n                 loc=None,\n                 fontproperties=None\n                 ):\n\n        # Call base\n        Rectangle.__init__(self, xy, width=width, height=height, fill=fill,\n                           edgecolor=edgecolor, facecolor=facecolor)\n        self.set_clip_on(False)\n\n        # Create text object\n        if loc is None:\n            loc = 'right'\n        self._loc = loc\n        self._text = Text(x=xy[0], y=xy[1], text=text,\n                          fontproperties=fontproperties)\n        self._text.set_clip_on(False)",
        "begin_line": 65,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.539709649871905e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.set_transform#86",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.set_transform(self, trans)",
        "snippet": "    def set_transform(self, trans):\n        Rectangle.set_transform(self, trans)\n        # the text does not get the transform!\n        self.stale = True",
        "begin_line": 86,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.252867871585376e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.set_figure#91",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.set_figure(self, fig)",
        "snippet": "    def set_figure(self, fig):\n        Rectangle.set_figure(self, fig)\n        self._text.set_figure(fig)",
        "begin_line": 91,
        "end_line": 93,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.035355564483728e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.set_fontsize#99",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.set_fontsize(self, size)",
        "snippet": "    def set_fontsize(self, size):\n        \"\"\"Set the text fontsize.\"\"\"\n        self._text.set_fontsize(size)\n        self.stale = True",
        "begin_line": 99,
        "end_line": 102,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.46880030300161e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.get_fontsize#104",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.get_fontsize(self)",
        "snippet": "    def get_fontsize(self):\n        \"\"\"Return the cell fontsize.\"\"\"\n        return self._text.get_fontsize()",
        "begin_line": 104,
        "end_line": 106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.480325644504748e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.auto_set_font_size#108",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.auto_set_font_size(self, renderer)",
        "snippet": "    def auto_set_font_size(self, renderer):\n        \"\"\"Shrink font size until the text fits into the cell width.\"\"\"\n        fontsize = self.get_fontsize()\n        required = self.get_required_width(renderer)\n        while fontsize > 1 and required > self.get_width():\n            fontsize -= 1\n            self.set_fontsize(fontsize)\n            required = self.get_required_width(renderer)\n\n        return fontsize",
        "begin_line": 108,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.104980424292088e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.draw#120",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            return\n        # draw the rectangle\n        Rectangle.draw(self, renderer)\n\n        # position the text\n        self._set_text_position(renderer)\n        self._text.draw(renderer)\n        self.stale = False",
        "begin_line": 120,
        "end_line": 129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.825346394845998e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Cell._set_text_position#131",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell._set_text_position(self, renderer)",
        "snippet": "    def _set_text_position(self, renderer):\n        \"\"\"Set text up so it draws in the right place.\n\n        Currently support 'left', 'center' and 'right'\n        \"\"\"\n        bbox = self.get_window_extent(renderer)\n        l, b, w, h = bbox.bounds\n\n        # draw in center vertically\n        self._text.set_verticalalignment('center')\n        y = b + (h / 2.0)\n\n        # now position horizontally\n        if self._loc == 'center':\n            self._text.set_horizontalalignment('center')\n            x = l + (w / 2.0)\n        elif self._loc == 'left':\n            self._text.set_horizontalalignment('left')\n            x = l + (w * self.PAD)\n        else:\n            self._text.set_horizontalalignment('right')\n            x = l + (w * (1.0 - self.PAD))\n\n        self._text.set_position((x, y))",
        "begin_line": 131,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.get_text_bounds#156",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.get_text_bounds(self, renderer)",
        "snippet": "    def get_text_bounds(self, renderer):\n        \"\"\"\n        Return the text bounds as *(x, y, width, height)* in table coordinates.\n        \"\"\"\n        bbox = self._text.get_window_extent(renderer)\n        bboxa = bbox.inverse_transformed(self.get_data_transform())\n        return bboxa.bounds",
        "begin_line": 156,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.000090000900009e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Cell.get_required_width#164",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Cell",
        "signature": "lib.matplotlib.table.Cell.get_required_width(self, renderer)",
        "snippet": "    def get_required_width(self, renderer):\n        \"\"\"Return the minimal required width for the cell.\"\"\"\n        l, b, w, h = self.get_text_bounds(renderer)\n        return w * (1.0 + (2.0 * self.PAD))",
        "begin_line": 164,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.057971014492754e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.CustomCell.visible_edges#212",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.CustomCell",
        "signature": "lib.matplotlib.table.CustomCell.visible_edges(self, value)",
        "snippet": "    def visible_edges(self, value):\n        if value is None:\n            self._visible_edges = self._edges\n        elif value in self._edge_aliases:\n            self._visible_edges = self._edge_aliases[value]\n        else:\n            if any(edge not in self._edges for edge in value):\n                raise ValueError('Invalid edge param {}, must only be one of '\n                                 '{} or string of {}'.format(\n                                     value,\n                                     \", \".join(self._edge_aliases),\n                                     \", \".join(self._edges)))\n            self._visible_edges = value\n        self.stale = True",
        "begin_line": 212,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.098477486232588e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.CustomCell.get_path#227",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.CustomCell",
        "signature": "lib.matplotlib.table.CustomCell.get_path(self)",
        "snippet": "    def get_path(self):\n        \"\"\"Return a `.Path` for the `.visible_edges`.\"\"\"\n        codes = [Path.MOVETO]\n        codes.extend(\n            Path.LINETO if edge in self._visible_edges else Path.MOVETO\n            for edge in self._edges)\n        if Path.MOVETO not in codes[1:]:  # All sides are visible\n            codes[-1] = Path.CLOSEPOLY\n        return Path(\n            [[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0], [0.0, 0.0]],\n            codes,\n            readonly=True\n            )",
        "begin_line": 227,
        "end_line": 239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Table.__init__#283",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table.__init__(self, ax, loc=None, bbox=None, **kwargs)",
        "snippet": "    def __init__(self, ax, loc=None, bbox=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        ax : `matplotlib.axes.Axes`\n            The `~.axes.Axes` to plot the table into.\n        loc : str\n            The position of the cell with respect to *ax*. This must be one of\n            the `~.Table.codes`.\n        bbox : `.Bbox` or None\n            A bounding box to draw the table into. If this is not *None*, this\n            overrides *loc*.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            `.Artist` properties.\n        \"\"\"\n\n        Artist.__init__(self)\n\n        if isinstance(loc, str):\n            if loc not in self.codes:\n                cbook.warn_deprecated(\n                    \"3.1\", message=\"Unrecognized location {!r}. Falling back \"\n                    \"on 'bottom'; valid locations are\\n\\t{}\\n\"\n                    \"This will raise an exception %(removal)s.\"\n                    .format(loc, '\\n\\t'.join(self.codes)))\n                loc = 'bottom'\n            loc = self.codes[loc]\n        self.set_figure(ax.figure)\n        self._axes = ax\n        self._loc = loc\n        self._bbox = bbox\n\n        # use axes coords\n        ax._unstale_viewLim()\n        self.set_transform(ax.transAxes)\n\n        self._cells = {}\n        self._edges = None\n        self._autoColumns = []\n        self._autoFontsize = True\n        self.update(kwargs)\n\n        self.set_clip_on(False)",
        "begin_line": 283,
        "end_line": 328,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Table.add_cell#330",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table.add_cell(self, row, col, *args, **kwargs)",
        "snippet": "    def add_cell(self, row, col, *args, **kwargs):\n        \"\"\"\n        Create a cell and add it to the table.\n\n        Parameters\n        ----------\n        row : int\n            Row index.\n        col : int\n            Column index.\n        *args, **kwargs\n            All other parameters are passed on to `Cell`.\n\n        Returns\n        -------\n        cell : `.CustomCell`\n            The created cell.\n\n        \"\"\"\n        xy = (0, 0)\n        cell = CustomCell(xy, visible_edges=self.edges, *args, **kwargs)\n        self[row, col] = cell\n        return cell",
        "begin_line": 330,
        "end_line": 352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Table.__setitem__#354",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table.__setitem__(self, position, cell)",
        "snippet": "    def __setitem__(self, position, cell):\n        \"\"\"\n        Set a custom cell in a given position.\n        \"\"\"\n        cbook._check_isinstance(CustomCell, cell=cell)\n        try:\n            row, col = position[0], position[1]\n        except Exception as err:\n            raise KeyError('Only tuples length 2 are accepted as '\n                           'coordinates') from err\n        cell.set_figure(self.figure)\n        cell.set_transform(self.get_transform())\n        cell.set_clip_on(False)\n        self._cells[row, col] = cell\n        self.stale = True",
        "begin_line": 354,
        "end_line": 368,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Table.edges#375",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table.edges(self)",
        "snippet": "    def edges(self):\n        \"\"\"\n        The default value of `~.CustomCell.visible_edges` for newly added\n        cells using `.add_cell`.\n\n        Notes\n        -----\n        This setting does currently only affect newly created cells using\n        `.add_cell`.\n\n        To change existing cells, you have to set their edges explicitly::\n\n            for c in tab.get_celld().values():\n                c.visible_edges = 'horizontal'\n\n        \"\"\"\n        return self._edges",
        "begin_line": 375,
        "end_line": 391,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Table.edges#394",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table.edges(self, value)",
        "snippet": "    def edges(self, value):\n        self._edges = value\n        self.stale = True",
        "begin_line": 394,
        "end_line": 396,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Table._approx_text_height#398",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table._approx_text_height(self)",
        "snippet": "    def _approx_text_height(self):\n        return (self.FONTSIZE / 72.0 * self.figure.dpi /\n                self._axes.bbox.height * 1.2)",
        "begin_line": 398,
        "end_line": 400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Table.draw#403",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        # docstring inherited\n\n        # Need a renderer to do hit tests on mouseevent; assume the last one\n        # will do\n        if renderer is None:\n            renderer = self.figure._cachedRenderer\n        if renderer is None:\n            raise RuntimeError('No renderer defined')\n\n        if not self.get_visible():\n            return\n        renderer.open_group('table', gid=self.get_gid())\n        self._update_positions(renderer)\n\n        for key in sorted(self._cells):\n            self._cells[key].draw(renderer)\n\n        renderer.close_group('table')\n        self.stale = False",
        "begin_line": 403,
        "end_line": 422,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Table._get_grid_bbox#424",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table._get_grid_bbox(self, renderer)",
        "snippet": "    def _get_grid_bbox(self, renderer):\n        \"\"\"\n        Get a bbox, in axes coordinates for the cells.\n\n        Only include those in the range (0, 0) to (maxRow, maxCol).\n        \"\"\"\n        boxes = [cell.get_window_extent(renderer)\n                 for (row, col), cell in self._cells.items()\n                 if row >= 0 and col >= 0]\n        bbox = Bbox.union(boxes)\n        return bbox.inverse_transformed(self.get_transform())",
        "begin_line": 424,
        "end_line": 434,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Table.get_window_extent#457",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table.get_window_extent(self, renderer)",
        "snippet": "    def get_window_extent(self, renderer):\n        \"\"\"Return the bounding box of the table in window coords.\"\"\"\n        self._update_positions(renderer)\n        boxes = [cell.get_window_extent(renderer)\n                 for cell in self._cells.values()]\n        return Bbox.union(boxes)",
        "begin_line": 457,
        "end_line": 462,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Table._do_cell_alignment#464",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table._do_cell_alignment(self)",
        "snippet": "    def _do_cell_alignment(self):\n        \"\"\"\n        Calculate row heights and column widths; position cells accordingly.\n        \"\"\"\n        # Calculate row/column widths\n        widths = {}\n        heights = {}\n        for (row, col), cell in self._cells.items():\n            height = heights.setdefault(row, 0.0)\n            heights[row] = max(height, cell.get_height())\n            width = widths.setdefault(col, 0.0)\n            widths[col] = max(width, cell.get_width())\n\n        # work out left position for each column\n        xpos = 0\n        lefts = {}\n        for col in sorted(widths):\n            lefts[col] = xpos\n            xpos += widths[col]\n\n        ypos = 0\n        bottoms = {}\n        for row in sorted(heights, reverse=True):\n            bottoms[row] = ypos\n            ypos += heights[row]\n\n        # set cell positions\n        for (row, col), cell in self._cells.items():\n            cell.set_x(lefts[col])\n            cell.set_y(bottoms[row])",
        "begin_line": 464,
        "end_line": 493,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Table.auto_set_column_width#495",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table.auto_set_column_width(self, col)",
        "snippet": "    def auto_set_column_width(self, col):\n        \"\"\"\n        Automatically set the widths of given columns to optimal sizes.\n\n        Parameters\n        ----------\n        col : int or sequence of ints\n            The indices of the columns to auto-scale.\n        \"\"\"\n        # check for col possibility on iteration\n        try:\n            iter(col)\n        except (TypeError, AttributeError):\n            self._autoColumns.append(col)\n        else:\n            for cell in col:\n                self._autoColumns.append(cell)\n\n        self.stale = True",
        "begin_line": 495,
        "end_line": 513,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Table._auto_set_column_width#515",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table._auto_set_column_width(self, col, renderer)",
        "snippet": "    def _auto_set_column_width(self, col, renderer):\n        \"\"\"Automatically set width for column.\"\"\"\n        cells = [cell for key, cell in self._cells.items() if key[1] == col]\n        max_width = max((cell.get_required_width(renderer) for cell in cells),\n                        default=0)\n        for cell in cells:\n            cell.set_width(max_width)",
        "begin_line": 515,
        "end_line": 521,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Table._auto_set_font_size#528",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table._auto_set_font_size(self, renderer)",
        "snippet": "    def _auto_set_font_size(self, renderer):\n\n        if len(self._cells) == 0:\n            return\n        fontsize = next(iter(self._cells.values())).get_fontsize()\n        cells = []\n        for key, cell in self._cells.items():\n            # ignore auto-sized columns\n            if key[1] in self._autoColumns:\n                continue\n            size = cell.auto_set_font_size(renderer)\n            fontsize = min(fontsize, size)\n            cells.append(cell)\n\n        # now set all fontsizes equal\n        for cell in self._cells.values():\n            cell.set_fontsize(fontsize)",
        "begin_line": 528,
        "end_line": 544,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Table._offset#577",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table._offset(self, ox, oy)",
        "snippet": "    def _offset(self, ox, oy):\n        \"\"\"Move all the artists by ox, oy (axes coords).\"\"\"\n        for c in self._cells.values():\n            x, y = c.get_x(), c.get_y()\n            c.set_x(x + ox)\n            c.set_y(y + oy)",
        "begin_line": 577,
        "end_line": 582,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.Table._update_positions#584",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table.Table",
        "signature": "lib.matplotlib.table.Table._update_positions(self, renderer)",
        "snippet": "    def _update_positions(self, renderer):\n        # called from renderer to allow more precise estimates of\n        # widths and heights with get_window_extent\n\n        # Do any auto width setting\n        for col in self._autoColumns:\n            self._auto_set_column_width(col, renderer)\n\n        if self._autoFontsize:\n            self._auto_set_font_size(renderer)\n\n        # Align all the cells\n        self._do_cell_alignment()\n\n        bbox = self._get_grid_bbox(renderer)\n        l, b, w, h = bbox.bounds\n\n        if self._bbox is not None:\n            # Position according to bbox\n            rl, rb, rw, rh = self._bbox\n            self.scale(rw / w, rh / h)\n            ox = rl - l\n            oy = rb - b\n            self._do_cell_alignment()\n        else:\n            # Position using loc\n            (BEST, UR, UL, LL, LR, CL, CR, LC, UC, C,\n             TR, TL, BL, BR, R, L, T, B) = range(len(self.codes))\n            # defaults for center\n            ox = (0.5 - w / 2) - l\n            oy = (0.5 - h / 2) - b\n            if self._loc in (UL, LL, CL):   # left\n                ox = self.AXESPAD - l\n            if self._loc in (BEST, UR, LR, R, CR):  # right\n                ox = 1 - (l + w + self.AXESPAD)\n            if self._loc in (BEST, UR, UL, UC):     # upper\n                oy = 1 - (b + h + self.AXESPAD)\n            if self._loc in (LL, LR, LC):           # lower\n                oy = self.AXESPAD - b\n            if self._loc in (LC, UC, C):            # center x\n                ox = (0.5 - w / 2) - l\n            if self._loc in (CL, CR, C):            # center y\n                oy = (0.5 - h / 2) - b\n\n            if self._loc in (TL, BL, L):            # out left\n                ox = - (l + w)\n            if self._loc in (TR, BR, R):            # out right\n                ox = 1.0 - l\n            if self._loc in (TR, TL, T):            # out top\n                oy = 1.0 - b\n            if self._loc in (BL, BR, B):           # out bottom\n                oy = - (b + h)\n\n        self._offset(ox, oy)",
        "begin_line": 584,
        "end_line": 637,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.table.table#659",
        "src_path": "lib/matplotlib/table.py",
        "class_name": "lib.matplotlib.table",
        "signature": "lib.matplotlib.table.table(ax, cellText=None, cellColours=None, cellLoc='right', colWidths=None, rowLabels=None, rowColours=None, rowLoc='left', colLabels=None, colColours=None, colLoc='center', loc='bottom', bbox=None, edges='closed', **kwargs)",
        "snippet": "def table(ax,\n          cellText=None, cellColours=None,\n          cellLoc='right', colWidths=None,\n          rowLabels=None, rowColours=None, rowLoc='left',\n          colLabels=None, colColours=None, colLoc='center',\n          loc='bottom', bbox=None, edges='closed',\n          **kwargs):\n    \"\"\"\n    Add a table to an `~.axes.Axes`.\n\n    At least one of *cellText* or *cellColours* must be specified. These\n    parameters must be 2D lists, in which the outer lists define the rows and\n    the inner list define the column values per row. Each row must have the\n    same number of elements.\n\n    The table can optionally have row and column headers, which are configured\n    using *rowLabels*, *rowColours*, *rowLoc* and *colLabels*, *colColours*,\n    *colLoc* respectively.\n\n    For finer grained control over tables, use the `.Table` class and add it to\n    the axes with `.Axes.add_table`.\n\n    Parameters\n    ----------\n    cellText : 2D list of str, optional\n        The texts to place into the table cells.\n\n        *Note*: Line breaks in the strings are currently not accounted for and\n        will result in the text exceeding the cell boundaries.\n\n    cellColours : 2D list of colors, optional\n        The background colors of the cells.\n\n    cellLoc : {'left', 'center', 'right'}, default: 'right'\n        The alignment of the text within the cells.\n\n    colWidths : list of float, optional\n        The column widths in units of the axes. If not given, all columns will\n        have a width of *1 / ncols*.\n\n    rowLabels : list of str, optional\n        The text of the row header cells.\n\n    rowColours : list of colors, optional\n        The colors of the row header cells.\n\n    rowLoc : {'left', 'center', 'right'}, default: 'left'\n        The text alignment of the row header cells.\n\n    colLabels : list of str, optional\n        The text of the column header cells.\n\n    colColours : list of colors, optional\n        The colors of the column header cells.\n\n    colLoc : {'left', 'center', 'right'}, default: 'left'\n        The text alignment of the column header cells.\n\n    loc : str, optional\n        The position of the cell with respect to *ax*. This must be one of\n        the `~.Table.codes`.\n\n    bbox : `.Bbox`, optional\n        A bounding box to draw the table into. If this is not *None*, this\n        overrides *loc*.\n\n    edges : substring of 'BRTL' or {'open', 'closed', 'horizontal', 'vertical'}\n        The cell edges to be drawn with a line. See also\n        `~.CustomCell.visible_edges`.\n\n    Other Parameters\n    ----------------\n    **kwargs\n        `.Table` properties.\n\n    %(Table)s\n\n    Returns\n    -------\n    table : `~matplotlib.table.Table`\n        The created table.\n    \"\"\"\n\n    if cellColours is None and cellText is None:\n        raise ValueError('At least one argument from \"cellColours\" or '\n                         '\"cellText\" must be provided to create a table.')\n\n    # Check we have some cellText\n    if cellText is None:\n        # assume just colours are needed\n        rows = len(cellColours)\n        cols = len(cellColours[0])\n        cellText = [[''] * cols] * rows\n\n    rows = len(cellText)\n    cols = len(cellText[0])\n    for row in cellText:\n        if len(row) != cols:\n            raise ValueError(\"Each row in 'cellText' must have {} columns\"\n                             .format(cols))\n\n    if cellColours is not None:\n        if len(cellColours) != rows:\n            raise ValueError(\"'cellColours' must have {} rows\".format(rows))\n        for row in cellColours:\n            if len(row) != cols:\n                raise ValueError(\"Each row in 'cellColours' must have {} \"\n                                 \"columns\".format(cols))\n    else:\n        cellColours = ['w' * cols] * rows\n\n    # Set colwidths if not given\n    if colWidths is None:\n        colWidths = [1.0 / cols] * cols\n\n    # Fill in missing information for column\n    # and row labels\n    rowLabelWidth = 0\n    if rowLabels is None:\n        if rowColours is not None:\n            rowLabels = [''] * rows\n            rowLabelWidth = colWidths[0]\n    elif rowColours is None:\n        rowColours = 'w' * rows\n\n    if rowLabels is not None:\n        if len(rowLabels) != rows:\n            raise ValueError(\"'rowLabels' must be of length {0}\".format(rows))\n\n    # If we have column labels, need to shift\n    # the text and colour arrays down 1 row\n    offset = 1\n    if colLabels is None:\n        if colColours is not None:\n            colLabels = [''] * cols\n        else:\n            offset = 0\n    elif colColours is None:\n        colColours = 'w' * cols\n\n    # Set up cell colours if not given\n    if cellColours is None:\n        cellColours = ['w' * cols] * rows\n\n    # Now create the table\n    table = Table(ax, loc, bbox, **kwargs)\n    table.edges = edges\n    height = table._approx_text_height()\n\n    # Add the cells\n    for row in range(rows):\n        for col in range(cols):\n            table.add_cell(row + offset, col,\n                           width=colWidths[col], height=height,\n                           text=cellText[row][col],\n                           facecolor=cellColours[row][col],\n                           loc=cellLoc)\n    # Do column labels\n    if colLabels is not None:\n        for col in range(cols):\n            table.add_cell(0, col,\n                           width=colWidths[col], height=height,\n                           text=colLabels[col], facecolor=colColours[col],\n                           loc=colLoc)\n\n    # Do row labels\n    if rowLabels is not None:\n        for row in range(rows):\n            table.add_cell(row + offset, -1,\n                           width=rowLabelWidth or 1e-15, height=height,\n                           text=rowLabels[row], facecolor=rowColours[row],\n                           loc=rowLoc)\n        if rowLabelWidth == 0:\n            table.auto_set_column_width(-1)\n\n    ax.add_table(table)\n    return table",
        "begin_line": 659,
        "end_line": 835,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.get_fontext_synonyms#134",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.get_fontext_synonyms(fontext)",
        "snippet": "def get_fontext_synonyms(fontext):\n    \"\"\"\n    Return a list of file extensions extensions that are synonyms for\n    the given file extension *fileext*.\n    \"\"\"\n    return {\n        'afm': ['afm'],\n        'otf': ['otf', 'ttc', 'ttf'],\n        'ttc': ['otf', 'ttc', 'ttf'],\n        'ttf': ['otf', 'ttc', 'ttf'],\n    }[fontext]",
        "begin_line": 134,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.022222222222222223,
            "pseudo_dstar_susp": 0.0005662514156285391,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0005662514156285391,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.font_manager.list_fonts#147",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.list_fonts(directory, extensions)",
        "snippet": "def list_fonts(directory, extensions):\n    \"\"\"\n    Return a list of all fonts matching any of the extensions, found\n    recursively under the directory.\n    \"\"\"\n    extensions = [\".\" + ext for ext in extensions]\n    return [os.path.join(dirpath, filename)\n            # os.walk ignores access errors, unlike Path.glob.\n            for dirpath, _, filenames in os.walk(directory)\n            for filename in filenames\n            if Path(filename).suffix.lower() in extensions]",
        "begin_line": 147,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.022222222222222223,
            "pseudo_dstar_susp": 0.0005662514156285391,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0005662514156285391,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.font_manager._call_fc_list#257",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager._call_fc_list()",
        "snippet": "def _call_fc_list():\n    \"\"\"Cache and list the font filenames known to `fc-list`.\n    \"\"\"\n    # Delay the warning by 5s.\n    timer = Timer(5, lambda: _log.warning(\n        'Matplotlib is building the font cache using fc-list. '\n        'This may take a moment.'))\n    timer.start()\n    try:\n        if b'--format' not in subprocess.check_output(['fc-list', '--help']):\n            _log.warning(  # fontconfig 2.7 implemented --format.\n                'Matplotlib needs fontconfig>=2.7 to query system fonts.')\n            return []\n        out = subprocess.check_output(['fc-list', '--format=%{file}\\\\n'])\n    except (OSError, subprocess.CalledProcessError):\n        return []\n    finally:\n        timer.cancel()\n    return [os.fsdecode(fname) for fname in out.split(b'\\n')]",
        "begin_line": 257,
        "end_line": 275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.font_manager.get_fontconfig_fonts#278",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.get_fontconfig_fonts(fontext='ttf')",
        "snippet": "def get_fontconfig_fonts(fontext='ttf'):\n    \"\"\"List the font filenames known to `fc-list` having the given extension.\n    \"\"\"\n    fontext = ['.' + ext for ext in get_fontext_synonyms(fontext)]\n    return [fname for fname in _call_fc_list()\n            if Path(fname).suffix.lower() in fontext]",
        "begin_line": 278,
        "end_line": 283,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.font_manager.findSystemFonts#286",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.findSystemFonts(fontpaths=None, fontext='ttf')",
        "snippet": "def findSystemFonts(fontpaths=None, fontext='ttf'):\n    \"\"\"\n    Search for fonts in the specified font paths.  If no paths are\n    given, will use a standard set of system paths, as well as the\n    list of fonts tracked by fontconfig if fontconfig is installed and\n    available.  A list of TrueType fonts are returned by default with\n    AFM fonts as an option.\n    \"\"\"\n    fontfiles = set()\n    fontexts = get_fontext_synonyms(fontext)\n\n    if fontpaths is None:\n        if sys.platform == 'win32':\n            fontpaths = MSUserFontDirectories + [win32FontDirectory()]\n            # now get all installed fonts directly...\n            fontfiles.update(win32InstalledFonts(fontext=fontext))\n        else:\n            fontpaths = X11FontDirectories\n            if sys.platform == 'darwin':\n                fontpaths = [*X11FontDirectories, *OSXFontDirectories]\n            fontfiles.update(get_fontconfig_fonts(fontext))\n\n    elif isinstance(fontpaths, str):\n        fontpaths = [fontpaths]\n\n    for path in fontpaths:\n        fontfiles.update(map(os.path.abspath, list_fonts(path, fontexts)))\n\n    return [fname for fname in fontfiles if os.path.exists(fname)]",
        "begin_line": 286,
        "end_line": 314,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontEntry.__init__#322",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontEntry",
        "signature": "lib.matplotlib.font_manager.FontEntry.__init__(self, fname='', name='', style='normal', variant='normal', weight='normal', stretch='normal', size='medium')",
        "snippet": "    def __init__(self,\n                 fname  ='',\n                 name   ='',\n                 style  ='normal',\n                 variant='normal',\n                 weight ='normal',\n                 stretch='normal',\n                 size   ='medium',\n                 ):\n        self.fname   = fname\n        self.name    = name\n        self.style   = style\n        self.variant = variant\n        self.weight  = weight\n        self.stretch = stretch\n        try:\n            self.size = str(float(size))\n        except ValueError:\n            self.size = size",
        "begin_line": 322,
        "end_line": 340,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.afmFontProperty#431",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.afmFontProperty(fontpath, font)",
        "snippet": "def afmFontProperty(fontpath, font):\n    \"\"\"\n    Extract information from an AFM font file.\n\n    Parameters\n    ----------\n    font : `.AFM`\n        The AFM font file from which information will be extracted.\n\n    Returns\n    -------\n    `FontEntry`\n        The extracted font properties.\n    \"\"\"\n\n    name = font.get_familyname()\n    fontname = font.get_fontname().lower()\n\n    #  Styles are: italic, oblique, and normal (default)\n\n    if font.get_angle() != 0 or 'italic' in name.lower():\n        style = 'italic'\n    elif 'oblique' in name.lower():\n        style = 'oblique'\n    else:\n        style = 'normal'\n\n    #  Variants are: small-caps and normal (default)\n\n    # !!!!  Untested\n    if name.lower() in ['capitals', 'small-caps']:\n        variant = 'small-caps'\n    else:\n        variant = 'normal'\n\n    weight = font.get_weight().lower()\n    if weight not in weight_dict:\n        weight = 'normal'\n\n    #  Stretch can be absolute and relative\n    #  Absolute stretches are: ultra-condensed, extra-condensed, condensed,\n    #    semi-condensed, normal, semi-expanded, expanded, extra-expanded,\n    #    and ultra-expanded.\n    #  Relative stretches are: wider, narrower\n    #  Child value is: inherit\n    if 'demi cond' in fontname:\n        stretch = 'semi-condensed'\n    elif any(word in fontname for word in ['narrow', 'cond']):\n        stretch = 'condensed'\n    elif any(word in fontname for word in ['wide', 'expanded', 'extended']):\n        stretch = 'expanded'\n    else:\n        stretch = 'normal'\n\n    #  Sizes can be absolute and relative.\n    #  Absolute sizes are: xx-small, x-small, small, medium, large, x-large,\n    #    and xx-large.\n    #  Relative sizes are: larger, smaller\n    #  Length value is an absolute font size, e.g., 12pt\n    #  Percentage values are in 'em's.  Most robust specification.\n\n    #  All AFM fonts are apparently scalable.\n\n    size = 'scalable'\n\n    return FontEntry(fontpath, name, style, variant, weight, stretch, size)",
        "begin_line": 431,
        "end_line": 496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.__init__#615",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.__init__(self, family=None, style=None, variant=None, weight=None, stretch=None, size=None, fname=None)",
        "snippet": "    def __init__(self,\n                 family = None,\n                 style  = None,\n                 variant= None,\n                 weight = None,\n                 stretch= None,\n                 size   = None,\n                 fname  = None,  # if set, it's a hardcoded filename to use\n                 ):\n        self._family = _normalize_font_family(rcParams['font.family'])\n        self._slant = rcParams['font.style']\n        self._variant = rcParams['font.variant']\n        self._weight = rcParams['font.weight']\n        self._stretch = rcParams['font.stretch']\n        self._size = rcParams['font.size']\n        self._file = None\n\n        if isinstance(family, str):\n            # Treat family as a fontconfig pattern if it is the only\n            # parameter provided.\n            if (style is None and\n                variant is None and\n                weight is None and\n                stretch is None and\n                size is None and\n                fname is None):\n                self.set_fontconfig_pattern(family)\n                return\n\n        self.set_family(family)\n        self.set_style(style)\n        self.set_variant(variant)\n        self.set_weight(weight)\n        self.set_stretch(stretch)\n        self.set_file(fname)\n        self.set_size(size)",
        "begin_line": 615,
        "end_line": 650,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002145922746781116,
            "pseudo_dstar_susp": 0.0014124293785310734,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.0014124293785310734,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties._from_any#653",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties._from_any(cls, arg)",
        "snippet": "    def _from_any(cls, arg):\n        if isinstance(arg, cls):\n            return arg\n        elif isinstance(arg, os.PathLike):\n            return cls(fname=arg)\n        elif isinstance(arg, str):\n            return cls(arg)\n        else:\n            return cls(**arg)",
        "begin_line": 653,
        "end_line": 661,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001607717041800643,
            "pseudo_dstar_susp": 0.0013986013986013986,
            "pseudo_tarantula_susp": 0.0006680026720106881,
            "pseudo_op2_susp": 0.0013986013986013986,
            "pseudo_barinel_susp": 0.0006680026720106881
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.__hash__#663",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.__hash__(self)",
        "snippet": "    def __hash__(self):\n        l = (tuple(self.get_family()),\n             self.get_slant(),\n             self.get_variant(),\n             self.get_weight(),\n             self.get_stretch(),\n             self.get_size_in_points(),\n             self.get_file())\n        return hash(l)",
        "begin_line": 663,
        "end_line": 671,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.__str__#676",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.__str__(self)",
        "snippet": "    def __str__(self):\n        return self.get_fontconfig_pattern()",
        "begin_line": 676,
        "end_line": 677,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.get_family#679",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.get_family(self)",
        "snippet": "    def get_family(self):\n        \"\"\"\n        Return a list of font names that comprise the font family.\n        \"\"\"\n        return self._family",
        "begin_line": 679,
        "end_line": 683,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.get_style#691",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.get_style(self)",
        "snippet": "    def get_style(self):\n        \"\"\"\n        Return the font style.  Values are: 'normal', 'italic' or 'oblique'.\n        \"\"\"\n        return self._slant",
        "begin_line": 691,
        "end_line": 695,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.3905531035778e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.get_variant#698",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.get_variant(self)",
        "snippet": "    def get_variant(self):\n        \"\"\"\n        Return the font variant.  Values are: 'normal' or 'small-caps'.\n        \"\"\"\n        return self._variant",
        "begin_line": 698,
        "end_line": 702,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031867431485022306,
            "pseudo_dstar_susp": 0.0003118178983473651,
            "pseudo_tarantula_susp": 0.00037064492216456633,
            "pseudo_op2_susp": 0.0003118178983473651,
            "pseudo_barinel_susp": 0.00037064492216456633
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.get_weight#704",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.get_weight(self)",
        "snippet": "    def get_weight(self):\n        \"\"\"\n        Set the font weight.  Options are: A numeric value in the\n        range 0-1000 or one of 'light', 'normal', 'regular', 'book',\n        'medium', 'roman', 'semibold', 'demibold', 'demi', 'bold',\n        'heavy', 'extra bold', 'black'\n        \"\"\"\n        return self._weight",
        "begin_line": 704,
        "end_line": 711,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.000090000900009e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.get_stretch#713",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.get_stretch(self)",
        "snippet": "    def get_stretch(self):\n        \"\"\"\n        Return the font stretch or width.  Options are: 'ultra-condensed',\n        'extra-condensed', 'condensed', 'semi-condensed', 'normal',\n        'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded'.\n        \"\"\"\n        return self._stretch",
        "begin_line": 713,
        "end_line": 719,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.get_file#730",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.get_file(self)",
        "snippet": "    def get_file(self):\n        \"\"\"\n        Return the filename of the associated font.\n        \"\"\"\n        return self._file",
        "begin_line": 730,
        "end_line": 734,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_family#746",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_family(self, family)",
        "snippet": "    def set_family(self, family):\n        \"\"\"\n        Change the font family.  May be either an alias (generic name\n        is CSS parlance), such as: 'serif', 'sans-serif', 'cursive',\n        'fantasy', or 'monospace', a real font name or a list of real\n        font names.  Real font names are not supported when\n        :rc:`text.usetex` is `True`.\n        \"\"\"\n        if family is None:\n            family = rcParams['font.family']\n        self._family = _normalize_font_family(family)",
        "begin_line": 746,
        "end_line": 756,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006381620931716656,
            "pseudo_dstar_susp": 0.0008156606851549756,
            "pseudo_tarantula_susp": 0.00039603960396039607,
            "pseudo_op2_susp": 0.0008156606851549756,
            "pseudo_barinel_susp": 0.00039603960396039607
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_style#759",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_style(self, style)",
        "snippet": "    def set_style(self, style):\n        \"\"\"\n        Set the font style.  Values are: 'normal', 'italic' or 'oblique'.\n        \"\"\"\n        if style is None:\n            style = rcParams['font.style']\n        cbook._check_in_list(['normal', 'italic', 'oblique'], style=style)\n        self._slant = style",
        "begin_line": 759,
        "end_line": 766,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029069767441860465,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0009182736455463728,
            "pseudo_op2_susp": 0.0011507479861910242,
            "pseudo_barinel_susp": 0.0009182736455463728
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_variant#769",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_variant(self, variant)",
        "snippet": "    def set_variant(self, variant):\n        \"\"\"\n        Set the font variant.  Values are: 'normal' or 'small-caps'.\n        \"\"\"\n        if variant is None:\n            variant = rcParams['font.variant']\n        cbook._check_in_list(['normal', 'small-caps'], variant=variant)\n        self._variant = variant",
        "begin_line": 769,
        "end_line": 776,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006915629322268327,
            "pseudo_dstar_susp": 0.0014084507042253522,
            "pseudo_tarantula_susp": 0.0006385696040868455,
            "pseudo_op2_susp": 0.0014084507042253522,
            "pseudo_barinel_susp": 0.0006385696040868455
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_weight#778",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_weight(self, weight)",
        "snippet": "    def set_weight(self, weight):\n        \"\"\"\n        Set the font weight.  May be either a numeric value in the\n        range 0-1000 or one of 'ultralight', 'light', 'normal',\n        'regular', 'book', 'medium', 'roman', 'semibold', 'demibold',\n        'demi', 'bold', 'heavy', 'extra bold', 'black'\n        \"\"\"\n        if weight is None:\n            weight = rcParams['font.weight']\n        try:\n            weight = int(weight)\n            if weight < 0 or weight > 1000:\n                raise ValueError()\n        except ValueError:\n            if weight not in weight_dict:\n                raise ValueError(\"weight is invalid\")\n        self._weight = weight",
        "begin_line": 778,
        "end_line": 794,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002577319587628866,
            "pseudo_dstar_susp": 0.0011123470522803114,
            "pseudo_tarantula_susp": 0.001004016064257028,
            "pseudo_op2_susp": 0.0011123470522803114,
            "pseudo_barinel_susp": 0.0010030090270812437
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_stretch#796",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_stretch(self, stretch)",
        "snippet": "    def set_stretch(self, stretch):\n        \"\"\"\n        Set the font stretch or width.  Options are: 'ultra-condensed',\n        'extra-condensed', 'condensed', 'semi-condensed', 'normal',\n        'semi-expanded', 'expanded', 'extra-expanded' or\n        'ultra-expanded', or a numeric value in the range 0-1000.\n        \"\"\"\n        if stretch is None:\n            stretch = rcParams['font.stretch']\n        try:\n            stretch = int(stretch)\n            if stretch < 0 or stretch > 1000:\n                raise ValueError()\n        except ValueError as err:\n            if stretch not in stretch_dict:\n                raise ValueError(\"stretch is invalid\") from err\n        self._stretch = stretch",
        "begin_line": 796,
        "end_line": 812,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0026595744680851063,
            "pseudo_dstar_susp": 0.0011235955056179776,
            "pseudo_tarantula_susp": 0.001455604075691412,
            "pseudo_op2_susp": 0.0011235955056179776,
            "pseudo_barinel_susp": 0.001455604075691412
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_size#814",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_size(self, size)",
        "snippet": "    def set_size(self, size):\n        \"\"\"\n        Set the font size.  Either an relative value of 'xx-small',\n        'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'\n        or an absolute font size, e.g., 12.\n        \"\"\"\n        if size is None:\n            size = rcParams['font.size']\n        try:\n            size = float(size)\n        except ValueError:\n            try:\n                scale = font_scalings[size]\n            except KeyError as err:\n                raise ValueError(\n                    \"Size is invalid. Valid font size are \"\n                    + \", \".join(map(str, font_scalings))) from err\n            else:\n                size = scale * FontManager.get_default_size()\n        if size < 1.0:\n            _log.info('Fontsize %1.2f < 1.0 pt not allowed by FreeType. '\n                      'Setting fontsize = 1 pt', size)\n            size = 1.0\n        self._size = size",
        "begin_line": 814,
        "end_line": 837,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002197802197802198,
            "pseudo_dstar_susp": 0.002325581395348837,
            "pseudo_tarantula_susp": 0.0014858841010401188,
            "pseudo_op2_susp": 0.002325581395348837,
            "pseudo_barinel_susp": 0.001483679525222552
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_file#839",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_file(self, file)",
        "snippet": "    def set_file(self, file):\n        \"\"\"\n        Set the filename of the fontfile to use.  In this case, all\n        other properties will be ignored.\n        \"\"\"\n        self._file = os.fspath(file) if file is not None else None",
        "begin_line": 839,
        "end_line": 844,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018832391713747645,
            "pseudo_dstar_susp": 0.0010193679918450561,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.0010193679918450561,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.set_fontconfig_pattern#846",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.set_fontconfig_pattern(self, pattern)",
        "snippet": "    def set_fontconfig_pattern(self, pattern):\n        \"\"\"\n        Set the properties by parsing a fontconfig_ *pattern*.\n\n        This support does not depend on fontconfig; we are merely borrowing its\n        pattern syntax for use here.\n        \"\"\"\n        for key, val in parse_fontconfig_pattern(pattern).items():\n            if type(val) == list:\n                getattr(self, \"set_\" + key)(val[0])\n            else:\n                getattr(self, \"set_\" + key)(val)",
        "begin_line": 846,
        "end_line": 857,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontProperties.copy#859",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontProperties",
        "signature": "lib.matplotlib.font_manager.FontProperties.copy(self)",
        "snippet": "    def copy(self):\n        \"\"\"Return a copy of self.\"\"\"\n        new = type(self)()\n        vars(new).update(vars(self))\n        return new",
        "begin_line": 859,
        "end_line": 863,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002638522427440633,
            "pseudo_dstar_susp": 0.0011198208286674132,
            "pseudo_tarantula_susp": 0.001422475106685633,
            "pseudo_op2_susp": 0.0011198208286674132,
            "pseudo_barinel_susp": 0.001422475106685633
        }
    },
    {
        "name": "lib.matplotlib.font_manager._JSONEncoder.default#867",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager._JSONEncoder",
        "signature": "lib.matplotlib.font_manager._JSONEncoder.default(self, o)",
        "snippet": "    def default(self, o):\n        if isinstance(o, FontManager):\n            return dict(o.__dict__, __class__='FontManager')\n        elif isinstance(o, FontEntry):\n            d = dict(o.__dict__, __class__='FontEntry')\n            try:\n                # Cache paths of fonts shipped with Matplotlib relative to the\n                # Matplotlib data path, which helps in the presence of venvs.\n                d[\"fname\"] = str(\n                    Path(d[\"fname\"]).relative_to(mpl.get_data_path()))\n            except ValueError:\n                pass\n            return d\n        else:\n            return super().default(o)",
        "begin_line": 867,
        "end_line": 881,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager._json_decode#889",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager._json_decode(o)",
        "snippet": "def _json_decode(o):\n    cls = o.pop('__class__', None)\n    if cls is None:\n        return o\n    elif cls == 'FontManager':\n        r = FontManager.__new__(FontManager)\n        r.__dict__.update(o)\n        return r\n    elif cls == 'FontEntry':\n        r = FontEntry.__new__(FontEntry)\n        r.__dict__.update(o)\n        if not os.path.isabs(r.fname):\n            r.fname = os.path.join(mpl.get_data_path(), r.fname)\n        return r\n    else:\n        raise ValueError(\"Don't know how to deserialize __class__=%s\" % cls)",
        "begin_line": 889,
        "end_line": 904,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.json_dump#907",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.json_dump(data, filename)",
        "snippet": "def json_dump(data, filename):\n    \"\"\"\n    Dump `FontManager` *data* as JSON to the file named *filename*.\n\n    Notes\n    -----\n    File paths that are children of the Matplotlib data path (typically, fonts\n    shipped with Matplotlib) are stored relative to that data path (to remain\n    valid across virtualenvs).\n\n    See Also\n    --------\n    json_load\n    \"\"\"\n    with open(filename, 'w') as fh:\n        try:\n            json.dump(data, fh, cls=_JSONEncoder, indent=2)\n        except OSError as e:\n            _log.warning('Could not save font_manager cache {}'.format(e))",
        "begin_line": 907,
        "end_line": 925,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.json_load#928",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.json_load(filename)",
        "snippet": "def json_load(filename):\n    \"\"\"\n    Load a `FontManager` from the JSON file named *filename*.\n\n    See Also\n    --------\n    json_dump\n    \"\"\"\n    with open(filename, 'r') as fh:\n        return json.load(fh, object_hook=_json_decode)",
        "begin_line": 928,
        "end_line": 937,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager._normalize_font_family#940",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager._normalize_font_family(family)",
        "snippet": "def _normalize_font_family(family):\n    if isinstance(family, str):\n        family = [family]\n    return family",
        "begin_line": 940,
        "end_line": 943,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006844626967830253,
            "pseudo_dstar_susp": 0.0008203445447087777,
            "pseudo_tarantula_susp": 0.0009267840593141798,
            "pseudo_op2_susp": 0.0008203445447087777,
            "pseudo_barinel_susp": 0.0009267840593141798
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.addfont#1000",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.addfont(self, path)",
        "snippet": "    def addfont(self, path):\n        \"\"\"\n        Cache the properties of the font at *path* to make it available to the\n        `FontManager`.  The type of font is inferred from the path suffix.\n\n        Parameters\n        ----------\n        path : str or path-like\n        \"\"\"\n        if Path(path).suffix.lower() == \".afm\":\n            with open(path, \"rb\") as fh:\n                font = afm.AFM(fh)\n            prop = afmFontProperty(path, font)\n            self.afmlist.append(prop)\n        else:\n            font = ft2font.FT2Font(path)\n            prop = ttfFontProperty(font)\n            self.ttflist.append(prop)",
        "begin_line": 1000,
        "end_line": 1017,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.5,
            "pseudo_dstar_susp": 0.0006297229219143577,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.score_family#1047",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.score_family(self, families, family2)",
        "snippet": "    def score_family(self, families, family2):\n        \"\"\"\n        Returns a match score between the list of font families in\n        *families* and the font family name *family2*.\n\n        An exact match at the head of the list returns 0.0.\n\n        A match further down the list will return between 0 and 1.\n\n        No match will return 1.0.\n        \"\"\"\n        if not isinstance(families, (list, tuple)):\n            families = [families]\n        elif len(families) == 0:\n            return 1.0\n        family2 = family2.lower()\n        step = 1 / len(families)\n        for i, family1 in enumerate(families):\n            family1 = family1.lower()\n            if family1 in font_family_aliases:\n                if family1 in ('sans', 'sans serif'):\n                    family1 = 'sans-serif'\n                options = rcParams['font.' + family1]\n                options = [x.lower() for x in options]\n                if family2 in options:\n                    idx = options.index(family2)\n                    return (i + (idx / len(options))) * step\n            elif family1 == family2:\n                # The score should be weighted by where in the\n                # list the font was found.\n                return i * step\n        return 1.0",
        "begin_line": 1047,
        "end_line": 1078,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.score_style#1080",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.score_style(self, style1, style2)",
        "snippet": "    def score_style(self, style1, style2):\n        \"\"\"\n        Returns a match score between *style1* and *style2*.\n\n        An exact match returns 0.0.\n\n        A match between 'italic' and 'oblique' returns 0.1.\n\n        No match returns 1.0.\n        \"\"\"\n        if style1 == style2:\n            return 0.0\n        elif (style1 in ('italic', 'oblique')\n              and style2 in ('italic', 'oblique')):\n            return 0.1\n        return 1.0",
        "begin_line": 1080,
        "end_line": 1095,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.score_variant#1097",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.score_variant(self, variant1, variant2)",
        "snippet": "    def score_variant(self, variant1, variant2):\n        \"\"\"\n        Returns a match score between *variant1* and *variant2*.\n\n        An exact match returns 0.0, otherwise 1.0.\n        \"\"\"\n        if variant1 == variant2:\n            return 0.0\n        else:\n            return 1.0",
        "begin_line": 1097,
        "end_line": 1106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.score_stretch#1108",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.score_stretch(self, stretch1, stretch2)",
        "snippet": "    def score_stretch(self, stretch1, stretch2):\n        \"\"\"\n        Returns a match score between *stretch1* and *stretch2*.\n\n        The result is the absolute value of the difference between the\n        CSS numeric values of *stretch1* and *stretch2*, normalized\n        between 0.0 and 1.0.\n        \"\"\"\n        try:\n            stretchval1 = int(stretch1)\n        except ValueError:\n            stretchval1 = stretch_dict.get(stretch1, 500)\n        try:\n            stretchval2 = int(stretch2)\n        except ValueError:\n            stretchval2 = stretch_dict.get(stretch2, 500)\n        return abs(stretchval1 - stretchval2) / 1000.0",
        "begin_line": 1108,
        "end_line": 1124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.score_weight#1126",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.score_weight(self, weight1, weight2)",
        "snippet": "    def score_weight(self, weight1, weight2):\n        \"\"\"\n        Returns a match score between *weight1* and *weight2*.\n\n        The result is 0.0 if both weight1 and weight 2 are given as strings\n        and have the same value.\n\n        Otherwise, the result is the absolute value of the difference between\n        the CSS numeric values of *weight1* and *weight2*, normalized between\n        0.05 and 1.0.\n        \"\"\"\n        # exact match of the weight names, e.g. weight1 == weight2 == \"regular\"\n        if cbook._str_equal(weight1, weight2):\n            return 0.0\n        w1 = weight1 if isinstance(weight1, Number) else weight_dict[weight1]\n        w2 = weight2 if isinstance(weight2, Number) else weight_dict[weight2]\n        return 0.95 * (abs(w1 - w2) / 1000) + 0.05",
        "begin_line": 1126,
        "end_line": 1142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.score_size#1144",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.score_size(self, size1, size2)",
        "snippet": "    def score_size(self, size1, size2):\n        \"\"\"\n        Returns a match score between *size1* and *size2*.\n\n        If *size2* (the size specified in the font file) is 'scalable', this\n        function always returns 0.0, since any font size can be generated.\n\n        Otherwise, the result is the absolute distance between *size1* and\n        *size2*, normalized so that the usual range of font sizes (6pt -\n        72pt) will lie between 0.0 and 1.0.\n        \"\"\"\n        if size2 == 'scalable':\n            return 0.0\n        # Size value should have already been\n        try:\n            sizeval1 = float(size1)\n        except ValueError:\n            sizeval1 = self.default_size * font_scalings[size1]\n        try:\n            sizeval2 = float(size2)\n        except ValueError:\n            return 1.0\n        return abs(sizeval1 - sizeval2) / 72",
        "begin_line": 1144,
        "end_line": 1166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager.findfont#1168",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager.findfont(self, prop, fontext='ttf', directory=None, fallback_to_default=True, rebuild_if_missing=True)",
        "snippet": "    def findfont(self, prop, fontext='ttf', directory=None,\n                 fallback_to_default=True, rebuild_if_missing=True):\n        \"\"\"\n        Find a font that most closely matches the given font properties.\n\n        Parameters\n        ----------\n        prop : str or `~matplotlib.font_manager.FontProperties`\n            The font properties to search for. This can be either a\n            `.FontProperties` object or a string defining a\n            `fontconfig patterns`_.\n\n        fontext : {'ttf', 'afm'}, default: 'ttf'\n            The extension of the font file:\n\n            - 'ttf': TrueType and OpenType fonts (.ttf, .ttc, .otf)\n            - 'afm': Adobe Font Metrics (.afm)\n\n        directory : str, optional\n            If given, only search this directory and its subdirectories.\n\n        fallback_to_default : bool\n            If True, will fallback to the default font family (usually\n            \"DejaVu Sans\" or \"Helvetica\") if the first lookup hard-fails.\n\n        rebuild_if_missing : bool\n            Whether to rebuild the font cache and search again if the first\n            match appears to point to a nonexisting font (i.e., the font cache\n            contains outdated entries).\n\n        Returns\n        -------\n        fontfile : str\n            The filename of the best matching font.\n\n        Notes\n        -----\n        This performs a nearest neighbor search.  Each font is given a\n        similarity score to the target font properties.  The first font with\n        the highest score is returned.  If no matches below a certain\n        threshold are found, the default font (usually DejaVu Sans) is\n        returned.\n\n        The result is cached, so subsequent lookups don't have to\n        perform the O(n) nearest neighbor search.\n\n        See the `W3C Cascading Style Sheet, Level 1\n        <http://www.w3.org/TR/1998/REC-CSS2-19980512/>`_ documentation\n        for a description of the font finding algorithm.\n\n        .. _fontconfig patterns:\n           https://www.freedesktop.org/software/fontconfig/fontconfig-user.html\n        \"\"\"\n        # Pass the relevant rcParams (and the font manager, as `self`) to\n        # _findfont_cached so to prevent using a stale cache entry after an\n        # rcParam was changed.\n        rc_params = tuple(tuple(rcParams[key]) for key in [\n            \"font.serif\", \"font.sans-serif\", \"font.cursive\", \"font.fantasy\",\n            \"font.monospace\"])\n        filename = self._findfont_cached(\n            prop, fontext, directory, fallback_to_default, rebuild_if_missing,\n            rc_params)\n        return os.path.realpath(filename)",
        "begin_line": 1168,
        "end_line": 1230,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043271311120726956,
            "pseudo_dstar_susp": 0.00038580246913580245,
            "pseudo_tarantula_susp": 0.001392757660167131,
            "pseudo_op2_susp": 0.00038580246913580245,
            "pseudo_barinel_susp": 0.001392757660167131
        }
    },
    {
        "name": "lib.matplotlib.font_manager.FontManager._findfont_cached#1233",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager.FontManager",
        "signature": "lib.matplotlib.font_manager.FontManager._findfont_cached(self, prop, fontext, directory, fallback_to_default, rebuild_if_missing, rc_params)",
        "snippet": "    def _findfont_cached(self, prop, fontext, directory, fallback_to_default,\n                         rebuild_if_missing, rc_params):\n\n        prop = FontProperties._from_any(prop)\n\n        fname = prop.get_file()\n        if fname is not None:\n            return fname\n\n        if fontext == 'afm':\n            fontlist = self.afmlist\n        else:\n            fontlist = self.ttflist\n\n        best_score = 1e64\n        best_font = None\n\n        _log.debug('findfont: Matching %s.', prop)\n        for font in fontlist:\n            if (directory is not None and\n                    Path(directory) not in Path(font.fname).parents):\n                continue\n            # Matching family should have top priority, so multiply it by 10.\n            score = (self.score_family(prop.get_family(), font.name) * 10\n                     + self.score_style(prop.get_style(), font.style)\n                     + self.score_variant(prop.get_variant(), font.variant)\n                     + self.score_weight(prop.get_weight(), font.weight)\n                     + self.score_stretch(prop.get_stretch(), font.stretch)\n                     + self.score_size(prop.get_size(), font.size))\n            _log.debug('findfont: score(%s) = %s', font, score)\n            if score < best_score:\n                best_score = score\n                best_font = font\n            if score == 0:\n                break\n\n        if best_font is None or best_score >= 10.0:\n            if fallback_to_default:\n                _log.warning(\n                    'findfont: Font family %s not found. Falling back to %s.',\n                    prop.get_family(), self.defaultFamily[fontext])\n                default_prop = prop.copy()\n                default_prop.set_family(self.defaultFamily[fontext])\n                return self.findfont(default_prop, fontext, directory,\n                                     fallback_to_default=False)\n            else:\n                raise ValueError(f\"Failed to find font {prop}, and fallback \"\n                                 f\"to the default font was disabled\")\n        else:\n            _log.debug('findfont: Matching %s to %s (%r) with score of %f.',\n                       prop, best_font.name, best_font.fname, best_score)\n            result = best_font.fname\n\n        if not os.path.isfile(result):\n            if rebuild_if_missing:\n                _log.info(\n                    'findfont: Found a missing font file.  Rebuilding cache.')\n                _rebuild()\n                return fontManager.findfont(\n                    prop, fontext, directory, rebuild_if_missing=False)\n            else:\n                raise ValueError(\"No valid font could be found\")\n\n        return result",
        "begin_line": 1233,
        "end_line": 1296,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.font_manager.get_font#1327",
        "src_path": "lib/matplotlib/font_manager.py",
        "class_name": "lib.matplotlib.font_manager",
        "signature": "lib.matplotlib.font_manager.get_font(filename, hinting_factor=None)",
        "snippet": "def get_font(filename, hinting_factor=None):\n    # Resolving the path avoids embedding the font twice in pdf/ps output if a\n    # single font is selected using two different relative paths.\n    filename = os.path.realpath(filename)\n    if hinting_factor is None:\n        hinting_factor = rcParams['text.hinting_factor']\n    return _get_font(os.fspath(filename), hinting_factor,\n                     _kerning_factor=rcParams['text.kerning_factor'])",
        "begin_line": 1327,
        "end_line": 1334,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.__init__#88",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.__init__(self, edgecolors=None, facecolors=None, linewidths=None, linestyles='solid', capstyle=None, joinstyle=None, antialiaseds=None, offsets=None, transOffset=None, norm=None, cmap=None, pickradius=5.0, hatch=None, urls=None, offset_position='screen', zorder=1, **kwargs)",
        "snippet": "    def __init__(self,\n                 edgecolors=None,\n                 facecolors=None,\n                 linewidths=None,\n                 linestyles='solid',\n                 capstyle=None,\n                 joinstyle=None,\n                 antialiaseds=None,\n                 offsets=None,\n                 transOffset=None,\n                 norm=None,  # optional for ScalarMappable\n                 cmap=None,  # ditto\n                 pickradius=5.0,\n                 hatch=None,\n                 urls=None,\n                 offset_position='screen',\n                 zorder=1,\n                 **kwargs\n                 ):\n        \"\"\"\n        Create a Collection\n\n        %(Collection)s\n        \"\"\"\n        artist.Artist.__init__(self)\n        cm.ScalarMappable.__init__(self, norm, cmap)\n        # list of un-scaled dash patterns\n        # this is needed scaling the dash pattern by linewidth\n        self._us_linestyles = [(0, None)]\n        # list of dash patterns\n        self._linestyles = [(0, None)]\n        # list of unbroadcast/scaled linewidths\n        self._us_lw = [0]\n        self._linewidths = [0]\n        self._is_filled = True  # May be modified by set_facecolor().\n\n        self._hatch_color = mcolors.to_rgba(mpl.rcParams['hatch.color'])\n        self.set_facecolor(facecolors)\n        self.set_edgecolor(edgecolors)\n        self.set_linewidth(linewidths)\n        self.set_linestyle(linestyles)\n        self.set_antialiased(antialiaseds)\n        self.set_pickradius(pickradius)\n        self.set_urls(urls)\n        self.set_hatch(hatch)\n        self.set_offset_position(offset_position)\n        self.set_zorder(zorder)\n\n        if capstyle:\n            self.set_capstyle(capstyle)\n        else:\n            self._capstyle = None\n\n        if joinstyle:\n            self.set_joinstyle(joinstyle)\n        else:\n            self._joinstyle = None\n\n        self._offsets = np.zeros((1, 2))\n        # save if offsets passed in were none...\n        self._offsetsNone = offsets is None\n        self._uniform_offsets = None\n        if offsets is not None:\n            offsets = np.asanyarray(offsets, float)\n            # Broadcast (2,) -> (1, 2) but nothing else.\n            if offsets.shape == (2,):\n                offsets = offsets[None, :]\n            if transOffset is not None:\n                self._offsets = offsets\n                self._transOffset = transOffset\n            else:\n                self._uniform_offsets = offsets\n\n        self._path_effects = None\n        self.update(kwargs)\n        self._paths = None",
        "begin_line": 88,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013477088948787063,
            "pseudo_dstar_susp": 0.0007662835249042146,
            "pseudo_tarantula_susp": 0.001128668171557562,
            "pseudo_op2_susp": 0.0007662835249042146,
            "pseudo_barinel_susp": 0.001128668171557562
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.get_paths#165",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.get_paths(self)",
        "snippet": "    def get_paths(self):\n        return self._paths",
        "begin_line": 165,
        "end_line": 166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010615711252653928,
            "pseudo_dstar_susp": 0.0007627765064836003,
            "pseudo_tarantula_susp": 0.0010695187165775401,
            "pseudo_op2_susp": 0.0007627765064836003,
            "pseudo_barinel_susp": 0.0010695187165775401
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.get_offset_transform#174",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.get_offset_transform(self)",
        "snippet": "    def get_offset_transform(self):\n        t = self._transOffset\n        if (not isinstance(t, transforms.Transform)\n                and hasattr(t, '_as_mpl_transform')):\n            t = t._as_mpl_transform(self.axes)\n        return t",
        "begin_line": 174,
        "end_line": 179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005224660397074191,
            "pseudo_dstar_susp": 0.0007645259938837921,
            "pseudo_tarantula_susp": 0.0004127115146512588,
            "pseudo_op2_susp": 0.0007645259938837921,
            "pseudo_barinel_susp": 0.0004127115146512588
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.get_datalim#181",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.get_datalim(self, transData)",
        "snippet": "    def get_datalim(self, transData):\n\n        # Get the automatic datalim of the collection.\n        #\n        # This operation depends on the transforms for the data in the\n        # collection and whether the collection has offsets.\n        #\n        # 1) offsets = None, transform child of transData: use the paths for\n        # the automatic limits (i.e. for LineCollection in streamline).\n        # 2) offsets != None: offset_transform is child of transData:\n        #    a) transform is child of transData: use the path + offset for\n        #       limits (i.e for bar).\n        #    b) transform is not a child of transData: just use the offsets\n        #       for the limits (i.e. for scatter)\n        # 3) otherwise return a null Bbox.\n\n        transform = self.get_transform()\n        transOffset = self.get_offset_transform()\n        if (not self._offsetsNone and\n            not transOffset.contains_branch(transData)):\n            # if there are offsets but in some coords other than data,\n            # then don't use them for autoscaling.\n            return transforms.Bbox.null()\n        offsets = self._offsets\n\n        paths = self.get_paths()\n\n        if not transform.is_affine:\n            paths = [transform.transform_path_non_affine(p) for p in paths]\n            # Don't convert transform to transform.get_affine() here because\n            # we may have transform.contains_branch(transData) but not\n            # transforms.get_affine().contains_branch(transData).  But later,\n            # be careful to only apply the affine part that remains.\n        if not transOffset.is_affine:\n            offsets = transOffset.transform_non_affine(offsets)\n\n        if isinstance(offsets, np.ma.MaskedArray):\n            offsets = offsets.filled(np.nan)\n            # get_path_collection_extents handles nan but not masked arrays\n\n        if len(paths) and len(offsets):\n            if transform.contains_branch(transData):\n                # collections that are just in data units (like quiver)\n                # can properly have the axes limits set by their shape +\n                # offset.  LineCollections that have no offsets can\n                # also use this algorithm (like streamplot).\n                result = mpath.get_path_collection_extents(\n                    transform.get_affine(), paths, self.get_transforms(),\n                    offsets, transOffset.get_affine().frozen())\n                return result.inverse_transformed(transData)\n            if not self._offsetsNone:\n                # this is for collections that have their paths (shapes)\n                # in physical, axes-relative, or figure-relative units\n                # (i.e. like scatter). We can't uniquely set limits based on\n                # those shapes, so we just set the limits based on their\n                # location.\n                # Finish the transform:\n                offsets = (transOffset.get_affine() +\n                           transData.inverted()).transform(offsets)\n                offsets = np.ma.masked_invalid(offsets)\n                if not offsets.mask.all():\n                    points = np.row_stack((offsets.min(axis=0),\n                                           offsets.max(axis=0)))\n                    return transforms.Bbox(points)\n        return transforms.Bbox.null()",
        "begin_line": 181,
        "end_line": 245,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012610340479192938,
            "pseudo_dstar_susp": 0.0007674597083653108,
            "pseudo_tarantula_susp": 0.001466275659824047,
            "pseudo_op2_susp": 0.0007674597083653108,
            "pseudo_barinel_susp": 0.001466275659824047
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection._prepare_points#252",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection._prepare_points(self)",
        "snippet": "    def _prepare_points(self):\n        # Helper for drawing and hit testing.\n\n        transform = self.get_transform()\n        transOffset = self.get_offset_transform()\n        offsets = self._offsets\n        paths = self.get_paths()\n\n        if self.have_units():\n            paths = []\n            for path in self.get_paths():\n                vertices = path.vertices\n                xs, ys = vertices[:, 0], vertices[:, 1]\n                xs = self.convert_xunits(xs)\n                ys = self.convert_yunits(ys)\n                paths.append(mpath.Path(np.column_stack([xs, ys]), path.codes))\n            if offsets.size:\n                xs = self.convert_xunits(offsets[:, 0])\n                ys = self.convert_yunits(offsets[:, 1])\n                offsets = np.column_stack([xs, ys])\n\n        if not transform.is_affine:\n            paths = [transform.transform_path_non_affine(path)\n                     for path in paths]\n            transform = transform.get_affine()\n        if not transOffset.is_affine:\n            offsets = transOffset.transform_non_affine(offsets)\n            # This might have changed an ndarray into a masked array.\n            transOffset = transOffset.get_affine()\n\n        if isinstance(offsets, np.ma.MaskedArray):\n            offsets = offsets.filled(np.nan)\n            # Changing from a masked array to nan-filled ndarray\n            # is probably most efficient at this point.\n\n        return transform, transOffset, offsets, paths",
        "begin_line": 252,
        "end_line": 287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001834862385321101,
            "pseudo_dstar_susp": 0.0007518796992481203,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0007513148009015778,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.draw#290",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            return\n        renderer.open_group(self.__class__.__name__, self.get_gid())\n\n        self.update_scalarmappable()\n\n        transform, transOffset, offsets, paths = self._prepare_points()\n\n        gc = renderer.new_gc()\n        self._set_gc_clip(gc)\n        gc.set_snap(self.get_snap())\n\n        if self._hatch:\n            gc.set_hatch(self._hatch)\n            try:\n                gc.set_hatch_color(self._hatch_color)\n            except AttributeError:\n                # if we end up with a GC that does not have this method\n                cbook.warn_deprecated(\n                    \"3.1\", message=\"Your backend does not support setting the \"\n                    \"hatch color; such backends will become unsupported in \"\n                    \"Matplotlib 3.3.\")\n\n        if self.get_sketch_params() is not None:\n            gc.set_sketch_params(*self.get_sketch_params())\n\n        if self.get_path_effects():\n            from matplotlib.patheffects import PathEffectRenderer\n            renderer = PathEffectRenderer(self.get_path_effects(), renderer)\n\n        # If the collection is made up of a single shape/color/stroke,\n        # it can be rendered once and blitted multiple times, using\n        # `draw_markers` rather than `draw_path_collection`.  This is\n        # *much* faster for Agg, and results in smaller file sizes in\n        # PDF/SVG/PS.\n\n        trans = self.get_transforms()\n        facecolors = self.get_facecolor()\n        edgecolors = self.get_edgecolor()\n        do_single_path_optimization = False\n        if (len(paths) == 1 and len(trans) <= 1 and\n            len(facecolors) == 1 and len(edgecolors) == 1 and\n            len(self._linewidths) == 1 and\n            all(ls[1] is None for ls in self._linestyles) and\n            len(self._antialiaseds) == 1 and len(self._urls) == 1 and\n            self.get_hatch() is None):\n            if len(trans):\n                combined_transform = transforms.Affine2D(trans[0]) + transform\n            else:\n                combined_transform = transform\n            extents = paths[0].get_extents(combined_transform)\n            if (extents.width < self.figure.bbox.width\n                    and extents.height < self.figure.bbox.height):\n                do_single_path_optimization = True\n\n        if self._joinstyle:\n            gc.set_joinstyle(self._joinstyle)\n\n        if self._capstyle:\n            gc.set_capstyle(self._capstyle)\n\n        if do_single_path_optimization:\n            gc.set_foreground(tuple(edgecolors[0]))\n            gc.set_linewidth(self._linewidths[0])\n            gc.set_dashes(*self._linestyles[0])\n            gc.set_antialiased(self._antialiaseds[0])\n            gc.set_url(self._urls[0])\n            renderer.draw_markers(\n                gc, paths[0], combined_transform.frozen(),\n                mpath.Path(offsets), transOffset, tuple(facecolors[0]))\n        else:\n            renderer.draw_path_collection(\n                gc, transform.frozen(), paths,\n                self.get_transforms(), offsets, transOffset,\n                self.get_facecolor(), self.get_edgecolor(),\n                self._linewidths, self._linestyles,\n                self._antialiaseds, self._urls,\n                self._offset_position)\n\n        gc.restore()\n        renderer.close_group(self.__class__.__name__)\n        self.stale = False",
        "begin_line": 290,
        "end_line": 372,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_pickradius#374",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_pickradius(self, pr)",
        "snippet": "    def set_pickradius(self, pr):\n        \"\"\"\n        Set the pick radius used for containment tests.\n\n        Parameters\n        ----------\n        d : float\n            Pick radius, in points.\n        \"\"\"\n        self._pickradius = pr",
        "begin_line": 374,
        "end_line": 383,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003189792663476874,
            "pseudo_dstar_susp": 0.00031210986267166043,
            "pseudo_tarantula_susp": 0.00037383177570093456,
            "pseudo_op2_susp": 0.00031210986267166043,
            "pseudo_barinel_susp": 0.00037383177570093456
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_urls#421",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_urls(self, urls)",
        "snippet": "    def set_urls(self, urls):\n        \"\"\"\n        Parameters\n        ----------\n        urls : List[str] or None\n        \"\"\"\n        self._urls = urls if urls is not None else [None]\n        self.stale = True",
        "begin_line": 421,
        "end_line": 428,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003155569580309246,
            "pseudo_dstar_susp": 0.00030959752321981426,
            "pseudo_tarantula_susp": 0.000355998576005696,
            "pseudo_op2_susp": 0.00030959752321981426,
            "pseudo_barinel_susp": 0.000355998576005696
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_hatch#433",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_hatch(self, hatch)",
        "snippet": "    def set_hatch(self, hatch):\n        r\"\"\"\n        Set the hatching pattern\n\n        *hatch* can be one of::\n\n          /   - diagonal hatching\n          \\   - back diagonal\n          |   - vertical\n          -   - horizontal\n          +   - crossed\n          x   - crossed diagonal\n          o   - small circle\n          O   - large circle\n          .   - dots\n          *   - stars\n\n        Letters can be combined, in which case all the specified\n        hatchings are done.  If same letter repeats, it increases the\n        density of hatching of that pattern.\n\n        Hatching is supported in the PostScript, PDF, SVG and Agg\n        backends only.\n\n        Unlike other properties such as linewidth and colors, hatching\n        can only be specified for the collection as a whole, not separately\n        for each member.\n\n        Parameters\n        ----------\n        hatch : {'/', '\\\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}\n        \"\"\"\n        self._hatch = hatch\n        self.stale = True",
        "begin_line": 433,
        "end_line": 466,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005431830526887561,
            "pseudo_dstar_susp": 0.0004170141784820684,
            "pseudo_tarantula_susp": 0.0021645021645021645,
            "pseudo_op2_susp": 0.0004170141784820684,
            "pseudo_barinel_susp": 0.0021645021645021645
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.get_hatch#468",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.get_hatch(self)",
        "snippet": "    def get_hatch(self):\n        \"\"\"Return the current hatching pattern.\"\"\"\n        return self._hatch",
        "begin_line": 468,
        "end_line": 470,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_offset_position#498",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_offset_position(self, offset_position)",
        "snippet": "    def set_offset_position(self, offset_position):\n        \"\"\"\n        Set how offsets are applied.  If *offset_position* is 'screen'\n        (default) the offset is applied after the master transform has\n        been applied, that is, the offsets are in screen coordinates.\n        If offset_position is 'data', the offset is applied before the\n        master transform, i.e., the offsets are in data coordinates.\n\n        Parameters\n        ----------\n        offset_position : {'screen', 'data'}\n        \"\"\"\n        cbook._check_in_list(['screen', 'data'],\n                             offset_position=offset_position)\n        self._offset_position = offset_position\n        self.stale = True",
        "begin_line": 498,
        "end_line": 513,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005243838489774515,
            "pseudo_dstar_susp": 0.00041203131437989287,
            "pseudo_tarantula_susp": 0.002,
            "pseudo_op2_susp": 0.00041203131437989287,
            "pseudo_barinel_susp": 0.002
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_linewidth#526",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_linewidth(self, lw)",
        "snippet": "    def set_linewidth(self, lw):\n        \"\"\"\n        Set the linewidth(s) for the collection.  *lw* can be a scalar\n        or a sequence; if it is a sequence the patches will cycle\n        through the sequence\n\n        Parameters\n        ----------\n        lw : float or sequence of floats\n        \"\"\"\n        if lw is None:\n            lw = mpl.rcParams['patch.linewidth']\n            if lw is None:\n                lw = mpl.rcParams['lines.linewidth']\n        # get the un-scaled/broadcast lw\n        self._us_lw = np.atleast_1d(np.asarray(lw))\n\n        # scale all of the dash patterns.\n        self._linewidths, self._linestyles = self._bcast_lwls(\n            self._us_lw, self._us_linestyles)\n        self.stale = True",
        "begin_line": 526,
        "end_line": 546,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005194805194805195,
            "pseudo_dstar_susp": 0.0004106776180698152,
            "pseudo_tarantula_susp": 0.0019569471624266144,
            "pseudo_op2_susp": 0.0004106776180698152,
            "pseudo_barinel_susp": 0.0019569471624266144
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_linestyle#548",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_linestyle(self, ls)",
        "snippet": "    def set_linestyle(self, ls):\n        \"\"\"\n        Set the linestyle(s) for the collection.\n\n        ===========================   =================\n        linestyle                     description\n        ===========================   =================\n        ``'-'`` or ``'solid'``        solid line\n        ``'--'`` or  ``'dashed'``     dashed line\n        ``'-.'`` or  ``'dashdot'``    dash-dotted line\n        ``':'`` or ``'dotted'``       dotted line\n        ===========================   =================\n\n        Alternatively a dash tuple of the following form can be provided::\n\n            (offset, onoffseq),\n\n        where ``onoffseq`` is an even length tuple of on and off ink in points.\n\n        Parameters\n        ----------\n        ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n            The line style.\n        \"\"\"\n        try:\n            if isinstance(ls, str):\n                ls = cbook.ls_mapper.get(ls, ls)\n                dashes = [mlines._get_dash_pattern(ls)]\n            else:\n                try:\n                    dashes = [mlines._get_dash_pattern(ls)]\n                except ValueError:\n                    dashes = [mlines._get_dash_pattern(x) for x in ls]\n\n        except ValueError as err:\n            raise ValueError('Do not know how to convert {!r} to '\n                             'dashes'.format(ls)) from err\n\n        # get the list of raw 'unscaled' dash patterns\n        self._us_linestyles = dashes\n\n        # broadcast and scale the lw and dash patterns\n        self._linewidths, self._linestyles = self._bcast_lwls(\n            self._us_lw, self._us_linestyles)",
        "begin_line": 548,
        "end_line": 591,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005107252298263534,
            "pseudo_dstar_susp": 0.0004073319755600815,
            "pseudo_tarantula_susp": 0.0018726591760299626,
            "pseudo_op2_susp": 0.0004073319755600815,
            "pseudo_barinel_susp": 0.0018726591760299626
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection._bcast_lwls#624",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection._bcast_lwls(linewidths, dashes)",
        "snippet": "    def _bcast_lwls(linewidths, dashes):\n        \"\"\"\n        Internal helper function to broadcast + scale ls/lw\n\n        In the collection drawing code, the linewidth and linestyle are cycled\n        through as circular buffers (via ``v[i % len(v)]``).  Thus, if we are\n        going to scale the dash pattern at set time (not draw time) we need to\n        do the broadcasting now and expand both lists to be the same length.\n\n        Parameters\n        ----------\n        linewidths : list\n            line widths of collection\n        dashes : list\n            dash specification (offset, (dash pattern tuple))\n\n        Returns\n        -------\n        linewidths, dashes : list\n             Will be the same length, dashes are scaled by paired linewidth\n        \"\"\"\n        if mpl.rcParams['_internal.classic_mode']:\n            return linewidths, dashes\n        # make sure they are the same length so we can zip them\n        if len(dashes) != len(linewidths):\n            l_dashes = len(dashes)\n            l_lw = len(linewidths)\n            gcd = math.gcd(l_dashes, l_lw)\n            dashes = list(dashes) * (l_lw // gcd)\n            linewidths = list(linewidths) * (l_dashes // gcd)\n\n        # scale the dash patters\n        dashes = [mlines._scale_dashes(o, d, lw)\n                  for (o, d), lw in zip(dashes, linewidths)]\n\n        return linewidths, dashes",
        "begin_line": 624,
        "end_line": 659,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000335795836131632,
            "pseudo_dstar_susp": 0.0003206155819172812,
            "pseudo_tarantula_susp": 0.00042283298097251583,
            "pseudo_op2_susp": 0.0003206155819172812,
            "pseudo_barinel_susp": 0.00042283298097251583
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_antialiased#661",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_antialiased(self, aa)",
        "snippet": "    def set_antialiased(self, aa):\n        \"\"\"\n        Set the antialiasing state for rendering.\n\n        Parameters\n        ----------\n        aa : bool or sequence of bools\n        \"\"\"\n        if aa is None:\n            aa = mpl.rcParams['patch.antialiased']\n        self._antialiaseds = np.atleast_1d(np.asarray(aa, bool))\n        self.stale = True",
        "begin_line": 661,
        "end_line": 672,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004752851711026616,
            "pseudo_dstar_susp": 0.00040241448692152917,
            "pseudo_tarantula_susp": 0.0017482517482517483,
            "pseudo_op2_susp": 0.00040241448692152917,
            "pseudo_barinel_susp": 0.0017482517482517483
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection._set_facecolor#690",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection._set_facecolor(self, c)",
        "snippet": "    def _set_facecolor(self, c):\n        if c is None:\n            c = mpl.rcParams['patch.facecolor']\n\n        self._is_filled = True\n        try:\n            if c.lower() == 'none':\n                self._is_filled = False\n        except AttributeError:\n            pass\n        self._facecolors = mcolors.to_rgba_array(c, self._alpha)\n        self.stale = True",
        "begin_line": 690,
        "end_line": 701,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005431830526887561,
            "pseudo_dstar_susp": 0.0004170141784820684,
            "pseudo_tarantula_susp": 0.0021645021645021645,
            "pseudo_op2_susp": 0.0004170141784820684,
            "pseudo_barinel_susp": 0.0021645021645021645
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_facecolor#703",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_facecolor(self, c)",
        "snippet": "    def set_facecolor(self, c):\n        \"\"\"\n        Set the facecolor(s) of the collection. *c* can be a color (all patches\n        have same color), or a sequence of colors; if it is a sequence the\n        patches will cycle through the sequence.\n\n        If *c* is 'none', the patch will not be filled.\n\n        Parameters\n        ----------\n        c : color or sequence of colors\n        \"\"\"\n        self._original_facecolor = c\n        self._set_facecolor(c)",
        "begin_line": 703,
        "end_line": 716,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004752851711026616,
            "pseudo_dstar_susp": 0.00040241448692152917,
            "pseudo_tarantula_susp": 0.0017482517482517483,
            "pseudo_op2_susp": 0.00040241448692152917,
            "pseudo_barinel_susp": 0.0017482517482517483
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection._set_edgecolor#727",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection._set_edgecolor(self, c)",
        "snippet": "    def _set_edgecolor(self, c):\n        set_hatch_color = True\n        if c is None:\n            if (mpl.rcParams['patch.force_edgecolor'] or\n                    not self._is_filled or self._edge_default):\n                c = mpl.rcParams['patch.edgecolor']\n            else:\n                c = 'none'\n                set_hatch_color = False\n\n        self._is_stroked = True\n        try:\n            if c.lower() == 'none':\n                self._is_stroked = False\n        except AttributeError:\n            pass\n\n        try:\n            if c.lower() == 'face':   # Special case: lookup in \"get\" method.\n                self._edgecolors = 'face'\n                return\n        except AttributeError:\n            pass\n        self._edgecolors = mcolors.to_rgba_array(c, self._alpha)\n        if set_hatch_color and len(self._edgecolors):\n            self._hatch_color = tuple(self._edgecolors[0])\n        self.stale = True",
        "begin_line": 727,
        "end_line": 753,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00037778617302606723,
            "pseudo_dstar_susp": 0.00034916201117318437,
            "pseudo_tarantula_susp": 0.0007358351729212656,
            "pseudo_op2_susp": 0.00034916201117318437,
            "pseudo_barinel_susp": 0.0007358351729212656
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_edgecolor#755",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_edgecolor(self, c)",
        "snippet": "    def set_edgecolor(self, c):\n        \"\"\"\n        Set the edgecolor(s) of the collection.\n\n        Parameters\n        ----------\n        c : color or sequence of colors or 'face'\n            The collection edgecolor(s).  If a sequence, the patches cycle\n            through it.  If 'face', match the facecolor.\n        \"\"\"\n        self._original_edgecolor = c\n        self._set_edgecolor(c)",
        "begin_line": 755,
        "end_line": 766,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005194805194805195,
            "pseudo_dstar_susp": 0.0004106776180698152,
            "pseudo_tarantula_susp": 0.0019569471624266144,
            "pseudo_op2_susp": 0.0004106776180698152,
            "pseudo_barinel_susp": 0.0019569471624266144
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.set_alpha#768",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.set_alpha(self, alpha)",
        "snippet": "    def set_alpha(self, alpha):\n        # docstring inherited\n        super().set_alpha(alpha)\n        self.update_dict['array'] = True\n        self._set_facecolor(self._original_facecolor)\n        self._set_edgecolor(self._original_edgecolor)",
        "begin_line": 768,
        "end_line": 773,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005988023952095808,
            "pseudo_dstar_susp": 0.0004233700254022015,
            "pseudo_tarantula_susp": 0.0024813895781637717,
            "pseudo_op2_susp": 0.0004233700254022015,
            "pseudo_barinel_susp": 0.0024813895781637717
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.get_linewidth#775",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.get_linewidth(self)",
        "snippet": "    def get_linewidth(self):\n        return self._linewidths",
        "begin_line": 775,
        "end_line": 776,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.get_linestyle#778",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.get_linestyle(self)",
        "snippet": "    def get_linestyle(self):\n        return self._linestyles",
        "begin_line": 778,
        "end_line": 779,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.update_scalarmappable#781",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.update_scalarmappable(self)",
        "snippet": "    def update_scalarmappable(self):\n        \"\"\"Update colors from the scalar mappable array, if it is not None.\"\"\"\n        if self._A is None:\n            return\n        if self._A.ndim > 1:\n            raise ValueError('Collections can only map rank 1 arrays')\n        if not self.check_update(\"array\"):\n            return\n        if self._is_filled:\n            self._facecolors = self.to_rgba(self._A, self._alpha)\n        elif self._is_stroked:\n            self._edgecolors = self.to_rgba(self._A, self._alpha)\n        self.stale = True",
        "begin_line": 781,
        "end_line": 793,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005431830526887561,
            "pseudo_dstar_susp": 0.0004170141784820684,
            "pseudo_tarantula_susp": 0.0021645021645021645,
            "pseudo_op2_susp": 0.0004170141784820684,
            "pseudo_barinel_susp": 0.0021645021645021645
        }
    },
    {
        "name": "lib.matplotlib.collections.Collection.update_from#799",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.Collection",
        "signature": "lib.matplotlib.collections.Collection.update_from(self, other)",
        "snippet": "    def update_from(self, other):\n        \"\"\"Copy properties from other to self.\"\"\"\n\n        artist.Artist.update_from(self, other)\n        self._antialiaseds = other._antialiaseds\n        self._original_edgecolor = other._original_edgecolor\n        self._edgecolors = other._edgecolors\n        self._original_facecolor = other._original_facecolor\n        self._facecolors = other._facecolors\n        self._linewidths = other._linewidths\n        self._linestyles = other._linestyles\n        self._us_linestyles = other._us_linestyles\n        self._pickradius = other._pickradius\n        self._hatch = other._hatch\n\n        # update_from for scalarmappable\n        self._A = other._A\n        self.norm = other.norm\n        self.cmap = other.cmap\n        # self.update_dict = other.update_dict # do we need to copy this? -JJL\n        self.stale = True",
        "begin_line": 799,
        "end_line": 819,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.collections._CollectionWithSizes.get_sizes#851",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections._CollectionWithSizes",
        "signature": "lib.matplotlib.collections._CollectionWithSizes.get_sizes(self)",
        "snippet": "    def get_sizes(self):\n        \"\"\"\n        Returns the sizes of the elements in the collection.  The\n        value represents the 'area' of the element.\n\n        Returns\n        -------\n        sizes : array\n            The 'area' of each element.\n        \"\"\"\n        return self._sizes",
        "begin_line": 851,
        "end_line": 861,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005431830526887561,
            "pseudo_dstar_susp": 0.0004170141784820684,
            "pseudo_tarantula_susp": 0.0021645021645021645,
            "pseudo_op2_susp": 0.0004170141784820684,
            "pseudo_barinel_susp": 0.0021645021645021645
        }
    },
    {
        "name": "lib.matplotlib.collections._CollectionWithSizes.set_sizes#863",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections._CollectionWithSizes",
        "signature": "lib.matplotlib.collections._CollectionWithSizes.set_sizes(self, sizes, dpi=72.0)",
        "snippet": "    def set_sizes(self, sizes, dpi=72.0):\n        \"\"\"\n        Set the sizes of each member of the collection.\n\n        Parameters\n        ----------\n        sizes : ndarray or None\n            The size to set for each element of the collection.  The\n            value is the 'area' of the element.\n        dpi : float, default: 72\n            The dpi of the canvas.\n        \"\"\"\n        if sizes is None:\n            self._sizes = np.array([])\n            self._transforms = np.empty((0, 3, 3))\n        else:\n            self._sizes = np.asarray(sizes)\n            self._transforms = np.zeros((len(self._sizes), 3, 3))\n            scale = np.sqrt(self._sizes) * dpi / 72.0 * self._factor\n            self._transforms[:, 0, 0] = scale\n            self._transforms[:, 1, 1] = scale\n            self._transforms[:, 2, 2] = 1.0\n        self.stale = True",
        "begin_line": 863,
        "end_line": 885,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004664179104477612,
            "pseudo_dstar_susp": 0.00039888312724371757,
            "pseudo_tarantula_susp": 0.0016666666666666668,
            "pseudo_op2_susp": 0.00039888312724371757,
            "pseudo_barinel_susp": 0.0016666666666666668
        }
    },
    {
        "name": "lib.matplotlib.collections._CollectionWithSizes.draw#888",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections._CollectionWithSizes",
        "signature": "lib.matplotlib.collections._CollectionWithSizes.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        self.set_sizes(self._sizes, self.figure.dpi)\n        Collection.draw(self, renderer)",
        "begin_line": 888,
        "end_line": 890,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00034094783498124785,
            "pseudo_dstar_susp": 0.00032299741602067185,
            "pseudo_tarantula_susp": 0.00043159257660768235,
            "pseudo_op2_susp": 0.00032299741602067185,
            "pseudo_barinel_susp": 0.00043159257660768235
        }
    },
    {
        "name": "lib.matplotlib.collections.PathCollection.__init__#899",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.PathCollection",
        "signature": "lib.matplotlib.collections.PathCollection.__init__(self, paths, sizes=None, **kwargs)",
        "snippet": "    def __init__(self, paths, sizes=None, **kwargs):\n        \"\"\"\n        *paths* is a sequence of `matplotlib.path.Path` instances.\n\n        %(Collection)s\n        \"\"\"\n\n        Collection.__init__(self, **kwargs)\n        self.set_paths(paths)\n        self.set_sizes(sizes)\n        self.stale = True",
        "begin_line": 899,
        "end_line": 909,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038880248833592535,
            "pseudo_dstar_susp": 0.00035816618911174784,
            "pseudo_tarantula_susp": 0.0008305647840531562,
            "pseudo_op2_susp": 0.00035816618911174784,
            "pseudo_barinel_susp": 0.0008305647840531562
        }
    },
    {
        "name": "lib.matplotlib.collections.PathCollection.set_paths#911",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.PathCollection",
        "signature": "lib.matplotlib.collections.PathCollection.set_paths(self, paths)",
        "snippet": "    def set_paths(self, paths):\n        self._paths = paths\n        self.stale = True",
        "begin_line": 911,
        "end_line": 913,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005431830526887561,
            "pseudo_dstar_susp": 0.0004170141784820684,
            "pseudo_tarantula_susp": 0.0021645021645021645,
            "pseudo_op2_susp": 0.0004170141784820684,
            "pseudo_barinel_susp": 0.0021645021645021645
        }
    },
    {
        "name": "lib.matplotlib.collections.PathCollection.get_paths#915",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.PathCollection",
        "signature": "lib.matplotlib.collections.PathCollection.get_paths(self)",
        "snippet": "    def get_paths(self):\n        return self._paths",
        "begin_line": 915,
        "end_line": 916,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.collections.PolyCollection.__init__#1047",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.PolyCollection",
        "signature": "lib.matplotlib.collections.PolyCollection.__init__(self, verts, sizes=None, closed=True, **kwargs)",
        "snippet": "    def __init__(self, verts, sizes=None, closed=True, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : sequence\n            The sequence of polygons [*verts0*, *verts1*, ...] where each\n            element *verts_i* defines the vertices of polygon *i* as a 2D\n            array-like of of shape (M, 2).\n        sizes : array-like, default: None\n            Squared scaling factors for the polygons. The coordinates of each\n            polygon *verts_i* are multiplied by the square-root of the\n            corresponding entry in *sizes* (i.e., *sizes* specify the scaling\n            of areas). The scaling is applied before the Artist master\n            transform. If *sizes* is shorter than *verts*, the additional\n            values will be taken cyclically from the *sizes*.\n        closed : bool, default: True\n            Whether the polygon should be closed by adding a CLOSEPOLY\n            connection at the end.\n        **kwargs\n            %(Collection)s\n        \"\"\"\n        Collection.__init__(self, **kwargs)\n        self.set_sizes(sizes)\n        self.set_verts(verts, closed)\n        self.stale = True",
        "begin_line": 1047,
        "end_line": 1071,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.19793966151582e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.PolyCollection.set_verts#1073",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.PolyCollection",
        "signature": "lib.matplotlib.collections.PolyCollection.set_verts(self, verts, closed=True)",
        "snippet": "    def set_verts(self, verts, closed=True):\n        \"\"\"\n        Set the vertices of the polygons.\n\n        Parameters\n        ----------\n        verts : sequence\n            The sequence of polygons [*verts0*, *verts1*, ...] where each\n            element *verts_i* defines the vertices of polygon *i* as a 2D\n            array-like of of shape (M, 2).\n        closed : bool, default: True\n            Whether the polygon should be closed by adding a CLOSEPOLY\n            connection at the end.\n        \"\"\"\n        self.stale = True\n        if isinstance(verts, np.ma.MaskedArray):\n            verts = verts.astype(float).filled(np.nan)\n\n        # No need to do anything fancy if the path isn't closed.\n        if not closed:\n            self._paths = [mpath.Path(xy) for xy in verts]\n            return\n\n        # Fast path for arrays\n        if isinstance(verts, np.ndarray):\n            verts_pad = np.concatenate((verts, verts[:, :1]), axis=1)\n            # Creating the codes once is much faster than having Path do it\n            # separately each time by passing closed=True.\n            codes = np.empty(verts_pad.shape[1], dtype=mpath.Path.code_type)\n            codes[:] = mpath.Path.LINETO\n            codes[0] = mpath.Path.MOVETO\n            codes[-1] = mpath.Path.CLOSEPOLY\n            self._paths = [mpath.Path(xy, codes) for xy in verts_pad]\n            return\n\n        self._paths = []\n        for xy in verts:\n            if len(xy):\n                if isinstance(xy, np.ma.MaskedArray):\n                    xy = np.ma.concatenate([xy, xy[:1]])\n                else:\n                    xy = np.concatenate([xy, xy[:1]])\n                self._paths.append(mpath.Path(xy, closed=True))\n            else:\n                self._paths.append(mpath.Path(xy))",
        "begin_line": 1073,
        "end_line": 1117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.RegularPolyCollection.__init__#1186",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.RegularPolyCollection",
        "signature": "lib.matplotlib.collections.RegularPolyCollection.__init__(self, numsides, rotation=0, sizes=(1,), **kwargs)",
        "snippet": "    def __init__(self,\n                 numsides,\n                 rotation=0,\n                 sizes=(1,),\n                 **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        numsides : int\n            The number of sides of the polygon.\n        rotation : float\n            The rotation of the polygon in radians.\n        sizes : tuple of float\n            The area of the circle circumscribing the polygon in points^2.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Other keyword arguments.\n            %(Collection)s\n\n        Examples\n        --------\n        See :doc:`/gallery/event_handling/lasso_demo` for a complete example::\n\n            offsets = np.random.rand(20, 2)\n            facecolors = [cm.jet(x) for x in np.random.rand(20)]\n\n            collection = RegularPolyCollection(\n                numsides=5, # a pentagon\n                rotation=0, sizes=(50,),\n                facecolors=facecolors,\n                edgecolors=(\"black\",),\n                linewidths=(1,),\n                offsets=offsets,\n                transOffset=ax.transData,\n                )\n        \"\"\"\n        Collection.__init__(self, **kwargs)\n        self.set_sizes(sizes)\n        self._numsides = numsides\n        self._paths = [self._path_generator(numsides)]\n        self._rotation = rotation\n        self.set_transform(transforms.IdentityTransform())",
        "begin_line": 1186,
        "end_line": 1229,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.RegularPolyCollection.draw#1238",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.RegularPolyCollection",
        "signature": "lib.matplotlib.collections.RegularPolyCollection.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        self.set_sizes(self._sizes, self.figure.dpi)\n        self._transforms = [\n            transforms.Affine2D(x).rotate(-self._rotation).get_matrix()\n            for x in self._transforms\n        ]\n        Collection.draw(self, renderer)",
        "begin_line": 1238,
        "end_line": 1244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.LineCollection.__init__#1271",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.LineCollection",
        "signature": "lib.matplotlib.collections.LineCollection.__init__(self, segments, linewidths=None, colors=None, antialiaseds=None, linestyles='solid', offsets=None, transOffset=None, norm=None, cmap=None, pickradius=5, zorder=2, facecolors='none', **kwargs)",
        "snippet": "    def __init__(self, segments,     # Can be None.\n                 linewidths=None,\n                 colors=None,\n                 antialiaseds=None,\n                 linestyles='solid',\n                 offsets=None,\n                 transOffset=None,\n                 norm=None,\n                 cmap=None,\n                 pickradius=5,\n                 zorder=2,\n                 facecolors='none',\n                 **kwargs\n                 ):\n        \"\"\"\n        Parameters\n        ----------\n        segments\n            A sequence of (*line0*, *line1*, *line2*), where::\n\n                linen = (x0, y0), (x1, y1), ... (xm, ym)\n\n            or the equivalent numpy array with two columns. Each line\n            can be a different length.\n\n        colors : sequence, optional\n            A sequence of RGBA tuples (e.g., arbitrary color\n            strings, etc, not allowed).\n\n        antialiaseds : sequence, optional\n            A sequence of ones or zeros.\n\n        linestyles : str or tuple, optional\n            Either one of {'solid', 'dashed', 'dashdot', 'dotted'}, or\n            a dash tuple. The dash tuple is::\n\n                (offset, onoffseq)\n\n            where ``onoffseq`` is an even length tuple of on and off ink\n            in points.\n\n        norm : Normalize, optional\n            `~.colors.Normalize` instance.\n\n        cmap : str or Colormap, optional\n            Colormap name or `~.colors.Colormap` instance.\n\n        pickradius : float, default: 5pt\n            The tolerance in points for mouse clicks picking a line.\n\n        zorder : int, default: 2\n           zorder of the LineCollection.\n\n        facecolors : default: 'none'\n           The facecolors of the LineCollection.\n           Setting to a value other than 'none' will lead to a filled\n           polygon being drawn between points on each line.\n\n        Notes\n        -----\n        If any of *edgecolors*, *facecolors*, *linewidths*, *antialiaseds* are\n        None, they default to their `.rcParams` patch setting, in sequence\n        form.\n\n        If *offsets* and *transOffset* are not None, then\n        *offsets* are transformed by *transOffset* and applied after\n        the segments have been transformed to display coordinates.\n\n        If *offsets* is not None but *transOffset* is None, then the\n        *offsets* are added to the segments before any transformation.\n        In this case, a single offset can be specified as::\n\n            offsets=(xo, yo)\n\n        and this value will be added cumulatively to each successive\n        segment, so as to produce a set of successively offset curves.\n\n        The use of `~matplotlib.cm.ScalarMappable` functionality is optional.\n        If the `~matplotlib.cm.ScalarMappable` matrix ``_A`` has been set (via\n        a call to `~.ScalarMappable.set_array`), at draw time a call to scalar\n        mappable will be made to set the face colors.\n        \"\"\"\n        if colors is None:\n            colors = mpl.rcParams['lines.color']\n        if linewidths is None:\n            linewidths = (mpl.rcParams['lines.linewidth'],)\n        if antialiaseds is None:\n            antialiaseds = (mpl.rcParams['lines.antialiased'],)\n\n        colors = mcolors.to_rgba_array(colors)\n        Collection.__init__(\n            self,\n            edgecolors=colors,\n            facecolors=facecolors,\n            linewidths=linewidths,\n            linestyles=linestyles,\n            antialiaseds=antialiaseds,\n            offsets=offsets,\n            transOffset=transOffset,\n            norm=norm,\n            cmap=cmap,\n            pickradius=pickradius,\n            zorder=zorder,\n            **kwargs)\n\n        self.set_segments(segments)",
        "begin_line": 1271,
        "end_line": 1376,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000708215297450425,
            "pseudo_dstar_susp": 0.0004268032437046522,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0004268032437046522,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "lib.matplotlib.collections.LineCollection.set_segments#1378",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.LineCollection",
        "signature": "lib.matplotlib.collections.LineCollection.set_segments(self, segments)",
        "snippet": "    def set_segments(self, segments):\n        if segments is None:\n            return\n        _segments = []\n\n        for seg in segments:\n            if not isinstance(seg, np.ma.MaskedArray):\n                seg = np.asarray(seg, float)\n            _segments.append(seg)\n\n        if self._uniform_offsets is not None:\n            _segments = self._add_offsets(_segments)\n\n        self._paths = [mpath.Path(_seg) for _seg in _segments]\n        self.stale = True",
        "begin_line": 1378,
        "end_line": 1392,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005988023952095808,
            "pseudo_dstar_susp": 0.0004233700254022015,
            "pseudo_tarantula_susp": 0.0024813895781637717,
            "pseudo_op2_susp": 0.0004233700254022015,
            "pseudo_barinel_susp": 0.0024813895781637717
        }
    },
    {
        "name": "lib.matplotlib.collections.LineCollection.get_segments#1397",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.LineCollection",
        "signature": "lib.matplotlib.collections.LineCollection.get_segments(self)",
        "snippet": "    def get_segments(self):\n        \"\"\"\n        Returns\n        -------\n        segments : list\n            List of segments in the LineCollection. Each list item contains an\n            array of vertices.\n        \"\"\"\n        segments = []\n\n        for path in self._paths:\n            vertices = [vertex for vertex, _ in path.iter_segments()]\n            vertices = np.asarray(vertices)\n            segments.append(vertices)\n\n        return segments",
        "begin_line": 1397,
        "end_line": 1412,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.LineCollection.set_color#1427",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.LineCollection",
        "signature": "lib.matplotlib.collections.LineCollection.set_color(self, c)",
        "snippet": "    def set_color(self, c):\n        \"\"\"\n        Set the color(s) of the LineCollection.\n\n        Parameters\n        ----------\n        c : color or list of colors\n            Single color (all patches have same color), or a\n            sequence of rgba tuples; if it is a sequence the patches will\n            cycle through the sequence.\n        \"\"\"\n        self.set_edgecolor(c)\n        self.stale = True",
        "begin_line": 1427,
        "end_line": 1439,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004975124378109452,
            "pseudo_dstar_susp": 0.00040404040404040404,
            "pseudo_tarantula_susp": 0.0017921146953405018,
            "pseudo_op2_susp": 0.00040404040404040404,
            "pseudo_barinel_susp": 0.0017921146953405018
        }
    },
    {
        "name": "lib.matplotlib.collections.LineCollection.get_color#1441",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.LineCollection",
        "signature": "lib.matplotlib.collections.LineCollection.get_color(self)",
        "snippet": "    def get_color(self):\n        return self._edgecolors",
        "begin_line": 1441,
        "end_line": 1442,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.__init__#1458",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.__init__(self, positions, orientation=None, lineoffset=0, linelength=1, linewidth=None, color=None, linestyle='solid', antialiased=None, **kwargs)",
        "snippet": "    def __init__(self,\n                 positions,     # Cannot be None.\n                 orientation=None,\n                 lineoffset=0,\n                 linelength=1,\n                 linewidth=None,\n                 color=None,\n                 linestyle='solid',\n                 antialiased=None,\n                 **kwargs\n                 ):\n        \"\"\"\n        Parameters\n        ----------\n        positions : 1D array-like\n            Each value is an event.\n\n        orientation : {None, 'horizontal', 'vertical'}, optional\n            The orientation of the **collection** (the event bars are along\n            the orthogonal direction). Defaults to 'horizontal' if not\n            specified or None.\n\n        lineoffset : scalar, default: 0\n            The offset of the center of the markers from the origin, in the\n            direction orthogonal to *orientation*.\n\n        linelength : scalar, default: 1\n            The total height of the marker (i.e. the marker stretches from\n            ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).\n\n        linewidth : scalar or None, default: None\n            If it is None, defaults to its rcParams setting, in sequence form.\n\n        color : color, sequence of colors or None, default: None\n            If it is None, defaults to its rcParams setting, in sequence form.\n\n        linestyle : str or tuple, default: 'solid'\n            Valid strings are ['solid', 'dashed', 'dashdot', 'dotted',\n            '-', '--', '-.', ':']. Dash tuples should be of the form::\n\n                (offset, onoffseq),\n\n            where *onoffseq* is an even length tuple of on and off ink\n            in points.\n\n        antialiased : {None, 1, 2}, optional\n            If it is None, defaults to its rcParams setting, in sequence form.\n\n        **kwargs : optional\n            Other keyword arguments are line collection properties.  See\n            :class:`~matplotlib.collections.LineCollection` for a list of\n            the valid properties.\n\n        Examples\n        --------\n        .. plot:: gallery/lines_bars_and_markers/eventcollection_demo.py\n        \"\"\"\n        if positions is None:\n            raise ValueError('positions must be an array-like object')\n        # Force a copy of positions\n        positions = np.array(positions, copy=True)\n        segment = (lineoffset + linelength / 2.,\n                   lineoffset - linelength / 2.)\n        if positions.size == 0:\n            segments = []\n        elif positions.ndim > 1:\n            raise ValueError('positions cannot be an array with more than '\n                             'one dimension.')\n        elif (orientation is None or orientation.lower() == 'none' or\n              orientation.lower() == 'horizontal'):\n            positions.sort()\n            segments = [[(coord1, coord2) for coord2 in segment] for\n                        coord1 in positions]\n            self._is_horizontal = True\n        elif orientation.lower() == 'vertical':\n            positions.sort()\n            segments = [[(coord2, coord1) for coord2 in segment] for\n                        coord1 in positions]\n            self._is_horizontal = False\n        else:\n            cbook._check_in_list(['horizontal', 'vertical'],\n                                 orientation=orientation)\n\n        LineCollection.__init__(self,\n                                segments,\n                                linewidths=linewidth,\n                                colors=color,\n                                antialiaseds=antialiased,\n                                linestyles=linestyle,\n                                **kwargs)\n\n        self._linelength = linelength\n        self._lineoffset = lineoffset",
        "begin_line": 1458,
        "end_line": 1550,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.get_positions#1552",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.get_positions(self)",
        "snippet": "    def get_positions(self):\n        \"\"\"\n        Return an array containing the floating-point values of the positions.\n        \"\"\"\n        pos = 0 if self.is_horizontal() else 1\n        return [segment[0, pos] for segment in self.get_segments()]",
        "begin_line": 1552,
        "end_line": 1557,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.set_positions#1559",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.set_positions(self, positions)",
        "snippet": "    def set_positions(self, positions):\n        \"\"\"Set the positions of the events to the specified value.\"\"\"\n        if positions is None or (hasattr(positions, 'len') and\n                                 len(positions) == 0):\n            self.set_segments([])\n            return\n\n        lineoffset = self.get_lineoffset()\n        linelength = self.get_linelength()\n        segment = (lineoffset + linelength / 2.,\n                   lineoffset - linelength / 2.)\n        positions = np.asanyarray(positions)\n        positions.sort()\n        if self.is_horizontal():\n            segments = [[(coord1, coord2) for coord2 in segment] for\n                        coord1 in positions]\n        else:\n            segments = [[(coord2, coord1) for coord2 in segment] for\n                        coord1 in positions]\n        self.set_segments(segments)",
        "begin_line": 1559,
        "end_line": 1578,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.add_positions#1580",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.add_positions(self, position)",
        "snippet": "    def add_positions(self, position):\n        \"\"\"Add one or more events at the specified positions.\"\"\"\n        if position is None or (hasattr(position, 'len') and\n                                len(position) == 0):\n            return\n        positions = self.get_positions()\n        positions = np.hstack([positions, np.asanyarray(position)])\n        self.set_positions(positions)",
        "begin_line": 1580,
        "end_line": 1587,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.get_orientation#1594",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.get_orientation(self)",
        "snippet": "    def get_orientation(self):\n        \"\"\"\n        Return the orientation of the event line ('horizontal' or 'vertical').\n        \"\"\"\n        return 'horizontal' if self.is_horizontal() else 'vertical'",
        "begin_line": 1594,
        "end_line": 1598,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.switch_orientation#1600",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.switch_orientation(self)",
        "snippet": "    def switch_orientation(self):\n        \"\"\"\n        Switch the orientation of the event line, either from vertical to\n        horizontal or vice versus.\n        \"\"\"\n        segments = self.get_segments()\n        for i, segment in enumerate(segments):\n            segments[i] = np.fliplr(segment)\n        self.set_segments(segments)\n        self._is_horizontal = not self.is_horizontal()\n        self.stale = True",
        "begin_line": 1600,
        "end_line": 1610,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.set_orientation#1612",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.set_orientation(self, orientation=None)",
        "snippet": "    def set_orientation(self, orientation=None):\n        \"\"\"\n        Set the orientation of the event line.\n\n        Parameters\n        ----------\n        orientation: {'horizontal', 'vertical'} or None\n            Defaults to 'horizontal' if not specified or None.\n        \"\"\"\n        if (orientation is None or orientation.lower() == 'none' or\n                orientation.lower() == 'horizontal'):\n            is_horizontal = True\n        elif orientation.lower() == 'vertical':\n            is_horizontal = False\n        else:\n            cbook._check_in_list(['horizontal', 'vertical'],\n                                 orientation=orientation)\n        if is_horizontal == self.is_horizontal():\n            return\n        self.switch_orientation()",
        "begin_line": 1612,
        "end_line": 1631,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.get_linelength#1633",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.get_linelength(self)",
        "snippet": "    def get_linelength(self):\n        \"\"\"\n        get the length of the lines used to mark each event\n        \"\"\"\n        return self._linelength",
        "begin_line": 1633,
        "end_line": 1637,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.set_linelength#1639",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.set_linelength(self, linelength)",
        "snippet": "    def set_linelength(self, linelength):\n        \"\"\"\n        set the length of the lines used to mark each event\n        \"\"\"\n        if linelength == self.get_linelength():\n            return\n        lineoffset = self.get_lineoffset()\n        segments = self.get_segments()\n        pos = 1 if self.is_horizontal() else 0\n        for segment in segments:\n            segment[0, pos] = lineoffset + linelength / 2.\n            segment[1, pos] = lineoffset - linelength / 2.\n        self.set_segments(segments)\n        self._linelength = linelength",
        "begin_line": 1639,
        "end_line": 1652,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.get_lineoffset#1654",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.get_lineoffset(self)",
        "snippet": "    def get_lineoffset(self):\n        \"\"\"Return the offset of the lines used to mark each event.\"\"\"\n        return self._lineoffset",
        "begin_line": 1654,
        "end_line": 1656,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.set_lineoffset#1658",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.set_lineoffset(self, lineoffset)",
        "snippet": "    def set_lineoffset(self, lineoffset):\n        \"\"\"Set the offset of the lines used to mark each event.\"\"\"\n        if lineoffset == self.get_lineoffset():\n            return\n        linelength = self.get_linelength()\n        segments = self.get_segments()\n        pos = 1 if self.is_horizontal() else 0\n        for segment in segments:\n            segment[0, pos] = lineoffset + linelength / 2.\n            segment[1, pos] = lineoffset - linelength / 2.\n        self.set_segments(segments)\n        self._lineoffset = lineoffset",
        "begin_line": 1658,
        "end_line": 1669,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.EventCollection.get_color#1678",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EventCollection",
        "signature": "lib.matplotlib.collections.EventCollection.get_color(self)",
        "snippet": "    def get_color(self):\n        \"\"\"Return the color of the lines used to mark each event.\"\"\"\n        return self.get_colors()[0]",
        "begin_line": 1678,
        "end_line": 1680,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.EllipseCollection.__init__#1706",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EllipseCollection",
        "signature": "lib.matplotlib.collections.EllipseCollection.__init__(self, widths, heights, angles, units='points', **kwargs)",
        "snippet": "    def __init__(self, widths, heights, angles, units='points', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        widths : array-like\n            The lengths of the first axes (e.g., major axis lengths).\n\n        heights : array-like\n            The lengths of second axes.\n\n        angles : array-like\n            The angles of the first axes, degrees CCW from the x-axis.\n\n        units : {'points', 'inches', 'dots', 'width', 'height', 'x', 'y', 'xy'}\n\n            The units in which majors and minors are given; 'width' and\n            'height' refer to the dimensions of the axes, while 'x' and 'y'\n            refer to the *offsets* data units. 'xy' differs from all others in\n            that the angle as plotted varies with the aspect ratio, and equals\n            the specified angle only when the aspect ratio is unity.  Hence\n            it behaves the same as the `~matplotlib.patches.Ellipse` with\n            ``axes.transData`` as its transform.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Additional kwargs inherited from the base :class:`Collection`.\n\n        %(Collection)s\n        \"\"\"\n        Collection.__init__(self, **kwargs)\n        self._widths = 0.5 * np.asarray(widths).ravel()\n        self._heights = 0.5 * np.asarray(heights).ravel()\n        self._angles = np.deg2rad(angles).ravel()\n        self._units = units\n        self.set_transform(transforms.IdentityTransform())\n        self._transforms = np.empty((0, 3, 3))\n        self._paths = [mpath.Path.unit_circle()]",
        "begin_line": 1706,
        "end_line": 1743,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.EllipseCollection._set_transforms#1745",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.EllipseCollection",
        "signature": "lib.matplotlib.collections.EllipseCollection._set_transforms(self)",
        "snippet": "    def _set_transforms(self):\n        \"\"\"Calculate transforms immediately before drawing.\"\"\"\n\n        ax = self.axes\n        fig = self.figure\n\n        if self._units == 'xy':\n            sc = 1\n        elif self._units == 'x':\n            sc = ax.bbox.width / ax.viewLim.width\n        elif self._units == 'y':\n            sc = ax.bbox.height / ax.viewLim.height\n        elif self._units == 'inches':\n            sc = fig.dpi\n        elif self._units == 'points':\n            sc = fig.dpi / 72.0\n        elif self._units == 'width':\n            sc = ax.bbox.width\n        elif self._units == 'height':\n            sc = ax.bbox.height\n        elif self._units == 'dots':\n            sc = 1.0\n        else:\n            raise ValueError('unrecognized units: %s' % self._units)\n\n        self._transforms = np.zeros((len(self._widths), 3, 3))\n        widths = self._widths * sc\n        heights = self._heights * sc\n        sin_angle = np.sin(self._angles)\n        cos_angle = np.cos(self._angles)\n        self._transforms[:, 0, 0] = widths * cos_angle\n        self._transforms[:, 0, 1] = heights * -sin_angle\n        self._transforms[:, 1, 0] = widths * sin_angle\n        self._transforms[:, 1, 1] = heights * cos_angle\n        self._transforms[:, 2, 2] = 1.0\n\n        _affine = transforms.Affine2D\n        if self._units == 'xy':\n            m = ax.transData.get_affine().get_matrix().copy()\n            m[:2, 2:] = 0\n            self.set_transform(_affine(m))",
        "begin_line": 1745,
        "end_line": 1785,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.PatchCollection.__init__#1804",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.PatchCollection",
        "signature": "lib.matplotlib.collections.PatchCollection.__init__(self, patches, match_original=False, **kwargs)",
        "snippet": "    def __init__(self, patches, match_original=False, **kwargs):\n        \"\"\"\n        *patches*\n            a sequence of Patch objects.  This list may include\n            a heterogeneous assortment of different patch types.\n\n        *match_original*\n            If True, use the colors and linewidths of the original\n            patches.  If False, new colors may be assigned by\n            providing the standard collection arguments, facecolor,\n            edgecolor, linewidths, norm or cmap.\n\n        If any of *edgecolors*, *facecolors*, *linewidths*, *antialiaseds* are\n        None, they default to their `.rcParams` patch setting, in sequence\n        form.\n\n        The use of `~matplotlib.cm.ScalarMappable` functionality is optional.\n        If the `~matplotlib.cm.ScalarMappable` matrix ``_A`` has been set (via\n        a call to `~.ScalarMappable.set_array`), at draw time a call to scalar\n        mappable will be made to set the face colors.\n        \"\"\"\n\n        if match_original:\n            def determine_facecolor(patch):\n                if patch.get_fill():\n                    return patch.get_facecolor()\n                return [0, 0, 0, 0]\n\n            kwargs['facecolors'] = [determine_facecolor(p) for p in patches]\n            kwargs['edgecolors'] = [p.get_edgecolor() for p in patches]\n            kwargs['linewidths'] = [p.get_linewidth() for p in patches]\n            kwargs['linestyles'] = [p.get_linestyle() for p in patches]\n            kwargs['antialiaseds'] = [p.get_antialiased() for p in patches]\n\n        Collection.__init__(self, **kwargs)\n\n        self.set_paths(patches)",
        "begin_line": 1804,
        "end_line": 1840,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.PatchCollection.set_paths#1842",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.PatchCollection",
        "signature": "lib.matplotlib.collections.PatchCollection.set_paths(self, patches)",
        "snippet": "    def set_paths(self, patches):\n        paths = [p.get_transform().transform_path(p.get_path())\n                 for p in patches]\n        self._paths = paths",
        "begin_line": 1842,
        "end_line": 1845,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.QuadMesh.__init__#1941",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.QuadMesh",
        "signature": "lib.matplotlib.collections.QuadMesh.__init__(self, meshWidth, meshHeight, coordinates, antialiased=True, shading='flat', **kwargs)",
        "snippet": "    def __init__(self, meshWidth, meshHeight, coordinates,\n                 antialiased=True, shading='flat', **kwargs):\n        Collection.__init__(self, **kwargs)\n        self._meshWidth = meshWidth\n        self._meshHeight = meshHeight\n        # By converting to floats now, we can avoid that on every draw.\n        self._coordinates = np.asarray(coordinates, float).reshape(\n            (meshHeight + 1, meshWidth + 1, 2))\n        self._antialiased = antialiased\n        self._shading = shading\n\n        self._bbox = transforms.Bbox.unit()\n        self._bbox.update_from_data_xy(coordinates.reshape(\n            ((meshWidth + 1) * (meshHeight + 1), 2)))",
        "begin_line": 1941,
        "end_line": 1954,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.QuadMesh.convert_mesh_to_paths#1970",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.QuadMesh",
        "signature": "lib.matplotlib.collections.QuadMesh.convert_mesh_to_paths(meshWidth, meshHeight, coordinates)",
        "snippet": "    def convert_mesh_to_paths(meshWidth, meshHeight, coordinates):\n        \"\"\"\n        Converts a given mesh into a sequence of `~.Path` objects.\n\n        This function is primarily of use to implementers of backends that do\n        not directly support quadmeshes.\n        \"\"\"\n        if isinstance(coordinates, np.ma.MaskedArray):\n            c = coordinates.data\n        else:\n            c = coordinates\n        points = np.concatenate((\n                    c[:-1, :-1],\n                    c[:-1, 1:],\n                    c[1:, 1:],\n                    c[1:, :-1],\n                    c[:-1, :-1]\n                ), axis=2)\n        points = points.reshape((meshWidth * meshHeight, 5, 2))\n        return [mpath.Path(x) for x in points]",
        "begin_line": 1970,
        "end_line": 1989,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.QuadMesh.convert_mesh_to_triangles#1991",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.QuadMesh",
        "signature": "lib.matplotlib.collections.QuadMesh.convert_mesh_to_triangles(self, meshWidth, meshHeight, coordinates)",
        "snippet": "    def convert_mesh_to_triangles(self, meshWidth, meshHeight, coordinates):\n        \"\"\"\n        Converts a given mesh into a sequence of triangles, each point\n        with its own color.  This is useful for experiments using\n        `~.RendererBase.draw_gouraud_triangle`.\n        \"\"\"\n        if isinstance(coordinates, np.ma.MaskedArray):\n            p = coordinates.data\n        else:\n            p = coordinates\n\n        p_a = p[:-1, :-1]\n        p_b = p[:-1, 1:]\n        p_c = p[1:, 1:]\n        p_d = p[1:, :-1]\n        p_center = (p_a + p_b + p_c + p_d) / 4.0\n\n        triangles = np.concatenate((\n                p_a, p_b, p_center,\n                p_b, p_c, p_center,\n                p_c, p_d, p_center,\n                p_d, p_a, p_center,\n            ), axis=2)\n        triangles = triangles.reshape((meshWidth * meshHeight * 4, 3, 2))\n\n        c = self.get_facecolor().reshape((meshHeight + 1, meshWidth + 1, 4))\n        c_a = c[:-1, :-1]\n        c_b = c[:-1, 1:]\n        c_c = c[1:, 1:]\n        c_d = c[1:, :-1]\n        c_center = (c_a + c_b + c_c + c_d) / 4.0\n\n        colors = np.concatenate((\n                        c_a, c_b, c_center,\n                        c_b, c_c, c_center,\n                        c_c, c_d, c_center,\n                        c_d, c_a, c_center,\n                    ), axis=2)\n        colors = colors.reshape((meshWidth * meshHeight * 4, 3, 4))\n\n        return triangles, colors",
        "begin_line": 1991,
        "end_line": 2031,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.collections.QuadMesh.draw#2034",
        "src_path": "lib/matplotlib/collections.py",
        "class_name": "lib.matplotlib.collections.QuadMesh",
        "signature": "lib.matplotlib.collections.QuadMesh.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            return\n        renderer.open_group(self.__class__.__name__, self.get_gid())\n        transform = self.get_transform()\n        transOffset = self.get_offset_transform()\n        offsets = self._offsets\n\n        if self.have_units():\n            if len(self._offsets):\n                xs = self.convert_xunits(self._offsets[:, 0])\n                ys = self.convert_yunits(self._offsets[:, 1])\n                offsets = np.column_stack([xs, ys])\n\n        self.update_scalarmappable()\n\n        if not transform.is_affine:\n            coordinates = self._coordinates.reshape((-1, 2))\n            coordinates = transform.transform(coordinates)\n            coordinates = coordinates.reshape(self._coordinates.shape)\n            transform = transforms.IdentityTransform()\n        else:\n            coordinates = self._coordinates\n\n        if not transOffset.is_affine:\n            offsets = transOffset.transform_non_affine(offsets)\n            transOffset = transOffset.get_affine()\n\n        gc = renderer.new_gc()\n        self._set_gc_clip(gc)\n        gc.set_linewidth(self.get_linewidth()[0])\n\n        if self._shading == 'gouraud':\n            triangles, colors = self.convert_mesh_to_triangles(\n                self._meshWidth, self._meshHeight, coordinates)\n            renderer.draw_gouraud_triangles(\n                gc, triangles, colors, transform.frozen())\n        else:\n            renderer.draw_quad_mesh(\n                gc, transform.frozen(), self._meshWidth, self._meshHeight,\n                coordinates, offsets, transOffset, self.get_facecolor(),\n                self._antialiased, self.get_edgecolors())\n        gc.restore()\n        renderer.close_group(self.__class__.__name__)\n        self.stale = False",
        "begin_line": 2034,
        "end_line": 2078,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecBase.__repr__#50",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecBase",
        "signature": "lib.matplotlib.gridspec.GridSpecBase.__repr__(self)",
        "snippet": "    def __repr__(self):\n        height_arg = (', height_ratios=%r' % self._row_height_ratios\n                      if self._row_height_ratios is not None else '')\n        width_arg = (', width_ratios=%r' % self._col_width_ratios\n                     if self._col_width_ratios is not None else '')\n        return '{clsname}({nrows}, {ncols}{optionals})'.format(\n            clsname=self.__class__.__name__,\n            nrows=self._nrows,\n            ncols=self._ncols,\n            optionals=height_arg + width_arg,\n            )",
        "begin_line": 50,
        "end_line": 60,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecBase.set_width_ratios#93",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecBase",
        "signature": "lib.matplotlib.gridspec.GridSpecBase.set_width_ratios(self, width_ratios)",
        "snippet": "    def set_width_ratios(self, width_ratios):\n        \"\"\"\n        Set the relative widths of the columns.\n\n        *width_ratios* must be of length *ncols*. Each column gets a relative\n        width of ``width_ratios[i] / sum(width_ratios)``.\n        \"\"\"\n        if width_ratios is not None and len(width_ratios) != self._ncols:\n            raise ValueError('Expected the given number of width ratios to '\n                             'match the number of columns of the grid')\n        self._col_width_ratios = width_ratios",
        "begin_line": 93,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecBase.set_height_ratios#113",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecBase",
        "signature": "lib.matplotlib.gridspec.GridSpecBase.set_height_ratios(self, height_ratios)",
        "snippet": "    def set_height_ratios(self, height_ratios):\n        \"\"\"\n        Set the relative heights of the rows.\n\n        *height_ratios* must be of length *nrows*. Each row gets a relative\n        height of ``height_ratios[i] / sum(height_ratios)``.\n        \"\"\"\n        if height_ratios is not None and len(height_ratios) != self._nrows:\n            raise ValueError('Expected the given number of height ratios to '\n                             'match the number of rows of the grid')\n        self._row_height_ratios = height_ratios",
        "begin_line": 113,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0034602076124567475,
            "pseudo_dstar_susp": 0.006993006993006993,
            "pseudo_tarantula_susp": 0.0004210526315789474,
            "pseudo_op2_susp": 0.006944444444444444,
            "pseudo_barinel_susp": 0.0004210526315789474
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecBase.get_grid_positions#133",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecBase",
        "signature": "lib.matplotlib.gridspec.GridSpecBase.get_grid_positions(self, fig, raw=False)",
        "snippet": "    def get_grid_positions(self, fig, raw=False):\n        \"\"\"\n        Return the positions of the grid cells in figure coordinates.\n\n        Parameters\n        ----------\n        fig : `~matplotlib.figure.Figure`\n            The figure the grid should be applied to. The subplot parameters\n            (margins and spacing between subplots) are taken from *fig*.\n        raw : bool, default: False\n            If *True*, the subplot parameters of the figure are not taken\n            into account. The grid spans the range [0, 1] in both directions\n            without margins and there is no space between grid cells. This is\n            used for constrained_layout.\n\n        Returns\n        -------\n        bottoms, tops, lefts, rights : array\n            The bottom, top, left, right positions of the grid cells in\n            figure coordinates.\n        \"\"\"\n        nrows, ncols = self.get_geometry()\n\n        if raw:\n            left = 0.\n            right = 1.\n            bottom = 0.\n            top = 1.\n            wspace = 0.\n            hspace = 0.\n        else:\n            subplot_params = self.get_subplot_params(fig)\n            left = subplot_params.left\n            right = subplot_params.right\n            bottom = subplot_params.bottom\n            top = subplot_params.top\n            wspace = subplot_params.wspace\n            hspace = subplot_params.hspace\n        tot_width = right - left\n        tot_height = top - bottom\n\n        # calculate accumulated heights of columns\n        cell_h = tot_height / (nrows + hspace*(nrows-1))\n        sep_h = hspace * cell_h\n        if self._row_height_ratios is not None:\n            norm = cell_h * nrows / sum(self._row_height_ratios)\n            cell_heights = [r * norm for r in self._row_height_ratios]\n        else:\n            cell_heights = [cell_h] * nrows\n        sep_heights = [0] + ([sep_h] * (nrows-1))\n        cell_hs = np.cumsum(np.column_stack([sep_heights, cell_heights]).flat)\n\n        # calculate accumulated widths of rows\n        cell_w = tot_width / (ncols + wspace*(ncols-1))\n        sep_w = wspace * cell_w\n        if self._col_width_ratios is not None:\n            norm = cell_w * ncols / sum(self._col_width_ratios)\n            cell_widths = [r * norm for r in self._col_width_ratios]\n        else:\n            cell_widths = [cell_w] * ncols\n        sep_widths = [0] + ([sep_w] * (ncols-1))\n        cell_ws = np.cumsum(np.column_stack([sep_widths, cell_widths]).flat)\n\n        fig_tops, fig_bottoms = (top - cell_hs).reshape((-1, 2)).T\n        fig_lefts, fig_rights = (left + cell_ws).reshape((-1, 2)).T\n        return fig_bottoms, fig_tops, fig_lefts, fig_rights",
        "begin_line": 133,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007518796992481203,
            "pseudo_dstar_susp": 0.007246376811594203,
            "pseudo_tarantula_susp": 0.0005577244841048522,
            "pseudo_op2_susp": 0.007142857142857143,
            "pseudo_barinel_susp": 0.0005577244841048522
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecBase.__getitem__#200",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecBase",
        "signature": "lib.matplotlib.gridspec.GridSpecBase.__getitem__(self, key)",
        "snippet": "    def __getitem__(self, key):\n        \"\"\"Create and return a `.SubplotSpec` instance.\"\"\"\n        nrows, ncols = self.get_geometry()\n\n        def _normalize(key, size, axis):  # Includes last index.\n            orig_key = key\n            if isinstance(key, slice):\n                start, stop, _ = key.indices(size)\n                if stop > start:\n                    return start, stop - 1\n                raise IndexError(\"GridSpec slice would result in no space \"\n                                 \"allocated for subplot\")\n            else:\n                if key < 0:\n                    key = key + size\n                if 0 <= key < size:\n                    return key, key\n                elif axis is not None:\n                    raise IndexError(f\"index {orig_key} is out of bounds for \"\n                                     f\"axis {axis} with size {size}\")\n                else:  # flat index\n                    raise IndexError(f\"index {orig_key} is out of bounds for \"\n                                     f\"GridSpec with size {size}\")\n\n        if isinstance(key, tuple):\n            try:\n                k1, k2 = key\n            except ValueError as err:\n                raise ValueError(\"Unrecognized subplot spec\") from err\n            num1, num2 = np.ravel_multi_index(\n                [_normalize(k1, nrows, 0), _normalize(k2, ncols, 1)],\n                (nrows, ncols))\n        else:  # Single key\n            num1, num2 = _normalize(key, nrows * ncols, None)\n\n        return SubplotSpec(self, num1, num2)",
        "begin_line": 200,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002544529262086514,
            "pseudo_dstar_susp": 0.005847953216374269,
            "pseudo_tarantula_susp": 0.0004389815627743635,
            "pseudo_op2_susp": 0.005681818181818182,
            "pseudo_barinel_susp": 0.0004389815627743635
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpecBase._normalize#204",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpecBase",
        "signature": "lib.matplotlib.gridspec.GridSpecBase._normalize(key, size, axis)",
        "snippet": "        def _normalize(key, size, axis):  # Includes last index.\n            orig_key = key\n            if isinstance(key, slice):\n                start, stop, _ = key.indices(size)\n                if stop > start:\n                    return start, stop - 1\n                raise IndexError(\"GridSpec slice would result in no space \"\n                                 \"allocated for subplot\")\n            else:\n                if key < 0:\n                    key = key + size\n                if 0 <= key < size:\n                    return key, key\n                elif axis is not None:\n                    raise IndexError(f\"index {orig_key} is out of bounds for \"\n                                     f\"axis {axis} with size {size}\")\n                else:  # flat index\n                    raise IndexError(f\"index {orig_key} is out of bounds for \"\n                                     f\"GridSpec with size {size}\")",
        "begin_line": 204,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.011764705882352941,
            "pseudo_dstar_susp": 0.013888888888888888,
            "pseudo_tarantula_susp": 0.0005757052389176742,
            "pseudo_op2_susp": 0.012048192771084338,
            "pseudo_barinel_susp": 0.0005757052389176742
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpec.__init__#246",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpec",
        "signature": "lib.matplotlib.gridspec.GridSpec.__init__(self, nrows, ncols, figure=None, left=None, bottom=None, right=None, top=None, wspace=None, hspace=None, width_ratios=None, height_ratios=None)",
        "snippet": "    def __init__(self, nrows, ncols, figure=None,\n                 left=None, bottom=None, right=None, top=None,\n                 wspace=None, hspace=None,\n                 width_ratios=None, height_ratios=None):\n        \"\"\"\n        Parameters\n        ----------\n        nrows, ncols : int\n            The number of rows and columns of the grid.\n\n        figure : `~.figure.Figure`, optional\n            Only used for constrained layout to create a proper layoutbox.\n\n        left, right, top, bottom : float, optional\n            Extent of the subplots as a fraction of figure width or height.\n            Left cannot be larger than right, and bottom cannot be larger than\n            top. If not given, the values will be inferred from a figure or\n            rcParams at draw time. See also `GridSpec.get_subplot_params`.\n\n        wspace : float, optional\n            The amount of width reserved for space between subplots,\n            expressed as a fraction of the average axis width.\n            If not given, the values will be inferred from a figure or\n            rcParams when necessary. See also `GridSpec.get_subplot_params`.\n\n        hspace : float, optional\n            The amount of height reserved for space between subplots,\n            expressed as a fraction of the average axis height.\n            If not given, the values will be inferred from a figure or\n            rcParams when necessary. See also `GridSpec.get_subplot_params`.\n\n        width_ratios : array-like of length *ncols*, optional\n            Defines the relative widths of the columns. Each column gets a\n            relative width of ``width_ratios[i] / sum(width_ratios)``.\n            If not given, all columns will have the same width.\n\n        height_ratios : array-like of length *nrows*, optional\n            Defines the relative heights of the rows. Each column gets a\n            relative height of ``height_ratios[i] / sum(height_ratios)``.\n            If not given, all rows will have the same height.\n\n        \"\"\"\n        self.left = left\n        self.bottom = bottom\n        self.right = right\n        self.top = top\n        self.wspace = wspace\n        self.hspace = hspace\n        self.figure = figure\n\n        GridSpecBase.__init__(self, nrows, ncols,\n                              width_ratios=width_ratios,\n                              height_ratios=height_ratios)\n\n        if self.figure is None or not self.figure.get_constrained_layout():\n            self._layoutbox = None\n        else:\n            self.figure.init_layoutbox()\n            self._layoutbox = layoutbox.LayoutBox(\n                parent=self.figure._layoutbox,\n                name='gridspec' + layoutbox.seq_id(),\n                artist=self)",
        "begin_line": 246,
        "end_line": 307,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024390243902439024,
            "pseudo_dstar_susp": 0.001095290251916758,
            "pseudo_tarantula_susp": 0.0008230452674897119,
            "pseudo_op2_susp": 0.001095290251916758,
            "pseudo_barinel_susp": 0.0008230452674897119
        }
    },
    {
        "name": "lib.matplotlib.gridspec.GridSpec.get_subplot_params#366",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.GridSpec",
        "signature": "lib.matplotlib.gridspec.GridSpec.get_subplot_params(self, figure=None)",
        "snippet": "    def get_subplot_params(self, figure=None):\n        \"\"\"\n        Return the `~.SubplotParams` for the GridSpec.\n\n        In order of precedence the values are taken from\n\n        - non-*None* attributes of the GridSpec\n        - the provided *figure*\n        - :rc:`figure.subplot.*`\n        \"\"\"\n        if figure is None:\n            kw = {k: rcParams[\"figure.subplot.\"+k] for k in self._AllowedKeys}\n            subplotpars = mpl.figure.SubplotParams(**kw)\n        else:\n            subplotpars = copy.copy(figure.subplotpars)\n\n        subplotpars.update(**{k: getattr(self, k) for k in self._AllowedKeys})\n\n        return subplotpars",
        "begin_line": 366,
        "end_line": 384,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003194888178913738,
            "pseudo_dstar_susp": 0.0011614401858304297,
            "pseudo_tarantula_susp": 0.0010111223458038423,
            "pseudo_op2_susp": 0.0011614401858304297,
            "pseudo_barinel_susp": 0.0010111223458038423
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.__init__#508",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.__init__(self, gridspec, num1, num2=None)",
        "snippet": "    def __init__(self, gridspec, num1, num2=None):\n        self._gridspec = gridspec\n        self.num1 = num1\n        self.num2 = num2\n        if gridspec._layoutbox is not None:\n            glb = gridspec._layoutbox\n            # So note that here we don't assign any layout yet,\n            # just make the layoutbox that will contain all items\n            # associated w/ this axis.  This can include other axes like\n            # a colorbar or a legend.\n            self._layoutbox = layoutbox.LayoutBox(\n                    parent=glb,\n                    name=glb.name + '.ss' + layoutbox.seq_id(),\n                    artist=self)\n        else:\n            self._layoutbox = None",
        "begin_line": 508,
        "end_line": 523,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002531645569620253,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.0008,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.0008
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.__repr__#525",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return (f\"{self.get_gridspec()}[\"\n                f\"{self.rowspan.start}:{self.rowspan.stop}, \"\n                f\"{self.colspan.start}:{self.colspan.stop}]\")",
        "begin_line": 525,
        "end_line": 528,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec._from_subplot_args#531",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec._from_subplot_args(figure, args)",
        "snippet": "    def _from_subplot_args(figure, args):\n        \"\"\"\n        Construct a `.SubplotSpec` from a parent `.Figure` and either\n\n        - a `.SubplotSpec` -- returned as is;\n        - one or three numbers -- a MATLAB-style subplot specifier.\n        \"\"\"\n        if len(args) == 1:\n            arg, = args\n            if isinstance(arg, SubplotSpec):\n                return arg\n            else:\n                try:\n                    s = str(int(arg))\n                    rows, cols, num = map(int, s)\n                except ValueError as err:\n                    raise ValueError(\"Single argument to subplot must be a \"\n                                     \"3-digit integer\") from err\n                # num - 1 for converting from MATLAB to python indexing\n                return GridSpec(rows, cols, figure=figure)[num - 1]\n        elif len(args) == 3:\n            rows, cols, num = args\n            rows = int(rows)\n            cols = int(cols)\n            if rows <= 0:\n                raise ValueError(f\"Number of rows must be > 0, not {rows}\")\n            if cols <= 0:\n                raise ValueError(f\"Number of columns must be > 0, not {cols}\")\n            if isinstance(num, tuple) and len(num) == 2:\n                i, j = map(int, num)\n                return GridSpec(rows, cols, figure=figure)[i-1:j]\n            else:\n                if num < 1 or num > rows*cols:\n                    raise ValueError(\n                        f\"num must be 1 <= num <= {rows*cols}, not {num}\")\n                # num - 1 for converting from MATLAB to python indexing\n                return GridSpec(rows, cols, figure=figure)[int(num) - 1]\n        else:\n            raise TypeError(f\"subplot() takes 1 or 3 positional arguments but \"\n                            f\"{len(args)} were given\")",
        "begin_line": 531,
        "end_line": 570,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036363636363636364,
            "pseudo_dstar_susp": 0.0007757951900698216,
            "pseudo_tarantula_susp": 0.0014641288433382138,
            "pseudo_op2_susp": 0.0007757951900698216,
            "pseudo_barinel_susp": 0.0014641288433382138
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.num2#576",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.num2(self)",
        "snippet": "    def num2(self):\n        return self.num1 if self._num2 is None else self._num2",
        "begin_line": 576,
        "end_line": 577,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013315579227696406,
            "pseudo_dstar_susp": 0.0009132420091324201,
            "pseudo_tarantula_susp": 0.0006009615384615385,
            "pseudo_op2_susp": 0.0009132420091324201,
            "pseudo_barinel_susp": 0.0006009615384615385
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.num2#580",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.num2(self, value)",
        "snippet": "    def num2(self, value):\n        self._num2 = value",
        "begin_line": 580,
        "end_line": 581,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.__getstate__#583",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.__getstate__(self)",
        "snippet": "    def __getstate__(self):\n        state = self.__dict__\n        try:\n            state.pop('_layoutbox')\n        except KeyError:\n            pass\n        return state",
        "begin_line": 583,
        "end_line": 589,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.get_geometry#599",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.get_geometry(self)",
        "snippet": "    def get_geometry(self):\n        \"\"\"\n        Return the subplot geometry as tuple ``(n_rows, n_cols, start, stop)``.\n\n        The indices *start* and *stop* define the range of the subplot within\n        the `GridSpec`. *stop* is inclusive (i.e. for a single cell\n        ``start == stop``).\n        \"\"\"\n        rows, cols = self.get_gridspec().get_geometry()\n        return rows, cols, self.num1, self.num2",
        "begin_line": 599,
        "end_line": 608,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.3905531035778e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.get_rows_columns#610",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.get_rows_columns(self)",
        "snippet": "    def get_rows_columns(self):\n        \"\"\"\n        Return the subplot row and column numbers as a tuple\n        ``(n_rows, n_cols, row_start, row_stop, col_start, col_stop)``.\n        \"\"\"\n        gridspec = self.get_gridspec()\n        nrows, ncols = gridspec.get_geometry()\n        row_start, col_start = divmod(self.num1, ncols)\n        row_stop, col_stop = divmod(self.num2, ncols)\n        return nrows, ncols, row_start, row_stop, col_start, col_stop",
        "begin_line": 610,
        "end_line": 619,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.rowspan#622",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.rowspan(self)",
        "snippet": "    def rowspan(self):\n        \"\"\"The rows spanned by this subplot, as a `range` object.\"\"\"\n        ncols = self.get_gridspec().ncols\n        return range(self.num1 // ncols, self.num2 // ncols + 1)",
        "begin_line": 622,
        "end_line": 625,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.colspan#628",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.colspan(self)",
        "snippet": "    def colspan(self):\n        \"\"\"The columns spanned by this subplot, as a `range` object.\"\"\"\n        ncols = self.get_gridspec().ncols\n        return range(self.num1 % ncols, self.num2 % ncols + 1)",
        "begin_line": 628,
        "end_line": 631,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.get_position#633",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.get_position(self, figure, return_all=False)",
        "snippet": "    def get_position(self, figure, return_all=False):\n        \"\"\"\n        Update the subplot position from ``figure.subplotpars``.\n        \"\"\"\n        gridspec = self.get_gridspec()\n        nrows, ncols = gridspec.get_geometry()\n        rows, cols = np.unravel_index([self.num1, self.num2], (nrows, ncols))\n        fig_bottoms, fig_tops, fig_lefts, fig_rights = \\\n            gridspec.get_grid_positions(figure)\n\n        fig_bottom = fig_bottoms[rows].min()\n        fig_top = fig_tops[rows].max()\n        fig_left = fig_lefts[cols].min()\n        fig_right = fig_rights[cols].max()\n        figbox = Bbox.from_extents(fig_left, fig_bottom, fig_right, fig_top)\n\n        if return_all:\n            return figbox, rows[0], cols[0], nrows, ncols\n        else:\n            return figbox",
        "begin_line": 633,
        "end_line": 652,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001639344262295082,
            "pseudo_dstar_susp": 0.00273224043715847,
            "pseudo_tarantula_susp": 0.0006653359946773121,
            "pseudo_op2_susp": 0.00273224043715847,
            "pseudo_barinel_susp": 0.0006653359946773121
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.__eq__#664",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        \"\"\"\n        Two SubplotSpecs are considered equal if they refer to the same\n        position(s) in the same `GridSpec`.\n        \"\"\"\n        # other may not even have the attributes we are checking.\n        return ((self._gridspec, self.num1, self.num2)\n                == (getattr(other, \"_gridspec\", object()),\n                    getattr(other, \"num1\", object()),\n                    getattr(other, \"num2\", object())))",
        "begin_line": 664,
        "end_line": 673,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.gridspec.SubplotSpec.__hash__#675",
        "src_path": "lib/matplotlib/gridspec.py",
        "class_name": "lib.matplotlib.gridspec.SubplotSpec",
        "signature": "lib.matplotlib.gridspec.SubplotSpec.__hash__(self)",
        "snippet": "    def __hash__(self):\n        return hash((self._gridspec, self.num1, self.num2))",
        "begin_line": 675,
        "end_line": 676,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000429553264604811,
            "pseudo_dstar_susp": 0.00038446751249519417,
            "pseudo_tarantula_susp": 0.0013605442176870747,
            "pseudo_op2_susp": 0.00038446751249519417,
            "pseudo_barinel_susp": 0.0013531799729364006
        }
    },
    {
        "name": "lib.matplotlib.container.Container.__new__#17",
        "src_path": "lib/matplotlib/container.py",
        "class_name": "lib.matplotlib.container.Container",
        "signature": "lib.matplotlib.container.Container.__new__(cls, *args, **kwargs)",
        "snippet": "    def __new__(cls, *args, **kwargs):\n        return tuple.__new__(cls, args[0])",
        "begin_line": 17,
        "end_line": 18,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00044802867383512545,
            "pseudo_dstar_susp": 0.0005955926146515784,
            "pseudo_tarantula_susp": 0.0006035003017501509,
            "pseudo_op2_susp": 0.0005955926146515784,
            "pseudo_barinel_susp": 0.0006035003017501509
        }
    },
    {
        "name": "lib.matplotlib.container.Container.__init__#20",
        "src_path": "lib/matplotlib/container.py",
        "class_name": "lib.matplotlib.container.Container",
        "signature": "lib.matplotlib.container.Container.__init__(self, kl, label=None)",
        "snippet": "    def __init__(self, kl, label=None):\n        self.eventson = False  # fire events only if eventson\n        self._oid = 0  # an observer id\n        self._propobservers = {}  # a dict from oids to funcs\n        self._remove_method = None\n        self.set_label(label)",
        "begin_line": 20,
        "end_line": 25,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003898635477582846,
            "pseudo_dstar_susp": 0.0006230529595015577,
            "pseudo_tarantula_susp": 0.0003479471120389701,
            "pseudo_op2_susp": 0.0006230529595015577,
            "pseudo_barinel_susp": 0.0003479471120389701
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.set_title#117",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.set_title(self, label, fontdict=None, loc=None, pad=None, **kwargs)",
        "snippet": "    def set_title(self, label, fontdict=None, loc=None, pad=None, **kwargs):\n        \"\"\"\n        Set a title for the axes.\n\n        Set one of the three available axes titles. The available titles\n        are positioned above the axes in the center, flush with the left\n        edge, and flush with the right edge.\n\n        Parameters\n        ----------\n        label : str\n            Text to use for the title\n\n        fontdict : dict\n            A dictionary controlling the appearance of the title text,\n            the default *fontdict* is::\n\n               {'fontsize': rcParams['axes.titlesize'],\n                'fontweight': rcParams['axes.titleweight'],\n                'color': rcParams['axes.titlecolor'],\n                'verticalalignment': 'baseline',\n                'horizontalalignment': loc}\n\n        loc : {'center', 'left', 'right'}, default: :rc:`axes.titlelocation`\n            Which title to set.\n\n        pad : float, default: :rc:`axes.titlepad`\n            The offset of the title from the top of the axes, in points.\n\n        Returns\n        -------\n        text : `.Text`\n            The matplotlib text instance representing the title\n\n        Other Parameters\n        ----------------\n        **kwargs : `.Text` properties\n            Other keyword arguments are text properties, see `.Text` for a list\n            of valid text properties.\n        \"\"\"\n        if loc is None:\n            loc = rcParams['axes.titlelocation']\n\n        titles = {'left': self._left_title,\n                  'center': self.title,\n                  'right': self._right_title}\n        title = cbook._check_getitem(titles, loc=loc.lower())\n        default = {\n            'fontsize': rcParams['axes.titlesize'],\n            'fontweight': rcParams['axes.titleweight'],\n            'verticalalignment': 'baseline',\n            'horizontalalignment': loc.lower()}\n        titlecolor = rcParams['axes.titlecolor']\n        if not cbook._str_lower_equal(titlecolor, 'auto'):\n            default[\"color\"] = titlecolor\n        if pad is None:\n            pad = rcParams['axes.titlepad']\n        self._set_title_offset_trans(float(pad))\n        title.set_text(label)\n        title.update(default)\n        if fontdict is not None:\n            title.update(fontdict)\n        title.update(kwargs)\n        return title",
        "begin_line": 117,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.768800497203231e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.set_xlabel#189",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.set_xlabel(self, xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
        "snippet": "    def set_xlabel(self, xlabel, fontdict=None, labelpad=None, *,\n                   loc=None, **kwargs):\n        \"\"\"\n        Set the label for the x-axis.\n\n        Parameters\n        ----------\n        xlabel : str\n            The label text.\n\n        labelpad : float, default: None\n            Spacing in points from the axes bounding box including ticks\n            and tick labels.\n\n        loc : {'left', 'center', 'right'}, default: :rc:`xaxis.labellocation`\n            The label position. This is a high-level alternative for passing\n            parameters *x* and *horizontalalignment*.\n\n        Other Parameters\n        ----------------\n        **kwargs : `.Text` properties\n            `.Text` properties control the appearance of the label.\n\n        See also\n        --------\n        text : Documents the properties supported by `.Text`.\n        \"\"\"\n        if labelpad is not None:\n            self.xaxis.labelpad = labelpad\n        protected_kw = ['x', 'horizontalalignment', 'ha']\n        if {*kwargs} & {*protected_kw}:\n            if loc is not None:\n                raise TypeError(f\"Specifying 'loc' is disallowed when any of \"\n                                f\"its corresponding low level keyword \"\n                                f\"arguments ({protected_kw}) are also \"\n                                f\"supplied\")\n            loc = 'center'\n        else:\n            loc = loc if loc is not None else rcParams['xaxis.labellocation']\n        cbook._check_in_list(('left', 'center', 'right'), loc=loc)\n        if loc == 'left':\n            kwargs.update(x=0, horizontalalignment='left')\n        elif loc == 'right':\n            kwargs.update(x=1, horizontalalignment='right')\n        return self.xaxis.set_label_text(xlabel, fontdict, **kwargs)",
        "begin_line": 189,
        "end_line": 233,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.808839606434484e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.set_ylabel#242",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.set_ylabel(self, ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
        "snippet": "    def set_ylabel(self, ylabel, fontdict=None, labelpad=None, *,\n                   loc=None, **kwargs):\n        \"\"\"\n        Set the label for the y-axis.\n\n        Parameters\n        ----------\n        ylabel : str\n            The label text.\n\n        labelpad : float, default: None\n            Spacing in points from the axes bounding box including ticks\n            and tick labels.\n\n        loc : {'bottom', 'center', 'top'}, default: :rc:`yaxis.labellocation`\n            The label position. This is a high-level alternative for passing\n            parameters *y* and *horizontalalignment*.\n\n        Other Parameters\n        ----------------\n        **kwargs : `.Text` properties\n            `.Text` properties control the appearance of the label.\n\n        See also\n        --------\n        text : Documents the properties supported by `.Text`.\n        \"\"\"\n        if labelpad is not None:\n            self.yaxis.labelpad = labelpad\n        protected_kw = ['y', 'horizontalalignment', 'ha']\n        if {*kwargs} & {*protected_kw}:\n            if loc is not None:\n                raise TypeError(f\"Specifying 'loc' is disallowed when any of \"\n                                f\"its corresponding low level keyword \"\n                                f\"arguments ({protected_kw}) are also \"\n                                f\"supplied\")\n            loc = 'center'\n        else:\n            loc = loc if loc is not None else rcParams['yaxis.labellocation']\n        cbook._check_in_list(('bottom', 'center', 'top'), loc=loc)\n        if loc == 'bottom':\n            kwargs.update(y=0, horizontalalignment='left')\n        elif loc == 'top':\n            kwargs.update(y=1, horizontalalignment='right')\n        return self.yaxis.set_label_text(ylabel, fontdict, **kwargs)",
        "begin_line": 242,
        "end_line": 286,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.legend#303",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.legend(self, *args, **kwargs)",
        "snippet": "    def legend(self, *args, **kwargs):\n        \"\"\"\n        Place a legend on the axes.\n\n        Call signatures::\n\n            legend()\n            legend(labels)\n            legend(handles, labels)\n\n        The call signatures correspond to three different ways how to use\n        this method.\n\n        **1. Automatic detection of elements to be shown in the legend**\n\n        The elements to be added to the legend are automatically determined,\n        when you do not pass in any extra arguments.\n\n        In this case, the labels are taken from the artist. You can specify\n        them either at artist creation or by calling the\n        :meth:`~.Artist.set_label` method on the artist::\n\n            line, = ax.plot([1, 2, 3], label='Inline label')\n            ax.legend()\n\n        or::\n\n            line, = ax.plot([1, 2, 3])\n            line.set_label('Label via method')\n            ax.legend()\n\n        Specific lines can be excluded from the automatic legend element\n        selection by defining a label starting with an underscore.\n        This is default for all artists, so calling `.Axes.legend` without\n        any arguments and without setting the labels manually will result in\n        no legend being drawn.\n\n\n        **2. Labeling existing plot elements**\n\n        To make a legend for lines which already exist on the axes\n        (via plot for instance), simply call this function with an iterable\n        of strings, one for each legend item. For example::\n\n            ax.plot([1, 2, 3])\n            ax.legend(['A simple line'])\n\n        Note: This way of using is discouraged, because the relation between\n        plot elements and labels is only implicit by their order and can\n        easily be mixed up.\n\n\n        **3. Explicitly defining the elements in the legend**\n\n        For full control of which artists have a legend entry, it is possible\n        to pass an iterable of legend artists followed by an iterable of\n        legend labels respectively::\n\n            legend((line1, line2, line3), ('label1', 'label2', 'label3'))\n\n        Parameters\n        ----------\n        handles : sequence of `.Artist`, optional\n            A list of Artists (lines, patches) to be added to the legend.\n            Use this together with *labels*, if you need full control on what\n            is shown in the legend and the automatic mechanism described above\n            is not sufficient.\n\n            The length of handles and labels should be the same in this\n            case. If they are not, they are truncated to the smaller length.\n\n        labels : list of str, optional\n            A list of labels to show next to the artists.\n            Use this together with *handles*, if you need full control on what\n            is shown in the legend and the automatic mechanism described above\n            is not sufficient.\n\n        Other Parameters\n        ----------------\n        %(_legend_kw_doc)s\n\n        Returns\n        -------\n        legend : `~matplotlib.legend.Legend`\n\n        Notes\n        -----\n        Some artists are not supported by this function.  See\n        :doc:`/tutorials/intermediate/legend_guide` for details.\n\n        Examples\n        --------\n        .. plot:: gallery/text_labels_and_annotations/legend.py\n        \"\"\"\n        handles, labels, extra_args, kwargs = mlegend._parse_legend_args(\n                [self],\n                *args,\n                **kwargs)\n        if len(extra_args):\n            raise TypeError('legend only accepts two non-keyword arguments')\n        self.legend_ = mlegend.Legend(self, handles, labels, **kwargs)\n        self.legend_._remove_method = self._remove_legend\n        return self.legend_",
        "begin_line": 303,
        "end_line": 405,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.179959100204499e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.text#688",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.text(self, x, y, s, fontdict=None, **kwargs)",
        "snippet": "    def text(self, x, y, s, fontdict=None, **kwargs):\n        \"\"\"\n        Add text to the axes.\n\n        Add the text *s* to the axes at location *x*, *y* in data coordinates.\n\n        Parameters\n        ----------\n        x, y : scalars\n            The position to place the text. By default, this is in data\n            coordinates. The coordinate system can be changed using the\n            *transform* parameter.\n\n        s : str\n            The text.\n\n        fontdict : dict, default: None\n            A dictionary to override the default text properties. If fontdict\n            is None, the defaults are determined by `.rcParams`.\n\n        Returns\n        -------\n        text : `.Text`\n            The created `.Text` instance.\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.text.Text` properties.\n            Other miscellaneous text parameters.\n\n            %(Text)s\n\n        Examples\n        --------\n        Individual keyword arguments can be used to override any given\n        parameter::\n\n            >>> text(x, y, s, fontsize=12)\n\n        The default transform specifies that text is in data coords,\n        alternatively, you can specify text in axis coords ((0, 0) is\n        lower-left and (1, 1) is upper-right).  The example below places\n        text in the center of the axes::\n\n            >>> text(0.5, 0.5, 'matplotlib', horizontalalignment='center',\n            ...      verticalalignment='center', transform=ax.transAxes)\n\n        You can put a rectangular box around the text instance (e.g., to\n        set a background color) by using the keyword *bbox*.  *bbox* is\n        a dictionary of `~matplotlib.patches.Rectangle`\n        properties.  For example::\n\n            >>> text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))\n        \"\"\"\n        effective_kwargs = {\n            'verticalalignment': 'baseline',\n            'horizontalalignment': 'left',\n            'transform': self.transData,\n            'clip_on': False,\n            **(fontdict if fontdict is not None else {}),\n            **kwargs,\n        }\n        t = mtext.Text(x, y, text=s, **effective_kwargs)\n        t.set_clip_path(self.patch)\n        self._add_text(t)\n        return t",
        "begin_line": 688,
        "end_line": 753,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.annotate#756",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.annotate(self, s, xy, *args, **kwargs)",
        "snippet": "    def annotate(self, s, xy, *args, **kwargs):\n        a = mtext.Annotation(s, xy, *args, **kwargs)\n        a.set_transform(mtransforms.IdentityTransform())\n        if 'clip_on' in kwargs:\n            a.set_clip_path(self.patch)\n        self._add_text(a)\n        return a",
        "begin_line": 756,
        "end_line": 762,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.axhline#767",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.axhline(self, y=0, xmin=0, xmax=1, **kwargs)",
        "snippet": "    def axhline(self, y=0, xmin=0, xmax=1, **kwargs):\n        \"\"\"\n        Add a horizontal line across the axis.\n\n        Parameters\n        ----------\n        y : float, default: 0\n            y position in data coordinates of the horizontal line.\n\n        xmin : float, default: 0\n            Should be between 0 and 1, 0 being the far left of the plot, 1 the\n            far right of the plot.\n\n        xmax : float, default: 1\n            Should be between 0 and 1, 0 being the far left of the plot, 1 the\n            far right of the plot.\n\n        Returns\n        -------\n        line : `~matplotlib.lines.Line2D`\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Valid keyword arguments are `.Line2D` properties, with the\n            exception of 'transform':\n\n            %(_Line2D_docstr)s\n\n        See also\n        --------\n        hlines : Add horizontal lines in data coordinates.\n        axhspan : Add a horizontal span (rectangle) across the axis.\n        axline : Add a line with an arbitrary slope.\n\n        Examples\n        --------\n        * draw a thick red hline at 'y' = 0 that spans the xrange::\n\n            >>> axhline(linewidth=4, color='r')\n\n        * draw a default hline at 'y' = 1 that spans the xrange::\n\n            >>> axhline(y=1)\n\n        * draw a default hline at 'y' = .5 that spans the middle half of\n          the xrange::\n\n            >>> axhline(y=.5, xmin=0.25, xmax=0.75)\n        \"\"\"\n        if \"transform\" in kwargs:\n            raise ValueError(\n                \"'transform' is not allowed as a kwarg;\"\n                + \"axhline generates its own transform.\")\n        ymin, ymax = self.get_ybound()\n\n        # We need to strip away the units for comparison with\n        # non-unitized bounds\n        self._process_unit_info(ydata=y, kwargs=kwargs)\n        yy = self.convert_yunits(y)\n        scaley = (yy < ymin) or (yy > ymax)\n\n        trans = self.get_yaxis_transform(which='grid')\n        l = mlines.Line2D([xmin, xmax], [y, y], transform=trans, **kwargs)\n        self.add_line(l)\n        self._request_autoscale_view(scalex=False, scaley=scaley)\n        return l",
        "begin_line": 767,
        "end_line": 833,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.axvline#836",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.axvline(self, x=0, ymin=0, ymax=1, **kwargs)",
        "snippet": "    def axvline(self, x=0, ymin=0, ymax=1, **kwargs):\n        \"\"\"\n        Add a vertical line across the axes.\n\n        Parameters\n        ----------\n        x : float, default: 0\n            x position in data coordinates of the vertical line.\n\n        ymin : float, default: 0\n            Should be between 0 and 1, 0 being the bottom of the plot, 1 the\n            top of the plot.\n\n        ymax : float, default: 1\n            Should be between 0 and 1, 0 being the bottom of the plot, 1 the\n            top of the plot.\n\n        Returns\n        -------\n        line : `~matplotlib.lines.Line2D`\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Valid keyword arguments are `.Line2D` properties, with the\n            exception of 'transform':\n\n            %(_Line2D_docstr)s\n\n        Examples\n        --------\n        * draw a thick red vline at *x* = 0 that spans the yrange::\n\n            >>> axvline(linewidth=4, color='r')\n\n        * draw a default vline at *x* = 1 that spans the yrange::\n\n            >>> axvline(x=1)\n\n        * draw a default vline at *x* = .5 that spans the middle half of\n          the yrange::\n\n            >>> axvline(x=.5, ymin=0.25, ymax=0.75)\n\n        See also\n        --------\n        vlines : Add vertical lines in data coordinates.\n        axvspan : Add a vertical span (rectangle) across the axis.\n        axline : Add a line with an abritrary slope.\n        \"\"\"\n\n        if \"transform\" in kwargs:\n            raise ValueError(\n                \"'transform' is not allowed as a kwarg;\"\n                + \"axvline generates its own transform.\")\n        xmin, xmax = self.get_xbound()\n\n        # We need to strip away the units for comparison with\n        # non-unitized bounds\n        self._process_unit_info(xdata=x, kwargs=kwargs)\n        xx = self.convert_xunits(x)\n        scalex = (xx < xmin) or (xx > xmax)\n\n        trans = self.get_xaxis_transform(which='grid')\n        l = mlines.Line2D([x, x], [ymin, ymax], transform=trans, **kwargs)\n        self.add_line(l)\n        self._request_autoscale_view(scalex=scalex, scaley=False)\n        return l",
        "begin_line": 836,
        "end_line": 903,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.axhspan#963",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs)",
        "snippet": "    def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs):\n        \"\"\"\n        Add a horizontal span (rectangle) across the axis.\n\n        The rectangle spans from *ymin* to *ymax* vertically, and, by default,\n        the whole x-axis horizontally.  The x-span can be set using *xmin*\n        (default: 0) and *xmax* (default: 1) which are in axis units; e.g.\n        ``xmin = 0.5`` always refers to the middle of the x-axis regardless of\n        the limits set by `~.Axes.set_xlim`.\n\n        Parameters\n        ----------\n        ymin : float\n            Lower y-coordinate of the span, in data units.\n        ymax : float\n            Upper y-coordinate of the span, in data units.\n        xmin : float, default: 0\n            Lower x-coordinate of the span, in x-axis (0-1) units.\n        xmax : float, default: 1\n            Upper x-coordinate of the span, in x-axis (0-1) units.\n\n        Returns\n        -------\n        rectangle : `~matplotlib.patches.Polygon`\n            Horizontal span (rectangle) from (xmin, ymin) to (xmax, ymax).\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.patches.Polygon` properties\n\n        %(Polygon)s\n\n        See Also\n        --------\n        axvspan : Add a vertical span across the axes.\n        \"\"\"\n        trans = self.get_yaxis_transform(which='grid')\n\n        # process the unit information\n        self._process_unit_info([xmin, xmax], [ymin, ymax], kwargs=kwargs)\n\n        # first we need to strip away the units\n        xmin, xmax = self.convert_xunits([xmin, xmax])\n        ymin, ymax = self.convert_yunits([ymin, ymax])\n\n        verts = (xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)\n        p = mpatches.Polygon(verts, **kwargs)\n        p.set_transform(trans)\n        self.add_patch(p)\n        self._request_autoscale_view(scalex=False)\n        return p",
        "begin_line": 963,
        "end_line": 1013,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.axvspan#1015",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs)",
        "snippet": "    def axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs):\n        \"\"\"\n        Add a vertical span (rectangle) across the axes.\n\n        The rectangle spans from *xmin* to *xmax* horizontally, and, by\n        default, the whole y-axis vertically.  The y-span can be set using\n        *ymin* (default: 0) and *ymax* (default: 1) which are in axis units;\n        e.g. ``ymin = 0.5`` always refers to the middle of the y-axis\n        regardless of the limits set by `~.Axes.set_ylim`.\n\n        Parameters\n        ----------\n        xmin : float\n            Lower x-coordinate of the span, in data units.\n        xmax : float\n            Upper x-coordinate of the span, in data units.\n        ymin : float, default: 0\n            Lower y-coordinate of the span, in y-axis units (0-1).\n        ymax : float, default: 1\n            Upper y-coordinate of the span, in y-axis units (0-1).\n\n        Returns\n        -------\n        rectangle : `~matplotlib.patches.Polygon`\n            Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.patches.Polygon` properties\n\n        %(Polygon)s\n\n        See Also\n        --------\n        axhspan : Add a horizontal span across the axes.\n\n        Examples\n        --------\n        Draw a vertical, green, translucent rectangle from x = 1.25 to\n        x = 1.55 that spans the yrange of the axes.\n\n        >>> axvspan(1.25, 1.55, facecolor='g', alpha=0.5)\n\n        \"\"\"\n        trans = self.get_xaxis_transform(which='grid')\n\n        # process the unit information\n        self._process_unit_info([xmin, xmax], [ymin, ymax], kwargs=kwargs)\n\n        # first we need to strip away the units\n        xmin, xmax = self.convert_xunits([xmin, xmax])\n        ymin, ymax = self.convert_yunits([ymin, ymax])\n\n        verts = [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]\n        p = mpatches.Polygon(verts, **kwargs)\n        p.set_transform(trans)\n        self.add_patch(p)\n        self._request_autoscale_view(scaley=False)\n        return p",
        "begin_line": 1015,
        "end_line": 1073,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.hlines#1077",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.hlines(self, y, xmin, xmax, colors='k', linestyles='solid', label='', **kwargs)",
        "snippet": "    def hlines(self, y, xmin, xmax, colors='k', linestyles='solid',\n               label='', **kwargs):\n        \"\"\"\n        Plot horizontal lines at each *y* from *xmin* to *xmax*.\n\n        Parameters\n        ----------\n        y : scalar or sequence of scalar\n            y-indexes where to plot the lines.\n\n        xmin, xmax : scalar or 1D array-like\n            Respective beginning and end of each line. If scalars are\n            provided, all lines will have same length.\n\n        colors : array-like of colors, default: 'k'\n\n        linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, optional\n\n        label : str, default: ''\n\n        Returns\n        -------\n        lines : `~matplotlib.collections.LineCollection`\n\n        Other Parameters\n        ----------------\n        **kwargs :  `~matplotlib.collections.LineCollection` properties.\n\n        See also\n        --------\n        vlines : vertical lines\n        axhline: horizontal line across the axes\n        \"\"\"\n\n        # We do the conversion first since not all unitized data is uniform\n        # process the unit information\n        self._process_unit_info([xmin, xmax], y, kwargs=kwargs)\n        y = self.convert_yunits(y)\n        xmin = self.convert_xunits(xmin)\n        xmax = self.convert_xunits(xmax)\n\n        if not np.iterable(y):\n            y = [y]\n        if not np.iterable(xmin):\n            xmin = [xmin]\n        if not np.iterable(xmax):\n            xmax = [xmax]\n\n        y, xmin, xmax = cbook.delete_masked_points(y, xmin, xmax)\n\n        y = np.ravel(y)\n        xmin = np.resize(xmin, y.shape)\n        xmax = np.resize(xmax, y.shape)\n\n        verts = [((thisxmin, thisy), (thisxmax, thisy))\n                 for thisxmin, thisxmax, thisy in zip(xmin, xmax, y)]\n        lines = mcoll.LineCollection(verts, colors=colors,\n                                     linestyles=linestyles, label=label)\n        self.add_collection(lines, autolim=False)\n        lines.update(kwargs)\n\n        if len(y) > 0:\n            minx = min(xmin.min(), xmax.min())\n            maxx = max(xmin.max(), xmax.max())\n            miny = y.min()\n            maxy = y.max()\n\n            corners = (minx, miny), (maxx, maxy)\n\n            self.update_datalim(corners)\n            self._request_autoscale_view()\n\n        return lines",
        "begin_line": 1077,
        "end_line": 1149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.vlines#1153",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.vlines(self, x, ymin, ymax, colors='k', linestyles='solid', label='', **kwargs)",
        "snippet": "    def vlines(self, x, ymin, ymax, colors='k', linestyles='solid',\n               label='', **kwargs):\n        \"\"\"\n        Plot vertical lines.\n\n        Plot vertical lines at each *x* from *ymin* to *ymax*.\n\n        Parameters\n        ----------\n        x : scalar or 1D array-like\n            x-indexes where to plot the lines.\n\n        ymin, ymax : scalar or 1D array-like\n            Respective beginning and end of each line. If scalars are\n            provided, all lines will have same length.\n\n        colors : array-like of colors, default: 'k'\n\n        linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, optional\n\n        label : str, default: ''\n\n        Returns\n        -------\n        lines : `~matplotlib.collections.LineCollection`\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.collections.LineCollection` properties.\n\n        See also\n        --------\n        hlines : horizontal lines\n        axvline: vertical line across the axes\n        \"\"\"\n\n        self._process_unit_info(xdata=x, ydata=[ymin, ymax], kwargs=kwargs)\n\n        # We do the conversion first since not all unitized data is uniform\n        x = self.convert_xunits(x)\n        ymin = self.convert_yunits(ymin)\n        ymax = self.convert_yunits(ymax)\n\n        if not np.iterable(x):\n            x = [x]\n        if not np.iterable(ymin):\n            ymin = [ymin]\n        if not np.iterable(ymax):\n            ymax = [ymax]\n\n        x, ymin, ymax = cbook.delete_masked_points(x, ymin, ymax)\n\n        x = np.ravel(x)\n        ymin = np.resize(ymin, x.shape)\n        ymax = np.resize(ymax, x.shape)\n\n        verts = [((thisx, thisymin), (thisx, thisymax))\n                 for thisx, thisymin, thisymax in zip(x, ymin, ymax)]\n        lines = mcoll.LineCollection(verts, colors=colors,\n                                     linestyles=linestyles, label=label)\n        self.add_collection(lines, autolim=False)\n        lines.update(kwargs)\n\n        if len(x) > 0:\n            minx = x.min()\n            maxx = x.max()\n            miny = min(ymin.min(), ymax.min())\n            maxy = max(ymin.max(), ymax.max())\n\n            corners = (minx, miny), (maxx, maxy)\n            self.update_datalim(corners)\n            self._request_autoscale_view()\n\n        return lines",
        "begin_line": 1153,
        "end_line": 1226,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.plot#1460",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.plot(self, *args, scalex=True, scaley=True, data=None, **kwargs)",
        "snippet": "    def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):\n        \"\"\"\n        Plot y versus x as lines and/or markers.\n\n        Call signatures::\n\n            plot([x], y, [fmt], *, data=None, **kwargs)\n            plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)\n\n        The coordinates of the points or line nodes are given by *x*, *y*.\n\n        The optional parameter *fmt* is a convenient way for defining basic\n        formatting like color, marker and linestyle. It's a shortcut string\n        notation described in the *Notes* section below.\n\n        >>> plot(x, y)        # plot x and y using default line style and color\n        >>> plot(x, y, 'bo')  # plot x and y using blue circle markers\n        >>> plot(y)           # plot y using x as index array 0..N-1\n        >>> plot(y, 'r+')     # ditto, but with red plusses\n\n        You can use `.Line2D` properties as keyword arguments for more\n        control on the appearance. Line properties and *fmt* can be mixed.\n        The following two calls yield identical results:\n\n        >>> plot(x, y, 'go--', linewidth=2, markersize=12)\n        >>> plot(x, y, color='green', marker='o', linestyle='dashed',\n        ...      linewidth=2, markersize=12)\n\n        When conflicting with *fmt*, keyword arguments take precedence.\n\n\n        **Plotting labelled data**\n\n        There's a convenient way for plotting objects with labelled data (i.e.\n        data that can be accessed by index ``obj['y']``). Instead of giving\n        the data in *x* and *y*, you can provide the object in the *data*\n        parameter and just give the labels for *x* and *y*::\n\n        >>> plot('xlabel', 'ylabel', data=obj)\n\n        All indexable objects are supported. This could e.g. be a `dict`, a\n        `pandas.DataFrame` or a structured numpy array.\n\n\n        **Plotting multiple sets of data**\n\n        There are various ways to plot multiple sets of data.\n\n        - The most straight forward way is just to call `plot` multiple times.\n          Example:\n\n          >>> plot(x1, y1, 'bo')\n          >>> plot(x2, y2, 'go')\n\n        - Alternatively, if your data is already a 2d array, you can pass it\n          directly to *x*, *y*. A separate data set will be drawn for every\n          column.\n\n          Example: an array ``a`` where the first column represents the *x*\n          values and the other columns are the *y* columns::\n\n          >>> plot(a[0], a[1:])\n\n        - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*\n          groups::\n\n          >>> plot(x1, y1, 'g^', x2, y2, 'g-')\n\n          In this case, any additional keyword argument applies to all\n          datasets. Also this syntax cannot be combined with the *data*\n          parameter.\n\n        By default, each line is assigned a different style specified by a\n        'style cycle'. The *fmt* and line property parameters are only\n        necessary if you want explicit deviations from these defaults.\n        Alternatively, you can also change the style cycle using\n        :rc:`axes.prop_cycle`.\n\n\n        Parameters\n        ----------\n        x, y : array-like or scalar\n            The horizontal / vertical coordinates of the data points.\n            *x* values are optional and default to ``range(len(y))``.\n\n            Commonly, these parameters are 1D arrays.\n\n            They can also be scalars, or two-dimensional (in that case, the\n            columns represent separate data sets).\n\n            These arguments cannot be passed as keywords.\n\n        fmt : str, optional\n            A format string, e.g. 'ro' for red circles. See the *Notes*\n            section for a full description of the format strings.\n\n            Format strings are just an abbreviation for quickly setting\n            basic line properties. All of these and more can also be\n            controlled by keyword arguments.\n\n            This argument cannot be passed as keyword.\n\n        data : indexable object, optional\n            An object with labelled data. If given, provide the label names to\n            plot in *x* and *y*.\n\n            .. note::\n                Technically there's a slight ambiguity in calls where the\n                second label is a valid *fmt*. ``plot('n', 'o', data=obj)``\n                could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,\n                the former interpretation is chosen, but a warning is issued.\n                You may suppress the warning by adding an empty format string\n                ``plot('n', 'o', '', data=obj)``.\n\n        Other Parameters\n        ----------------\n        scalex, scaley : bool, default: True\n            These parameters determine if the view limits are adapted to the\n            data limits. The values are passed on to `autoscale_view`.\n\n        **kwargs : `.Line2D` properties, optional\n            *kwargs* are used to specify properties like a line label (for\n            auto legends), linewidth, antialiasing, marker face color.\n            Example::\n\n            >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)\n            >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')\n\n            If you make multiple lines with one plot call, the kwargs\n            apply to all those lines.\n\n            Here is a list of available `.Line2D` properties:\n\n            %(_Line2D_docstr)s\n\n        Returns\n        -------\n        lines\n            A list of `.Line2D` objects representing the plotted data.\n\n        See Also\n        --------\n        scatter : XY scatter plot with markers of varying size and/or color (\n            sometimes also called bubble chart).\n\n        Notes\n        -----\n        **Format Strings**\n\n        A format string consists of a part for color, marker and line::\n\n            fmt = '[marker][line][color]'\n\n        Each of them is optional. If not provided, the value from the style\n        cycle is used. Exception: If ``line`` is given, but no ``marker``,\n        the data will be a line without markers.\n\n        Other combinations such as ``[color][marker][line]`` are also\n        supported, but note that their parsing may be ambiguous.\n\n        **Markers**\n\n        =============    ===============================\n        character        description\n        =============    ===============================\n        ``'.'``          point marker\n        ``','``          pixel marker\n        ``'o'``          circle marker\n        ``'v'``          triangle_down marker\n        ``'^'``          triangle_up marker\n        ``'<'``          triangle_left marker\n        ``'>'``          triangle_right marker\n        ``'1'``          tri_down marker\n        ``'2'``          tri_up marker\n        ``'3'``          tri_left marker\n        ``'4'``          tri_right marker\n        ``'s'``          square marker\n        ``'p'``          pentagon marker\n        ``'*'``          star marker\n        ``'h'``          hexagon1 marker\n        ``'H'``          hexagon2 marker\n        ``'+'``          plus marker\n        ``'x'``          x marker\n        ``'D'``          diamond marker\n        ``'d'``          thin_diamond marker\n        ``'|'``          vline marker\n        ``'_'``          hline marker\n        =============    ===============================\n\n        **Line Styles**\n\n        =============    ===============================\n        character        description\n        =============    ===============================\n        ``'-'``          solid line style\n        ``'--'``         dashed line style\n        ``'-.'``         dash-dot line style\n        ``':'``          dotted line style\n        =============    ===============================\n\n        Example format strings::\n\n            'b'    # blue markers with default shape\n            'or'   # red circles\n            '-g'   # green solid line\n            '--'   # dashed line with default color\n            '^k:'  # black triangle_up markers connected by a dotted line\n\n        **Colors**\n\n        The supported color abbreviations are the single letter codes\n\n        =============    ===============================\n        character        color\n        =============    ===============================\n        ``'b'``          blue\n        ``'g'``          green\n        ``'r'``          red\n        ``'c'``          cyan\n        ``'m'``          magenta\n        ``'y'``          yellow\n        ``'k'``          black\n        ``'w'``          white\n        =============    ===============================\n\n        and the ``'CN'`` colors that index into the default property cycle.\n\n        If the color is the only part of the format string, you can\n        additionally use any  `matplotlib.colors` spec, e.g. full names\n        (``'green'``) or hex strings (``'#008000'``).\n        \"\"\"\n        kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)\n        lines = [*self._get_lines(*args, data=data, **kwargs)]\n        for line in lines:\n            self.add_line(line)\n        self._request_autoscale_view(scalex=scalex, scaley=scaley)\n        return lines",
        "begin_line": 1460,
        "end_line": 1696,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005227391531625719,
            "pseudo_dstar_susp": 0.0006622516556291391,
            "pseudo_tarantula_susp": 0.000572737686139748,
            "pseudo_op2_susp": 0.0006622516556291391,
            "pseudo_barinel_susp": 0.000572737686139748
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.loglog#1771",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.loglog(self, *args, **kwargs)",
        "snippet": "    def loglog(self, *args, **kwargs):\n        \"\"\"\n        Make a plot with log scaling on both the x and y axis.\n\n        Call signatures::\n\n            loglog([x], y, [fmt], data=None, **kwargs)\n            loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)\n\n        This is just a thin wrapper around `.plot` which additionally changes\n        both the x-axis and the y-axis to log scaling. All of the concepts and\n        parameters of plot can be used here as well.\n\n        The additional parameters *base*, *subs* and *nonpositive* control the\n        x/y-axis properties. They are just forwarded to `.Axes.set_xscale` and\n        `.Axes.set_yscale`. To use different properties on the x-axis and the\n        y-axis, use e.g.\n        ``ax.set_xscale(\"log\", base=10); ax.set_yscale(\"log\", base=2)``.\n\n        Parameters\n        ----------\n        base : float, default: 10\n            Base of the logarithm.\n\n        subs : sequence, optional\n            The location of the minor ticks. If *None*, reasonable locations\n            are automatically chosen depending on the number of decades in the\n            plot. See `.Axes.set_xscale`/`.Axes.set_yscale` for details.\n\n        nonpositive : {'mask', 'clip'}, default: 'mask'\n            Non-positive values can be masked as invalid, or clipped to a very\n            small positive number.\n\n        Returns\n        -------\n        lines\n            A list of `.Line2D` objects representing the plotted data.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            All parameters supported by `.plot`.\n        \"\"\"\n        dx = {k: v for k, v in kwargs.items()\n              if k in ['base', 'subs', 'nonpositive',\n                       'basex', 'subsx', 'nonposx']}\n        self.set_xscale('log', **dx)\n        dy = {k: v for k, v in kwargs.items()\n              if k in ['base', 'subs', 'nonpositive',\n                       'basey', 'subsy', 'nonposy']}\n        self.set_yscale('log', **dy)\n        return self.plot(\n            *args, **{k: v for k, v in kwargs.items() if k not in {*dx, *dy}})",
        "begin_line": 1771,
        "end_line": 1823,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.semilogx#1827",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.semilogx(self, *args, **kwargs)",
        "snippet": "    def semilogx(self, *args, **kwargs):\n        \"\"\"\n        Make a plot with log scaling on the x axis.\n\n        Call signatures::\n\n            semilogx([x], y, [fmt], data=None, **kwargs)\n            semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)\n\n        This is just a thin wrapper around `.plot` which additionally changes\n        the x-axis to log scaling. All of the concepts and parameters of plot\n        can be used here as well.\n\n        The additional parameters *base*, *subs*, and *nonpositive* control the\n        x-axis properties. They are just forwarded to `.Axes.set_xscale`.\n\n        Parameters\n        ----------\n        base : float, default: 10\n            Base of the x logarithm.\n\n        subs : array-like, optional\n            The location of the minor xticks. If *None*, reasonable locations\n            are automatically chosen depending on the number of decades in the\n            plot. See `.Axes.set_xscale` for details.\n\n        nonpositive : {'mask', 'clip'}, default: 'mask'\n            Non-positive values in x can be masked as invalid, or clipped to a\n            very small positive number.\n\n        Returns\n        -------\n        lines\n            A list of `.Line2D` objects representing the plotted data.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            All parameters supported by `.plot`.\n        \"\"\"\n        d = {k: v for k, v in kwargs.items()\n             if k in ['base', 'subs', 'nonpositive',\n                      'basex', 'subsx', 'nonposx']}\n        self.set_xscale('log', **d)\n        return self.plot(\n            *args, **{k: v for k, v in kwargs.items() if k not in d})",
        "begin_line": 1827,
        "end_line": 1872,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.semilogy#1876",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.semilogy(self, *args, **kwargs)",
        "snippet": "    def semilogy(self, *args, **kwargs):\n        \"\"\"\n        Make a plot with log scaling on the y axis.\n\n        Call signatures::\n\n            semilogy([x], y, [fmt], data=None, **kwargs)\n            semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)\n\n        This is just a thin wrapper around `.plot` which additionally changes\n        the y-axis to log scaling. All of the concepts and parameters of plot\n        can be used here as well.\n\n        The additional parameters *base*, *subs*, and *nonpositive* control the\n        y-axis properties. They are just forwarded to `.Axes.set_yscale`.\n\n        Parameters\n        ----------\n        base : float, default: 10\n            Base of the y logarithm.\n\n        subs : array-like, optional\n            The location of the minor yticks. If *None*, reasonable locations\n            are automatically chosen depending on the number of decades in the\n            plot. See `.Axes.set_yscale` for details.\n\n        nonpositive : {'mask', 'clip'}, default: 'mask'\n            Non-positive values in y can be masked as invalid, or clipped to a\n            very small positive number.\n\n        Returns\n        -------\n        lines\n            A list of `.Line2D` objects representing the plotted data.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            All parameters supported by `.plot`.\n        \"\"\"\n        d = {k: v for k, v in kwargs.items()\n             if k in ['base', 'subs', 'nonpositive',\n                      'basey', 'subsy', 'nonposy']}\n        self.set_yscale('log', **d)\n        return self.plot(\n            *args, **{k: v for k, v in kwargs.items() if k not in d})",
        "begin_line": 1876,
        "end_line": 1921,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.xcorr#1993",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.xcorr(self, x, y, normed=True, detrend=mlab.detrend_none, usevlines=True, maxlags=10, **kwargs)",
        "snippet": "    def xcorr(self, x, y, normed=True, detrend=mlab.detrend_none,\n              usevlines=True, maxlags=10, **kwargs):\n        r\"\"\"\n        Plot the cross correlation between *x* and *y*.\n\n        The correlation with lag k is defined as\n        :math:`\\sum_n x[n+k] \\cdot y^*[n]`, where :math:`y^*` is the complex\n        conjugate of :math:`y`.\n\n        Parameters\n        ----------\n        x, y : array-like of length n\n\n        detrend : callable, default: `.mlab.detrend_none` (no detrending)\n            A detrending function applied to *x* and *y*.  It must have the\n            signature ::\n\n                detrend(x: np.ndarray) -> np.ndarray\n\n        normed : bool, default: True\n            If ``True``, input vectors are normalised to unit length.\n\n        usevlines : bool, default: True\n            Determines the plot style.\n\n            If ``True``, vertical lines are plotted from 0 to the xcorr value\n            using `.Axes.vlines`. Additionally, a horizontal line is plotted\n            at y=0 using `.Axes.axhline`.\n\n            If ``False``, markers are plotted at the xcorr values using\n            `.Axes.plot`.\n\n        maxlags : int, default: 10\n            Number of lags to show. If None, will return all ``2 * len(x) - 1``\n            lags.\n\n        Returns\n        -------\n        lags : array (length ``2*maxlags+1``)\n            The lag vector.\n        c : array  (length ``2*maxlags+1``)\n            The auto correlation vector.\n        line : `.LineCollection` or `.Line2D`\n            `.Artist` added to the axes of the correlation:\n\n            - `.LineCollection` if *usevlines* is True.\n            - `.Line2D` if *usevlines* is False.\n        b : `.Line2D` or None\n            Horizontal line at 0 if *usevlines* is True\n            None *usevlines* is False.\n\n        Other Parameters\n        ----------------\n        linestyle : `.Line2D` property, optional\n            The linestyle for plotting the data points.\n            Only used if *usevlines* is ``False``.\n\n        marker : str, default: 'o'\n            The marker for plotting the data points.\n            Only used if *usevlines* is ``False``.\n\n        **kwargs\n            Additional parameters are passed to `.Axes.vlines` and\n            `.Axes.axhline` if *usevlines* is ``True``; otherwise they are\n            passed to `.Axes.plot`.\n\n        Notes\n        -----\n        The cross correlation is performed with `numpy.correlate` with\n        ``mode = \"full\"``.\n        \"\"\"\n        Nx = len(x)\n        if Nx != len(y):\n            raise ValueError('x and y must be equal length')\n\n        x = detrend(np.asarray(x))\n        y = detrend(np.asarray(y))\n\n        correls = np.correlate(x, y, mode=\"full\")\n\n        if normed:\n            correls /= np.sqrt(np.dot(x, x) * np.dot(y, y))\n\n        if maxlags is None:\n            maxlags = Nx - 1\n\n        if maxlags >= Nx or maxlags < 1:\n            raise ValueError('maxlags must be None or strictly '\n                             'positive < %d' % Nx)\n\n        lags = np.arange(-maxlags, maxlags + 1)\n        correls = correls[Nx - 1 - maxlags:Nx + maxlags]\n\n        if usevlines:\n            a = self.vlines(lags, [0], correls, **kwargs)\n            # Make label empty so only vertical lines get a legend entry\n            kwargs.pop('label', '')\n            b = self.axhline(**kwargs)\n        else:\n            kwargs.setdefault('marker', 'o')\n            kwargs.setdefault('linestyle', 'None')\n            a, = self.plot(lags, correls, **kwargs)\n            b = None\n        return lags, correls, a, b",
        "begin_line": 1993,
        "end_line": 2096,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.step#2101",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.step(self, x, y, *args, where='pre', data=None, **kwargs)",
        "snippet": "    def step(self, x, y, *args, where='pre', data=None, **kwargs):\n        \"\"\"\n        Make a step plot.\n\n        Call signatures::\n\n            step(x, y, [fmt], *, data=None, where='pre', **kwargs)\n            step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)\n\n        This is just a thin wrapper around `.plot` which changes some\n        formatting options. Most of the concepts and parameters of plot can be\n        used here as well.\n\n        Parameters\n        ----------\n        x : array-like\n            1-D sequence of x positions. It is assumed, but not checked, that\n            it is uniformly increasing.\n\n        y : array-like\n            1-D sequence of y levels.\n\n        fmt : str, optional\n            A format string, e.g. 'g' for a green line. See `.plot` for a more\n            detailed description.\n\n            Note: While full format strings are accepted, it is recommended to\n            only specify the color. Line styles are currently ignored (use\n            the keyword argument *linestyle* instead). Markers are accepted\n            and plotted on the given positions, however, this is a rarely\n            needed feature for step plots.\n\n        data : indexable object, optional\n            An object with labelled data. If given, provide the label names to\n            plot in *x* and *y*.\n\n        where : {'pre', 'post', 'mid'}, default: 'pre'\n            Define where the steps should be placed:\n\n            - 'pre': The y value is continued constantly to the left from\n              every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the\n              value ``y[i]``.\n            - 'post': The y value is continued constantly to the right from\n              every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the\n              value ``y[i]``.\n            - 'mid': Steps occur half-way between the *x* positions.\n\n        Returns\n        -------\n        lines\n            A list of `.Line2D` objects representing the plotted data.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Additional parameters are the same as those for `.plot`.\n\n        Notes\n        -----\n        .. [notes section required to get data note injection right]\n        \"\"\"\n        cbook._check_in_list(('pre', 'post', 'mid'), where=where)\n        kwargs['drawstyle'] = 'steps-' + where\n        return self.plot(x, y, *args, data=data, **kwargs)",
        "begin_line": 2101,
        "end_line": 2164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes._convert_dx#2167",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes._convert_dx(dx, x0, xconv, convert)",
        "snippet": "    def _convert_dx(dx, x0, xconv, convert):\n        \"\"\"\n        Small helper to do logic of width conversion flexibly.\n\n        *dx* and *x0* have units, but *xconv* has already been converted\n        to unitless (and is an ndarray).  This allows the *dx* to have units\n        that are different from *x0*, but are still accepted by the\n        ``__add__`` operator of *x0*.\n        \"\"\"\n\n        # x should be an array...\n        assert type(xconv) is np.ndarray\n\n        if xconv.size == 0:\n            # xconv has already been converted, but maybe empty...\n            return convert(dx)\n\n        try:\n            # attempt to add the width to x0; this works for\n            # datetime+timedelta, for instance\n\n            # only use the first element of x and x0.  This saves\n            # having to be sure addition works across the whole\n            # vector.  This is particularly an issue if\n            # x0 and dx are lists so x0 + dx just concatenates the lists.\n            # We can't just cast x0 and dx to numpy arrays because that\n            # removes the units from unit packages like `pint` that\n            # wrap numpy arrays.\n            try:\n                x0 = cbook.safe_first_element(x0)\n            except (TypeError, IndexError, KeyError):\n                x0 = x0\n\n            try:\n                x = cbook.safe_first_element(xconv)\n            except (TypeError, IndexError, KeyError):\n                x = xconv\n\n            delist = False\n            if not np.iterable(dx):\n                dx = [dx]\n                delist = True\n            dx = [convert(x0 + ddx) - x for ddx in dx]\n            if delist:\n                dx = dx[0]\n        except (ValueError, TypeError, AttributeError):\n            # if the above fails (for any reason) just fallback to what\n            # we do by default and convert dx by itself.\n            dx = convert(dx)\n        return dx",
        "begin_line": 2167,
        "end_line": 2216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008539709649871904,
            "pseudo_dstar_susp": 0.0006207324643078833,
            "pseudo_tarantula_susp": 0.002028397565922921,
            "pseudo_op2_susp": 0.0006207324643078833,
            "pseudo_barinel_susp": 0.002028397565922921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.bar#2220",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.bar(self, x, height, width=0.8, bottom=None, *, align='center', **kwargs)",
        "snippet": "    def bar(self, x, height, width=0.8, bottom=None, *, align=\"center\",\n            **kwargs):\n        r\"\"\"\n        Make a bar plot.\n\n        The bars are positioned at *x* with the given *align*\\ment. Their\n        dimensions are given by *width* and *height*. The vertical baseline\n        is *bottom* (default 0).\n\n        Each of *x*, *height*, *width*, and *bottom* may either be a scalar\n        applying to all bars, or it may be a sequence of length N providing a\n        separate value for each bar.\n\n        Parameters\n        ----------\n        x : sequence of scalars\n            The x coordinates of the bars. See also *align* for the\n            alignment of the bars to the coordinates.\n\n        height : scalar or sequence of scalars\n            The height(s) of the bars.\n\n        width : scalar or array-like, default: 0.8\n            The width(s) of the bars.\n\n        bottom : scalar or array-like, default: 0\n            The y coordinate(s) of the bars bases.\n\n        align : {'center', 'edge'}, default: 'center'\n            Alignment of the bars to the *x* coordinates:\n\n            - 'center': Center the base on the *x* positions.\n            - 'edge': Align the left edges of the bars with the *x* positions.\n\n            To align the bars on the right edge pass a negative *width* and\n            ``align='edge'``.\n\n        Returns\n        -------\n        container : `.BarContainer`\n            Container with all the bars and optionally errorbars.\n\n        Other Parameters\n        ----------------\n        color : scalar or array-like, optional\n            The colors of the bar faces.\n\n        edgecolor : scalar or array-like, optional\n            The colors of the bar edges.\n\n        linewidth : scalar or array-like, optional\n            Width of the bar edge(s). If 0, don't draw edges.\n\n        tick_label : str or array-like, optional\n            The tick labels of the bars.\n            Default: None (Use default numeric labels.)\n\n        xerr, yerr : scalar or array-like of shape(N,) or shape(2, N), optional\n            If not *None*, add horizontal / vertical errorbars to the bar tips.\n            The values are +/- sizes relative to the data:\n\n            - scalar: symmetric +/- values for all bars\n            - shape(N,): symmetric +/- values for each bar\n            - shape(2, N): Separate - and + values for each bar. First row\n              contains the lower errors, the second row contains the upper\n              errors.\n            - *None*: No errorbar. (Default)\n\n            See :doc:`/gallery/statistics/errorbar_features`\n            for an example on the usage of ``xerr`` and ``yerr``.\n\n        ecolor : scalar or array-like, default: 'black'\n            The line color of the errorbars.\n\n        capsize : scalar, optional\n           The length of the error bar caps in points.\n           Default: None, which will take the value from\n           :rc:`errorbar.capsize`.\n\n        error_kw : dict, optional\n            Dictionary of kwargs to be passed to the `~.Axes.errorbar`\n            method. Values of *ecolor* or *capsize* defined here take\n            precedence over the independent kwargs.\n\n        log : bool, default: False\n            If *True*, set the y-axis to be log scale.\n\n        orientation : {'vertical',  'horizontal'}, optional\n            *This is for internal use only.* Please use `barh` for\n            horizontal bar plots. Default: 'vertical'.\n\n        See also\n        --------\n        barh: Plot a horizontal bar plot.\n\n        Notes\n        -----\n        The optional arguments *color*, *edgecolor*, *linewidth*,\n        *xerr*, and *yerr* can be either scalars or sequences of\n        length equal to the number of bars.  This enables you to use\n        bar as the basis for stacked bar charts, or candlestick plots.\n        Detail: *xerr* and *yerr* are passed directly to\n        :meth:`errorbar`, so they can also have shape 2xN for\n        independent specification of lower and upper errors.\n\n        Other optional kwargs:\n\n        %(Rectangle)s\n        \"\"\"\n        kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)\n        color = kwargs.pop('color', None)\n        if color is None:\n            color = self._get_patches_for_fill.get_next_color()\n        edgecolor = kwargs.pop('edgecolor', None)\n        linewidth = kwargs.pop('linewidth', None)\n\n        # Because xerr and yerr will be passed to errorbar, most dimension\n        # checking and processing will be left to the errorbar method.\n        xerr = kwargs.pop('xerr', None)\n        yerr = kwargs.pop('yerr', None)\n        error_kw = kwargs.pop('error_kw', {})\n        ezorder = error_kw.pop('zorder', None)\n        if ezorder is None:\n            ezorder = kwargs.get('zorder', None)\n            if ezorder is not None:\n                # If using the bar zorder, increment slightly to make sure\n                # errorbars are drawn on top of bars\n                ezorder += 0.01\n        error_kw.setdefault('zorder', ezorder)\n        ecolor = kwargs.pop('ecolor', 'k')\n        capsize = kwargs.pop('capsize', rcParams[\"errorbar.capsize\"])\n        error_kw.setdefault('ecolor', ecolor)\n        error_kw.setdefault('capsize', capsize)\n\n        orientation = kwargs.pop('orientation', 'vertical')\n        cbook._check_in_list(['vertical', 'horizontal'],\n                             orientation=orientation)\n        log = kwargs.pop('log', False)\n        label = kwargs.pop('label', '')\n        tick_labels = kwargs.pop('tick_label', None)\n\n        y = bottom  # Matches barh call signature.\n        if orientation == 'vertical':\n            if y is None:\n                y = 0\n        elif orientation == 'horizontal':\n            if x is None:\n                x = 0\n\n        if orientation == 'vertical':\n            self._process_unit_info(xdata=x, ydata=height, kwargs=kwargs)\n            if log:\n                self.set_yscale('log', nonpositive='clip')\n        elif orientation == 'horizontal':\n            self._process_unit_info(xdata=width, ydata=y, kwargs=kwargs)\n            if log:\n                self.set_xscale('log', nonpositive='clip')\n\n        # lets do some conversions now since some types cannot be\n        # subtracted uniformly\n        if self.xaxis is not None:\n            x0 = x\n            x = np.asarray(self.convert_xunits(x))\n            width = self._convert_dx(width, x0, x, self.convert_xunits)\n            if xerr is not None:\n                xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)\n        if self.yaxis is not None:\n            y0 = y\n            y = np.asarray(self.convert_yunits(y))\n            height = self._convert_dx(height, y0, y, self.convert_yunits)\n            if yerr is not None:\n                yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)\n\n        x, height, width, y, linewidth = np.broadcast_arrays(\n            # Make args iterable too.\n            np.atleast_1d(x), height, width, y, linewidth)\n\n        # Now that units have been converted, set the tick locations.\n        if orientation == 'vertical':\n            tick_label_axis = self.xaxis\n            tick_label_position = x\n        elif orientation == 'horizontal':\n            tick_label_axis = self.yaxis\n            tick_label_position = y\n\n        linewidth = itertools.cycle(np.atleast_1d(linewidth))\n        color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),\n                                # Fallback if color == \"none\".\n                                itertools.repeat('none'))\n        if edgecolor is None:\n            edgecolor = itertools.repeat(None)\n        else:\n            edgecolor = itertools.chain(\n                itertools.cycle(mcolors.to_rgba_array(edgecolor)),\n                # Fallback if edgecolor == \"none\".\n                itertools.repeat('none'))\n\n        # We will now resolve the alignment and really have\n        # left, bottom, width, height vectors\n        cbook._check_in_list(['center', 'edge'], align=align)\n        if align == 'center':\n            if orientation == 'vertical':\n                try:\n                    left = x - width / 2\n                except TypeError as e:\n                    raise TypeError(f'the dtypes of parameters x ({x.dtype}) '\n                                    f'and width ({width.dtype}) '\n                                    f'are incompatible') from e\n                bottom = y\n            elif orientation == 'horizontal':\n                try:\n                    bottom = y - height / 2\n                except TypeError as e:\n                    raise TypeError(f'the dtypes of parameters y ({y.dtype}) '\n                                    f'and height ({height.dtype}) '\n                                    f'are incompatible') from e\n                left = x\n        elif align == 'edge':\n            left = x\n            bottom = y\n\n        patches = []\n        args = zip(left, bottom, width, height, color, edgecolor, linewidth)\n        for l, b, w, h, c, e, lw in args:\n            r = mpatches.Rectangle(\n                xy=(l, b), width=w, height=h,\n                facecolor=c,\n                edgecolor=e,\n                linewidth=lw,\n                label='_nolegend_',\n                )\n            r.update(kwargs)\n            r.get_path()._interpolation_steps = 100\n            if orientation == 'vertical':\n                r.sticky_edges.y.append(b)\n            elif orientation == 'horizontal':\n                r.sticky_edges.x.append(l)\n            self.add_patch(r)\n            patches.append(r)\n\n        if xerr is not None or yerr is not None:\n            if orientation == 'vertical':\n                # using list comps rather than arrays to preserve unit info\n                ex = [l + 0.5 * w for l, w in zip(left, width)]\n                ey = [b + h for b, h in zip(bottom, height)]\n\n            elif orientation == 'horizontal':\n                # using list comps rather than arrays to preserve unit info\n                ex = [l + w for l, w in zip(left, width)]\n                ey = [b + 0.5 * h for b, h in zip(bottom, height)]\n\n            error_kw.setdefault(\"label\", '_nolegend_')\n\n            errorbar = self.errorbar(ex, ey,\n                                     yerr=yerr, xerr=xerr,\n                                     fmt='none', **error_kw)\n        else:\n            errorbar = None\n\n        self._request_autoscale_view()\n\n        bar_container = BarContainer(patches, errorbar, label=label)\n        self.add_container(bar_container)\n\n        if tick_labels is not None:\n            tick_labels = np.broadcast_to(tick_labels, len(patches))\n            tick_label_axis.set_ticks(tick_label_position)\n            tick_label_axis.set_ticklabels(tick_labels)\n\n        return bar_container",
        "begin_line": 2220,
        "end_line": 2489,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000708215297450425,
            "pseudo_dstar_susp": 0.0006191950464396285,
            "pseudo_tarantula_susp": 0.0019569471624266144,
            "pseudo_op2_susp": 0.0006191950464396285,
            "pseudo_barinel_susp": 0.0019569471624266144
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.barh#2492",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.barh(self, y, width, height=0.8, left=None, *, align='center', **kwargs)",
        "snippet": "    def barh(self, y, width, height=0.8, left=None, *, align=\"center\",\n             **kwargs):\n        r\"\"\"\n        Make a horizontal bar plot.\n\n        The bars are positioned at *y* with the given *align*\\ment. Their\n        dimensions are given by *width* and *height*. The horizontal baseline\n        is *left* (default 0).\n\n        Each of *y*, *width*, *height*, and *left* may either be a scalar\n        applying to all bars, or it may be a sequence of length N providing a\n        separate value for each bar.\n\n        Parameters\n        ----------\n        y : scalar or array-like\n            The y coordinates of the bars. See also *align* for the\n            alignment of the bars to the coordinates.\n\n        width : scalar or array-like\n            The width(s) of the bars.\n\n        height : sequence of scalars, default: 0.8\n            The heights of the bars.\n\n        left : sequence of scalars, default: 0\n            The x coordinates of the left sides of the bars.\n\n        align : {'center', 'edge'}, default: 'center'\n            Alignment of the base to the *y* coordinates*:\n\n            - 'center': Center the bars on the *y* positions.\n            - 'edge': Align the bottom edges of the bars with the *y*\n              positions.\n\n            To align the bars on the top edge pass a negative *height* and\n            ``align='edge'``.\n\n        Returns\n        -------\n        container : `.BarContainer`\n            Container with all the bars and optionally errorbars.\n\n        Other Parameters\n        ----------------\n        color : scalar or array-like, optional\n            The colors of the bar faces.\n\n        edgecolor : scalar or array-like, optional\n            The colors of the bar edges.\n\n        linewidth : scalar or array-like, optional\n            Width of the bar edge(s). If 0, don't draw edges.\n\n        tick_label : str or array-like, optional\n            The tick labels of the bars.\n            Default: None (Use default numeric labels.)\n\n        xerr, yerr : scalar or array-like of shape(N,) or shape(2, N), optional\n            If not ``None``, add horizontal / vertical errorbars to the\n            bar tips. The values are +/- sizes relative to the data:\n\n            - scalar: symmetric +/- values for all bars\n            - shape(N,): symmetric +/- values for each bar\n            - shape(2, N): Separate - and + values for each bar. First row\n              contains the lower errors, the second row contains the upper\n              errors.\n            - *None*: No errorbar. (default)\n\n            See :doc:`/gallery/statistics/errorbar_features`\n            for an example on the usage of ``xerr`` and ``yerr``.\n\n        ecolor : scalar or array-like, default: 'black'\n            The line color of the errorbars.\n\n        capsize : scalar, optional\n           The length of the error bar caps in points.\n           Default: None, which will take the value from\n           :rc:`errorbar.capsize`.\n\n        error_kw : dict, optional\n            Dictionary of kwargs to be passed to the `~.Axes.errorbar`\n            method. Values of *ecolor* or *capsize* defined here take\n            precedence over the independent kwargs.\n\n        log : bool, default: False\n            If ``True``, set the x-axis to be log scale.\n\n        See also\n        --------\n        bar: Plot a vertical bar plot.\n\n        Notes\n        -----\n        The optional arguments *color*, *edgecolor*, *linewidth*,\n        *xerr*, and *yerr* can be either scalars or sequences of\n        length equal to the number of bars.  This enables you to use\n        bar as the basis for stacked bar charts, or candlestick plots.\n        Detail: *xerr* and *yerr* are passed directly to\n        :meth:`errorbar`, so they can also have shape 2xN for\n        independent specification of lower and upper errors.\n\n        Other optional kwargs:\n\n        %(Rectangle)s\n        \"\"\"\n        kwargs.setdefault('orientation', 'horizontal')\n        patches = self.bar(x=left, height=height, width=width, bottom=y,\n                           align=align, **kwargs)\n        return patches",
        "begin_line": 2492,
        "end_line": 2601,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.broken_barh#2605",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.broken_barh(self, xranges, yrange, **kwargs)",
        "snippet": "    def broken_barh(self, xranges, yrange, **kwargs):\n        \"\"\"\n        Plot a horizontal sequence of rectangles.\n\n        A rectangle is drawn for each element of *xranges*. All rectangles\n        have the same vertical position and size defined by *yrange*.\n\n        This is a convenience function for instantiating a\n        `.BrokenBarHCollection`, adding it to the axes and autoscaling the\n        view.\n\n        Parameters\n        ----------\n        xranges : sequence of tuples (*xmin*, *xwidth*)\n            The x-positions and extends of the rectangles. For each tuple\n            (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +\n            *xwidth*.\n        yrange : (*ymin*, *yheight*)\n            The y-position and extend for all the rectangles.\n\n        Other Parameters\n        ----------------\n        **kwargs : `.BrokenBarHCollection` properties\n\n            Each *kwarg* can be either a single argument applying to all\n            rectangles, e.g.::\n\n                facecolors='black'\n\n            or a sequence of arguments over which is cycled, e.g.::\n\n                facecolors=('black', 'blue')\n\n            would create interleaving black and blue rectangles.\n\n            Supported keywords:\n\n            %(BrokenBarHCollection)s\n\n        Returns\n        -------\n        collection : `~.collections.BrokenBarHCollection`\n        \"\"\"\n        # process the unit information\n        if len(xranges):\n            xdata = cbook.safe_first_element(xranges)\n        else:\n            xdata = None\n        if len(yrange):\n            ydata = cbook.safe_first_element(yrange)\n        else:\n            ydata = None\n        self._process_unit_info(xdata=xdata,\n                                ydata=ydata,\n                                kwargs=kwargs)\n        xranges_conv = []\n        for xr in xranges:\n            if len(xr) != 2:\n                raise ValueError('each range in xrange must be a sequence '\n                                 'with two elements (i.e. an Nx2 array)')\n            # convert the absolute values, not the x and dx...\n            x_conv = np.asarray(self.convert_xunits(xr[0]))\n            x1 = self._convert_dx(xr[1], xr[0], x_conv, self.convert_xunits)\n            xranges_conv.append((x_conv, x1))\n\n        yrange_conv = self.convert_yunits(yrange)\n\n        col = mcoll.BrokenBarHCollection(xranges_conv, yrange_conv, **kwargs)\n        self.add_collection(col, autolim=True)\n        self._request_autoscale_view()\n\n        return col",
        "begin_line": 2605,
        "end_line": 2676,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.stem#2679",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0, label=None, use_line_collection=True)",
        "snippet": "    def stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,\n             label=None, use_line_collection=True):\n        \"\"\"\n        Create a stem plot.\n\n        A stem plot plots vertical lines at each *x* location from the baseline\n        to *y*, and places a marker there.\n\n        Call signature::\n\n          stem([x,] y, linefmt=None, markerfmt=None, basefmt=None)\n\n        The x-positions are optional. The formats may be provided either as\n        positional or as keyword-arguments.\n\n        Parameters\n        ----------\n        x : array-like, optional\n            The x-positions of the stems. Default: (0, 1, ..., len(y) - 1).\n\n        y : array-like\n            The y-values of the stem heads.\n\n        linefmt : str, optional\n            A string defining the properties of the vertical lines. Usually,\n            this will be a color or a color and a linestyle:\n\n            =========  =============\n            Character  Line Style\n            =========  =============\n            ``'-'``    solid line\n            ``'--'``   dashed line\n            ``'-.'``   dash-dot line\n            ``':'``    dotted line\n            =========  =============\n\n            Default: 'C0-', i.e. solid line with the first color of the color\n            cycle.\n\n            Note: While it is technically possible to specify valid formats\n            other than color or color and linestyle (e.g. 'rx' or '-.'), this\n            is beyond the intention of the method and will most likely not\n            result in a reasonable reasonable plot.\n\n        markerfmt : str, optional\n            A string defining the properties of the markers at the stem heads.\n            Default: 'C0o', i.e. filled circles with the first color of the\n            color cycle.\n\n        basefmt : str, default: 'C3-' ('C2-' in classic mode)\n            A format string defining the properties of the baseline.\n\n        bottom : float, default: 0\n            The y-position of the baseline.\n\n        label : str, default: None\n            The label to use for the stems in legends.\n\n        use_line_collection : bool, default: True\n            If ``True``, store and plot the stem lines as a\n            `~.collections.LineCollection` instead of individual lines, which\n            significantly increases performance.  If ``False``, defaults to the\n            old behavior of using a list of `.Line2D` objects.  This parameter\n            may be deprecated in the future.\n\n        Returns\n        -------\n        container : `.StemContainer`\n            The container may be treated like a tuple\n            (*markerline*, *stemlines*, *baseline*)\n\n        Notes\n        -----\n        .. seealso::\n            The MATLAB function\n            `stem <http://www.mathworks.com/help/techdoc/ref/stem.html>`_\n            which inspired this method.\n        \"\"\"\n        if not 1 <= len(args) <= 5:\n            raise TypeError('stem expected between 1 and 5 positional '\n                            'arguments, got {}'.format(args))\n\n        if len(args) == 1:\n            y, = args\n            x = np.arange(len(y))\n            args = ()\n        else:\n            x, y, *args = args\n\n        self._process_unit_info(xdata=x, ydata=y)\n        x = self.convert_xunits(x)\n        y = self.convert_yunits(y)\n\n        # defaults for formats\n        if linefmt is None:\n            try:\n                # fallback to positional argument\n                linefmt = args[0]\n            except IndexError:\n                linecolor = 'C0'\n                linemarker = 'None'\n                linestyle = '-'\n            else:\n                linestyle, linemarker, linecolor = \\\n                    _process_plot_format(linefmt)\n        else:\n            linestyle, linemarker, linecolor = _process_plot_format(linefmt)\n\n        if markerfmt is None:\n            try:\n                # fallback to positional argument\n                markerfmt = args[1]\n            except IndexError:\n                markercolor = 'C0'\n                markermarker = 'o'\n                markerstyle = 'None'\n            else:\n                markerstyle, markermarker, markercolor = \\\n                    _process_plot_format(markerfmt)\n        else:\n            markerstyle, markermarker, markercolor = \\\n                _process_plot_format(markerfmt)\n\n        if basefmt is None:\n            try:\n                # fallback to positional argument\n                basefmt = args[2]\n            except IndexError:\n                if rcParams['_internal.classic_mode']:\n                    basecolor = 'C2'\n                else:\n                    basecolor = 'C3'\n                basemarker = 'None'\n                basestyle = '-'\n            else:\n                basestyle, basemarker, basecolor = \\\n                    _process_plot_format(basefmt)\n        else:\n            basestyle, basemarker, basecolor = _process_plot_format(basefmt)\n\n        # New behaviour in 3.1 is to use a LineCollection for the stemlines\n        if use_line_collection:\n            stemlines = [((xi, bottom), (xi, yi)) for xi, yi in zip(x, y)]\n            if linestyle is None:\n                linestyle = rcParams['lines.linestyle']\n            stemlines = mcoll.LineCollection(stemlines, linestyles=linestyle,\n                                             colors=linecolor,\n                                             label='_nolegend_')\n            self.add_collection(stemlines)\n        # Old behaviour is to plot each of the lines individually\n        else:\n            stemlines = []\n            for xi, yi in zip(x, y):\n                l, = self.plot([xi, xi], [bottom, yi],\n                               color=linecolor, linestyle=linestyle,\n                               marker=linemarker, label=\"_nolegend_\")\n                stemlines.append(l)\n\n        markerline, = self.plot(x, y, color=markercolor, linestyle=markerstyle,\n                                marker=markermarker, label=\"_nolegend_\")\n\n        baseline, = self.plot([np.min(x), np.max(x)], [bottom, bottom],\n                              color=basecolor, linestyle=basestyle,\n                              marker=basemarker, label=\"_nolegend_\")\n\n        stem_container = StemContainer((markerline, stemlines, baseline),\n                                       label=label)\n        self.add_container(stem_container)\n        return stem_container",
        "begin_line": 2679,
        "end_line": 2847,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.pie#2850",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.pie(self, x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None, radius=None, counterclock=True, wedgeprops=None, textprops=None, center=(0, 0), frame=False, rotatelabels=False)",
        "snippet": "    def pie(self, x, explode=None, labels=None, colors=None,\n            autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,\n            startangle=None, radius=None, counterclock=True,\n            wedgeprops=None, textprops=None, center=(0, 0),\n            frame=False, rotatelabels=False):\n        \"\"\"\n        Plot a pie chart.\n\n        Make a pie chart of array *x*.  The fractional area of each wedge is\n        given by ``x/sum(x)``.  If ``sum(x) < 1``, then the values of *x* give\n        the fractional area directly and the array will not be normalized. The\n        resulting pie will have an empty wedge of size ``1 - sum(x)``.\n\n        The wedges are plotted counterclockwise, by default starting from the\n        x-axis.\n\n        Parameters\n        ----------\n        x : array-like\n            The wedge sizes.\n\n        explode : array-like, default: None\n            If not *None*, is a ``len(x)`` array which specifies the fraction\n            of the radius with which to offset each wedge.\n\n        labels : list, default: None\n            A sequence of strings providing the labels for each wedge\n\n        colors : array-like, default: None\n            A sequence of colors through which the pie chart will cycle.  If\n            *None*, will use the colors in the currently active cycle.\n\n        autopct : None or str or callable, default: None\n            If not *None*, is a string or function used to label the wedges\n            with their numeric value.  The label will be placed inside the\n            wedge.  If it is a format string, the label will be ``fmt%pct``.\n            If it is a function, it will be called.\n\n        pctdistance : float, default: 0.6\n            The ratio between the center of each pie slice and the start of\n            the text generated by *autopct*.  Ignored if *autopct* is *None*.\n\n        shadow : bool, default: False\n            Draw a shadow beneath the pie.\n\n        labeldistance : float or None, default: 1.1\n            The radial distance at which the pie labels are drawn.\n            If set to ``None``, label are not drawn, but are stored for use in\n            ``legend()``\n\n        startangle : float, default: None\n            If not *None*, rotates the start of the pie chart by *angle*\n            degrees counterclockwise from the x-axis.\n\n        radius : float, default: None\n            The radius of the pie, if *radius* is *None* it will be set to 1.\n\n        counterclock : bool, default: True\n            Specify fractions direction, clockwise or counterclockwise.\n\n        wedgeprops : dict, default: None\n            Dict of arguments passed to the wedge objects making the pie.\n            For example, you can pass in ``wedgeprops = {'linewidth': 3}``\n            to set the width of the wedge border lines equal to 3.\n            For more details, look at the doc/arguments of the wedge object.\n            By default ``clip_on=False``.\n\n        textprops : dict, default: None\n            Dict of arguments to pass to the text objects.\n\n        center : (float, float), default: (0, 0)\n            The coordinates of the center of the chart.\n\n        frame : bool, default: False\n            Plot axes frame with the chart if true.\n\n        rotatelabels : bool, default: False\n            Rotate each label to the angle of the corresponding slice if true.\n\n        Returns\n        -------\n        patches : list\n            A sequence of `matplotlib.patches.Wedge` instances\n\n        texts : list\n            A list of the label `.Text` instances.\n\n        autotexts : list\n            A list of `.Text` instances for the numeric labels. This will only\n            be returned if the parameter *autopct* is not *None*.\n\n        Notes\n        -----\n        The pie chart will probably look best if the figure and axes are\n        square, or the Axes aspect is equal.\n        This method sets the aspect ratio of the axis to \"equal\".\n        The axes aspect ratio can be controlled with `.Axes.set_aspect`.\n        \"\"\"\n        self.set_aspect('equal')\n        # The use of float32 is \"historical\", but can't be changed without\n        # regenerating the test baselines.\n        x = np.asarray(x, np.float32)\n        if x.ndim != 1 and x.squeeze().ndim <= 1:\n            cbook.warn_deprecated(\n                \"3.1\", message=\"Non-1D inputs to pie() are currently \"\n                \"squeeze()d, but this behavior is deprecated since %(since)s \"\n                \"and will be removed %(removal)s; pass a 1D array instead.\")\n            x = np.atleast_1d(x.squeeze())\n\n        if np.any(x < 0):\n            raise ValueError(\"Wedge sizes 'x' must be non negative values\")\n\n        sx = x.sum()\n        if sx > 1:\n            x = x / sx\n\n        if labels is None:\n            labels = [''] * len(x)\n        if explode is None:\n            explode = [0] * len(x)\n        if len(x) != len(labels):\n            raise ValueError(\"'label' must be of length 'x'\")\n        if len(x) != len(explode):\n            raise ValueError(\"'explode' must be of length 'x'\")\n        if colors is None:\n            get_next_color = self._get_patches_for_fill.get_next_color\n        else:\n            color_cycle = itertools.cycle(colors)\n\n            def get_next_color():\n                return next(color_cycle)\n\n        if radius is None:\n            radius = 1\n\n        # Starting theta1 is the start fraction of the circle\n        if startangle is None:\n            theta1 = 0\n        else:\n            theta1 = startangle / 360.0\n\n        # set default values in wedge_prop\n        if wedgeprops is None:\n            wedgeprops = {}\n        wedgeprops.setdefault('clip_on', False)\n\n        if textprops is None:\n            textprops = {}\n        textprops.setdefault('clip_on', False)\n\n        texts = []\n        slices = []\n        autotexts = []\n\n        for frac, label, expl in zip(x, labels, explode):\n            x, y = center\n            theta2 = (theta1 + frac) if counterclock else (theta1 - frac)\n            thetam = 2 * np.pi * 0.5 * (theta1 + theta2)\n            x += expl * math.cos(thetam)\n            y += expl * math.sin(thetam)\n\n            w = mpatches.Wedge((x, y), radius, 360. * min(theta1, theta2),\n                               360. * max(theta1, theta2),\n                               facecolor=get_next_color(),\n                               **wedgeprops)\n            slices.append(w)\n            self.add_patch(w)\n            w.set_label(label)\n\n            if shadow:\n                # make sure to add a shadow after the call to\n                # add_patch so the figure and transform props will be\n                # set\n                shad = mpatches.Shadow(w, -0.02, -0.02)\n                shad.set_zorder(0.9 * w.get_zorder())\n                shad.set_label('_nolegend_')\n                self.add_patch(shad)\n\n            if labeldistance is not None:\n                xt = x + labeldistance * radius * math.cos(thetam)\n                yt = y + labeldistance * radius * math.sin(thetam)\n                label_alignment_h = 'left' if xt > 0 else 'right'\n                label_alignment_v = 'center'\n                label_rotation = 'horizontal'\n                if rotatelabels:\n                    label_alignment_v = 'bottom' if yt > 0 else 'top'\n                    label_rotation = (np.rad2deg(thetam)\n                                      + (0 if xt > 0 else 180))\n                props = dict(horizontalalignment=label_alignment_h,\n                             verticalalignment=label_alignment_v,\n                             rotation=label_rotation,\n                             size=rcParams['xtick.labelsize'])\n                props.update(textprops)\n\n                t = self.text(xt, yt, label, **props)\n\n                texts.append(t)\n\n            if autopct is not None:\n                xt = x + pctdistance * radius * math.cos(thetam)\n                yt = y + pctdistance * radius * math.sin(thetam)\n                if isinstance(autopct, str):\n                    s = autopct % (100. * frac)\n                elif callable(autopct):\n                    s = autopct(100. * frac)\n                else:\n                    raise TypeError(\n                        'autopct must be callable or a format string')\n\n                props = dict(horizontalalignment='center',\n                             verticalalignment='center')\n                props.update(textprops)\n                t = self.text(xt, yt, s, **props)\n\n                autotexts.append(t)\n\n            theta1 = theta2\n\n        if not frame:\n            self.set_frame_on(False)\n\n            self.set_xlim((-1.25 + center[0],\n                           1.25 + center[0]))\n            self.set_ylim((-1.25 + center[1],\n                           1.25 + center[1]))\n            self.set_xticks([])\n            self.set_yticks([])\n\n        if autopct is None:\n            return slices, texts\n        else:\n            return slices, texts, autotexts",
        "begin_line": 2850,
        "end_line": 3081,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.get_next_color#2979",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.get_next_color()",
        "snippet": "            def get_next_color():\n                return next(color_cycle)",
        "begin_line": 2979,
        "end_line": 2980,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.errorbar#3086",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.errorbar(self, x, y, yerr=None, xerr=None, fmt='', ecolor=None, elinewidth=None, capsize=None, barsabove=False, lolims=False, uplims=False, xlolims=False, xuplims=False, errorevery=1, capthick=None, **kwargs)",
        "snippet": "    def errorbar(self, x, y, yerr=None, xerr=None,\n                 fmt='', ecolor=None, elinewidth=None, capsize=None,\n                 barsabove=False, lolims=False, uplims=False,\n                 xlolims=False, xuplims=False, errorevery=1, capthick=None,\n                 **kwargs):\n        \"\"\"\n        Plot y versus x as lines and/or markers with attached errorbars.\n\n        *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar\n        sizes. By default, this draws the data markers/lines as well the\n        errorbars. Use fmt='none' to draw errorbars without any data markers.\n\n        Parameters\n        ----------\n        x, y : scalar or array-like\n            The data positions.\n\n        xerr, yerr : scalar or array-like, shape(N,) or shape(2, N), optional\n            The errorbar sizes:\n\n            - scalar: Symmetric +/- values for all data points.\n            - shape(N,): Symmetric +/-values for each data point.\n            - shape(2, N): Separate - and + values for each bar. First row\n              contains the lower errors, the second row contains the upper\n              errors.\n            - *None*: No errorbar.\n\n            Note that all error arrays should have *positive* values.\n\n            See :doc:`/gallery/statistics/errorbar_features`\n            for an example on the usage of ``xerr`` and ``yerr``.\n\n        fmt : str, default: ''\n            The format for the data points / data lines. See `.plot` for\n            details.\n\n            Use 'none' (case insensitive) to plot errorbars without any data\n            markers.\n\n        ecolor : color, default: None\n            The color of the errorbar lines.  If None, use the color of the\n            line connecting the markers.\n\n        elinewidth : scalar, default: None\n            The linewidth of the errorbar lines. If None, the linewidth of\n            the current style is used.\n\n        capsize : scalar, default: :rc:`errorbar.capsize`\n            The length of the error bar caps in points.\n\n        capthick : scalar, default: None\n            An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).\n            This setting is a more sensible name for the property that\n            controls the thickness of the error bar cap in points. For\n            backwards compatibility, if *mew* or *markeredgewidth* are given,\n            then they will over-ride *capthick*. This may change in future\n            releases.\n\n        barsabove : bool, default: False\n            If True, will plot the errorbars above the plot\n            symbols. Default is below.\n\n        lolims, uplims, xlolims, xuplims : bool, default: False\n            These arguments can be used to indicate that a value gives only\n            upper/lower limits. In that case a caret symbol is used to\n            indicate this. *lims*-arguments may be of the same type as *xerr*\n            and *yerr*.  To use limits with inverted axes, `~.Axes.set_xlim`\n            or `~.Axes.set_ylim` must be called before :meth:`errorbar`.\n\n        errorevery : int or (int, int), default: 1\n            draws error bars on a subset of the data. *errorevery* =N draws\n            error bars on the points (x[::N], y[::N]).\n            *errorevery* =(start, N) draws error bars on the points\n            (x[start::N], y[start::N]). e.g. errorevery=(6, 3)\n            adds error bars to the data at (x[6], x[9], x[12], x[15], ...).\n            Used to avoid overlapping error bars when two series share x-axis\n            values.\n\n        Returns\n        -------\n        container : `.ErrorbarContainer`\n            The container contains:\n\n            - plotline: `.Line2D` instance of x, y plot markers and/or line.\n            - caplines: A tuple of `.Line2D` instances of the error bar caps.\n            - barlinecols: A tuple of `.LineCollection` with the horizontal and\n              vertical error ranges.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            All other keyword arguments are passed on to the `~.Axes.plot` call\n            drawing the markers. For example, this code makes big red squares\n            with thick green edges::\n\n                x, y, yerr = rand(3, 10)\n                errorbar(x, y, yerr, marker='s', mfc='red',\n                         mec='green', ms=20, mew=4)\n\n            where *mfc*, *mec*, *ms* and *mew* are aliases for the longer\n            property names, *markerfacecolor*, *markeredgecolor*, *markersize*\n            and *markeredgewidth*.\n\n            Valid kwargs for the marker properties are `.Line2D` properties:\n\n            %(_Line2D_docstr)s\n        \"\"\"\n        kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)\n        # anything that comes in as 'None', drop so the default thing\n        # happens down stream\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        kwargs.setdefault('zorder', 2)\n\n        try:\n            offset, errorevery = errorevery\n        except TypeError:\n            offset = 0\n\n        if errorevery < 1 or int(errorevery) != errorevery:\n            raise ValueError(\n                'errorevery must be positive integer or tuple of integers')\n        if int(offset) != offset:\n            raise ValueError(\"errorevery's starting index must be an integer\")\n\n        self._process_unit_info(xdata=x, ydata=y, kwargs=kwargs)\n\n        plot_line = (fmt.lower() != 'none')\n        label = kwargs.pop(\"label\", None)\n\n        if fmt == '':\n            fmt_style_kwargs = {}\n        else:\n            fmt_style_kwargs = {k: v for k, v in\n                                zip(('linestyle', 'marker', 'color'),\n                                    _process_plot_format(fmt))\n                                if v is not None}\n        if fmt == 'none':\n            # Remove alpha=0 color that _process_plot_format returns\n            fmt_style_kwargs.pop('color')\n\n        if ('color' in kwargs or 'color' in fmt_style_kwargs):\n            base_style = {}\n            if 'color' in kwargs:\n                base_style['color'] = kwargs.pop('color')\n        else:\n            base_style = next(self._get_lines.prop_cycler)\n\n        base_style['label'] = '_nolegend_'\n        base_style.update(fmt_style_kwargs)\n        if 'color' not in base_style:\n            base_style['color'] = 'C0'\n        if ecolor is None:\n            ecolor = base_style['color']\n        # make sure all the args are iterable; use lists not arrays to\n        # preserve units\n        if not np.iterable(x):\n            x = [x]\n\n        if not np.iterable(y):\n            y = [y]\n\n        if xerr is not None:\n            if not np.iterable(xerr):\n                xerr = [xerr] * len(x)\n\n        if yerr is not None:\n            if not np.iterable(yerr):\n                yerr = [yerr] * len(y)\n\n        # make the style dict for the 'normal' plot line\n        plot_line_style = {\n            **base_style,\n            **kwargs,\n            'zorder': (kwargs['zorder'] - .1 if barsabove else\n                       kwargs['zorder'] + .1),\n        }\n\n        # make the style dict for the line collections (the bars)\n        eb_lines_style = dict(base_style)\n        eb_lines_style.pop('marker', None)\n        eb_lines_style.pop('linestyle', None)\n        eb_lines_style['color'] = ecolor\n\n        if elinewidth:\n            eb_lines_style['linewidth'] = elinewidth\n        elif 'linewidth' in kwargs:\n            eb_lines_style['linewidth'] = kwargs['linewidth']\n\n        for key in ('transform', 'alpha', 'zorder', 'rasterized'):\n            if key in kwargs:\n                eb_lines_style[key] = kwargs[key]\n\n        # set up cap style dictionary\n        eb_cap_style = dict(base_style)\n        # eject any marker information from format string\n        eb_cap_style.pop('marker', None)\n        eb_lines_style.pop('markerfacecolor', None)\n        eb_lines_style.pop('markeredgewidth', None)\n        eb_lines_style.pop('markeredgecolor', None)\n        eb_cap_style.pop('ls', None)\n        eb_cap_style['linestyle'] = 'none'\n        if capsize is None:\n            capsize = rcParams[\"errorbar.capsize\"]\n        if capsize > 0:\n            eb_cap_style['markersize'] = 2. * capsize\n        if capthick is not None:\n            eb_cap_style['markeredgewidth'] = capthick\n\n        # For backwards-compat, allow explicit setting of\n        # 'markeredgewidth' to over-ride capthick.\n        for key in ('markeredgewidth', 'transform', 'alpha',\n                    'zorder', 'rasterized'):\n            if key in kwargs:\n                eb_cap_style[key] = kwargs[key]\n        eb_cap_style['color'] = ecolor\n\n        data_line = None\n        if plot_line:\n            data_line = mlines.Line2D(x, y, **plot_line_style)\n            self.add_line(data_line)\n\n        barcols = []\n        caplines = []\n\n        # arrays fine here, they are booleans and hence not units\n        lolims = np.broadcast_to(lolims, len(x)).astype(bool)\n        uplims = np.broadcast_to(uplims, len(x)).astype(bool)\n        xlolims = np.broadcast_to(xlolims, len(x)).astype(bool)\n        xuplims = np.broadcast_to(xuplims, len(x)).astype(bool)\n\n        everymask = np.zeros(len(x), bool)\n        everymask[offset::errorevery] = True\n\n        def xywhere(xs, ys, mask):\n            \"\"\"\n            return xs[mask], ys[mask] where mask is True but xs and\n            ys are not arrays\n            \"\"\"\n            assert len(xs) == len(ys)\n            assert len(xs) == len(mask)\n            xs = [thisx for thisx, b in zip(xs, mask) if b]\n            ys = [thisy for thisy, b in zip(ys, mask) if b]\n            return xs, ys\n\n        def extract_err(err, data):\n            \"\"\"\n            Private function to parse *err* and subtract/add it to *data*.\n\n            Both *err* and *data* are already iterables at this point.\n            \"\"\"\n            try:  # Asymmetric error: pair of 1D iterables.\n                a, b = err\n                iter(a)\n                iter(b)\n            except (TypeError, ValueError):\n                a = b = err  # Symmetric error: 1D iterable.\n            # This could just be `np.ndim(a) > 1 and np.ndim(b) > 1`, except\n            # for the (undocumented, but tested) support for (n, 1) arrays.\n            a_sh = np.shape(a)\n            b_sh = np.shape(b)\n            if (len(a_sh) > 2 or (len(a_sh) == 2 and a_sh[1] != 1)\n                    or len(b_sh) > 2 or (len(b_sh) == 2 and b_sh[1] != 1)):\n                raise ValueError(\n                    \"err must be a scalar or a 1D or (2, n) array-like\")\n            if len(a_sh) == 2 or len(b_sh) == 2:\n                cbook.warn_deprecated(\n                    \"3.1\", message=\"Support for passing a (n, 1)-shaped error \"\n                    \"array to errorbar() is deprecated since Matplotlib \"\n                    \"%(since)s and will be removed %(removal)s; pass a 1D \"\n                    \"array instead.\")\n            # Using list comprehensions rather than arrays to preserve units.\n            for e in [a, b]:\n                if len(data) != len(e):\n                    raise ValueError(\n                        f\"The lengths of the data ({len(data)}) and the \"\n                        f\"error {len(e)} do not match\")\n            low = [v - e for v, e in zip(data, a)]\n            high = [v + e for v, e in zip(data, b)]\n            return low, high\n\n        if xerr is not None:\n            left, right = extract_err(xerr, x)\n            # select points without upper/lower limits in x and\n            # draw normal errorbars for these points\n            noxlims = ~(xlolims | xuplims)\n            if noxlims.any() or len(noxlims) == 0:\n                yo, _ = xywhere(y, right, noxlims & everymask)\n                lo, ro = xywhere(left, right, noxlims & everymask)\n                barcols.append(self.hlines(yo, lo, ro, **eb_lines_style))\n                if capsize > 0:\n                    caplines.append(mlines.Line2D(lo, yo, marker='|',\n                                                  **eb_cap_style))\n                    caplines.append(mlines.Line2D(ro, yo, marker='|',\n                                                  **eb_cap_style))\n\n            if xlolims.any():\n                yo, _ = xywhere(y, right, xlolims & everymask)\n                lo, ro = xywhere(x, right, xlolims & everymask)\n                barcols.append(self.hlines(yo, lo, ro, **eb_lines_style))\n                rightup, yup = xywhere(right, y, xlolims & everymask)\n                if self.xaxis_inverted():\n                    marker = mlines.CARETLEFTBASE\n                else:\n                    marker = mlines.CARETRIGHTBASE\n                caplines.append(\n                    mlines.Line2D(rightup, yup, ls='None', marker=marker,\n                                  **eb_cap_style))\n                if capsize > 0:\n                    xlo, ylo = xywhere(x, y, xlolims & everymask)\n                    caplines.append(mlines.Line2D(xlo, ylo, marker='|',\n                                                  **eb_cap_style))\n\n            if xuplims.any():\n                yo, _ = xywhere(y, right, xuplims & everymask)\n                lo, ro = xywhere(left, x, xuplims & everymask)\n                barcols.append(self.hlines(yo, lo, ro, **eb_lines_style))\n                leftlo, ylo = xywhere(left, y, xuplims & everymask)\n                if self.xaxis_inverted():\n                    marker = mlines.CARETRIGHTBASE\n                else:\n                    marker = mlines.CARETLEFTBASE\n                caplines.append(\n                    mlines.Line2D(leftlo, ylo, ls='None', marker=marker,\n                                  **eb_cap_style))\n                if capsize > 0:\n                    xup, yup = xywhere(x, y, xuplims & everymask)\n                    caplines.append(mlines.Line2D(xup, yup, marker='|',\n                                                  **eb_cap_style))\n\n        if yerr is not None:\n            lower, upper = extract_err(yerr, y)\n            # select points without upper/lower limits in y and\n            # draw normal errorbars for these points\n            noylims = ~(lolims | uplims)\n            if noylims.any() or len(noylims) == 0:\n                xo, _ = xywhere(x, lower, noylims & everymask)\n                lo, uo = xywhere(lower, upper, noylims & everymask)\n                barcols.append(self.vlines(xo, lo, uo, **eb_lines_style))\n                if capsize > 0:\n                    caplines.append(mlines.Line2D(xo, lo, marker='_',\n                                                  **eb_cap_style))\n                    caplines.append(mlines.Line2D(xo, uo, marker='_',\n                                                  **eb_cap_style))\n\n            if lolims.any():\n                xo, _ = xywhere(x, lower, lolims & everymask)\n                lo, uo = xywhere(y, upper, lolims & everymask)\n                barcols.append(self.vlines(xo, lo, uo, **eb_lines_style))\n                xup, upperup = xywhere(x, upper, lolims & everymask)\n                if self.yaxis_inverted():\n                    marker = mlines.CARETDOWNBASE\n                else:\n                    marker = mlines.CARETUPBASE\n                caplines.append(\n                    mlines.Line2D(xup, upperup, ls='None', marker=marker,\n                                  **eb_cap_style))\n                if capsize > 0:\n                    xlo, ylo = xywhere(x, y, lolims & everymask)\n                    caplines.append(mlines.Line2D(xlo, ylo, marker='_',\n                                                  **eb_cap_style))\n\n            if uplims.any():\n                xo, _ = xywhere(x, lower, uplims & everymask)\n                lo, uo = xywhere(lower, y, uplims & everymask)\n                barcols.append(self.vlines(xo, lo, uo, **eb_lines_style))\n                xlo, lowerlo = xywhere(x, lower, uplims & everymask)\n                if self.yaxis_inverted():\n                    marker = mlines.CARETUPBASE\n                else:\n                    marker = mlines.CARETDOWNBASE\n                caplines.append(\n                    mlines.Line2D(xlo, lowerlo, ls='None', marker=marker,\n                                  **eb_cap_style))\n                if capsize > 0:\n                    xup, yup = xywhere(x, y, uplims & everymask)\n                    caplines.append(mlines.Line2D(xup, yup, marker='_',\n                                                  **eb_cap_style))\n        for l in caplines:\n            self.add_line(l)\n\n        self._request_autoscale_view()\n        errorbar_container = ErrorbarContainer((data_line, tuple(caplines),\n                                                tuple(barcols)),\n                                               has_xerr=(xerr is not None),\n                                               has_yerr=(yerr is not None),\n                                               label=label)\n        self.containers.append(errorbar_container)\n\n        return errorbar_container  # (l0, caplines, barcols)",
        "begin_line": 3086,
        "end_line": 3474,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.xywhere#3319",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.xywhere(xs, ys, mask)",
        "snippet": "        def xywhere(xs, ys, mask):\n            \"\"\"\n            return xs[mask], ys[mask] where mask is True but xs and\n            ys are not arrays\n            \"\"\"\n            assert len(xs) == len(ys)\n            assert len(xs) == len(mask)\n            xs = [thisx for thisx, b in zip(xs, mask) if b]\n            ys = [thisy for thisy, b in zip(ys, mask) if b]\n            return xs, ys",
        "begin_line": 3319,
        "end_line": 3328,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.extract_err#3330",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.extract_err(err, data)",
        "snippet": "        def extract_err(err, data):\n            \"\"\"\n            Private function to parse *err* and subtract/add it to *data*.\n\n            Both *err* and *data* are already iterables at this point.\n            \"\"\"\n            try:  # Asymmetric error: pair of 1D iterables.\n                a, b = err\n                iter(a)\n                iter(b)\n            except (TypeError, ValueError):\n                a = b = err  # Symmetric error: 1D iterable.\n            # This could just be `np.ndim(a) > 1 and np.ndim(b) > 1`, except\n            # for the (undocumented, but tested) support for (n, 1) arrays.\n            a_sh = np.shape(a)\n            b_sh = np.shape(b)\n            if (len(a_sh) > 2 or (len(a_sh) == 2 and a_sh[1] != 1)\n                    or len(b_sh) > 2 or (len(b_sh) == 2 and b_sh[1] != 1)):\n                raise ValueError(\n                    \"err must be a scalar or a 1D or (2, n) array-like\")\n            if len(a_sh) == 2 or len(b_sh) == 2:\n                cbook.warn_deprecated(\n                    \"3.1\", message=\"Support for passing a (n, 1)-shaped error \"\n                    \"array to errorbar() is deprecated since Matplotlib \"\n                    \"%(since)s and will be removed %(removal)s; pass a 1D \"\n                    \"array instead.\")\n            # Using list comprehensions rather than arrays to preserve units.\n            for e in [a, b]:\n                if len(data) != len(e):\n                    raise ValueError(\n                        f\"The lengths of the data ({len(data)}) and the \"\n                        f\"error {len(e)} do not match\")\n            low = [v - e for v, e in zip(data, a)]\n            high = [v + e for v, e in zip(data, b)]\n            return low, high",
        "begin_line": 3330,
        "end_line": 3364,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.boxplot#3477",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.boxplot(self, x, notch=None, sym=None, vert=None, whis=None, positions=None, widths=None, patch_artist=None, bootstrap=None, usermedians=None, conf_intervals=None, meanline=None, showmeans=None, showcaps=None, showbox=None, showfliers=None, boxprops=None, labels=None, flierprops=None, medianprops=None, meanprops=None, capprops=None, whiskerprops=None, manage_ticks=True, autorange=False, zorder=None)",
        "snippet": "    def boxplot(self, x, notch=None, sym=None, vert=None, whis=None,\n                positions=None, widths=None, patch_artist=None,\n                bootstrap=None, usermedians=None, conf_intervals=None,\n                meanline=None, showmeans=None, showcaps=None,\n                showbox=None, showfliers=None, boxprops=None,\n                labels=None, flierprops=None, medianprops=None,\n                meanprops=None, capprops=None, whiskerprops=None,\n                manage_ticks=True, autorange=False, zorder=None):\n        \"\"\"\n        Make a box and whisker plot.\n\n        Make a box and whisker plot for each column of *x* or each\n        vector in sequence *x*.  The box extends from the lower to\n        upper quartile values of the data, with a line at the median.\n        The whiskers extend from the box to show the range of the\n        data.  Flier points are those past the end of the whiskers.\n\n        Parameters\n        ----------\n        x : Array or a sequence of vectors.\n            The input data.\n\n        notch : bool, default: False\n            Whether to draw a noteched box plot (`True`), or a rectangular box\n            plot (`False`).  The notches represent the confidence interval (CI)\n            around the median.  The documentation for *bootstrap* describes how\n            the locations of the notches are computed.\n\n            .. note::\n\n                In cases where the values of the CI are less than the\n                lower quartile or greater than the upper quartile, the\n                notches will extend beyond the box, giving it a\n                distinctive \"flipped\" appearance. This is expected\n                behavior and consistent with other statistical\n                visualization packages.\n\n        sym : str, optional\n            The default symbol for flier points.  An empty string ('') hides\n            the fliers.  If `None`, then the fliers default to 'b+'.  More\n            control is provided by the *flierprops* parameter.\n\n        vert : bool, default: True\n            If `True`, draws vertical boxes.\n            If `False`, draw horizontal boxes.\n\n        whis : float or (float, float), default: 1.5\n            The position of the whiskers.\n\n            If a float, the lower whisker is at the lowest datum above\n            ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum\n            below ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and\n            third quartiles.  The default value of ``whis = 1.5`` corresponds\n            to Tukey's original definition of boxplots.\n\n            If a pair of floats, they indicate the percentiles at which to\n            draw the whiskers (e.g., (5, 95)).  In particular, setting this to\n            (0, 100) results in whiskers covering the whole range of the data.\n            \"range\" is a deprecated synonym for (0, 100).\n\n            In the edge case where ``Q1 == Q3``, *whis* is automatically set\n            to (0, 100) (cover the whole range of the data) if *autorange* is\n            True.\n\n            Beyond the whiskers, data are considered outliers and are plotted\n            as individual points.\n\n        bootstrap : int, optional\n            Specifies whether to bootstrap the confidence intervals\n            around the median for notched boxplots. If *bootstrap* is\n            None, no bootstrapping is performed, and notches are\n            calculated using a Gaussian-based asymptotic approximation\n            (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and\n            Kendall and Stuart, 1967). Otherwise, bootstrap specifies\n            the number of times to bootstrap the median to determine its\n            95% confidence intervals. Values between 1000 and 10000 are\n            recommended.\n\n        usermedians : array-like, optional\n            A 1D array-like of length ``len(x)``.  Each entry that is not\n            `None` forces the value of the median for the corresponding\n            dataset.  For entries that are `None`, the medians are computed\n            by Matplotlib as normal.\n\n        conf_intervals : array-like, optional\n            A 2D array-like of shape ``(len(x), 2)``.  Each entry that is not\n            None forces the location of the corresponding notch (which is\n            only drawn if *notch* is `True`).  For entries that are `None`,\n            the notches are computed by the method specified by the other\n            parameters (e.g., *bootstrap*).\n\n        positions : array-like, optional\n            Sets the positions of the boxes. The ticks and limits are\n            automatically set to match the positions. Defaults to\n            ``range(1, N+1)`` where N is the number of boxes to be drawn.\n\n        widths : scalar or array-like\n            Sets the width of each box either with a scalar or a\n            sequence. The default is 0.5, or ``0.15*(distance between\n            extreme positions)``, if that is smaller.\n\n        patch_artist : bool, default: False\n            If `False` produces boxes with the Line2D artist. Otherwise,\n            boxes and drawn with Patch artists.\n\n        labels : sequence, optional\n            Labels for each dataset (one per dataset).\n\n        manage_ticks : bool, default: True\n            If True, the tick locations and labels will be adjusted to match\n            the boxplot positions.\n\n        autorange : bool, default: False\n            When `True` and the data are distributed such that the 25th and\n            75th percentiles are equal, *whis* is set to (0, 100) such\n            that the whisker ends are at the minimum and maximum of the data.\n\n        meanline : bool, default: False\n            If `True` (and *showmeans* is `True`), will try to render the\n            mean as a line spanning the full width of the box according to\n            *meanprops* (see below).  Not recommended if *shownotches* is also\n            True.  Otherwise, means will be shown as points.\n\n        zorder : scalar, default: None\n            Sets the zorder of the boxplot.\n\n        Other Parameters\n        ----------------\n        showcaps : bool, default: True\n            Show the caps on the ends of whiskers.\n        showbox : bool, default: True\n            Show the central box.\n        showfliers : bool, default: True\n            Show the outliers beyond the caps.\n        showmeans : bool, default: False\n            Show the arithmetic means.\n        capprops : dict, default: None\n            The style of the caps.\n        boxprops : dict, default: None\n            The style of the box.\n        whiskerprops : dict, default: None\n            The style of the whiskers.\n        flierprops : dict, default: None\n            The style of the fliers.\n        medianprops : dict, default: None\n            The style of the median.\n        meanprops : dict, default: None\n            The style of the mean.\n\n        Returns\n        -------\n        result : dict\n          A dictionary mapping each component of the boxplot to a list\n          of the `.Line2D` instances created. That dictionary has the\n          following keys (assuming vertical boxplots):\n\n          - ``boxes``: the main body of the boxplot showing the\n            quartiles and the median's confidence intervals if\n            enabled.\n\n          - ``medians``: horizontal lines at the median of each box.\n\n          - ``whiskers``: the vertical lines extending to the most\n            extreme, non-outlier data points.\n\n          - ``caps``: the horizontal lines at the ends of the\n            whiskers.\n\n          - ``fliers``: points representing data that extend beyond\n            the whiskers (fliers).\n\n          - ``means``: points or lines representing the means.\n\n        \"\"\"\n\n        # Missing arguments default to rcParams.\n        if whis is None:\n            whis = rcParams['boxplot.whiskers']\n        if bootstrap is None:\n            bootstrap = rcParams['boxplot.bootstrap']\n\n        bxpstats = cbook.boxplot_stats(x, whis=whis, bootstrap=bootstrap,\n                                       labels=labels, autorange=autorange)\n        if notch is None:\n            notch = rcParams['boxplot.notch']\n        if vert is None:\n            vert = rcParams['boxplot.vertical']\n        if patch_artist is None:\n            patch_artist = rcParams['boxplot.patchartist']\n        if meanline is None:\n            meanline = rcParams['boxplot.meanline']\n        if showmeans is None:\n            showmeans = rcParams['boxplot.showmeans']\n        if showcaps is None:\n            showcaps = rcParams['boxplot.showcaps']\n        if showbox is None:\n            showbox = rcParams['boxplot.showbox']\n        if showfliers is None:\n            showfliers = rcParams['boxplot.showfliers']\n\n        if boxprops is None:\n            boxprops = {}\n        if whiskerprops is None:\n            whiskerprops = {}\n        if capprops is None:\n            capprops = {}\n        if medianprops is None:\n            medianprops = {}\n        if meanprops is None:\n            meanprops = {}\n        if flierprops is None:\n            flierprops = {}\n\n        if patch_artist:\n            boxprops['linestyle'] = 'solid'  # Not consistent with bxp.\n            if 'color' in boxprops:\n                boxprops['edgecolor'] = boxprops.pop('color')\n\n        # if non-default sym value, put it into the flier dictionary\n        # the logic for providing the default symbol ('b+') now lives\n        # in bxp in the initial value of final_flierprops\n        # handle all of the *sym* related logic here so we only have to pass\n        # on the flierprops dict.\n        if sym is not None:\n            # no-flier case, which should really be done with\n            # 'showfliers=False' but none-the-less deal with it to keep back\n            # compatibility\n            if sym == '':\n                # blow away existing dict and make one for invisible markers\n                flierprops = dict(linestyle='none', marker='', color='none')\n                # turn the fliers off just to be safe\n                showfliers = False\n            # now process the symbol string\n            else:\n                # process the symbol string\n                # discarded linestyle\n                _, marker, color = _process_plot_format(sym)\n                # if we have a marker, use it\n                if marker is not None:\n                    flierprops['marker'] = marker\n                # if we have a color, use it\n                if color is not None:\n                    # assume that if color is passed in the user want\n                    # filled symbol, if the users want more control use\n                    # flierprops\n                    flierprops['color'] = color\n                    flierprops['markerfacecolor'] = color\n                    flierprops['markeredgecolor'] = color\n\n        # replace medians if necessary:\n        if usermedians is not None:\n            if (len(np.ravel(usermedians)) != len(bxpstats) or\n                    np.shape(usermedians)[0] != len(bxpstats)):\n                raise ValueError(\n                    \"'usermedians' and 'x' have different lengths\")\n            else:\n                # reassign medians as necessary\n                for stats, med in zip(bxpstats, usermedians):\n                    if med is not None:\n                        stats['med'] = med\n\n        if conf_intervals is not None:\n            if np.shape(conf_intervals)[0] != len(bxpstats):\n                raise ValueError(\n                    \"'conf_intervals' and 'x' have different lengths\")\n            else:\n                for stats, ci in zip(bxpstats, conf_intervals):\n                    if ci is not None:\n                        if len(ci) != 2:\n                            raise ValueError('each confidence interval must '\n                                             'have two values')\n                        else:\n                            if ci[0] is not None:\n                                stats['cilo'] = ci[0]\n                            if ci[1] is not None:\n                                stats['cihi'] = ci[1]\n\n        artists = self.bxp(bxpstats, positions=positions, widths=widths,\n                           vert=vert, patch_artist=patch_artist,\n                           shownotches=notch, showmeans=showmeans,\n                           showcaps=showcaps, showbox=showbox,\n                           boxprops=boxprops, flierprops=flierprops,\n                           medianprops=medianprops, meanprops=meanprops,\n                           meanline=meanline, showfliers=showfliers,\n                           capprops=capprops, whiskerprops=whiskerprops,\n                           manage_ticks=manage_ticks, zorder=zorder)\n        return artists",
        "begin_line": 3477,
        "end_line": 3763,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.bxp#3765",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.bxp(self, bxpstats, positions=None, widths=None, vert=True, patch_artist=False, shownotches=False, showmeans=False, showcaps=True, showbox=True, showfliers=True, boxprops=None, whiskerprops=None, flierprops=None, medianprops=None, capprops=None, meanprops=None, meanline=False, manage_ticks=True, zorder=None)",
        "snippet": "    def bxp(self, bxpstats, positions=None, widths=None, vert=True,\n            patch_artist=False, shownotches=False, showmeans=False,\n            showcaps=True, showbox=True, showfliers=True,\n            boxprops=None, whiskerprops=None, flierprops=None,\n            medianprops=None, capprops=None, meanprops=None,\n            meanline=False, manage_ticks=True, zorder=None):\n        \"\"\"\n        Drawing function for box and whisker plots.\n\n        Make a box and whisker plot for each column of *x* or each\n        vector in sequence *x*.  The box extends from the lower to\n        upper quartile values of the data, with a line at the median.\n        The whiskers extend from the box to show the range of the\n        data.  Flier points are those past the end of the whiskers.\n\n        Parameters\n        ----------\n        bxpstats : list of dicts\n          A list of dictionaries containing stats for each boxplot.\n          Required keys are:\n\n          - ``med``: The median (scalar float).\n\n          - ``q1``: The first quartile (25th percentile) (scalar\n            float).\n\n          - ``q3``: The third quartile (75th percentile) (scalar\n            float).\n\n          - ``whislo``: Lower bound of the lower whisker (scalar\n            float).\n\n          - ``whishi``: Upper bound of the upper whisker (scalar\n            float).\n\n          Optional keys are:\n\n          - ``mean``: The mean (scalar float). Needed if\n            ``showmeans=True``.\n\n          - ``fliers``: Data beyond the whiskers (sequence of floats).\n            Needed if ``showfliers=True``.\n\n          - ``cilo`` & ``cihi``: Lower and upper confidence intervals\n            about the median. Needed if ``shownotches=True``.\n\n          - ``label``: Name of the dataset (string). If available,\n            this will be used a tick label for the boxplot\n\n        positions : array-like, default: [1, 2, ..., n]\n          Sets the positions of the boxes. The ticks and limits\n          are automatically set to match the positions.\n\n        widths : array-like, default: None\n          Either a scalar or a vector and sets the width of each\n          box. The default is ``0.15*(distance between extreme\n          positions)``, clipped to no less than 0.15 and no more than\n          0.5.\n\n        vert : bool, default: True\n          If `True` (default), makes the boxes vertical.  If `False`,\n          makes horizontal boxes.\n\n        patch_artist : bool, default: False\n          If `False` produces boxes with the `.Line2D` artist.\n          If `True` produces boxes with the `~matplotlib.patches.Patch` artist.\n\n        shownotches : bool, default: False\n          If `False` (default), produces a rectangular box plot.\n          If `True`, will produce a notched box plot\n\n        showmeans : bool, default: False\n          If `True`, will toggle on the rendering of the means\n\n        showcaps  : bool, default: True\n          If `True`, will toggle on the rendering of the caps\n\n        showbox  : bool, default: True\n          If `True`, will toggle on the rendering of the box\n\n        showfliers : bool, default: True\n          If `True`, will toggle on the rendering of the fliers\n\n        boxprops : dict or None (default)\n          If provided, will set the plotting style of the boxes\n\n        whiskerprops : dict or None (default)\n          If provided, will set the plotting style of the whiskers\n\n        capprops : dict or None (default)\n          If provided, will set the plotting style of the caps\n\n        flierprops : dict or None (default)\n          If provided will set the plotting style of the fliers\n\n        medianprops : dict or None (default)\n          If provided, will set the plotting style of the medians\n\n        meanprops : dict or None (default)\n          If provided, will set the plotting style of the means\n\n        meanline : bool, default: False\n          If `True` (and *showmeans* is `True`), will try to render the mean\n          as a line spanning the full width of the box according to\n          *meanprops*. Not recommended if *shownotches* is also True.\n          Otherwise, means will be shown as points.\n\n        manage_ticks : bool, default: True\n          If True, the tick locations and labels will be adjusted to match the\n          boxplot positions.\n\n        zorder : scalar, default: None\n          The zorder of the resulting boxplot.\n\n        Returns\n        -------\n        result : dict\n          A dictionary mapping each component of the boxplot to a list\n          of the `.Line2D` instances created. That dictionary has the\n          following keys (assuming vertical boxplots):\n\n          - ``boxes``: the main body of the boxplot showing the\n            quartiles and the median's confidence intervals if\n            enabled.\n\n          - ``medians``: horizontal lines at the median of each box.\n\n          - ``whiskers``: the vertical lines extending to the most\n            extreme, non-outlier data points.\n\n          - ``caps``: the horizontal lines at the ends of the\n            whiskers.\n\n          - ``fliers``: points representing data that extend beyond\n            the whiskers (fliers).\n\n          - ``means``: points or lines representing the means.\n\n        Examples\n        --------\n        .. plot:: gallery/statistics/bxp.py\n\n        \"\"\"\n        # lists of artists to be output\n        whiskers = []\n        caps = []\n        boxes = []\n        medians = []\n        means = []\n        fliers = []\n\n        # empty list of xticklabels\n        datalabels = []\n\n        # Use default zorder if none specified\n        if zorder is None:\n            zorder = mlines.Line2D.zorder\n\n        zdelta = 0.1\n\n        def line_props_with_rcdefaults(subkey, explicit, zdelta=0,\n                                       use_marker=True):\n            d = {k.split('.')[-1]: v for k, v in rcParams.items()\n                 if k.startswith(f'boxplot.{subkey}')}\n            d['zorder'] = zorder + zdelta\n            if not use_marker:\n                d['marker'] = ''\n            if explicit is not None:\n                d.update(cbook.normalize_kwargs(explicit, mlines.Line2D))\n            return d\n\n        # box properties\n        if patch_artist:\n            final_boxprops = dict(\n                linestyle=rcParams['boxplot.boxprops.linestyle'],\n                linewidth=rcParams['boxplot.boxprops.linewidth'],\n                edgecolor=rcParams['boxplot.boxprops.color'],\n                facecolor=('white' if rcParams['_internal.classic_mode'] else\n                           rcParams['patch.facecolor']),\n                zorder=zorder,\n            )\n            if boxprops is not None:\n                final_boxprops.update(\n                    cbook.normalize_kwargs(boxprops, mpatches.PathPatch))\n        else:\n            final_boxprops = line_props_with_rcdefaults('boxprops', boxprops,\n                                                        use_marker=False)\n        final_whiskerprops = line_props_with_rcdefaults(\n            'whiskerprops', whiskerprops, use_marker=False)\n        final_capprops = line_props_with_rcdefaults(\n            'capprops', capprops, use_marker=False)\n        final_flierprops = line_props_with_rcdefaults(\n            'flierprops', flierprops)\n        final_medianprops = line_props_with_rcdefaults(\n            'medianprops', medianprops, zdelta, use_marker=False)\n        final_meanprops = line_props_with_rcdefaults(\n            'meanprops', meanprops, zdelta)\n        removed_prop = 'marker' if meanline else 'linestyle'\n        # Only remove the property if it's not set explicitly as a parameter.\n        if meanprops is None or removed_prop not in meanprops:\n            final_meanprops[removed_prop] = ''\n\n        def patch_list(xs, ys, **kwargs):\n            path = mpath.Path(\n                # Last vertex will have a CLOSEPOLY code and thus be ignored.\n                np.append(np.column_stack([xs, ys]), [(0, 0)], 0),\n                closed=True)\n            patch = mpatches.PathPatch(path, **kwargs)\n            self.add_artist(patch)\n            return [patch]\n\n        # vertical or horizontal plot?\n        if vert:\n            def doplot(*args, **kwargs):\n                return self.plot(*args, **kwargs)\n\n            def dopatch(xs, ys, **kwargs):\n                return patch_list(xs, ys, **kwargs)\n\n        else:\n            def doplot(*args, **kwargs):\n                shuffled = []\n                for i in range(0, len(args), 2):\n                    shuffled.extend([args[i + 1], args[i]])\n                return self.plot(*shuffled, **kwargs)\n\n            def dopatch(xs, ys, **kwargs):\n                xs, ys = ys, xs  # flip X, Y\n                return patch_list(xs, ys, **kwargs)\n\n        # input validation\n        N = len(bxpstats)\n        datashape_message = (\"List of boxplot statistics and `{0}` \"\n                             \"values must have same the length\")\n        # check position\n        if positions is None:\n            positions = list(range(1, N + 1))\n        elif len(positions) != N:\n            raise ValueError(datashape_message.format(\"positions\"))\n\n        positions = np.array(positions)\n        if len(positions) > 0 and not isinstance(positions[0], Number):\n            raise TypeError(\"positions should be an iterable of numbers\")\n\n        # width\n        if widths is None:\n            widths = [np.clip(0.15 * np.ptp(positions), 0.15, 0.5)] * N\n        elif np.isscalar(widths):\n            widths = [widths] * N\n        elif len(widths) != N:\n            raise ValueError(datashape_message.format(\"widths\"))\n\n        for pos, width, stats in zip(positions, widths, bxpstats):\n            # try to find a new label\n            datalabels.append(stats.get('label', pos))\n\n            # whisker coords\n            whisker_x = np.ones(2) * pos\n            whiskerlo_y = np.array([stats['q1'], stats['whislo']])\n            whiskerhi_y = np.array([stats['q3'], stats['whishi']])\n\n            # cap coords\n            cap_left = pos - width * 0.25\n            cap_right = pos + width * 0.25\n            cap_x = np.array([cap_left, cap_right])\n            cap_lo = np.ones(2) * stats['whislo']\n            cap_hi = np.ones(2) * stats['whishi']\n\n            # box and median coords\n            box_left = pos - width * 0.5\n            box_right = pos + width * 0.5\n            med_y = [stats['med'], stats['med']]\n\n            # notched boxes\n            if shownotches:\n                box_x = [box_left, box_right, box_right, cap_right, box_right,\n                         box_right, box_left, box_left, cap_left, box_left,\n                         box_left]\n                box_y = [stats['q1'], stats['q1'], stats['cilo'],\n                         stats['med'], stats['cihi'], stats['q3'],\n                         stats['q3'], stats['cihi'], stats['med'],\n                         stats['cilo'], stats['q1']]\n                med_x = cap_x\n\n            # plain boxes\n            else:\n                box_x = [box_left, box_right, box_right, box_left, box_left]\n                box_y = [stats['q1'], stats['q1'], stats['q3'], stats['q3'],\n                         stats['q1']]\n                med_x = [box_left, box_right]\n\n            # maybe draw the box:\n            if showbox:\n                if patch_artist:\n                    boxes.extend(dopatch(box_x, box_y, **final_boxprops))\n                else:\n                    boxes.extend(doplot(box_x, box_y, **final_boxprops))\n\n            # draw the whiskers\n            whiskers.extend(doplot(\n                whisker_x, whiskerlo_y, **final_whiskerprops\n            ))\n            whiskers.extend(doplot(\n                whisker_x, whiskerhi_y, **final_whiskerprops\n            ))\n\n            # maybe draw the caps:\n            if showcaps:\n                caps.extend(doplot(cap_x, cap_lo, **final_capprops))\n                caps.extend(doplot(cap_x, cap_hi, **final_capprops))\n\n            # draw the medians\n            medians.extend(doplot(med_x, med_y, **final_medianprops))\n\n            # maybe draw the means\n            if showmeans:\n                if meanline:\n                    means.extend(doplot(\n                        [box_left, box_right], [stats['mean'], stats['mean']],\n                        **final_meanprops\n                    ))\n                else:\n                    means.extend(doplot(\n                        [pos], [stats['mean']], **final_meanprops\n                    ))\n\n            # maybe draw the fliers\n            if showfliers:\n                # fliers coords\n                flier_x = np.full(len(stats['fliers']), pos, dtype=np.float64)\n                flier_y = stats['fliers']\n\n                fliers.extend(doplot(\n                    flier_x, flier_y, **final_flierprops\n                ))\n\n        if manage_ticks:\n            axis_name = \"x\" if vert else \"y\"\n            interval = getattr(self.dataLim, f\"interval{axis_name}\")\n            axis = getattr(self, f\"{axis_name}axis\")\n            positions = axis.convert_units(positions)\n            # The 0.5 additional padding ensures reasonable-looking boxes\n            # even when drawing a single box.  We set the sticky edge to\n            # prevent margins expansion, in order to match old behavior (back\n            # when separate calls to boxplot() would completely reset the axis\n            # limits regardless of what was drawn before).  The sticky edges\n            # are attached to the median lines, as they are always present.\n            interval[:] = (min(interval[0], min(positions) - .5),\n                           max(interval[1], max(positions) + .5))\n            for median, position in zip(medians, positions):\n                getattr(median.sticky_edges, axis_name).extend(\n                    [position - .5, position + .5])\n            # Modified from Axis.set_ticks and Axis.set_ticklabels.\n            locator = axis.get_major_locator()\n            if not isinstance(axis.get_major_locator(),\n                              mticker.FixedLocator):\n                locator = mticker.FixedLocator([])\n                axis.set_major_locator(locator)\n            locator.locs = np.array([*locator.locs, *positions])\n            formatter = axis.get_major_formatter()\n            if not isinstance(axis.get_major_formatter(),\n                              mticker.FixedFormatter):\n                formatter = mticker.FixedFormatter([])\n                axis.set_major_formatter(formatter)\n            formatter.seq = [*formatter.seq, *datalabels]\n\n            self._request_autoscale_view(\n                scalex=self._autoscaleXon, scaley=self._autoscaleYon)\n\n        return dict(whiskers=whiskers, caps=caps, boxes=boxes,\n                    medians=medians, fliers=fliers, means=means)",
        "begin_line": 3765,
        "end_line": 4135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.line_props_with_rcdefaults#3925",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.line_props_with_rcdefaults(subkey, explicit, zdelta=0, use_marker=True)",
        "snippet": "        def line_props_with_rcdefaults(subkey, explicit, zdelta=0,\n                                       use_marker=True):\n            d = {k.split('.')[-1]: v for k, v in rcParams.items()\n                 if k.startswith(f'boxplot.{subkey}')}\n            d['zorder'] = zorder + zdelta\n            if not use_marker:\n                d['marker'] = ''\n            if explicit is not None:\n                d.update(cbook.normalize_kwargs(explicit, mlines.Line2D))\n            return d",
        "begin_line": 3925,
        "end_line": 3934,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.patch_list#3967",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.patch_list(xs, ys, **kwargs)",
        "snippet": "        def patch_list(xs, ys, **kwargs):\n            path = mpath.Path(\n                # Last vertex will have a CLOSEPOLY code and thus be ignored.\n                np.append(np.column_stack([xs, ys]), [(0, 0)], 0),\n                closed=True)\n            patch = mpatches.PathPatch(path, **kwargs)\n            self.add_artist(patch)\n            return [patch]",
        "begin_line": 3967,
        "end_line": 3974,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.doplot#3978",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.doplot(*args, **kwargs)",
        "snippet": "            def doplot(*args, **kwargs):\n                return self.plot(*args, **kwargs)",
        "begin_line": 3978,
        "end_line": 3979,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.dopatch#3981",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.dopatch(xs, ys, **kwargs)",
        "snippet": "            def dopatch(xs, ys, **kwargs):\n                return patch_list(xs, ys, **kwargs)",
        "begin_line": 3981,
        "end_line": 3982,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.doplot#3985",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.doplot(*args, **kwargs)",
        "snippet": "            def doplot(*args, **kwargs):\n                shuffled = []\n                for i in range(0, len(args), 2):\n                    shuffled.extend([args[i + 1], args[i]])\n                return self.plot(*shuffled, **kwargs)",
        "begin_line": 3985,
        "end_line": 3989,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes._parse_scatter_color_args#4138",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes._parse_scatter_color_args(c, edgecolors, kwargs, xsize, get_next_color_func)",
        "snippet": "    def _parse_scatter_color_args(c, edgecolors, kwargs, xsize,\n                                  get_next_color_func):\n        \"\"\"\n        Helper function to process color related arguments of `.Axes.scatter`.\n\n        Argument precedence for facecolors:\n\n        - c (if not None)\n        - kwargs['facecolors']\n        - kwargs['facecolor']\n        - kwargs['color'] (==kwcolor)\n        - 'b' if in classic mode else the result of ``get_next_color_func()``\n\n        Argument precedence for edgecolors:\n\n        - edgecolors (is an explicit kw argument in scatter())\n        - kwargs['edgecolor']\n        - kwargs['color'] (==kwcolor)\n        - 'face' if not in classic mode else None\n\n        Parameters\n        ----------\n        c : color or sequence or sequence of color or None\n            See argument description of `.Axes.scatter`.\n        edgecolors : color or sequence of color or {'face', 'none'} or None\n            See argument description of `.Axes.scatter`.\n        kwargs : dict\n            Additional kwargs. If these keys exist, we pop and process them:\n            'facecolors', 'facecolor', 'edgecolor', 'color'\n            Note: The dict is modified by this function.\n        xsize : int\n            The size of the x and y arrays passed to `.Axes.scatter`.\n        get_next_color_func : callable\n            A callable that returns a color. This color is used as facecolor\n            if no other color is provided.\n\n            Note, that this is a function rather than a fixed color value to\n            support conditional evaluation of the next color.  As of the\n            current implementation obtaining the next color from the\n            property cycle advances the cycle. This must only happen if we\n            actually use the color, which will only be decided within this\n            method.\n\n        Returns\n        -------\n        c\n            The input *c* if it was not *None*, else a color derived from the\n            other inputs or defaults.\n        colors : array(N, 4) or None\n            The facecolors as RGBA values, or *None* if a colormap is used.\n        edgecolors\n            The edgecolor.\n\n        \"\"\"\n        facecolors = kwargs.pop('facecolors', None)\n        facecolors = kwargs.pop('facecolor', facecolors)\n        edgecolors = kwargs.pop('edgecolor', edgecolors)\n\n        kwcolor = kwargs.pop('color', None)\n\n        if kwcolor is not None and c is not None:\n            raise ValueError(\"Supply a 'c' argument or a 'color'\"\n                             \" kwarg but not both; they differ but\"\n                             \" their functionalities overlap.\")\n\n        if kwcolor is not None:\n            try:\n                mcolors.to_rgba_array(kwcolor)\n            except ValueError as err:\n                raise ValueError(\n                    \"'color' kwarg must be an color or sequence of color \"\n                    \"specs.  For a sequence of values to be color-mapped, use \"\n                    \"the 'c' argument instead.\") from err\n            if edgecolors is None:\n                edgecolors = kwcolor\n            if facecolors is None:\n                facecolors = kwcolor\n\n        if edgecolors is None and not rcParams['_internal.classic_mode']:\n            edgecolors = rcParams['scatter.edgecolors']\n\n        c_was_none = c is None\n        if c is None:\n            c = (facecolors if facecolors is not None\n                 else \"b\" if rcParams['_internal.classic_mode']\n                 else get_next_color_func())\n        c_is_string_or_strings = (\n            isinstance(c, str)\n            or (np.iterable(c) and len(c) > 0\n                and isinstance(cbook.safe_first_element(c), str)))\n\n        def invalid_shape_exception(csize, xsize):\n            return ValueError(\n                f\"'c' argument has {csize} elements, which is inconsistent \"\n                f\"with 'x' and 'y' with size {xsize}.\")\n\n        c_is_mapped = False  # Unless proven otherwise below.\n        valid_shape = True  # Unless proven otherwise below.\n        if not c_was_none and kwcolor is None and not c_is_string_or_strings:\n            try:  # First, does 'c' look suitable for value-mapping?\n                c = np.asanyarray(c, dtype=float)\n            except ValueError:\n                pass  # Failed to convert to float array; must be color specs.\n            else:\n                # If c can be either mapped values or a RGB(A) color, prefer\n                # the former if shapes match, the latter otherwise.\n                if c.size == xsize:\n                    c = c.ravel()\n                    c_is_mapped = True\n                else:  # Wrong size; it must not be intended for mapping.\n                    if c.shape in ((3,), (4,)):\n                        _log.warning(\n                            \"'c' argument looks like a single numeric RGB or \"\n                            \"RGBA sequence, which should be avoided as value-\"\n                            \"mapping will have precedence in case its length \"\n                            \"matches with 'x' & 'y'.  Please use a 2-D array \"\n                            \"with a single row if you really want to specify \"\n                            \"the same RGB or RGBA value for all points.\")\n                    valid_shape = False\n        if not c_is_mapped:\n            try:  # Is 'c' acceptable as PathCollection facecolors?\n                colors = mcolors.to_rgba_array(c)\n            except (TypeError, ValueError) as err:\n                if not valid_shape:\n                    raise invalid_shape_exception(c.size, xsize) from err\n                # Both the mapping *and* the RGBA conversion failed: pretty\n                # severe failure => one may appreciate a verbose feedback.\n                raise ValueError(\n                    f\"'c' argument must be a color, a sequence of colors, or \"\n                    f\"a sequence of numbers, not {c}\") from err\n            else:\n                if len(colors) not in (0, 1, xsize):\n                    # NB: remember that a single color is also acceptable.\n                    # Besides *colors* will be an empty array if c == 'none'.\n                    raise invalid_shape_exception(len(colors), xsize)\n        else:\n            colors = None  # use cmap, norm after collection is created\n        return c, colors, edgecolors",
        "begin_line": 4138,
        "end_line": 4275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005431830526887561,
            "pseudo_dstar_susp": 0.0005115089514066496,
            "pseudo_tarantula_susp": 0.0021645021645021645,
            "pseudo_op2_susp": 0.0005115089514066496,
            "pseudo_barinel_susp": 0.0021645021645021645
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.invalid_shape_exception#4229",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.invalid_shape_exception(csize, xsize)",
        "snippet": "        def invalid_shape_exception(csize, xsize):\n            return ValueError(\n                f\"'c' argument has {csize} elements, which is inconsistent \"\n                f\"with 'x' and 'y' with size {xsize}.\")",
        "begin_line": 4229,
        "end_line": 4232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000419639110365086,
            "pseudo_dstar_susp": 0.0005073566717402334,
            "pseudo_tarantula_susp": 0.0005885815185403178,
            "pseudo_op2_susp": 0.0005073566717402334,
            "pseudo_barinel_susp": 0.0005885815185403178
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.scatter#4282",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, verts=None, edgecolors=None, *, plotnonfinite=False, **kwargs)",
        "snippet": "    def scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None,\n                vmin=None, vmax=None, alpha=None, linewidths=None,\n                verts=None, edgecolors=None, *, plotnonfinite=False,\n                **kwargs):\n        \"\"\"\n        A scatter plot of *y* vs. *x* with varying marker size and/or color.\n\n        Parameters\n        ----------\n        x, y : scalar or array-like, shape (n, )\n            The data positions.\n\n        s : scalar or array-like, shape (n, ), optional\n            The marker size in points**2.\n            Default is ``rcParams['lines.markersize'] ** 2``.\n\n        c : color, sequence, or sequence of colors, optional\n            The marker color. Possible values:\n\n            - A single color format string.\n            - A sequence of colors of length n.\n            - A scalar or sequence of n numbers to be mapped to colors using\n              *cmap* and *norm*.\n            - A 2-D array in which the rows are RGB or RGBA.\n\n            Note that *c* should not be a single numeric RGB or RGBA sequence\n            because that is indistinguishable from an array of values to be\n            colormapped. If you want to specify the same RGB or RGBA value for\n            all points, use a 2-D array with a single row.  Otherwise, value-\n            matching will have precedence in case of a size matching with *x*\n            and *y*.\n\n            Defaults to ``None``. In that case the marker color is determined\n            by the value of ``color``, ``facecolor`` or ``facecolors``. In case\n            those are not specified or ``None``, the marker color is determined\n            by the next color of the ``Axes``' current \"shape and fill\" color\n            cycle. This cycle defaults to :rc:`axes.prop_cycle`.\n\n        marker : `~.markers.MarkerStyle`, default: :rc:`scatter.marker`\n            The marker style. *marker* can be either an instance of the class\n            or the text shorthand for a particular marker.\n            See :mod:`matplotlib.markers` for more information about marker\n            styles.\n\n        cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n            A `.Colormap` instance or registered colormap name. *cmap* is only\n            used if *c* is an array of floats.\n\n        norm : `~matplotlib.colors.Normalize`, default: None\n            If *c* is an array of floats, *norm* is used to scale the color\n            data, *c*, in the range 0 to 1, in order to map into the colormap\n            *cmap*.\n            If *None*, use the default `.colors.Normalize`.\n\n        vmin, vmax : scalar, default: None\n            *vmin* and *vmax* are used in conjunction with the default norm to\n            map the color array *c* to the colormap *cmap*. If None, the\n            respective min and max of the color array is used.\n            It is deprecated to use *vmin*/*vmax* when *norm* is given.\n\n        alpha : scalar, default: None\n            The alpha blending value, between 0 (transparent) and 1 (opaque).\n\n        linewidths : scalar or array-like, default: :rc:`lines.linewidth`\n            The linewidth of the marker edges. Note: The default *edgecolors*\n            is 'face'. You may want to change this as well.\n\n        edgecolors : {'face', 'none', *None*} or color or sequence of color, \\\ndefault: :rc:`scatter.edgecolors`\n            The edge color of the marker. Possible values:\n\n            - 'face': The edge color will always be the same as the face color.\n            - 'none': No patch boundary will be drawn.\n            - A color or sequence of colors.\n\n            For non-filled markers, the *edgecolors* kwarg is ignored and\n            forced to 'face' internally.\n\n        plotnonfinite : bool, default: False\n            Set to plot points with nonfinite *c*, in conjunction with\n            `~matplotlib.colors.Colormap.set_bad`.\n\n        Returns\n        -------\n        paths : `~matplotlib.collections.PathCollection`\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.collections.Collection` properties\n\n        See Also\n        --------\n        plot : To plot scatter plots when markers are identical in size and\n            color.\n\n        Notes\n        -----\n        * The `.plot` function will be faster for scatterplots where markers\n          don't vary in size or color.\n\n        * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which\n          case all masks will be combined and only unmasked points will be\n          plotted.\n\n        * Fundamentally, scatter works with 1-D arrays; *x*, *y*, *s*, and *c*\n          may be input as N-D arrays, but within scatter they will be\n          flattened. The exception is *c*, which will be flattened only if its\n          size matches the size of *x* and *y*.\n\n        \"\"\"\n        # Process **kwargs to handle aliases, conflicts with explicit kwargs:\n\n        self._process_unit_info(xdata=x, ydata=y, kwargs=kwargs)\n        x = self.convert_xunits(x)\n        y = self.convert_yunits(y)\n\n        # np.ma.ravel yields an ndarray, not a masked array,\n        # unless its argument is a masked array.\n        x = np.ma.ravel(x)\n        y = np.ma.ravel(y)\n        if x.size != y.size:\n            raise ValueError(\"x and y must be the same size\")\n\n        if s is None:\n            s = (20 if rcParams['_internal.classic_mode'] else\n                 rcParams['lines.markersize'] ** 2.0)\n        s = np.ma.ravel(s)\n        if len(s) not in (1, x.size):\n            raise ValueError(\"s must be a scalar, or the same size as x and y\")\n\n        c, colors, edgecolors = \\\n            self._parse_scatter_color_args(\n                c, edgecolors, kwargs, x.size,\n                get_next_color_func=self._get_patches_for_fill.get_next_color)\n\n        if plotnonfinite and colors is None:\n            c = np.ma.masked_invalid(c)\n            x, y, s, edgecolors, linewidths = \\\n                cbook._combine_masks(x, y, s, edgecolors, linewidths)\n        else:\n            x, y, s, c, colors, edgecolors, linewidths = \\\n                cbook._combine_masks(\n                    x, y, s, c, colors, edgecolors, linewidths)\n\n        scales = s   # Renamed for readability below.\n\n        # load default marker from rcParams\n        if marker is None:\n            marker = rcParams['scatter.marker']\n\n        if isinstance(marker, mmarkers.MarkerStyle):\n            marker_obj = marker\n        else:\n            marker_obj = mmarkers.MarkerStyle(marker)\n\n        path = marker_obj.get_path().transformed(\n            marker_obj.get_transform())\n        if not marker_obj.is_filled():\n            edgecolors = 'face'\n            linewidths = rcParams['lines.linewidth']\n\n        offsets = np.ma.column_stack([x, y])\n\n        collection = mcoll.PathCollection(\n                (path,), scales,\n                facecolors=colors,\n                edgecolors=edgecolors,\n                linewidths=linewidths,\n                offsets=offsets,\n                transOffset=kwargs.pop('transform', self.transData),\n                alpha=alpha\n                )\n        collection.set_transform(mtransforms.IdentityTransform())\n        collection.update(kwargs)\n\n        if colors is None:\n            collection.set_array(c)\n            collection.set_cmap(cmap)\n            collection.set_norm(norm)\n            collection._scale_norm(norm, vmin, vmax)\n\n        # Classic mode only:\n        # ensure there are margins to allow for the\n        # finite size of the symbols.  In v2.x, margins\n        # are present by default, so we disable this\n        # scatter-specific override.\n        if rcParams['_internal.classic_mode']:\n            if self._xmargin < 0.05 and x.size > 0:\n                self.set_xmargin(0.05)\n            if self._ymargin < 0.05 and x.size > 0:\n                self.set_ymargin(0.05)\n\n        self.add_collection(collection)\n        self._request_autoscale_view()\n\n        return collection",
        "begin_line": 4282,
        "end_line": 4477,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004697040864255519,
            "pseudo_dstar_susp": 0.0005213764337851929,
            "pseudo_tarantula_susp": 0.001037344398340249,
            "pseudo_op2_susp": 0.0005213764337851929,
            "pseudo_barinel_susp": 0.001037344398340249
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.hexbin#4481",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.hexbin(self, x, y, C=None, gridsize=100, bins=None, xscale='linear', yscale='linear', extent=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, edgecolors='face', reduce_C_function=np.mean, mincnt=None, marginals=False, **kwargs)",
        "snippet": "    def hexbin(self, x, y, C=None, gridsize=100, bins=None,\n               xscale='linear', yscale='linear', extent=None,\n               cmap=None, norm=None, vmin=None, vmax=None,\n               alpha=None, linewidths=None, edgecolors='face',\n               reduce_C_function=np.mean, mincnt=None, marginals=False,\n               **kwargs):\n        \"\"\"\n        Make a 2D hexagonal binning plot of points *x*, *y*.\n\n        If *C* is *None*, the value of the hexagon is determined by the number\n        of points in the hexagon. Otherwise, *C* specifies values at the\n        coordinate (x[i], y[i]). For each hexagon, these values are reduced\n        using *reduce_C_function*.\n\n        Parameters\n        ----------\n        x, y : array-like\n            The data positions. *x* and *y* must be of the same length.\n\n        C : array-like, optional\n            If given, these values are accumulated in the bins. Otherwise,\n            every point has a value of 1. Must be of the same length as *x*\n            and *y*.\n\n        gridsize : int or (int, int), default: 100\n            If a single int, the number of hexagons in the *x*-direction.\n            The number of hexagons in the *y*-direction is chosen such that\n            the hexagons are approximately regular.\n\n            Alternatively, if a tuple (*nx*, *ny*), the number of hexagons\n            in the *x*-direction and the *y*-direction.\n\n        bins : 'log' or int or sequence, default: None\n            Discretization of the hexagon values.\n\n            - If *None*, no binning is applied; the color of each hexagon\n              directly corresponds to its count value.\n            - If 'log', use a logarithmic scale for the color map.\n              Internally, :math:`log_{10}(i+1)` is used to determine the\n              hexagon color. This is equivalent to ``norm=LogNorm()``.\n            - If an integer, divide the counts in the specified number\n              of bins, and color the hexagons accordingly.\n            - If a sequence of values, the values of the lower bound of\n              the bins to be used.\n\n        xscale : {'linear', 'log'}, default: 'linear'\n            Use a linear or log10 scale on the horizontal axis.\n\n        yscale : {'linear', 'log'}, default: 'linear'\n            Use a linear or log10 scale on the vertical axis.\n\n        mincnt : int > 0, default: *None*\n            If not *None*, only display cells with more than *mincnt*\n            number of points in the cell.\n\n        marginals : bool, default: *False*\n            If marginals is *True*, plot the marginal density as\n            colormapped rectangles along the bottom of the x-axis and\n            left of the y-axis.\n\n        extent : float, default: *None*\n            The limits of the bins. The default assigns the limits\n            based on *gridsize*, *x*, *y*, *xscale* and *yscale*.\n\n            If *xscale* or *yscale* is set to 'log', the limits are\n            expected to be the exponent for a power of 10. E.g. for\n            x-limits of 1 and 50 in 'linear' scale and y-limits\n            of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).\n\n            Order of scalars is (left, right, bottom, top).\n\n        Other Parameters\n        ----------------\n        cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n            The Colormap instance or registered colormap name used to map\n            the bin values to colors.\n\n        norm : `~matplotlib.colors.Normalize`, optional\n            The Normalize instance scales the bin values to the canonical\n            colormap range [0, 1] for mapping to colors. By default, the data\n            range is mapped to the colorbar range using linear scaling.\n\n        vmin, vmax : float, default: None\n            The colorbar range. If *None*, suitable min/max values are\n            automatically chosen by the `~.Normalize` instance (defaults to\n            the respective min/max values of the bins in case of the default\n            linear scaling).\n            It is deprecated to use *vmin*/*vmax* when *norm* is given.\n\n        alpha : float between 0 and 1, optional\n            The alpha blending value, between 0 (transparent) and 1 (opaque).\n\n        linewidths : float, default: *None*\n            If *None*, defaults to 1.0.\n\n        edgecolors : {'face', 'none', *None*} or color, default: 'face'\n            The color of the hexagon edges. Possible values are:\n\n            - 'face': Draw the edges in the same color as the fill color.\n            - 'none': No edges are drawn. This can sometimes lead to unsightly\n              unpainted pixels between the hexagons.\n            - *None*: Draw outlines in the default color.\n            - An explicit color.\n\n        reduce_C_function : callable, default: `numpy.mean`\n            The function to aggregate *C* within the bins. It is ignored if\n            *C* is not given. This must have the signature::\n\n                def reduce_C_function(C: array) -> float\n\n            Commonly used functions are:\n\n            - `numpy.mean`: average of the points\n            - `numpy.sum`: integral of the point values\n            - `numpy.max`: value taken from the largest point\n\n        **kwargs : `~matplotlib.collections.PolyCollection` properties\n            All other keyword arguments are passed on to `.PolyCollection`:\n\n            %(PolyCollection)s\n\n        Returns\n        -------\n        polycollection : `~matplotlib.collections.PolyCollection`\n            A `.PolyCollection` defining the hexagonal bins.\n\n            - `.PolyCollection.get_offset` contains a Mx2 array containing\n              the x, y positions of the M hexagon centers.\n            - `.PolyCollection.get_array` contains the values of the M\n              hexagons.\n\n            If *marginals* is *True*, horizontal\n            bar and vertical bar (both PolyCollections) will be attached\n            to the return collection as attributes *hbar* and *vbar*.\n\n        \"\"\"\n        self._process_unit_info(xdata=x, ydata=y, kwargs=kwargs)\n\n        x, y, C = cbook.delete_masked_points(x, y, C)\n\n        # Set the size of the hexagon grid\n        if np.iterable(gridsize):\n            nx, ny = gridsize\n        else:\n            nx = gridsize\n            ny = int(nx / math.sqrt(3))\n        # Count the number of data in each hexagon\n        x = np.array(x, float)\n        y = np.array(y, float)\n        if xscale == 'log':\n            if np.any(x <= 0.0):\n                raise ValueError(\"x contains non-positive values, so can not\"\n                                 \" be log-scaled\")\n            x = np.log10(x)\n        if yscale == 'log':\n            if np.any(y <= 0.0):\n                raise ValueError(\"y contains non-positive values, so can not\"\n                                 \" be log-scaled\")\n            y = np.log10(y)\n        if extent is not None:\n            xmin, xmax, ymin, ymax = extent\n        else:\n            xmin, xmax = (np.min(x), np.max(x)) if len(x) else (0, 1)\n            ymin, ymax = (np.min(y), np.max(y)) if len(y) else (0, 1)\n\n            # to avoid issues with singular data, expand the min/max pairs\n            xmin, xmax = mtransforms.nonsingular(xmin, xmax, expander=0.1)\n            ymin, ymax = mtransforms.nonsingular(ymin, ymax, expander=0.1)\n\n        # In the x-direction, the hexagons exactly cover the region from\n        # xmin to xmax. Need some padding to avoid roundoff errors.\n        padding = 1.e-9 * (xmax - xmin)\n        xmin -= padding\n        xmax += padding\n        sx = (xmax - xmin) / nx\n        sy = (ymax - ymin) / ny\n\n        if marginals:\n            xorig = x.copy()\n            yorig = y.copy()\n\n        x = (x - xmin) / sx\n        y = (y - ymin) / sy\n        ix1 = np.round(x).astype(int)\n        iy1 = np.round(y).astype(int)\n        ix2 = np.floor(x).astype(int)\n        iy2 = np.floor(y).astype(int)\n\n        nx1 = nx + 1\n        ny1 = ny + 1\n        nx2 = nx\n        ny2 = ny\n        n = nx1 * ny1 + nx2 * ny2\n\n        d1 = (x - ix1) ** 2 + 3.0 * (y - iy1) ** 2\n        d2 = (x - ix2 - 0.5) ** 2 + 3.0 * (y - iy2 - 0.5) ** 2\n        bdist = (d1 < d2)\n        if C is None:\n            lattice1 = np.zeros((nx1, ny1))\n            lattice2 = np.zeros((nx2, ny2))\n            c1 = (0 <= ix1) & (ix1 < nx1) & (0 <= iy1) & (iy1 < ny1) & bdist\n            c2 = (0 <= ix2) & (ix2 < nx2) & (0 <= iy2) & (iy2 < ny2) & ~bdist\n            np.add.at(lattice1, (ix1[c1], iy1[c1]), 1)\n            np.add.at(lattice2, (ix2[c2], iy2[c2]), 1)\n            if mincnt is not None:\n                lattice1[lattice1 < mincnt] = np.nan\n                lattice2[lattice2 < mincnt] = np.nan\n            accum = np.concatenate([lattice1.ravel(), lattice2.ravel()])\n            good_idxs = ~np.isnan(accum)\n\n        else:\n            if mincnt is None:\n                mincnt = 0\n\n            # create accumulation arrays\n            lattice1 = np.empty((nx1, ny1), dtype=object)\n            for i in range(nx1):\n                for j in range(ny1):\n                    lattice1[i, j] = []\n            lattice2 = np.empty((nx2, ny2), dtype=object)\n            for i in range(nx2):\n                for j in range(ny2):\n                    lattice2[i, j] = []\n\n            for i in range(len(x)):\n                if bdist[i]:\n                    if 0 <= ix1[i] < nx1 and 0 <= iy1[i] < ny1:\n                        lattice1[ix1[i], iy1[i]].append(C[i])\n                else:\n                    if 0 <= ix2[i] < nx2 and 0 <= iy2[i] < ny2:\n                        lattice2[ix2[i], iy2[i]].append(C[i])\n\n            for i in range(nx1):\n                for j in range(ny1):\n                    vals = lattice1[i, j]\n                    if len(vals) > mincnt:\n                        lattice1[i, j] = reduce_C_function(vals)\n                    else:\n                        lattice1[i, j] = np.nan\n            for i in range(nx2):\n                for j in range(ny2):\n                    vals = lattice2[i, j]\n                    if len(vals) > mincnt:\n                        lattice2[i, j] = reduce_C_function(vals)\n                    else:\n                        lattice2[i, j] = np.nan\n\n            accum = np.hstack((lattice1.astype(float).ravel(),\n                               lattice2.astype(float).ravel()))\n            good_idxs = ~np.isnan(accum)\n\n        offsets = np.zeros((n, 2), float)\n        offsets[:nx1 * ny1, 0] = np.repeat(np.arange(nx1), ny1)\n        offsets[:nx1 * ny1, 1] = np.tile(np.arange(ny1), nx1)\n        offsets[nx1 * ny1:, 0] = np.repeat(np.arange(nx2) + 0.5, ny2)\n        offsets[nx1 * ny1:, 1] = np.tile(np.arange(ny2), nx2) + 0.5\n        offsets[:, 0] *= sx\n        offsets[:, 1] *= sy\n        offsets[:, 0] += xmin\n        offsets[:, 1] += ymin\n        # remove accumulation bins with no data\n        offsets = offsets[good_idxs, :]\n        accum = accum[good_idxs]\n\n        polygon = [sx, sy / 3] * np.array(\n            [[.5, -.5], [.5, .5], [0., 1.], [-.5, .5], [-.5, -.5], [0., -1.]])\n\n        if linewidths is None:\n            linewidths = [1.0]\n\n        if xscale == 'log' or yscale == 'log':\n            polygons = np.expand_dims(polygon, 0) + np.expand_dims(offsets, 1)\n            if xscale == 'log':\n                polygons[:, :, 0] = 10.0 ** polygons[:, :, 0]\n                xmin = 10.0 ** xmin\n                xmax = 10.0 ** xmax\n                self.set_xscale(xscale)\n            if yscale == 'log':\n                polygons[:, :, 1] = 10.0 ** polygons[:, :, 1]\n                ymin = 10.0 ** ymin\n                ymax = 10.0 ** ymax\n                self.set_yscale(yscale)\n            collection = mcoll.PolyCollection(\n                polygons,\n                edgecolors=edgecolors,\n                linewidths=linewidths,\n                )\n        else:\n            collection = mcoll.PolyCollection(\n                [polygon],\n                edgecolors=edgecolors,\n                linewidths=linewidths,\n                offsets=offsets,\n                transOffset=mtransforms.IdentityTransform(),\n                offset_position=\"data\"\n                )\n\n        # Set normalizer if bins is 'log'\n        if bins == 'log':\n            if norm is not None:\n                cbook._warn_external(\"Only one of 'bins' and 'norm' \"\n                                     \"arguments can be supplied, ignoring \"\n                                     \"bins={}\".format(bins))\n            else:\n                norm = mcolors.LogNorm()\n            bins = None\n\n        if isinstance(norm, mcolors.LogNorm):\n            if (accum == 0).any():\n                # make sure we have no zeros\n                accum += 1\n\n        # autoscale the norm with curren accum values if it hasn't\n        # been set\n        if norm is not None:\n            if norm.vmin is None and norm.vmax is None:\n                norm.autoscale(accum)\n\n        if bins is not None:\n            if not np.iterable(bins):\n                minimum, maximum = min(accum), max(accum)\n                bins -= 1  # one less edge than bins\n                bins = minimum + (maximum - minimum) * np.arange(bins) / bins\n            bins = np.sort(bins)\n            accum = bins.searchsorted(accum)\n\n        collection.set_array(accum)\n        collection.set_cmap(cmap)\n        collection.set_norm(norm)\n        collection.set_alpha(alpha)\n        collection.update(kwargs)\n        collection._scale_norm(norm, vmin, vmax)\n\n        corners = ((xmin, ymin), (xmax, ymax))\n        self.update_datalim(corners)\n        self._request_autoscale_view(tight=True)\n\n        # add the collection last\n        self.add_collection(collection, autolim=False)\n        if not marginals:\n            return collection\n\n        if C is None:\n            C = np.ones(len(x))\n\n        def coarse_bin(x, y, coarse):\n            ind = coarse.searchsorted(x).clip(0, len(coarse) - 1)\n            mus = np.zeros(len(coarse))\n            for i in range(len(coarse)):\n                yi = y[ind == i]\n                if len(yi) > 0:\n                    mu = reduce_C_function(yi)\n                else:\n                    mu = np.nan\n                mus[i] = mu\n            return mus\n\n        coarse = np.linspace(xmin, xmax, gridsize)\n\n        xcoarse = coarse_bin(xorig, C, coarse)\n        valid = ~np.isnan(xcoarse)\n        verts, values = [], []\n        for i, val in enumerate(xcoarse):\n            thismin = coarse[i]\n            if i < len(coarse) - 1:\n                thismax = coarse[i + 1]\n            else:\n                thismax = thismin + np.diff(coarse)[-1]\n\n            if not valid[i]:\n                continue\n\n            verts.append([(thismin, 0),\n                          (thismin, 0.05),\n                          (thismax, 0.05),\n                          (thismax, 0)])\n            values.append(val)\n\n        values = np.array(values)\n        trans = self.get_xaxis_transform(which='grid')\n\n        hbar = mcoll.PolyCollection(verts, transform=trans, edgecolors='face')\n\n        hbar.set_array(values)\n        hbar.set_cmap(cmap)\n        hbar.set_norm(norm)\n        hbar.set_alpha(alpha)\n        hbar.update(kwargs)\n        self.add_collection(hbar, autolim=False)\n\n        coarse = np.linspace(ymin, ymax, gridsize)\n        ycoarse = coarse_bin(yorig, C, coarse)\n        valid = ~np.isnan(ycoarse)\n        verts, values = [], []\n        for i, val in enumerate(ycoarse):\n            thismin = coarse[i]\n            if i < len(coarse) - 1:\n                thismax = coarse[i + 1]\n            else:\n                thismax = thismin + np.diff(coarse)[-1]\n            if not valid[i]:\n                continue\n            verts.append([(0, thismin), (0.0, thismax),\n                          (0.05, thismax), (0.05, thismin)])\n            values.append(val)\n\n        values = np.array(values)\n\n        trans = self.get_yaxis_transform(which='grid')\n\n        vbar = mcoll.PolyCollection(verts, transform=trans, edgecolors='face')\n        vbar.set_array(values)\n        vbar.set_cmap(cmap)\n        vbar.set_norm(norm)\n        vbar.set_alpha(alpha)\n        vbar.update(kwargs)\n        self.add_collection(vbar, autolim=False)\n\n        collection.hbar = hbar\n        collection.vbar = vbar\n\n        def on_changed(collection):\n            hbar.set_cmap(collection.get_cmap())\n            hbar.set_clim(collection.get_clim())\n            vbar.set_cmap(collection.get_cmap())\n            vbar.set_clim(collection.get_clim())\n\n        collection.callbacksSM.connect('changed', on_changed)\n\n        return collection",
        "begin_line": 4481,
        "end_line": 4910,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.arrow#4913",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.arrow(self, x, y, dx, dy, **kwargs)",
        "snippet": "    def arrow(self, x, y, dx, dy, **kwargs):\n        \"\"\"\n        Add an arrow to the axes.\n\n        This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.\n\n        Parameters\n        ----------\n        x, y : float\n            The x and y coordinates of the arrow base.\n\n        dx, dy : float\n            The length of the arrow along x and y direction.\n\n        %(FancyArrow)s\n\n        Returns\n        -------\n        arrow : `.FancyArrow`\n            The created `.FancyArrow` object.\n\n        Notes\n        -----\n        The resulting arrow is affected by the axes aspect ratio and limits.\n        This may produce an arrow whose head is not square with its stem. To\n        create an arrow whose head is square with its stem,\n        use :meth:`annotate` for example:\n\n        >>> ax.annotate(\"\", xy=(0.5, 0.5), xytext=(0, 0),\n        ...             arrowprops=dict(arrowstyle=\"->\"))\n\n        \"\"\"\n        # Strip away units for the underlying patch since units\n        # do not make sense to most patch-like code\n        x = self.convert_xunits(x)\n        y = self.convert_yunits(y)\n        dx = self.convert_xunits(dx)\n        dy = self.convert_yunits(dy)\n\n        a = mpatches.FancyArrow(x, y, dx, dy, **kwargs)\n        self.add_artist(a)\n        return a",
        "begin_line": 4913,
        "end_line": 4954,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.quiverkey#4957",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.quiverkey(self, Q, X, Y, U, label, **kw)",
        "snippet": "    def quiverkey(self, Q, X, Y, U, label, **kw):\n        qk = mquiver.QuiverKey(Q, X, Y, U, label, **kw)\n        self.add_artist(qk)\n        return qk",
        "begin_line": 4957,
        "end_line": 4960,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes._quiver_units#4963",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes._quiver_units(self, args, kw)",
        "snippet": "    def _quiver_units(self, args, kw):\n        if len(args) > 3:\n            x, y = args[0:2]\n            self._process_unit_info(xdata=x, ydata=y, kwargs=kw)\n            x = self.convert_xunits(x)\n            y = self.convert_yunits(y)\n            return (x, y) + args[2:]\n        return args",
        "begin_line": 4963,
        "end_line": 4970,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.quiver#4974",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.quiver(self, *args, **kw)",
        "snippet": "    def quiver(self, *args, **kw):\n        # Make sure units are handled for x and y values\n        args = self._quiver_units(args, kw)\n\n        q = mquiver.Quiver(self, *args, **kw)\n\n        self.add_collection(q, autolim=True)\n        self._request_autoscale_view()\n        return q",
        "begin_line": 4974,
        "end_line": 4982,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.28332714444857e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.barbs#4988",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.barbs(self, *args, **kw)",
        "snippet": "    def barbs(self, *args, **kw):\n        \"\"\"\n        %(barbs_doc)s\n        \"\"\"\n        # Make sure units are handled for x and y values\n        args = self._quiver_units(args, kw)\n\n        b = mquiver.Barbs(self, *args, **kw)\n        self.add_collection(b, autolim=True)\n        self._request_autoscale_view()\n        return b",
        "begin_line": 4988,
        "end_line": 4998,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.fill#5002",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.fill(self, *args, data=None, **kwargs)",
        "snippet": "    def fill(self, *args, data=None, **kwargs):\n        \"\"\"\n        Plot filled polygons.\n\n        Parameters\n        ----------\n        *args : sequence of x, y, [color]\n            Each polygon is defined by the lists of *x* and *y* positions of\n            its nodes, optionally followed by a *color* specifier. See\n            :mod:`matplotlib.colors` for supported color specifiers. The\n            standard color cycle is used for polygons without a color\n            specifier.\n\n            You can plot multiple polygons by providing multiple *x*, *y*,\n            *[color]* groups.\n\n            For example, each of the following is legal::\n\n                ax.fill(x, y)                    # a polygon with default color\n                ax.fill(x, y, \"b\")               # a blue polygon\n                ax.fill(x, y, x2, y2)            # two polygons\n                ax.fill(x, y, \"b\", x2, y2, \"r\")  # a blue and a red polygon\n\n        data : indexable object, optional\n            An object with labelled data. If given, provide the label names to\n            plot in *x* and *y*, e.g.::\n\n                ax.fill(\"time\", \"signal\",\n                        data={\"time\": [0, 1, 2], \"signal\": [0, 1, 0]})\n\n        Returns\n        -------\n        list of `~matplotlib.patches.Polygon`\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.patches.Polygon` properties\n\n        Notes\n        -----\n        Use :meth:`fill_between` if you would like to fill the region between\n        two curves.\n        \"\"\"\n        # For compatibility(!), get aliases from Line2D rather than Patch.\n        kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)\n        # _get_patches_for_fill returns a generator, convert it to a list.\n        patches = [*self._get_patches_for_fill(*args, data=data, **kwargs)]\n        for poly in patches:\n            self.add_patch(poly)\n        self._request_autoscale_view()\n        return patches",
        "begin_line": 5002,
        "end_line": 5052,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes._fill_between_x_or_y#5054",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes._fill_between_x_or_y(self, ind_dir, ind, dep1, dep2=0, *, where=None, interpolate=False, step=None, **kwargs)",
        "snippet": "    def _fill_between_x_or_y(\n            self, ind_dir, ind, dep1, dep2=0, *,\n            where=None, interpolate=False, step=None, **kwargs):\n        # Common implementation between fill_between (*ind_dir*=\"x\") and\n        # fill_betweenx (*ind_dir*=\"y\").  *ind* is the indepedent variable,\n        # *dep* the dependent variable.  The docstring below is interpolated\n        # to generate both methods' docstrings.\n        \"\"\"\n        Fill the area between two {dir} curves.\n\n        The curves are defined by the points (*{ind}*, *{dep}1*) and (*{ind}*,\n        *{dep}2*).  This creates one or multiple polygons describing the filled\n        area.\n\n        You may exclude some {dir} sections from filling using *where*.\n\n        By default, the edges connect the given points directly.  Use *step*\n        if the filling should be a step function, i.e. constant in between\n        *{ind}*.\n\n        Parameters\n        ----------\n        {ind} : array (length N)\n            The {ind} coordinates of the nodes defining the curves.\n\n        {dep}1 : array (length N) or scalar\n            The {dep} coordinates of the nodes defining the first curve.\n\n        {dep}2 : array (length N) or scalar, default: 0\n            The {dep} coordinates of the nodes defining the second curve.\n\n        where : array of bool (length N), optional\n            Define *where* to exclude some {dir} regions from being filled.\n            The filled regions are defined by the coordinates ``{ind}[where]``.\n            More precisely, fill between ``{ind}[i]`` and ``{ind}[i+1]`` if\n            ``where[i] and where[i+1]``.  Note that this definition implies\n            that an isolated *True* value between two *False* values in *where*\n            will not result in filling.  Both sides of the *True* position\n            remain unfilled due to the adjacent *False* values.\n\n        interpolate : bool, default: False\n            This option is only relevant if *where* is used and the two curves\n            are crossing each other.\n\n            Semantically, *where* is often used for *{dep}1* > *{dep}2* or\n            similar.  By default, the nodes of the polygon defining the filled\n            region will only be placed at the positions in the *{ind}* array.\n            Such a polygon cannot describe the above semantics close to the\n            intersection.  The {ind}-sections containing the intersection are\n            simply clipped.\n\n            Setting *interpolate* to *True* will calculate the actual\n            intersection point and extend the filled region up to this point.\n\n        step : {{'pre', 'post', 'mid'}}, optional\n            Define *step* if the filling should be a step function,\n            i.e. constant in between *{ind}*.  The value determines where the\n            step will occur:\n\n            - 'pre': The y value is continued constantly to the left from\n              every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the\n              value ``y[i]``.\n            - 'post': The y value is continued constantly to the right from\n              every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the\n              value ``y[i]``.\n            - 'mid': Steps occur half-way between the *x* positions.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            All other keyword arguments are passed on to `.PolyCollection`.\n            They control the `.Polygon` properties:\n\n            %(PolyCollection)s\n\n        Returns\n        -------\n        `.PolyCollection`\n            A `.PolyCollection` containing the plotted polygons.\n\n        See Also\n        --------\n        fill_between : Fill between two sets of y-values.\n        fill_betweenx : Fill between two sets of x-values.\n\n        Notes\n        -----\n        .. [notes section required to get data note injection right]\n        \"\"\"\n\n        dep_dir = {\"x\": \"y\", \"y\": \"x\"}[ind_dir]\n        func_name = {\"x\": \"fill_between\", \"y\": \"fill_betweenx\"}[dep_dir]\n\n        if not rcParams[\"_internal.classic_mode\"]:\n            kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)\n            if not any(c in kwargs for c in (\"color\", \"facecolor\")):\n                kwargs[\"facecolor\"] = \\\n                    self._get_patches_for_fill.get_next_color()\n\n        # Handle united data, such as dates\n        self._process_unit_info(\n            **{f\"{ind_dir}data\": ind, f\"{dep_dir}data\": dep1}, kwargs=kwargs)\n        self._process_unit_info(\n            **{f\"{dep_dir}data\": dep2})\n\n        # Convert the arrays so we can work with them\n        ind = ma.masked_invalid(getattr(self, f\"convert_{ind_dir}units\")(ind))\n        dep1 = ma.masked_invalid(\n            getattr(self, f\"convert_{dep_dir}units\")(dep1))\n        dep2 = ma.masked_invalid(\n            getattr(self, f\"convert_{dep_dir}units\")(dep2))\n\n        for name, array in [\n                (ind_dir, ind), (f\"{dep_dir}1\", dep1), (f\"{dep_dir}2\", dep2)]:\n            if array.ndim > 1:\n                raise ValueError(f\"{name!r} is not 1-dimensional\")\n\n        if where is None:\n            where = True\n        else:\n            where = np.asarray(where, dtype=bool)\n            if where.size != ind.size:\n                cbook.warn_deprecated(\n                    \"3.2\", message=f\"The parameter where must have the same \"\n                    f\"size as {ind} in {func_name}(). This will become an \"\n                    \"error in future versions of Matplotlib.\")\n        where = where & ~functools.reduce(\n            np.logical_or, map(np.ma.getmask, [ind, dep1, dep2]))\n\n        ind, dep1, dep2 = np.broadcast_arrays(np.atleast_1d(ind), dep1, dep2)\n\n        polys = []\n        for idx0, idx1 in cbook.contiguous_regions(where):\n            indslice = ind[idx0:idx1]\n            dep1slice = dep1[idx0:idx1]\n            dep2slice = dep2[idx0:idx1]\n            if step is not None:\n                step_func = cbook.STEP_LOOKUP_MAP[\"steps-\" + step]\n                indslice, dep1slice, dep2slice = \\\n                    step_func(indslice, dep1slice, dep2slice)\n\n            if not len(indslice):\n                continue\n\n            N = len(indslice)\n            pts = np.zeros((2 * N + 2, 2))\n\n            if interpolate:\n                def get_interp_point(idx):\n                    im1 = max(idx - 1, 0)\n                    ind_values = ind[im1:idx+1]\n                    diff_values = dep1[im1:idx+1] - dep2[im1:idx+1]\n                    dep1_values = dep1[im1:idx+1]\n\n                    if len(diff_values) == 2:\n                        if np.ma.is_masked(diff_values[1]):\n                            return ind[im1], dep1[im1]\n                        elif np.ma.is_masked(diff_values[0]):\n                            return ind[idx], dep1[idx]\n\n                    diff_order = diff_values.argsort()\n                    diff_root_ind = np.interp(\n                        0, diff_values[diff_order], ind_values[diff_order])\n                    ind_order = ind_values.argsort()\n                    diff_root_dep = np.interp(\n                        diff_root_ind,\n                        ind_values[ind_order], dep1_values[ind_order])\n                    return diff_root_ind, diff_root_dep\n\n                start = get_interp_point(idx0)\n                end = get_interp_point(idx1)\n            else:\n                # Handle scalar dep2 (e.g. 0): the fill should go all\n                # the way down to 0 even if none of the dep1 sample points do.\n                start = indslice[0], dep2slice[0]\n                end = indslice[-1], dep2slice[-1]\n\n            pts[0] = start\n            pts[N + 1] = end\n\n            pts[1:N+1, 0] = indslice\n            pts[1:N+1, 1] = dep1slice\n            pts[N+2:, 0] = indslice[::-1]\n            pts[N+2:, 1] = dep2slice[::-1]\n\n            if ind_dir == \"y\":\n                pts = pts[:, ::-1]\n\n            polys.append(pts)\n\n        collection = mcoll.PolyCollection(polys, **kwargs)\n\n        # now update the datalim and autoscale\n        pts = np.row_stack([np.column_stack([ind[where], dep1[where]]),\n                            np.column_stack([ind[where], dep2[where]])])\n        if ind_dir == \"y\":\n            pts = pts[:, ::-1]\n        self.dataLim.update_from_data_xy(pts, self.ignore_existing_data_limits,\n                                         updatex=True, updatey=True)\n        self.ignore_existing_data_limits = False\n        self.add_collection(collection, autolim=False)\n        self._request_autoscale_view()\n        return collection",
        "begin_line": 5054,
        "end_line": 5256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.get_interp_point#5202",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.get_interp_point(idx)",
        "snippet": "                def get_interp_point(idx):\n                    im1 = max(idx - 1, 0)\n                    ind_values = ind[im1:idx+1]\n                    diff_values = dep1[im1:idx+1] - dep2[im1:idx+1]\n                    dep1_values = dep1[im1:idx+1]\n\n                    if len(diff_values) == 2:\n                        if np.ma.is_masked(diff_values[1]):\n                            return ind[im1], dep1[im1]\n                        elif np.ma.is_masked(diff_values[0]):\n                            return ind[idx], dep1[idx]\n\n                    diff_order = diff_values.argsort()\n                    diff_root_ind = np.interp(\n                        0, diff_values[diff_order], ind_values[diff_order])\n                    ind_order = ind_values.argsort()\n                    diff_root_dep = np.interp(\n                        diff_root_ind,\n                        ind_values[ind_order], dep1_values[ind_order])\n                    return diff_root_ind, diff_root_dep",
        "begin_line": 5202,
        "end_line": 5221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.fill_between#5258",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.fill_between(self, x, y1, y2=0, where=None, interpolate=False, step=None, **kwargs)",
        "snippet": "    def fill_between(self, x, y1, y2=0, where=None, interpolate=False,\n                     step=None, **kwargs):\n        return self._fill_between_x_or_y(\n            \"x\", x, y1, y2,\n            where=where, interpolate=interpolate, step=step, **kwargs)",
        "begin_line": 5258,
        "end_line": 5262,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.fill_betweenx#5270",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.fill_betweenx(self, y, x1, x2=0, where=None, step=None, interpolate=False, **kwargs)",
        "snippet": "    def fill_betweenx(self, y, x1, x2=0, where=None,\n                      step=None, interpolate=False, **kwargs):\n        return self._fill_between_x_or_y(\n            \"y\", y, x1, x2,\n            where=where, interpolate=interpolate, step=step, **kwargs)",
        "begin_line": 5270,
        "end_line": 5274,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.imshow#5284",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.imshow(self, X, cmap=None, norm=None, aspect=None, interpolation=None, alpha=None, vmin=None, vmax=None, origin=None, extent=None, *, filternorm=True, filterrad=4.0, resample=None, url=None, **kwargs)",
        "snippet": "    def imshow(self, X, cmap=None, norm=None, aspect=None,\n               interpolation=None, alpha=None, vmin=None, vmax=None,\n               origin=None, extent=None, *, filternorm=True, filterrad=4.0,\n               resample=None, url=None, **kwargs):\n        \"\"\"\n        Display data as an image; i.e. on a 2D regular raster.\n\n        The input may either be actual RGB(A) data, or 2D scalar data, which\n        will be rendered as a pseudocolor image. Note: For actually displaying\n        a grayscale image set up the color mapping using the parameters\n        ``cmap='gray', vmin=0, vmax=255``.\n\n        Parameters\n        ----------\n        X : array-like or PIL image\n            The image data. Supported array shapes are:\n\n            - (M, N): an image with scalar data. The values are mapped to\n              colors using normalization and a colormap. See parameters *norm*,\n              *cmap*, *vmin*, *vmax*.\n            - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).\n            - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),\n              i.e. including transparency.\n\n            The first two dimensions (M, N) define the rows and columns of\n            the image.\n\n            Out-of-range RGB(A) values are clipped.\n\n        cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n            The Colormap instance or registered colormap name used to map\n            scalar data to colors. This parameter is ignored for RGB(A) data.\n\n        norm : `~matplotlib.colors.Normalize`, optional\n            The `.Normalize` instance used to scale scalar data to the [0, 1]\n            range before mapping to colors using *cmap*. By default, a linear\n            scaling mapping the lowest value to 0 and the highest to 1 is used.\n            This parameter is ignored for RGB(A) data.\n\n        aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`\n            The aspect ratio of the axes.  This parameter is particularly\n            relevant for images since it determines whether data pixels are\n            square.\n\n            This parameter is a shortcut for explicitly calling\n            `.Axes.set_aspect`. See there for further details.\n\n            - 'equal': Ensures an aspect ratio of 1. Pixels will be square\n              (unless pixel sizes are explicitly made non-square in data\n              coordinates using *extent*).\n            - 'auto': The axes is kept fixed and the aspect is adjusted so\n              that the data fit in the axes. In general, this will result in\n              non-square pixels.\n\n        interpolation : str, default: :rc:`image.interpolation`\n            The interpolation method used.\n\n            Supported values are 'none', 'antialiased', 'nearest', 'bilinear',\n            'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',\n            'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',\n            'sinc', 'lanczos'.\n\n            If *interpolation* is 'none', then no interpolation is performed\n            on the Agg, ps, pdf and svg backends. Other backends will fall back\n            to 'nearest'. Note that most SVG renders perform interpolation at\n            rendering and that the default interpolation method they implement\n            may differ.\n\n            If *interpolation* is the default 'antialiased', then 'nearest'\n            interpolation is used if the image is upsampled by more than a\n            factor of three (i.e. the number of display pixels is at least\n            three times the size of the data array).  If the upsampling rate is\n            smaller than 3, or the image is downsampled, then 'hanning'\n            interpolation is used to act as an anti-aliasing filter, unless the\n            image happens to be upsampled by exactly a factor of two or one.\n\n            See\n            :doc:`/gallery/images_contours_and_fields/interpolation_methods`\n            for an overview of the supported interpolation methods, and\n            :doc:`/gallery/images_contours_and_fields/image_antialiasing` for\n            a discussion of image antialiasing.\n\n            Some interpolation methods require an additional radius parameter,\n            which can be set by *filterrad*. Additionally, the antigrain image\n            resize filter is controlled by the parameter *filternorm*.\n\n        alpha : scalar or array-like, optional\n            The alpha blending value, between 0 (transparent) and 1 (opaque).\n            If *alpha* is an array, the alpha blending values are applied pixel\n            by pixel, and *alpha* must have the same shape as *X*.\n\n        vmin, vmax : scalar, optional\n            When using scalar data and no explicit *norm*, *vmin* and *vmax*\n            define the data range that the colormap covers. By default,\n            the colormap covers the complete value range of the supplied\n            data. It is deprecated to use *vmin*/*vmax* when *norm* is given.\n\n        origin : {'upper', 'lower'}, default: :rc:`image.origin`\n            Place the [0, 0] index of the array in the upper left or lower\n            left corner of the axes. The convention (the default) 'upper' is\n            typically used for matrices and images.\n\n            Note that the vertical axes points upward for 'lower'\n            but downward for 'upper'.\n\n            See the :doc:`/tutorials/intermediate/imshow_extent` tutorial for\n            examples and a more detailed description.\n\n        extent : scalars (left, right, bottom, top), optional\n            The bounding box in data coordinates that the image will fill.\n            The image is stretched individually along x and y to fill the box.\n\n            The default extent is determined by the following conditions.\n            Pixels have unit size in data coordinates. Their centers are on\n            integer coordinates, and their center coordinates range from 0 to\n            columns-1 horizontally and from 0 to rows-1 vertically.\n\n            Note that the direction of the vertical axis and thus the default\n            values for top and bottom depend on *origin*:\n\n            - For ``origin == 'upper'`` the default is\n              ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.\n            - For ``origin == 'lower'`` the default is\n              ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.\n\n            See the :doc:`/tutorials/intermediate/imshow_extent` tutorial for\n            examples and a more detailed description.\n\n        filternorm : bool, default: True\n            A parameter for the antigrain image resize filter (see the\n            antigrain documentation).  If *filternorm* is set, the filter\n            normalizes integer values and corrects the rounding errors. It\n            doesn't do anything with the source floating point values, it\n            corrects only integers according to the rule of 1.0 which means\n            that any sum of pixel weights must be equal to 1.0.  So, the\n            filter function must produce a graph of the proper shape.\n\n        filterrad : float > 0, default: 4.0\n            The filter radius for filters that have a radius parameter, i.e.\n            when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.\n\n        resample : bool, optional\n            When *True*, use a full resampling method.  When *False*, only\n            resample when the output image is larger than the input image.\n\n        url : str, optional\n            Set the url of the created `.AxesImage`. See `.Artist.set_url`.\n\n        Returns\n        -------\n        image : `~matplotlib.image.AxesImage`\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.artist.Artist` properties\n            These parameters are passed on to the constructor of the\n            `.AxesImage` artist.\n\n        See also\n        --------\n        matshow : Plot a matrix or an array as an image.\n\n        Notes\n        -----\n        Unless *extent* is used, pixel centers will be located at integer\n        coordinates. In other words: the origin will coincide with the center\n        of pixel (0, 0).\n\n        There are two common representations for RGB images with an alpha\n        channel:\n\n        -   Straight (unassociated) alpha: R, G, and B channels represent the\n            color of the pixel, disregarding its opacity.\n        -   Premultiplied (associated) alpha: R, G, and B channels represent\n            the color of the pixel, adjusted for its opacity by multiplication.\n\n        `~matplotlib.pyplot.imshow` expects RGB images adopting the straight\n        (unassociated) alpha representation.\n        \"\"\"\n        if aspect is None:\n            aspect = rcParams['image.aspect']\n        self.set_aspect(aspect)\n        im = mimage.AxesImage(self, cmap, norm, interpolation, origin, extent,\n                              filternorm=filternorm, filterrad=filterrad,\n                              resample=resample, **kwargs)\n\n        im.set_data(X)\n        im.set_alpha(alpha)\n        if im.get_clip_path() is None:\n            # image does not already have clipping set, clip to axes patch\n            im.set_clip_path(self.patch)\n        im._scale_norm(norm, vmin, vmax)\n        im.set_url(url)\n\n        # update ax.dataLim, and, if autoscaling, set viewLim\n        # to tightly fit the image, regardless of dataLim.\n        im.set_extent(im.get_extent())\n\n        self.add_image(im)\n        return im",
        "begin_line": 5284,
        "end_line": 5483,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00033025099075297226,
            "pseudo_dstar_susp": 0.00032,
            "pseudo_tarantula_susp": 0.000419639110365086,
            "pseudo_op2_susp": 0.00032,
            "pseudo_barinel_susp": 0.000419639110365086
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes._pcolorargs#5486",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes._pcolorargs(funcname, *args, shading='flat')",
        "snippet": "    def _pcolorargs(funcname, *args, shading='flat'):\n        # - create X and Y if not present;\n        # - reshape X and Y as needed if they are 1-D;\n        # - check for proper sizes based on `shading` kwarg;\n        # - reset shading if shading='auto' to flat or nearest\n        #   depending on size;\n\n        if len(args) == 1:\n            C = np.asanyarray(args[0])\n            nrows, ncols = C.shape\n            if shading in ['gouraud', 'nearest']:\n                X, Y = np.meshgrid(np.arange(ncols), np.arange(nrows))\n            else:\n                X, Y = np.meshgrid(np.arange(ncols + 1), np.arange(nrows + 1))\n                shading = 'flat'\n            C = cbook.safe_masked_invalid(C)\n            return X, Y, C, shading\n\n        if len(args) == 3:\n            # Check x and y for bad data...\n            C = np.asanyarray(args[2])\n            X, Y = [cbook.safe_masked_invalid(a) for a in args[:2]]\n            if funcname == 'pcolormesh':\n                if np.ma.is_masked(X) or np.ma.is_masked(Y):\n                    raise ValueError(\n                        'x and y arguments to pcolormesh cannot have '\n                        'non-finite values or be of type '\n                        'numpy.ma.core.MaskedArray with masked values')\n                # safe_masked_invalid() returns an ndarray for dtypes other\n                # than floating point.\n                if isinstance(X, np.ma.core.MaskedArray):\n                    X = X.data  # strip mask as downstream doesn't like it...\n                if isinstance(Y, np.ma.core.MaskedArray):\n                    Y = Y.data\n            nrows, ncols = C.shape\n        else:\n            raise TypeError(f'{funcname}() takes 1 or 3 positional arguments '\n                            f'but {len(args)} were given')\n\n        Nx = X.shape[-1]\n        Ny = Y.shape[0]\n        if X.ndim != 2 or X.shape[0] == 1:\n            x = X.reshape(1, Nx)\n            X = x.repeat(Ny, axis=0)\n        if Y.ndim != 2 or Y.shape[1] == 1:\n            y = Y.reshape(Ny, 1)\n            Y = y.repeat(Nx, axis=1)\n        if X.shape != Y.shape:\n            raise TypeError(\n                'Incompatible X, Y inputs to %s; see help(%s)' % (\n                funcname, funcname))\n\n        if shading == 'auto':\n            if ncols == Nx and nrows == Ny:\n                shading = 'nearest'\n            else:\n                shading = 'flat'\n\n        if shading == 'flat':\n            if not (ncols in (Nx, Nx - 1) and nrows in (Ny, Ny - 1)):\n                raise TypeError('Dimensions of C %s are incompatible with'\n                                ' X (%d) and/or Y (%d); see help(%s)' % (\n                                    C.shape, Nx, Ny, funcname))\n            if (ncols == Nx or nrows == Ny):\n                cbook.warn_deprecated(\n                    \"3.3\", message=\"shading='flat' when X and Y have the same \"\n                    \"dimensions as C is deprecated since %(since)s.  Either \"\n                    \"specify the corners of the quadrilaterals with X and Y, \"\n                    \"or pass shading='auto', 'nearest' or 'gouraud', or set \"\n                    \"rcParams['pcolor.shading']\")\n            C = C[:Ny - 1, :Nx - 1]\n        else:    # ['nearest', 'gouraud']:\n            if (Nx, Ny) != (ncols, nrows):\n                raise TypeError('Dimensions of C %s are incompatible with'\n                                ' X (%d) and/or Y (%d); see help(%s)' % (\n                                    C.shape, Nx, Ny, funcname))\n            if shading in ['nearest', 'auto']:\n                # grid is specified at the center, so define corners\n                # at the midpoints between the grid centers and then use the\n                # flat algorithm.\n                def _interp_grid(X):\n                    # helper for below\n                    if np.shape(X)[1] > 1:\n                        dX = np.diff(X, axis=1)/2.\n                        X = np.hstack((X[:, [0]] - dX[:, [0]],\n                                       X[:, :-1] + dX,\n                                       X[:, [-1]] + dX[:, [-1]]))\n                    else:\n                        # This is just degenerate, but we can't reliably guess\n                        # a dX if there is just one value.\n                        X = np.hstack((X, X))\n                    return X\n\n                if ncols == Nx:\n                    X = _interp_grid(X)\n                    Y = _interp_grid(Y)\n                if nrows == Ny:\n                    X = _interp_grid(X.T).T\n                    Y = _interp_grid(Y.T).T\n                shading = 'flat'\n\n        C = cbook.safe_masked_invalid(C)\n        return X, Y, C, shading",
        "begin_line": 5486,
        "end_line": 5588,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes._interp_grid#5566",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes._interp_grid(X)",
        "snippet": "                def _interp_grid(X):\n                    # helper for below\n                    if np.shape(X)[1] > 1:\n                        dX = np.diff(X, axis=1)/2.\n                        X = np.hstack((X[:, [0]] - dX[:, [0]],\n                                       X[:, :-1] + dX,\n                                       X[:, [-1]] + dX[:, [-1]]))\n                    else:\n                        # This is just degenerate, but we can't reliably guess\n                        # a dX if there is just one value.\n                        X = np.hstack((X, X))\n                    return X",
        "begin_line": 5566,
        "end_line": 5577,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.pcolor#5592",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.pcolor(self, *args, shading=None, alpha=None, norm=None, cmap=None, vmin=None, vmax=None, **kwargs)",
        "snippet": "    def pcolor(self, *args, shading=None, alpha=None, norm=None, cmap=None,\n               vmin=None, vmax=None, **kwargs):\n        r\"\"\"\n        Create a pseudocolor plot with a non-regular rectangular grid.\n\n        Call signature::\n\n            pcolor([X, Y,] C, **kwargs)\n\n        *X* and *Y* can be used to specify the corners of the quadrilaterals.\n\n        .. hint::\n\n            ``pcolor()`` can be very slow for large arrays. In most\n            cases you should use the similar but much faster\n            `~.Axes.pcolormesh` instead. See\n            :ref:`Differences between pcolor() and pcolormesh()\n            <differences-pcolor-pcolormesh>` for a discussion of the\n            differences.\n\n        Parameters\n        ----------\n        C : array-like\n            A scalar 2-D array. The values will be color-mapped.\n\n        X, Y : array-like, optional\n            The coordinates of the corners of quadrilaterals of a pcolormesh::\n\n                (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])\n                                      +-----+\n                                      |     |\n                                      +-----+\n                    (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])\n\n            Note that the column index corresponds to the x-coordinate, and\n            the row index corresponds to y. For details, see the\n            :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.\n\n            If ``shading='flat'`` the dimensions of *X* and *Y* should be one\n            greater than those of *C*, and the quadrilateral is colored due\n            to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal\n            dimensions, a warning will be raised and the last row and column\n            of *C* will be ignored.\n\n            If ``shading='nearest'``, the dimensions of *X* and *Y* should be\n            the same as those of *C* (if not, a ValueError will be raised). The\n            color ``C[i, j]`` will be centered on ``(X[i, j], Y[i, j])``.\n\n            If *X* and/or *Y* are 1-D arrays or column vectors they will be\n            expanded as needed into the appropriate 2-D arrays, making a\n            rectangular grid.\n\n        shading : {'flat', 'nearest', 'auto'}, optional\n            The fill style for the quadrilateral; defaults to 'flat' or\n            :rc:`pcolor.shading`. Possible values:\n\n            - 'flat': A solid color is used for each quad. The color of the\n              quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by\n              ``C[i, j]``. The dimensions of *X* and *Y* should be\n              one greater than those of *C*; if they are the same as *C*,\n              then a deprecation warning is raised, and the last row\n              and column of *C* are dropped.\n            - 'nearest': Each grid point will have a color centered on it,\n              extending halfway between the adjacent grid centers.  The\n              dimensions of *X* and *Y* must be the same as *C*.\n            - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one\n              larger than *C*.  Choose 'nearest' if dimensions are the same.\n\n            See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`\n            for more description.\n\n        cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n            A Colormap instance or registered colormap name. The colormap\n            maps the *C* values to colors.\n\n        norm : `~matplotlib.colors.Normalize`, optional\n            The Normalize instance scales the data values to the canonical\n            colormap range [0, 1] for mapping to colors. By default, the data\n            range is mapped to the colorbar range using linear scaling.\n\n        vmin, vmax : scalar, default: None\n            The colorbar range. If *None*, suitable min/max values are\n            automatically chosen by the `~.Normalize` instance (defaults to\n            the respective min/max values of *C* in case of the default linear\n            scaling).\n            It is deprecated to use *vmin*/*vmax* when *norm* is given.\n\n        edgecolors : {'none', None, 'face', color, color sequence}, optional\n            The color of the edges. Defaults to 'none'. Possible values:\n\n            - 'none' or '': No edge.\n            - *None*: :rc:`patch.edgecolor` will be used. Note that currently\n              :rc:`patch.force_edgecolor` has to be True for this to work.\n            - 'face': Use the adjacent face color.\n            - A color or sequence of colors will set the edge color.\n\n            The singular form *edgecolor* works as an alias.\n\n        alpha : scalar, default: None\n            The alpha blending value of the face color, between 0 (transparent)\n            and 1 (opaque). Note: The edgecolor is currently not affected by\n            this.\n\n        snap : bool, default: False\n            Whether to snap the mesh to pixel boundaries.\n\n        Returns\n        -------\n        collection : `matplotlib.collections.Collection`\n\n        Other Parameters\n        ----------------\n        antialiaseds : bool, default: False\n            The default *antialiaseds* is False if the default\n            *edgecolors*\\ =\"none\" is used.  This eliminates artificial lines\n            at patch boundaries, and works regardless of the value of alpha.\n            If *edgecolors* is not \"none\", then the default *antialiaseds*\n            is taken from :rc:`patch.antialiased`.\n            Stroking the edges may be preferred if *alpha* is 1, but will\n            cause artifacts otherwise.\n\n        **kwargs\n            Additionally, the following arguments are allowed. They are passed\n            along to the `~matplotlib.collections.PolyCollection` constructor:\n\n        %(PolyCollection)s\n\n        See Also\n        --------\n        pcolormesh : for an explanation of the differences between\n            pcolor and pcolormesh.\n        imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a\n            faster alternative.\n\n        Notes\n        -----\n        **Masked arrays**\n\n        *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one\n        of the vertices surrounding ``C[i, j]`` (*X* or *Y* at\n        ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is\n        plotted.\n\n        .. _axes-pcolor-grid-orientation:\n\n        **Grid orientation**\n\n        The grid orientation follows the standard matrix convention: An array\n        *C* with shape (nrows, ncolumns) is plotted with the column number as\n        *X* and the row number as *Y*.\n        \"\"\"\n\n        if shading is None:\n            shading = rcParams['pcolor.shading']\n        shading = shading.lower()\n        X, Y, C, shading = self._pcolorargs('pcolor', *args, shading=shading)\n        Ny, Nx = X.shape\n\n        # unit conversion allows e.g. datetime objects as axis values\n        self._process_unit_info(xdata=X, ydata=Y, kwargs=kwargs)\n        X = self.convert_xunits(X)\n        Y = self.convert_yunits(Y)\n\n        # convert to MA, if necessary.\n        C = ma.asarray(C)\n        X = ma.asarray(X)\n        Y = ma.asarray(Y)\n\n        mask = ma.getmaskarray(X) + ma.getmaskarray(Y)\n        xymask = (mask[0:-1, 0:-1] + mask[1:, 1:] +\n                  mask[0:-1, 1:] + mask[1:, 0:-1])\n        # don't plot if C or any of the surrounding vertices are masked.\n        mask = ma.getmaskarray(C) + xymask\n\n        unmask = ~mask\n        X1 = ma.filled(X[:-1, :-1])[unmask]\n        Y1 = ma.filled(Y[:-1, :-1])[unmask]\n        X2 = ma.filled(X[1:, :-1])[unmask]\n        Y2 = ma.filled(Y[1:, :-1])[unmask]\n        X3 = ma.filled(X[1:, 1:])[unmask]\n        Y3 = ma.filled(Y[1:, 1:])[unmask]\n        X4 = ma.filled(X[:-1, 1:])[unmask]\n        Y4 = ma.filled(Y[:-1, 1:])[unmask]\n        npoly = len(X1)\n\n        xy = np.stack([X1, Y1, X2, Y2, X3, Y3, X4, Y4, X1, Y1], axis=-1)\n        verts = xy.reshape((npoly, 5, 2))\n\n        C = ma.filled(C[:Ny - 1, :Nx - 1])[unmask]\n\n        linewidths = (0.25,)\n        if 'linewidth' in kwargs:\n            kwargs['linewidths'] = kwargs.pop('linewidth')\n        kwargs.setdefault('linewidths', linewidths)\n\n        if 'edgecolor' in kwargs:\n            kwargs['edgecolors'] = kwargs.pop('edgecolor')\n        ec = kwargs.setdefault('edgecolors', 'none')\n\n        # aa setting will default via collections to patch.antialiased\n        # unless the boundary is not stroked, in which case the\n        # default will be False; with unstroked boundaries, aa\n        # makes artifacts that are often disturbing.\n        if 'antialiased' in kwargs:\n            kwargs['antialiaseds'] = kwargs.pop('antialiased')\n        if 'antialiaseds' not in kwargs and cbook._str_lower_equal(ec, \"none\"):\n            kwargs['antialiaseds'] = False\n\n        kwargs.setdefault('snap', False)\n\n        collection = mcoll.PolyCollection(verts, **kwargs)\n\n        collection.set_alpha(alpha)\n        collection.set_array(C)\n        collection.set_cmap(cmap)\n        collection.set_norm(norm)\n        collection._scale_norm(norm, vmin, vmax)\n        self.grid(False)\n\n        x = X.compressed()\n        y = Y.compressed()\n\n        # Transform from native to data coordinates?\n        t = collection._transform\n        if (not isinstance(t, mtransforms.Transform) and\n            hasattr(t, '_as_mpl_transform')):\n            t = t._as_mpl_transform(self.axes)\n\n        if t and any(t.contains_branch_seperately(self.transData)):\n            trans_to_data = t - self.transData\n            pts = np.vstack([x, y]).T.astype(float)\n            transformed_pts = trans_to_data.transform(pts)\n            x = transformed_pts[..., 0]\n            y = transformed_pts[..., 1]\n\n        self.add_collection(collection, autolim=False)\n\n        minx = np.min(x)\n        maxx = np.max(x)\n        miny = np.min(y)\n        maxy = np.max(y)\n        collection.sticky_edges.x[:] = [minx, maxx]\n        collection.sticky_edges.y[:] = [miny, maxy]\n        corners = (minx, miny), (maxx, maxy)\n        self.update_datalim(corners)\n        self._request_autoscale_view()\n        return collection",
        "begin_line": 5592,
        "end_line": 5838,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.pcolormesh#5842",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None, vmax=None, shading=None, antialiased=False, **kwargs)",
        "snippet": "    def pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None,\n                   vmax=None, shading=None, antialiased=False, **kwargs):\n        \"\"\"\n        Create a pseudocolor plot with a non-regular rectangular grid.\n\n        Call signature::\n\n            pcolormesh([X, Y,] C, **kwargs)\n\n        *X* and *Y* can be used to specify the corners of the quadrilaterals.\n\n        .. hint::\n\n           `~.Axes.pcolormesh` is similar to `~.Axes.pcolor`. It is much faster\n           and preferred in most cases. For a detailed discussion on the\n           differences see :ref:`Differences between pcolor() and pcolormesh()\n           <differences-pcolor-pcolormesh>`.\n\n        Parameters\n        ----------\n        C : array-like\n            A scalar 2-D array. The values will be color-mapped.\n\n        X, Y : array-like, optional\n            The coordinates of the corners of quadrilaterals of a pcolormesh::\n\n                (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])\n                                      +-----+\n                                      |     |\n                                      +-----+\n                    (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])\n\n            Note that the column index corresponds to the x-coordinate, and\n            the row index corresponds to y. For details, see the\n            :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.\n\n            If ``shading='flat'`` the dimensions of *X* and *Y* should be one\n            greater than those of *C*, and the quadrilateral is colored due\n            to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal\n            dimensions, a warning will be raised and the last row and column\n            of *C* will be ignored.\n\n            If ``shading='nearest'`` or ``'gouraud'``, the dimensions of *X*\n            and *Y* should be the same as those of *C* (if not, a ValueError\n            will be raised).  For ``'nearest'`` the color ``C[i, j]`` is\n            centered on ``(X[i, j], Y[i, j])``.  For ``'gouraud'``, a smooth\n            interpolation is caried out between the quadrilateral corners.\n\n            If *X* and/or *Y* are 1-D arrays or column vectors they will be\n            expanded as needed into the appropriate 2-D arrays, making a\n            rectangular grid.\n\n        cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n            A Colormap instance or registered colormap name. The colormap\n            maps the *C* values to colors.\n\n        norm : `~matplotlib.colors.Normalize`, optional\n            The Normalize instance scales the data values to the canonical\n            colormap range [0, 1] for mapping to colors. By default, the data\n            range is mapped to the colorbar range using linear scaling.\n\n        vmin, vmax : scalar, default: None\n            The colorbar range. If *None*, suitable min/max values are\n            automatically chosen by the `~.Normalize` instance (defaults to\n            the respective min/max values of *C* in case of the default linear\n            scaling).\n            It is deprecated to use *vmin*/*vmax* when *norm* is given.\n\n        edgecolors : {'none', None, 'face', color, color sequence}, optional\n            The color of the edges. Defaults to 'none'. Possible values:\n\n            - 'none' or '': No edge.\n            - *None*: :rc:`patch.edgecolor` will be used. Note that currently\n              :rc:`patch.force_edgecolor` has to be True for this to work.\n            - 'face': Use the adjacent face color.\n            - A color or sequence of colors will set the edge color.\n\n            The singular form *edgecolor* works as an alias.\n\n        alpha : scalar, default: None\n            The alpha blending value, between 0 (transparent) and 1 (opaque).\n\n        shading : {'flat', 'nearest', 'gouraud', 'auto'}, optional\n            The fill style for the quadrilateral; defaults to\n            'flat' or :rc:`pcolor.shading`. Possible values:\n\n            - 'flat': A solid color is used for each quad. The color of the\n              quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by\n              ``C[i, j]``. The dimensions of *X* and *Y* should be\n              one greater than those of *C*; if they are the same as *C*,\n              then a deprecation warning is raised, and the last row\n              and column of *C* are dropped.\n            - 'nearest': Each grid point will have a color centered on it,\n              extending halfway between the adjacent grid centers.  The\n              dimensions of *X* and *Y* must be the same as *C*.\n            - 'gouraud': Each quad will be Gouraud shaded: The color of the\n              corners (i', j') are given by ``C[i', j']``. The color values of\n              the area in between is interpolated from the corner values.\n              The dimensions of *X* and *Y* must be the same as *C*. When\n              Gouraud shading is used, *edgecolors* is ignored.\n            - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one\n              larger than *C*.  Choose 'nearest' if dimensions are the same.\n\n            See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`\n            for more description.\n\n        snap : bool, default: False\n            Whether to snap the mesh to pixel boundaries.\n\n        Returns\n        -------\n        mesh : `matplotlib.collections.QuadMesh`\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Additionally, the following arguments are allowed. They are passed\n            along to the `~matplotlib.collections.QuadMesh` constructor:\n\n        %(QuadMesh)s\n\n        See Also\n        --------\n        pcolor : An alternative implementation with slightly different\n            features. For a detailed discussion on the differences see\n            :ref:`Differences between pcolor() and pcolormesh()\n            <differences-pcolor-pcolormesh>`.\n        imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a\n            faster alternative.\n\n        Notes\n        -----\n        **Masked arrays**\n\n        *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding\n        quadrilateral will be transparent. Masking of *X* and *Y* is not\n        supported. Use `~.Axes.pcolor` if you need this functionality.\n\n        .. _axes-pcolormesh-grid-orientation:\n\n        **Grid orientation**\n\n        The grid orientation follows the standard matrix convention: An array\n        *C* with shape (nrows, ncolumns) is plotted with the column number as\n        *X* and the row number as *Y*.\n\n        .. _differences-pcolor-pcolormesh:\n\n        **Differences between pcolor() and pcolormesh()**\n\n        Both methods are used to create a pseudocolor plot of a 2-D array\n        using quadrilaterals.\n\n        The main difference lies in the created object and internal data\n        handling:\n        While `~.Axes.pcolor` returns a `.PolyCollection`, `~.Axes.pcolormesh`\n        returns a `.QuadMesh`. The latter is more specialized for the given\n        purpose and thus is faster. It should almost always be preferred.\n\n        There is also a slight difference in the handling of masked arrays.\n        Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays\n        for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*\n        and *Y*. The reason lies in the internal handling of the masked values.\n        `~.Axes.pcolor` leaves out the respective polygons from the\n        PolyCollection. `~.Axes.pcolormesh` sets the facecolor of the masked\n        elements to transparent. You can see the difference when using\n        edgecolors. While all edges are drawn irrespective of masking in a\n        QuadMesh, the edge between two adjacent masked quadrilaterals in\n        `~.Axes.pcolor` is not drawn as the corresponding polygons do not\n        exist in the PolyCollection.\n\n        Another difference is the support of Gouraud shading in\n        `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.\n\n        \"\"\"\n        if shading is None:\n            shading = rcParams['pcolor.shading']\n        shading = shading.lower()\n        kwargs.setdefault('edgecolors', 'None')\n\n        X, Y, C, shading = self._pcolorargs('pcolormesh', *args,\n                                            shading=shading)\n        Ny, Nx = X.shape\n        X = X.ravel()\n        Y = Y.ravel()\n        # unit conversion allows e.g. datetime objects as axis values\n        self._process_unit_info(xdata=X, ydata=Y, kwargs=kwargs)\n        X = self.convert_xunits(X)\n        Y = self.convert_yunits(Y)\n\n        # convert to one dimensional arrays\n        C = C.ravel()\n        coords = np.column_stack((X, Y)).astype(float, copy=False)\n        collection = mcoll.QuadMesh(Nx - 1, Ny - 1, coords,\n                                    antialiased=antialiased, shading=shading,\n                                    **kwargs)\n        collection.set_alpha(alpha)\n        collection.set_array(C)\n        collection.set_cmap(cmap)\n        collection.set_norm(norm)\n        collection._scale_norm(norm, vmin, vmax)\n\n        self.grid(False)\n\n        # Transform from native to data coordinates?\n        t = collection._transform\n        if (not isinstance(t, mtransforms.Transform) and\n            hasattr(t, '_as_mpl_transform')):\n            t = t._as_mpl_transform(self.axes)\n\n        if t and any(t.contains_branch_seperately(self.transData)):\n            trans_to_data = t - self.transData\n            coords = trans_to_data.transform(coords)\n\n        self.add_collection(collection, autolim=False)\n\n        minx, miny = np.min(coords, axis=0)\n        maxx, maxy = np.max(coords, axis=0)\n        collection.sticky_edges.x[:] = [minx, maxx]\n        collection.sticky_edges.y[:] = [miny, maxy]\n        corners = (minx, miny), (maxx, maxy)\n        self.update_datalim(corners)\n        self._request_autoscale_view()\n        return collection",
        "begin_line": 5842,
        "end_line": 6065,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.pcolorfast#6069",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None, vmax=None, **kwargs)",
        "snippet": "    def pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None,\n                   vmax=None, **kwargs):\n        \"\"\"\n        Create a pseudocolor plot with a non-regular rectangular grid.\n\n        Call signature::\n\n          ax.pcolorfast([X, Y], C, /, **kwargs)\n\n        This method is similar to `~.Axes.pcolor` and `~.Axes.pcolormesh`.\n        It's designed to provide the fastest pcolor-type plotting with the\n        Agg backend. To achieve this, it uses different algorithms internally\n        depending on the complexity of the input grid (regular rectangular,\n        non-regular rectangular or arbitrary quadrilateral).\n\n        .. warning::\n\n           This method is experimental. Compared to `~.Axes.pcolor` or\n           `~.Axes.pcolormesh` it has some limitations:\n\n           - It supports only flat shading (no outlines)\n           - It lacks support for log scaling of the axes.\n           - It does not have a have a pyplot wrapper.\n\n        Parameters\n        ----------\n        C : array-like(M, N)\n            The image data. Supported array shapes are:\n\n            - (M, N): an image with scalar data. The data is visualized\n              using a colormap.\n            - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).\n            - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),\n              i.e. including transparency.\n\n            The first two dimensions (M, N) define the rows and columns of\n            the image.\n\n            This parameter can only be passed positionally.\n\n        X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``\n            *X* and *Y* are used to specify the coordinates of the\n            quadrilaterals. There are different ways to do this:\n\n            - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define\n              a *uniform rectangular grid*.\n\n              The tuples define the outer edges of the grid. All individual\n              quadrilaterals will be of the same size. This is the fastest\n              version.\n\n            - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular\n              grid*.\n\n              In this case *X* and *Y* have to be monotonic 1D arrays of length\n              *N+1* and *M+1*, specifying the x and y boundaries of the cells.\n\n              The speed is intermediate. Note: The grid is checked, and if\n              found to be uniform the fast version is used.\n\n            - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral\n              grid* (i.e. if the quadrilaterals are not rectangular).\n\n              In this case *X* and *Y* are 2D arrays with shape (M + 1, N + 1),\n              specifying the x and y coordinates of the corners of the colored\n              quadrilaterals.\n\n              This is the most general, but the slowest to render.  It may\n              produce faster and more compact output using ps, pdf, and\n              svg backends, however.\n\n            These arguments can only be passed positionally.\n\n        cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n            A Colormap instance or registered colormap name. The colormap\n            maps the *C* values to colors.\n\n        norm : `~matplotlib.colors.Normalize`, optional\n            The Normalize instance scales the data values to the canonical\n            colormap range [0, 1] for mapping to colors. By default, the data\n            range is mapped to the colorbar range using linear scaling.\n\n        vmin, vmax : scalar, default: None\n            The colorbar range. If *None*, suitable min/max values are\n            automatically chosen by the `~.Normalize` instance (defaults to\n            the respective min/max values of *C* in case of the default linear\n            scaling).\n            It is deprecated to use *vmin*/*vmax* when *norm* is given.\n\n        alpha : scalar, default: None\n            The alpha blending value, between 0 (transparent) and 1 (opaque).\n\n        snap : bool, default: False\n            Whether to snap the mesh to pixel boundaries.\n\n        Returns\n        -------\n        image : `.AxesImage` or `.PcolorImage` or `.QuadMesh`\n            The return type depends on the type of grid:\n\n            - `.AxesImage` for a regular rectangular grid.\n            - `.PcolorImage` for a non-regular rectangular grid.\n            - `.QuadMesh` for a non-rectangular grid.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Supported additional parameters depend on the type of grid.\n            See return types of *image* for further description.\n\n        Notes\n        -----\n        .. [notes section required to get data note injection right]\n        \"\"\"\n\n        C = args[-1]\n        nr, nc = np.shape(C)[:2]\n        if len(args) == 1:\n            style = \"image\"\n            x = [0, nc]\n            y = [0, nr]\n        elif len(args) == 3:\n            x, y = args[:2]\n            x = np.asarray(x)\n            y = np.asarray(y)\n            if x.ndim == 1 and y.ndim == 1:\n                if x.size == 2 and y.size == 2:\n                    style = \"image\"\n                else:\n                    dx = np.diff(x)\n                    dy = np.diff(y)\n                    if (np.ptp(dx) < 0.01 * abs(dx.mean()) and\n                        np.ptp(dy) < 0.01 * abs(dy.mean())):\n                        style = \"image\"\n                    else:\n                        style = \"pcolorimage\"\n            elif x.ndim == 2 and y.ndim == 2:\n                style = \"quadmesh\"\n            else:\n                raise TypeError(\"arguments do not match valid signatures\")\n        else:\n            raise TypeError(\"need 1 argument or 3 arguments\")\n\n        if style == \"quadmesh\":\n            # data point in each cell is value at lower left corner\n            coords = np.stack([x, y], axis=-1)\n            if np.ndim(C) == 2:\n                qm_kwargs = {\"array\": np.ma.ravel(C)}\n            elif np.ndim(C) == 3:\n                qm_kwargs = {\"color\": np.ma.reshape(C, (-1, C.shape[-1]))}\n            else:\n                raise ValueError(\"C must be 2D or 3D\")\n            collection = mcoll.QuadMesh(\n                nc, nr, coords, **qm_kwargs,\n                alpha=alpha, cmap=cmap, norm=norm,\n                antialiased=False, edgecolors=\"none\")\n            self.add_collection(collection, autolim=False)\n            xl, xr, yb, yt = x.min(), x.max(), y.min(), y.max()\n            ret = collection\n\n        else:  # It's one of the two image styles.\n            extent = xl, xr, yb, yt = x[0], x[-1], y[0], y[-1]\n            if style == \"image\":\n                im = mimage.AxesImage(\n                    self, cmap, norm,\n                    data=C, alpha=alpha, extent=extent,\n                    interpolation='nearest', origin='lower',\n                    **kwargs)\n            elif style == \"pcolorimage\":\n                im = mimage.PcolorImage(\n                    self, x, y, C,\n                    cmap=cmap, norm=norm, alpha=alpha, extent=extent,\n                    **kwargs)\n            self.add_image(im)\n            ret = im\n\n        if np.ndim(C) == 2:  # C.ndim == 3 is RGB(A) so doesn't need scaling.\n            ret._scale_norm(norm, vmin, vmax)\n\n        if ret.get_clip_path() is None:\n            # image does not already have clipping set, clip to axes patch\n            ret.set_clip_path(self.patch)\n\n        ret.sticky_edges.x[:] = [xl, xr]\n        ret.sticky_edges.y[:] = [yb, yt]\n        self.update_datalim(np.array([[xl, yb], [xr, yt]]))\n        self._request_autoscale_view(tight=True)\n        return ret",
        "begin_line": 6069,
        "end_line": 6256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.contour#6259",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.contour(self, *args, **kwargs)",
        "snippet": "    def contour(self, *args, **kwargs):\n        kwargs['filled'] = False\n        contours = mcontour.QuadContourSet(self, *args, **kwargs)\n        self._request_autoscale_view()\n        return contours",
        "begin_line": 6259,
        "end_line": 6263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.872327211427557e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.contourf#6267",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.contourf(self, *args, **kwargs)",
        "snippet": "    def contourf(self, *args, **kwargs):\n        kwargs['filled'] = True\n        contours = mcontour.QuadContourSet(self, *args, **kwargs)\n        self._request_autoscale_view()\n        return contours",
        "begin_line": 6267,
        "end_line": 6271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.19793966151582e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.clabel#6274",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.clabel(self, CS, levels=None, **kwargs)",
        "snippet": "    def clabel(self, CS, levels=None, **kwargs):\n        \"\"\"\n        Label a contour plot.\n\n        Adds labels to line contours in given `.ContourSet`.\n\n        Parameters\n        ----------\n        CS : `~.ContourSet` instance\n            Line contours to label.\n\n        levels : array-like, optional\n            A list of level values, that should be labeled. The list must be\n            a subset of ``CS.levels``. If not given, all levels are labeled.\n\n        **kwargs\n            All other parameters are documented in `~.ContourLabeler.clabel`.\n        \"\"\"\n        return CS.clabel(levels, **kwargs)",
        "begin_line": 6274,
        "end_line": 6292,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.hist#6297",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.hist(self, x, bins=None, range=None, density=False, weights=None, cumulative=False, bottom=None, histtype='bar', align='mid', orientation='vertical', rwidth=None, log=False, color=None, label=None, stacked=False, **kwargs)",
        "snippet": "    def hist(self, x, bins=None, range=None, density=False, weights=None,\n             cumulative=False, bottom=None, histtype='bar', align='mid',\n             orientation='vertical', rwidth=None, log=False,\n             color=None, label=None, stacked=False, **kwargs):\n        \"\"\"\n        Plot a histogram.\n\n        Compute and draw the histogram of *x*.  The return value is a tuple\n        (*n*, *bins*, *patches*) or ([*n0*, *n1*, ...], *bins*, [*patches0*,\n        *patches1*, ...]) if the input contains multiple data.  See the\n        documentation of the *weights* parameter to draw a histogram of\n        already-binned data.\n\n        Multiple data can be provided via *x* as a list of datasets\n        of potentially different length ([*x0*, *x1*, ...]), or as\n        a 2-D ndarray in which each column is a dataset.  Note that\n        the ndarray form is transposed relative to the list form.\n\n        Masked arrays are not supported.\n\n        The *bins*, *range*, *weights*, and *density* parameters behave as in\n        `numpy.histogram`.\n\n        Parameters\n        ----------\n        x : (n,) array or sequence of (n,) arrays\n            Input values, this takes either a single array or a sequence of\n            arrays which are not required to be of the same length.\n\n        bins : int or sequence or str, default: :rc:`hist.bins`\n            If *bins* is an integer, it defines the number of equal-width bins\n            in the range.\n\n            If *bins* is a sequence, it defines the bin edges, including the\n            left edge of the first bin and the right edge of the last bin;\n            in this case, bins may be unequally spaced.  All but the last\n            (righthand-most) bin is half-open.  In other words, if *bins* is::\n\n                [1, 2, 3, 4]\n\n            then the first bin is ``[1, 2)`` (including 1, but excluding 2) and\n            the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which\n            *includes* 4.\n\n            If *bins* is a string, it is one of the binning strategies\n            supported by `numpy.histogram_bin_edges`: 'auto', 'fd', 'doane',\n            'scott', 'stone', 'rice', 'sturges', or 'sqrt'.\n\n        range : tuple or None, default: None\n            The lower and upper range of the bins. Lower and upper outliers\n            are ignored. If not provided, *range* is ``(x.min(), x.max())``.\n            Range has no effect if *bins* is a sequence.\n\n            If *bins* is a sequence or *range* is specified, autoscaling\n            is based on the specified bin range instead of the\n            range of x.\n\n        density : bool, default: False\n            If ``True``, draw and return a probability density: each bin\n            will display the bin's raw count divided by the total number of\n            counts *and the bin width*\n            (``density = counts / (sum(counts) * np.diff(bins))``),\n            so that the area under the histogram integrates to 1\n            (``np.sum(density * np.diff(bins)) == 1``).\n\n            If *stacked* is also ``True``, the sum of the histograms is\n            normalized to 1.\n\n        weights : (n,) array-like or None, default: None\n            An array of weights, of the same shape as *x*.  Each value in\n            *x* only contributes its associated weight towards the bin count\n            (instead of 1).  If *density* is ``True``, the weights are\n            normalized, so that the integral of the density over the range\n            remains 1.\n\n            This parameter can be used to draw a histogram of data that has\n            already been binned, e.g. using `numpy.histogram` (by treating each\n            bin as a single point with a weight equal to its count) ::\n\n                counts, bins = np.histogram(data)\n                plt.hist(bins[:-1], bins, weights=counts)\n\n            (or you may alternatively use `~.bar()`).\n\n        cumulative : bool or -1, default: False\n            If ``True``, then a histogram is computed where each bin gives the\n            counts in that bin plus all bins for smaller values. The last bin\n            gives the total number of datapoints.\n\n            If *density* is also ``True`` then the histogram is normalized such\n            that the last bin equals 1.\n\n            If *cumulative* is a number less than 0 (e.g., -1), the direction\n            of accumulation is reversed.  In this case, if *density* is also\n            ``True``, then the histogram is normalized such that the first bin\n            equals 1.\n\n        bottom : array-like, scalar, or None, default: None\n            Location of the bottom of each bin, ie. bins are drawn from\n            ``bottom`` to ``bottom + hist(x, bins)`` If a scalar, the bottom\n            of each bin is shifted by the same amount. If an array, each bin\n            is shifted independently and the length of bottom must match the\n            number of bins. If None, defaults to 0.\n\n        histtype : {'bar', 'barstacked', 'step', 'stepfilled'}, default: 'bar'\n            The type of histogram to draw.\n\n            - 'bar' is a traditional bar-type histogram.  If multiple data\n              are given the bars are arranged side by side.\n            - 'barstacked' is a bar-type histogram where multiple\n              data are stacked on top of each other.\n            - 'step' generates a lineplot that is by default unfilled.\n            - 'stepfilled' generates a lineplot that is by default filled.\n\n        align : {'left', 'mid', 'right'}, default: 'mid'\n            The horizontal alignment of the histogram bars.\n\n            - 'left': bars are centered on the left bin edges.\n            - 'mid': bars are centered between the bin edges.\n            - 'right': bars are centered on the right bin edges.\n\n        orientation : {'vertical', 'horizontal'}, default: 'vertical'\n            If 'horizontal', `~.Axes.barh` will be used for bar-type histograms\n            and the *bottom* kwarg will be the left edges.\n\n        rwidth : scalar or None, default: None\n            The relative width of the bars as a fraction of the bin width.  If\n            ``None``, automatically compute the width.\n\n            Ignored if *histtype* is 'step' or 'stepfilled'.\n\n        log : bool, default: False\n            If ``True``, the histogram axis will be set to a log scale. If\n            *log* is ``True`` and *x* is a 1D array, empty bins will be\n            filtered out and only the non-empty ``(n, bins, patches)``\n            will be returned.\n\n        color : color or array-like of colors or None, default: None\n            Color or sequence of colors, one per dataset.  Default (``None``)\n            uses the standard line color sequence.\n\n        label : str or None, default: None\n            String, or sequence of strings to match multiple datasets.  Bar\n            charts yield multiple patches per dataset, but only the first gets\n            the label, so that `~.Axes.legend` will work as expected.\n\n        stacked : bool, default: False\n            If ``True``, multiple data are stacked on top of each other If\n            ``False`` multiple data are arranged side by side if histtype is\n            'bar' or on top of each other if histtype is 'step'\n\n        Returns\n        -------\n        n : array or list of arrays\n            The values of the histogram bins. See *density* and *weights* for a\n            description of the possible semantics.  If input *x* is an array,\n            then this is an array of length *nbins*. If input is a sequence of\n            arrays ``[data1, data2, ...]``, then this is a list of arrays with\n            the values of the histograms for each of the arrays in the same\n            order.  The dtype of the array *n* (or of its element arrays) will\n            always be float even if no weighting or normalization is used.\n\n        bins : array\n            The edges of the bins. Length nbins + 1 (nbins left edges and right\n            edge of last bin).  Always a single array even when multiple data\n            sets are passed in.\n\n        patches : list or list of lists\n            Silent list of individual patches used to create the histogram\n            or list of such list if multiple input datasets.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            `~matplotlib.patches.Patch` properties\n\n        See also\n        --------\n        hist2d : 2D histograms\n\n        Notes\n        -----\n        For large numbers of bins (>1000), 'step' and 'stepfilled' can be\n        significantly faster than 'bar' and 'barstacked'.\n\n        \"\"\"\n        # Avoid shadowing the builtin.\n        bin_range = range\n        from builtins import range\n\n        if np.isscalar(x):\n            x = [x]\n\n        if bins is None:\n            bins = rcParams['hist.bins']\n\n        # Validate string inputs here to avoid cluttering subsequent code.\n        cbook._check_in_list(['bar', 'barstacked', 'step', 'stepfilled'],\n                             histtype=histtype)\n        cbook._check_in_list(['left', 'mid', 'right'], align=align)\n        cbook._check_in_list(['horizontal', 'vertical'],\n                             orientation=orientation)\n\n        if histtype == 'barstacked' and not stacked:\n            stacked = True\n\n        # basic input validation\n        input_empty = np.size(x) == 0\n        # Massage 'x' for processing.\n        x = cbook._reshape_2D(x, 'x')\n        nx = len(x)  # number of datasets\n\n        # Process unit information\n        # Unit conversion is done individually on each dataset\n        self._process_unit_info(xdata=x[0], kwargs=kwargs)\n        x = [self.convert_xunits(xi) for xi in x]\n\n        if bin_range is not None:\n            bin_range = self.convert_xunits(bin_range)\n\n        if not cbook.is_scalar_or_string(bins):\n            bins = self.convert_xunits(bins)\n\n        # We need to do to 'weights' what was done to 'x'\n        if weights is not None:\n            w = cbook._reshape_2D(weights, 'weights')\n        else:\n            w = [None] * nx\n\n        if len(w) != nx:\n            raise ValueError('weights should have the same shape as x')\n\n        for xi, wi in zip(x, w):\n            if wi is not None and len(wi) != len(xi):\n                raise ValueError('weights should have the same shape as x')\n\n        if color is None:\n            color = [self._get_lines.get_next_color() for i in range(nx)]\n        else:\n            color = mcolors.to_rgba_array(color)\n            if len(color) != nx:\n                raise ValueError(f\"The 'color' keyword argument must have one \"\n                                 f\"color per dataset, but {nx} datasets and \"\n                                 f\"{len(color)} colors were provided\")\n\n        hist_kwargs = dict()\n\n        # if the bin_range is not given, compute without nan numpy\n        # does not do this for us when guessing the range (but will\n        # happily ignore nans when computing the histogram).\n        if bin_range is None:\n            xmin = np.inf\n            xmax = -np.inf\n            for xi in x:\n                if len(xi):\n                    # python's min/max ignore nan,\n                    # np.minnan returns nan for all nan input\n                    xmin = min(xmin, np.nanmin(xi))\n                    xmax = max(xmax, np.nanmax(xi))\n            if xmin <= xmax:  # Only happens if we have seen a finite value.\n                bin_range = (xmin, xmax)\n\n        # If bins are not specified either explicitly or via range,\n        # we need to figure out the range required for all datasets,\n        # and supply that to np.histogram.\n        if not input_empty and len(x) > 1:\n            if weights is not None:\n                _w = np.concatenate(w)\n            else:\n                _w = None\n            bins = np.histogram_bin_edges(\n                np.concatenate(x), bins, bin_range, _w)\n        else:\n            hist_kwargs['range'] = bin_range\n\n        density = bool(density)\n        if density and not stacked:\n            hist_kwargs['density'] = density\n\n        # List to store all the top coordinates of the histograms\n        tops = []  # Will have shape (n_datasets, n_bins).\n        # Loop through datasets\n        for i in range(nx):\n            # this will automatically overwrite bins,\n            # so that each histogram uses the same bins\n            m, bins = np.histogram(x[i], bins, weights=w[i], **hist_kwargs)\n            tops.append(m)\n        tops = np.array(tops, float)  # causes problems later if it's an int\n        if stacked:\n            tops = tops.cumsum(axis=0)\n            # If a stacked density plot, normalize so the area of all the\n            # stacked histograms together is 1\n            if density:\n                tops = (tops / np.diff(bins)) / tops[-1].sum()\n        if cumulative:\n            slc = slice(None)\n            if isinstance(cumulative, Number) and cumulative < 0:\n                slc = slice(None, None, -1)\n            if density:\n                tops = (tops * np.diff(bins))[:, slc].cumsum(axis=1)[:, slc]\n            else:\n                tops = tops[:, slc].cumsum(axis=1)[:, slc]\n\n        patches = []\n\n        # Save autoscale state for later restoration; turn autoscaling\n        # off so we can do it all a single time at the end, instead\n        # of having it done by bar or fill and then having to be redone.\n        _saved_autoscalex = self.get_autoscalex_on()\n        _saved_autoscaley = self.get_autoscaley_on()\n        self.set_autoscalex_on(False)\n        self.set_autoscaley_on(False)\n\n        if histtype.startswith('bar'):\n\n            totwidth = np.diff(bins)\n\n            if rwidth is not None:\n                dr = np.clip(rwidth, 0, 1)\n            elif (len(tops) > 1 and\n                  ((not stacked) or rcParams['_internal.classic_mode'])):\n                dr = 0.8\n            else:\n                dr = 1.0\n\n            if histtype == 'bar' and not stacked:\n                width = dr * totwidth / nx\n                dw = width\n                boffset = -0.5 * dr * totwidth * (1 - 1 / nx)\n            elif histtype == 'barstacked' or stacked:\n                width = dr * totwidth\n                boffset, dw = 0.0, 0.0\n\n            if align == 'mid':\n                boffset += 0.5 * totwidth\n            elif align == 'right':\n                boffset += totwidth\n\n            if orientation == 'horizontal':\n                _barfunc = self.barh\n                bottom_kwarg = 'left'\n            else:  # orientation == 'vertical'\n                _barfunc = self.bar\n                bottom_kwarg = 'bottom'\n\n            for m, c in zip(tops, color):\n                if bottom is None:\n                    bottom = np.zeros(len(m))\n                if stacked:\n                    height = m - bottom\n                else:\n                    height = m\n                patch = _barfunc(bins[:-1]+boffset, height, width,\n                                 align='center', log=log,\n                                 color=c, **{bottom_kwarg: bottom})\n                patches.append(patch)\n                if stacked:\n                    bottom[:] = m\n                boffset += dw\n\n        elif histtype.startswith('step'):\n            # these define the perimeter of the polygon\n            x = np.zeros(4 * len(bins) - 3)\n            y = np.zeros(4 * len(bins) - 3)\n\n            x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]\n            x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]\n\n            if bottom is None:\n                bottom = 0\n\n            y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom\n            y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]\n\n            if log:\n                if orientation == 'horizontal':\n                    self.set_xscale('log', nonpositive='clip')\n                else:  # orientation == 'vertical'\n                    self.set_yscale('log', nonpositive='clip')\n\n            if align == 'left':\n                x -= 0.5*(bins[1]-bins[0])\n            elif align == 'right':\n                x += 0.5*(bins[1]-bins[0])\n\n            # If fill kwarg is set, it will be passed to the patch collection,\n            # overriding this\n            fill = (histtype == 'stepfilled')\n\n            xvals, yvals = [], []\n            for m in tops:\n                if stacked:\n                    # top of the previous polygon becomes the bottom\n                    y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]\n                # set the top of this polygon\n                y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = m + bottom\n\n                # The starting point of the polygon has not yet been\n                # updated. So far only the endpoint was adjusted. This\n                # assignment closes the polygon. The redundant endpoint is\n                # later discarded (for step and stepfilled).\n                y[0] = y[-1]\n\n                if orientation == 'horizontal':\n                    xvals.append(y.copy())\n                    yvals.append(x.copy())\n                else:\n                    xvals.append(x.copy())\n                    yvals.append(y.copy())\n\n            # stepfill is closed, step is not\n            split = -1 if fill else 2 * len(bins)\n            # add patches in reverse order so that when stacking,\n            # items lower in the stack are plotted on top of\n            # items higher in the stack\n            for x, y, c in reversed(list(zip(xvals, yvals, color))):\n                patches.append(self.fill(\n                    x[:split], y[:split],\n                    closed=True if fill else None,\n                    facecolor=c,\n                    edgecolor=None if fill else c,\n                    fill=fill if fill else None))\n            for patch_list in patches:\n                for patch in patch_list:\n                    if orientation == 'vertical':\n                        patch.sticky_edges.y.append(0)\n                    elif orientation == 'horizontal':\n                        patch.sticky_edges.x.append(0)\n\n            # we return patches, so put it back in the expected order\n            patches.reverse()\n\n        self.set_autoscalex_on(_saved_autoscalex)\n        self.set_autoscaley_on(_saved_autoscaley)\n        self._request_autoscale_view()\n\n        # If None, make all labels None (via zip_longest below); otherwise,\n        # cast each element to str, but keep a single str as it.\n        labels = [] if label is None else np.atleast_1d(np.asarray(label, str))\n        for patch, lbl in itertools.zip_longest(patches, labels):\n            if patch:\n                p = patch[0]\n                p.update(kwargs)\n                if lbl is not None:\n                    p.set_label(lbl)\n                for p in patch[1:]:\n                    p.update(kwargs)\n                    p.set_label('_nolegend_')\n\n        if nx == 1:\n            return tops[0], bins, cbook.silent_list('Patch', patches[0])\n        else:\n            return tops, bins, cbook.silent_list('Lists of Patches', patches)",
        "begin_line": 6297,
        "end_line": 6749,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.1111111111111111,
            "pseudo_dstar_susp": 0.0007710100231303007,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0007710100231303007,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.hist2d#6753",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.hist2d(self, x, y, bins=10, range=None, density=False, weights=None, cmin=None, cmax=None, **kwargs)",
        "snippet": "    def hist2d(self, x, y, bins=10, range=None, density=False, weights=None,\n               cmin=None, cmax=None, **kwargs):\n        \"\"\"\n        Make a 2D histogram plot.\n\n        Parameters\n        ----------\n        x, y : array-like, shape (n, )\n            Input values\n\n        bins : None or int or [int, int] or array-like or [array, array]\n\n            The bin specification:\n\n            - If int, the number of bins for the two dimensions\n              (nx=ny=bins).\n            - If ``[int, int]``, the number of bins in each dimension\n              (nx, ny = bins).\n            - If array-like, the bin edges for the two dimensions\n              (x_edges=y_edges=bins).\n            - If ``[array, array]``, the bin edges in each dimension\n              (x_edges, y_edges = bins).\n\n            The default value is 10.\n\n        range : array-like shape(2, 2), optional\n            The leftmost and rightmost edges of the bins along each dimension\n            (if not specified explicitly in the bins parameters): ``[[xmin,\n            xmax], [ymin, ymax]]``. All values outside of this range will be\n            considered outliers and not tallied in the histogram.\n\n        density : bool, default: False\n            Normalize histogram.  See the documentation for the *density*\n            parameter of `~.Axes.hist` for more details.\n\n        weights : array-like, shape (n, ), optional\n            An array of values w_i weighing each sample (x_i, y_i).\n\n        cmin : scalar, optional, default: None\n            All bins that has count less than cmin will not be displayed (set\n            to NaN before passing to imshow) and these count values in the\n            return value count histogram will also be set to nan upon return.\n\n        cmax : scalar, optional, default: None\n            All bins that has count more than cmax will not be displayed (set\n            to NaN before passing to imshow) and these count values in the\n            return value count histogram will also be set to nan upon return.\n\n        Returns\n        -------\n        h : 2D array\n            The bi-dimensional histogram of samples x and y. Values in x are\n            histogrammed along the first dimension and values in y are\n            histogrammed along the second dimension.\n        xedges : 1D array\n            The bin edges along the x axis.\n        yedges : 1D array\n            The bin edges along the y axis.\n        image : `~.matplotlib.collections.QuadMesh`\n\n        Other Parameters\n        ----------------\n        cmap : Colormap or str, optional\n            A `.colors.Colormap` instance.  If not set, use rc settings.\n\n        norm : Normalize, optional\n            A `.colors.Normalize` instance is used to\n            scale luminance data to ``[0, 1]``. If not set, defaults to\n            `.colors.Normalize()`.\n\n        vmin/vmax : None or scalar, optional\n            Arguments passed to the `~.colors.Normalize` instance.\n\n        alpha : ``0 <= scalar <= 1`` or ``None``, optional\n            The alpha blending value.\n\n        **kwargs\n            Additional parameters are passed along to the\n            `~.Axes.pcolormesh` method and `~matplotlib.collections.QuadMesh`\n            constructor.\n\n        See also\n        --------\n        hist : 1D histogram plotting\n\n        Notes\n        -----\n        - Currently ``hist2d`` calculates its own axis limits, and any limits\n          previously set are ignored.\n        - Rendering the histogram with a logarithmic color scale is\n          accomplished by passing a `.colors.LogNorm` instance to the *norm*\n          keyword argument. Likewise, power-law normalization (similar\n          in effect to gamma correction) can be accomplished with\n          `.colors.PowerNorm`.\n        \"\"\"\n\n        h, xedges, yedges = np.histogram2d(x, y, bins=bins, range=range,\n                                           density=density, weights=weights)\n\n        if cmin is not None:\n            h[h < cmin] = None\n        if cmax is not None:\n            h[h > cmax] = None\n\n        pc = self.pcolormesh(xedges, yedges, h.T, **kwargs)\n        self.set_xlim(xedges[0], xedges[-1])\n        self.set_ylim(yedges[0], yedges[-1])\n\n        return h, xedges, yedges, pc",
        "begin_line": 6753,
        "end_line": 6861,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.psd#6865",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None, return_line=None, **kwargs)",
        "snippet": "    def psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,\n            window=None, noverlap=None, pad_to=None,\n            sides=None, scale_by_freq=None, return_line=None, **kwargs):\n        r\"\"\"\n        Plot the power spectral density.\n\n        The power spectral density :math:`P_{xx}` by Welch's average\n        periodogram method.  The vector *x* is divided into *NFFT* length\n        segments.  Each segment is detrended by function *detrend* and\n        windowed by function *window*.  *noverlap* gives the length of\n        the overlap between segments.  The :math:`|\\mathrm{fft}(i)|^2`\n        of each segment :math:`i` are averaged to compute :math:`P_{xx}`,\n        with a scaling to correct for power loss due to windowing.\n\n        If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.\n\n        Parameters\n        ----------\n        x : 1-D array or sequence\n            Array or sequence containing the data\n\n        %(Spectral)s\n\n        %(PSD)s\n\n        noverlap : int, default: 0 (no overlap)\n            The number of points of overlap between segments.\n\n        Fc : int, default: 0\n            The center frequency of *x*, which offsets the x extents of the\n            plot to reflect the frequency range used when a signal is acquired\n            and then filtered and downsampled to baseband.\n\n        return_line : bool, default: False\n            Whether to include the line object plotted in the returned values.\n\n        Returns\n        -------\n        Pxx : 1-D array\n            The values for the power spectrum :math:`P_{xx}` before scaling\n            (real valued).\n\n        freqs : 1-D array\n            The frequencies corresponding to the elements in *Pxx*.\n\n        line : `~matplotlib.lines.Line2D`\n            The line created by this function.\n            Only returned if *return_line* is True.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Keyword arguments control the `.Line2D` properties:\n\n            %(_Line2D_docstr)s\n\n        See Also\n        --------\n        specgram\n            Differs in the default overlap; in not returning the mean of the\n            segment periodograms; in returning the times of the segments; and\n            in plotting a colormap instead of a line.\n        magnitude_spectrum\n            Plots the magnitude spectrum.\n        csd\n            Plots the spectral density between two signals.\n\n        Notes\n        -----\n        For plotting, the power is plotted as\n        :math:`10\\log_{10}(P_{xx})` for decibels, though *Pxx* itself\n        is returned.\n\n        References\n        ----------\n        Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,\n        John Wiley & Sons (1986)\n        \"\"\"\n        if Fc is None:\n            Fc = 0\n\n        pxx, freqs = mlab.psd(x=x, NFFT=NFFT, Fs=Fs, detrend=detrend,\n                              window=window, noverlap=noverlap, pad_to=pad_to,\n                              sides=sides, scale_by_freq=scale_by_freq)\n        freqs += Fc\n\n        if scale_by_freq in (None, True):\n            psd_units = 'dB/Hz'\n        else:\n            psd_units = 'dB'\n\n        line = self.plot(freqs, 10 * np.log10(pxx), **kwargs)\n        self.set_xlabel('Frequency')\n        self.set_ylabel('Power Spectral Density (%s)' % psd_units)\n        self.grid(True)\n        vmin, vmax = self.viewLim.intervaly\n        intv = vmax - vmin\n        logi = int(np.log10(intv))\n        if logi == 0:\n            logi = .1\n        step = 10 * logi\n        ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)\n        self.set_yticks(ticks)\n\n        if return_line is None or not return_line:\n            return pxx, freqs\n        else:\n            return pxx, freqs, line",
        "begin_line": 6865,
        "end_line": 6972,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.csd#6976",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None, return_line=None, **kwargs)",
        "snippet": "    def csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None,\n            window=None, noverlap=None, pad_to=None,\n            sides=None, scale_by_freq=None, return_line=None, **kwargs):\n        r\"\"\"\n        Plot the cross-spectral density.\n\n        The cross spectral density :math:`P_{xy}` by Welch's average\n        periodogram method.  The vectors *x* and *y* are divided into\n        *NFFT* length segments.  Each segment is detrended by function\n        *detrend* and windowed by function *window*.  *noverlap* gives\n        the length of the overlap between segments.  The product of\n        the direct FFTs of *x* and *y* are averaged over each segment\n        to compute :math:`P_{xy}`, with a scaling to correct for power\n        loss due to windowing.\n\n        If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero\n        padded to *NFFT*.\n\n        Parameters\n        ----------\n        x, y : 1-D arrays or sequences\n            Arrays or sequences containing the data.\n\n        %(Spectral)s\n\n        %(PSD)s\n\n        noverlap : int, default: 0 (no overlap)\n            The number of points of overlap between segments.\n\n        Fc : int, default: 0\n            The center frequency of *x*, which offsets the x extents of the\n            plot to reflect the frequency range used when a signal is acquired\n            and then filtered and downsampled to baseband.\n\n        return_line : bool, default: False\n            Whether to include the line object plotted in the returned values.\n\n        Returns\n        -------\n        Pxy : 1-D array\n            The values for the cross spectrum :math:`P_{xy}` before scaling\n            (complex valued).\n\n        freqs : 1-D array\n            The frequencies corresponding to the elements in *Pxy*.\n\n        line : `~matplotlib.lines.Line2D`\n            The line created by this function.\n            Only returned if *return_line* is True.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Keyword arguments control the `.Line2D` properties:\n\n            %(_Line2D_docstr)s\n\n        See Also\n        --------\n        psd : is equivalent to setting ``y = x``.\n\n        Notes\n        -----\n        For plotting, the power is plotted as\n        :math:`10 \\log_{10}(P_{xy})` for decibels, though :math:`P_{xy}` itself\n        is returned.\n\n        References\n        ----------\n        Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,\n        John Wiley & Sons (1986)\n        \"\"\"\n        if Fc is None:\n            Fc = 0\n\n        pxy, freqs = mlab.csd(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,\n                              window=window, noverlap=noverlap, pad_to=pad_to,\n                              sides=sides, scale_by_freq=scale_by_freq)\n        # pxy is complex\n        freqs += Fc\n\n        line = self.plot(freqs, 10 * np.log10(np.abs(pxy)), **kwargs)\n        self.set_xlabel('Frequency')\n        self.set_ylabel('Cross Spectrum Magnitude (dB)')\n        self.grid(True)\n        vmin, vmax = self.viewLim.intervaly\n\n        intv = vmax - vmin\n        step = 10 * int(np.log10(intv))\n\n        ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)\n        self.set_yticks(ticks)\n\n        if return_line is None or not return_line:\n            return pxy, freqs\n        else:\n            return pxy, freqs, line",
        "begin_line": 6976,
        "end_line": 7073,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.magnitude_spectrum#7077",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.magnitude_spectrum(self, x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, scale=None, **kwargs)",
        "snippet": "    def magnitude_spectrum(self, x, Fs=None, Fc=None, window=None,\n                           pad_to=None, sides=None, scale=None,\n                           **kwargs):\n        \"\"\"\n        Plot the magnitude spectrum.\n\n        Compute the magnitude spectrum of *x*.  Data is padded to a\n        length of *pad_to* and the windowing function *window* is applied to\n        the signal.\n\n        Parameters\n        ----------\n        x : 1-D array or sequence\n            Array or sequence containing the data.\n\n        %(Spectral)s\n\n        %(Single_Spectrum)s\n\n        scale : {'default', 'linear', 'dB'}\n            The scaling of the values in the *spec*.  'linear' is no scaling.\n            'dB' returns the values in dB scale, i.e., the dB amplitude\n            (20 * log10). 'default' is 'linear'.\n\n        Fc : int, default: 0\n            The center frequency of *x*, which offsets the x extents of the\n            plot to reflect the frequency range used when a signal is acquired\n            and then filtered and downsampled to baseband.\n\n        Returns\n        -------\n        spectrum : 1-D array\n            The values for the magnitude spectrum before scaling (real valued).\n\n        freqs : 1-D array\n            The frequencies corresponding to the elements in *spectrum*.\n\n        line : `~matplotlib.lines.Line2D`\n            The line created by this function.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Keyword arguments control the `.Line2D` properties:\n\n            %(_Line2D_docstr)s\n\n        See Also\n        --------\n        psd\n            Plots the power spectral density.\n        angle_spectrum\n            Plots the angles of the corresponding frequencies.\n        phase_spectrum\n            Plots the phase (unwrapped angle) of the corresponding frequencies.\n        specgram\n            Can plot the magnitude spectrum of segments within the signal in a\n            colormap.\n        \"\"\"\n        if Fc is None:\n            Fc = 0\n\n        spec, freqs = mlab.magnitude_spectrum(x=x, Fs=Fs, window=window,\n                                              pad_to=pad_to, sides=sides)\n        freqs += Fc\n\n        yunits = cbook._check_getitem(\n            {None: 'energy', 'default': 'energy', 'linear': 'energy',\n             'dB': 'dB'},\n            scale=scale)\n        if yunits == 'energy':\n            Z = spec\n        else:  # yunits == 'dB'\n            Z = 20. * np.log10(spec)\n\n        line, = self.plot(freqs, Z, **kwargs)\n        self.set_xlabel('Frequency')\n        self.set_ylabel('Magnitude (%s)' % yunits)\n\n        return spec, freqs, line",
        "begin_line": 7077,
        "end_line": 7156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.angle_spectrum#7160",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.angle_spectrum(self, x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, **kwargs)",
        "snippet": "    def angle_spectrum(self, x, Fs=None, Fc=None, window=None,\n                       pad_to=None, sides=None, **kwargs):\n        \"\"\"\n        Plot the angle spectrum.\n\n        Compute the angle spectrum (wrapped phase spectrum) of *x*.\n        Data is padded to a length of *pad_to* and the windowing function\n        *window* is applied to the signal.\n\n        Parameters\n        ----------\n        x : 1-D array or sequence\n            Array or sequence containing the data.\n\n        %(Spectral)s\n\n        %(Single_Spectrum)s\n\n        Fc : int, default: 0\n            The center frequency of *x*, which offsets the x extents of the\n            plot to reflect the frequency range used when a signal is acquired\n            and then filtered and downsampled to baseband.\n\n        Returns\n        -------\n        spectrum : 1-D array\n            The values for the angle spectrum in radians (real valued).\n\n        freqs : 1-D array\n            The frequencies corresponding to the elements in *spectrum*.\n\n        line : `~matplotlib.lines.Line2D`\n            The line created by this function.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Keyword arguments control the `.Line2D` properties:\n\n            %(_Line2D_docstr)s\n\n        See Also\n        --------\n        magnitude_spectrum\n            Plots the magnitudes of the corresponding frequencies.\n        phase_spectrum\n            Plots the unwrapped version of this function.\n        specgram\n            Can plot the angle spectrum of segments within the signal in a\n            colormap.\n        \"\"\"\n        if Fc is None:\n            Fc = 0\n\n        spec, freqs = mlab.angle_spectrum(x=x, Fs=Fs, window=window,\n                                          pad_to=pad_to, sides=sides)\n        freqs += Fc\n\n        lines = self.plot(freqs, spec, **kwargs)\n        self.set_xlabel('Frequency')\n        self.set_ylabel('Angle (radians)')\n\n        return spec, freqs, lines[0]",
        "begin_line": 7160,
        "end_line": 7222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.phase_spectrum#7226",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.phase_spectrum(self, x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, **kwargs)",
        "snippet": "    def phase_spectrum(self, x, Fs=None, Fc=None, window=None,\n                       pad_to=None, sides=None, **kwargs):\n        \"\"\"\n        Plot the phase spectrum.\n\n        Compute the phase spectrum (unwrapped angle spectrum) of *x*.\n        Data is padded to a length of *pad_to* and the windowing function\n        *window* is applied to the signal.\n\n        Parameters\n        ----------\n        x : 1-D array or sequence\n            Array or sequence containing the data\n\n        %(Spectral)s\n\n        %(Single_Spectrum)s\n\n        Fc : int, default: 0\n            The center frequency of *x*, which offsets the x extents of the\n            plot to reflect the frequency range used when a signal is acquired\n            and then filtered and downsampled to baseband.\n\n        Returns\n        -------\n        spectrum : 1-D array\n            The values for the phase spectrum in radians (real valued).\n\n        freqs : 1-D array\n            The frequencies corresponding to the elements in *spectrum*.\n\n        line : `~matplotlib.lines.Line2D`\n            The line created by this function.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Keyword arguments control the `.Line2D` properties:\n\n            %(_Line2D_docstr)s\n\n        See Also\n        --------\n        magnitude_spectrum\n            Plots the magnitudes of the corresponding frequencies.\n        angle_spectrum\n            Plots the wrapped version of this function.\n        specgram\n            Can plot the phase spectrum of segments within the signal in a\n            colormap.\n        \"\"\"\n        if Fc is None:\n            Fc = 0\n\n        spec, freqs = mlab.phase_spectrum(x=x, Fs=Fs, window=window,\n                                          pad_to=pad_to, sides=sides)\n        freqs += Fc\n\n        lines = self.plot(freqs, spec, **kwargs)\n        self.set_xlabel('Frequency')\n        self.set_ylabel('Phase (radians)')\n\n        return spec, freqs, lines[0]",
        "begin_line": 7226,
        "end_line": 7288,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.specgram#7353",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None, noverlap=None, cmap=None, xextent=None, pad_to=None, sides=None, scale_by_freq=None, mode=None, scale=None, vmin=None, vmax=None, **kwargs)",
        "snippet": "    def specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,\n                 window=None, noverlap=None,\n                 cmap=None, xextent=None, pad_to=None, sides=None,\n                 scale_by_freq=None, mode=None, scale=None,\n                 vmin=None, vmax=None, **kwargs):\n        \"\"\"\n        Plot a spectrogram.\n\n        Compute and plot a spectrogram of data in *x*.  Data are split into\n        *NFFT* length segments and the spectrum of each section is\n        computed.  The windowing function *window* is applied to each\n        segment, and the amount of overlap of each segment is\n        specified with *noverlap*. The spectrogram is plotted as a colormap\n        (using imshow).\n\n        Parameters\n        ----------\n        x : 1-D array or sequence\n            Array or sequence containing the data.\n\n        %(Spectral)s\n\n        %(PSD)s\n\n        mode : {'default', 'psd', 'magnitude', 'angle', 'phase'}\n            What sort of spectrum to use.  Default is 'psd', which takes the\n            power spectral density.  'magnitude' returns the magnitude\n            spectrum.  'angle' returns the phase spectrum without unwrapping.\n            'phase' returns the phase spectrum with unwrapping.\n\n        noverlap : int\n            The number of points of overlap between blocks.  The\n            default value is 128.\n\n        scale : {'default', 'linear', 'dB'}\n            The scaling of the values in the *spec*.  'linear' is no scaling.\n            'dB' returns the values in dB scale.  When *mode* is 'psd',\n            this is dB power (10 * log10).  Otherwise this is dB amplitude\n            (20 * log10). 'default' is 'dB' if *mode* is 'psd' or\n            'magnitude' and 'linear' otherwise.  This must be 'linear'\n            if *mode* is 'angle' or 'phase'.\n\n        Fc : int, default: 0\n            The center frequency of *x*, which offsets the x extents of the\n            plot to reflect the frequency range used when a signal is acquired\n            and then filtered and downsampled to baseband.\n\n        cmap : `.Colormap`, default: :rc:`image.cmap`\n\n        xextent : *None* or (xmin, xmax)\n            The image extent along the x-axis. The default sets *xmin* to the\n            left border of the first bin (*spectrum* column) and *xmax* to the\n            right border of the last bin. Note that for *noverlap>0* the width\n            of the bins is smaller than those of the segments.\n\n        **kwargs\n            Additional keyword arguments are passed on to `~.axes.Axes.imshow`\n            which makes the specgram image.\n\n        Returns\n        -------\n        spectrum : 2-D array\n            Columns are the periodograms of successive segments.\n\n        freqs : 1-D array\n            The frequencies corresponding to the rows in *spectrum*.\n\n        t : 1-D array\n            The times corresponding to midpoints of segments (i.e., the columns\n            in *spectrum*).\n\n        im : `.AxesImage`\n            The image created by imshow containing the spectrogram.\n\n        See Also\n        --------\n        psd\n            Differs in the default overlap; in returning the mean of the\n            segment periodograms; in not returning times; and in generating a\n            line plot instead of colormap.\n        magnitude_spectrum\n            A single spectrum, similar to having a single segment when *mode*\n            is 'magnitude'. Plots a line instead of a colormap.\n        angle_spectrum\n            A single spectrum, similar to having a single segment when *mode*\n            is 'angle'. Plots a line instead of a colormap.\n        phase_spectrum\n            A single spectrum, similar to having a single segment when *mode*\n            is 'phase'. Plots a line instead of a colormap.\n\n        Notes\n        -----\n        The parameters *detrend* and *scale_by_freq* do only apply when *mode*\n        is set to 'psd'.\n        \"\"\"\n        if NFFT is None:\n            NFFT = 256  # same default as in mlab.specgram()\n        if Fc is None:\n            Fc = 0  # same default as in mlab._spectral_helper()\n        if noverlap is None:\n            noverlap = 128  # same default as in mlab.specgram()\n\n        if mode == 'complex':\n            raise ValueError('Cannot plot a complex specgram')\n\n        if scale is None or scale == 'default':\n            if mode in ['angle', 'phase']:\n                scale = 'linear'\n            else:\n                scale = 'dB'\n        elif mode in ['angle', 'phase'] and scale == 'dB':\n            raise ValueError('Cannot use dB scale with angle or phase mode')\n\n        spec, freqs, t = mlab.specgram(x=x, NFFT=NFFT, Fs=Fs,\n                                       detrend=detrend, window=window,\n                                       noverlap=noverlap, pad_to=pad_to,\n                                       sides=sides,\n                                       scale_by_freq=scale_by_freq,\n                                       mode=mode)\n\n        if scale == 'linear':\n            Z = spec\n        elif scale == 'dB':\n            if mode is None or mode == 'default' or mode == 'psd':\n                Z = 10. * np.log10(spec)\n            else:\n                Z = 20. * np.log10(spec)\n        else:\n            raise ValueError('Unknown scale %s', scale)\n\n        Z = np.flipud(Z)\n\n        if xextent is None:\n            # padding is needed for first and last segment:\n            pad_xextent = (NFFT-noverlap) / Fs / 2\n            xextent = np.min(t) - pad_xextent, np.max(t) + pad_xextent\n        xmin, xmax = xextent\n        freqs += Fc\n        extent = xmin, xmax, freqs[0], freqs[-1]\n        im = self.imshow(Z, cmap, extent=extent, vmin=vmin, vmax=vmax,\n                         **kwargs)\n        self.axis('auto')\n\n        return spec, freqs, t, im",
        "begin_line": 7353,
        "end_line": 7496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.spy#7499",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.spy(self, Z, precision=0, marker=None, markersize=None, aspect='equal', origin='upper', **kwargs)",
        "snippet": "    def spy(self, Z, precision=0, marker=None, markersize=None,\n            aspect='equal', origin=\"upper\", **kwargs):\n        \"\"\"\n        Plot the sparsity pattern of a 2D array.\n\n        This visualizes the non-zero values of the array.\n\n        Two plotting styles are available: image and marker. Both\n        are available for full arrays, but only the marker style\n        works for `scipy.sparse.spmatrix` instances.\n\n        **Image style**\n\n        If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any\n        extra remaining keyword arguments are passed to this method.\n\n        **Marker style**\n\n        If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are\n        *None*, a `.Line2D` object will be returned with the value of marker\n        determining the marker type, and any remaining keyword arguments\n        passed to `~.Axes.plot`.\n\n        Parameters\n        ----------\n        Z : array-like (M, N)\n            The array to be plotted.\n\n        precision : float or 'present', default: 0\n            If *precision* is 0, any non-zero value will be plotted. Otherwise,\n            values of :math:`|Z| > precision` will be plotted.\n\n            For `scipy.sparse.spmatrix` instances, you can also\n            pass 'present'. In this case any value present in the array\n            will be plotted, even if it is identically zero.\n\n        aspect : {'equal', 'auto', None} or float, default: 'equal'\n            The aspect ratio of the axes.  This parameter is particularly\n            relevant for images since it determines whether data pixels are\n            square.\n\n            This parameter is a shortcut for explicitly calling\n            `.Axes.set_aspect`. See there for further details.\n\n            - 'equal': Ensures an aspect ratio of 1. Pixels will be square.\n            - 'auto': The axes is kept fixed and the aspect is adjusted so\n              that the data fit in the axes. In general, this will result in\n              non-square pixels.\n            - *None*: Use :rc:`image.aspect`.\n\n        origin : {'upper', 'lower'}, default: :rc:`image.origin`\n            Place the [0, 0] index of the array in the upper left or lower left\n            corner of the axes. The convention 'upper' is typically used for\n            matrices and images.\n\n        Returns\n        -------\n        ret : `~matplotlib.image.AxesImage` or `.Line2D`\n            The return type depends on the plotting style (see above).\n\n        Other Parameters\n        ----------------\n        **kwargs\n            The supported additional parameters depend on the plotting style.\n\n            For the image style, you can pass the following additional\n            parameters of `~.Axes.imshow`:\n\n            - *cmap*\n            - *alpha*\n            - *url*\n            - any `.Artist` properties (passed on to the `.AxesImage`)\n\n            For the marker style, you can pass any `.Line2D` property except\n            for *linestyle*:\n\n            %(_Line2D_docstr)s\n        \"\"\"\n        if marker is None and markersize is None and hasattr(Z, 'tocoo'):\n            marker = 's'\n        cbook._check_in_list([\"upper\", \"lower\"], origin=origin)\n        if marker is None and markersize is None:\n            Z = np.asarray(Z)\n            mask = np.abs(Z) > precision\n\n            if 'cmap' not in kwargs:\n                kwargs['cmap'] = mcolors.ListedColormap(['w', 'k'],\n                                                        name='binary')\n            if 'interpolation' in kwargs:\n                raise TypeError(\n                    \"spy() got an unexpected keyword argument 'interpolation'\")\n            ret = self.imshow(mask, interpolation='nearest', aspect=aspect,\n                              origin=origin, **kwargs)\n        else:\n            if hasattr(Z, 'tocoo'):\n                c = Z.tocoo()\n                if precision == 'present':\n                    y = c.row\n                    x = c.col\n                else:\n                    nonzero = np.abs(c.data) > precision\n                    y = c.row[nonzero]\n                    x = c.col[nonzero]\n            else:\n                Z = np.asarray(Z)\n                nonzero = np.abs(Z) > precision\n                y, x = np.nonzero(nonzero)\n            if marker is None:\n                marker = 's'\n            if markersize is None:\n                markersize = 10\n            if 'linestyle' in kwargs:\n                raise TypeError(\n                    \"spy() got an unexpected keyword argument 'linestyle'\")\n            ret = mlines.Line2D(\n                x, y, linestyle='None', marker=marker, markersize=markersize,\n                **kwargs)\n            self.add_line(ret)\n            nr, nc = Z.shape\n            self.set_xlim(-0.5, nc - 0.5)\n            if origin == \"upper\":\n                self.set_ylim(nr - 0.5, -0.5)\n            else:\n                self.set_ylim(-0.5, nr - 0.5)\n            self.set_aspect(aspect)\n        self.title.set_y(1.05)\n        if origin == \"upper\":\n            self.xaxis.tick_top()\n        else:\n            self.xaxis.tick_bottom()\n        self.xaxis.set_ticks_position('both')\n        self.xaxis.set_major_locator(\n            mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))\n        self.yaxis.set_major_locator(\n            mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))\n        return ret",
        "begin_line": 7499,
        "end_line": 7634,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.matshow#7636",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.matshow(self, Z, **kwargs)",
        "snippet": "    def matshow(self, Z, **kwargs):\n        \"\"\"\n        Plot the values of a 2D matrix or array as color-coded image.\n\n        The matrix will be shown the way it would be printed, with the first\n        row at the top.  Row and column numbering is zero-based.\n\n        Parameters\n        ----------\n        Z : array-like(M, N)\n            The matrix to be displayed.\n\n        Returns\n        -------\n        image : `~matplotlib.image.AxesImage`\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.axes.Axes.imshow` arguments\n\n        See Also\n        --------\n        imshow : More general function to plot data on a 2D regular raster.\n\n        Notes\n        -----\n        This is just a convenience function wrapping `.imshow` to set useful\n        defaults for displaying a matrix. In particular:\n\n        - Set ``origin='upper'``.\n        - Set ``interpolation='nearest'``.\n        - Set ``aspect='equal'``.\n        - Ticks are placed to the left and above.\n        - Ticks are formatted to show integer indices.\n\n        \"\"\"\n        Z = np.asanyarray(Z)\n        kw = {'origin': 'upper',\n              'interpolation': 'nearest',\n              'aspect': 'equal',          # (already the imshow default)\n              **kwargs}\n        im = self.imshow(Z, **kw)\n        self.title.set_y(1.05)\n        self.xaxis.tick_top()\n        self.xaxis.set_ticks_position('both')\n        self.xaxis.set_major_locator(\n            mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))\n        self.yaxis.set_major_locator(\n            mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))\n        return im",
        "begin_line": 7636,
        "end_line": 7685,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes._kde_method#7773",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes._kde_method(X, coords)",
        "snippet": "        def _kde_method(X, coords):\n            # fallback gracefully if the vector contains only one value\n            if np.all(X[0] == X):\n                return (X[0] == coords).astype(float)\n            kde = mlab.GaussianKDE(X, bw_method)\n            return kde.evaluate(coords)",
        "begin_line": 7773,
        "end_line": 7778,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.violinplot#7688",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.violinplot(self, dataset, positions=None, vert=True, widths=0.5, showmeans=False, showextrema=True, showmedians=False, quantiles=None, points=100, bw_method=None)",
        "snippet": "    def violinplot(self, dataset, positions=None, vert=True, widths=0.5,\n                   showmeans=False, showextrema=True, showmedians=False,\n                   quantiles=None, points=100, bw_method=None):\n        \"\"\"\n        Make a violin plot.\n\n        Make a violin plot for each column of *dataset* or each vector in\n        sequence *dataset*.  Each filled area extends to represent the\n        entire data range, with optional lines at the mean, the median,\n        the minimum, the maximum, and user-specified quantiles.\n\n        Parameters\n        ----------\n        dataset : Array or a sequence of vectors.\n          The input data.\n\n        positions : array-like, default: [1, 2, ..., n]\n          Sets the positions of the violins. The ticks and limits are\n          automatically set to match the positions.\n\n        vert : bool, default: True.\n          If true, creates a vertical violin plot.\n          Otherwise, creates a horizontal violin plot.\n\n        widths : array-like, default: 0.5\n          Either a scalar or a vector that sets the maximal width of\n          each violin. The default is 0.5, which uses about half of the\n          available horizontal space.\n\n        showmeans : bool, default: False\n          If `True`, will toggle rendering of the means.\n\n        showextrema : bool, default: True\n          If `True`, will toggle rendering of the extrema.\n\n        showmedians : bool, default: False\n          If `True`, will toggle rendering of the medians.\n\n        quantiles : array-like, default: None\n          If not None, set a list of floats in interval [0, 1] for each violin,\n          which stands for the quantiles that will be rendered for that\n          violin.\n\n        points : scalar, default: 100\n          Defines the number of points to evaluate each of the\n          gaussian kernel density estimations at.\n\n        bw_method : str, scalar or callable, optional\n          The method used to calculate the estimator bandwidth.  This can be\n          'scott', 'silverman', a scalar constant or a callable.  If a\n          scalar, this will be used directly as `kde.factor`.  If a\n          callable, it should take a `GaussianKDE` instance as its only\n          parameter and return a scalar. If None (default), 'scott' is used.\n\n        Returns\n        -------\n        result : dict\n          A dictionary mapping each component of the violinplot to a\n          list of the corresponding collection instances created. The\n          dictionary has the following keys:\n\n          - ``bodies``: A list of the `~.collections.PolyCollection`\n            instances containing the filled area of each violin.\n\n          - ``cmeans``: A `~.collections.LineCollection` instance that marks\n            the mean values of each of the violin's distribution.\n\n          - ``cmins``: A `~.collections.LineCollection` instance that marks\n            the bottom of each violin's distribution.\n\n          - ``cmaxes``: A `~.collections.LineCollection` instance that marks\n            the top of each violin's distribution.\n\n          - ``cbars``: A `~.collections.LineCollection` instance that marks\n            the centers of each violin's distribution.\n\n          - ``cmedians``: A `~.collections.LineCollection` instance that\n            marks the median values of each of the violin's distribution.\n\n          - ``cquantiles``: A `~.collections.LineCollection` instance created\n            to identify the quantile values of each of the violin's\n            distribution.\n\n        \"\"\"\n\n        def _kde_method(X, coords):\n            # fallback gracefully if the vector contains only one value\n            if np.all(X[0] == X):\n                return (X[0] == coords).astype(float)\n            kde = mlab.GaussianKDE(X, bw_method)\n            return kde.evaluate(coords)\n\n        vpstats = cbook.violin_stats(dataset, _kde_method, points=points,\n                                     quantiles=quantiles)\n        return self.violin(vpstats, positions=positions, vert=vert,\n                           widths=widths, showmeans=showmeans,\n                           showextrema=showextrema, showmedians=showmedians)",
        "begin_line": 7688,
        "end_line": 7784,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.28332714444857e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._axes.Axes.violin#7786",
        "src_path": "lib/matplotlib/axes/_axes.py",
        "class_name": "lib.matplotlib.axes._axes.Axes",
        "signature": "lib.matplotlib.axes._axes.Axes.violin(self, vpstats, positions=None, vert=True, widths=0.5, showmeans=False, showextrema=True, showmedians=False)",
        "snippet": "    def violin(self, vpstats, positions=None, vert=True, widths=0.5,\n               showmeans=False, showextrema=True, showmedians=False):\n        \"\"\"Drawing function for violin plots.\n\n        Draw a violin plot for each column of *vpstats*. Each filled area\n        extends to represent the entire data range, with optional lines at the\n        mean, the median, the minimum, the maximum, and the quantiles values.\n\n        Parameters\n        ----------\n        vpstats : list of dicts\n          A list of dictionaries containing stats for each violin plot.\n          Required keys are:\n\n          - ``coords``: A list of scalars containing the coordinates that\n            the violin's kernel density estimate were evaluated at.\n\n          - ``vals``: A list of scalars containing the values of the\n            kernel density estimate at each of the coordinates given\n            in *coords*.\n\n          - ``mean``: The mean value for this violin's dataset.\n\n          - ``median``: The median value for this violin's dataset.\n\n          - ``min``: The minimum value for this violin's dataset.\n\n          - ``max``: The maximum value for this violin's dataset.\n\n          Optional keys are:\n\n          - ``quantiles``: A list of scalars containing the quantile values\n            for this violin's dataset.\n\n        positions : array-like, default: [1, 2, ..., n]\n          Sets the positions of the violins. The ticks and limits are\n          automatically set to match the positions.\n\n        vert : bool, default: True.\n          If true, plots the violins vertically.\n          Otherwise, plots the violins horizontally.\n\n        widths : array-like, default: 0.5\n          Either a scalar or a vector that sets the maximal width of\n          each violin. The default is 0.5, which uses about half of the\n          available horizontal space.\n\n        showmeans : bool, default: False\n          If true, will toggle rendering of the means.\n\n        showextrema : bool, default: True\n          If true, will toggle rendering of the extrema.\n\n        showmedians : bool, default: False\n          If true, will toggle rendering of the medians.\n\n        Returns\n        -------\n        result : dict\n          A dictionary mapping each component of the violinplot to a\n          list of the corresponding collection instances created. The\n          dictionary has the following keys:\n\n          - ``bodies``: A list of the `~.collections.PolyCollection`\n            instances containing the filled area of each violin.\n\n          - ``cmeans``: A `~.collections.LineCollection` instance that marks\n            the mean values of each of the violin's distribution.\n\n          - ``cmins``: A `~.collections.LineCollection` instance that marks\n            the bottom of each violin's distribution.\n\n          - ``cmaxes``: A `~.collections.LineCollection` instance that marks\n            the top of each violin's distribution.\n\n          - ``cbars``: A `~.collections.LineCollection` instance that marks\n            the centers of each violin's distribution.\n\n          - ``cmedians``: A `~.collections.LineCollection` instance that\n            marks the median values of each of the violin's distribution.\n\n          - ``cquantiles``: A `~.collections.LineCollection` instance created\n            to identify the quantiles values of each of the violin's\n            distribution.\n\n        \"\"\"\n\n        # Statistical quantities to be plotted on the violins\n        means = []\n        mins = []\n        maxes = []\n        medians = []\n        quantiles = np.asarray([])\n\n        # Collections to be returned\n        artists = {}\n\n        N = len(vpstats)\n        datashape_message = (\"List of violinplot statistics and `{0}` \"\n                             \"values must have the same length\")\n\n        # Validate positions\n        if positions is None:\n            positions = range(1, N + 1)\n        elif len(positions) != N:\n            raise ValueError(datashape_message.format(\"positions\"))\n\n        # Validate widths\n        if np.isscalar(widths):\n            widths = [widths] * N\n        elif len(widths) != N:\n            raise ValueError(datashape_message.format(\"widths\"))\n\n        # Calculate ranges for statistics lines\n        pmins = -0.25 * np.array(widths) + positions\n        pmaxes = 0.25 * np.array(widths) + positions\n\n        # Check whether we are rendering vertically or horizontally\n        if vert:\n            fill = self.fill_betweenx\n            perp_lines = self.hlines\n            par_lines = self.vlines\n        else:\n            fill = self.fill_between\n            perp_lines = self.vlines\n            par_lines = self.hlines\n\n        if rcParams['_internal.classic_mode']:\n            fillcolor = 'y'\n            edgecolor = 'r'\n        else:\n            fillcolor = edgecolor = self._get_lines.get_next_color()\n\n        # Render violins\n        bodies = []\n        for stats, pos, width in zip(vpstats, positions, widths):\n            # The 0.5 factor reflects the fact that we plot from v-p to\n            # v+p\n            vals = np.array(stats['vals'])\n            vals = 0.5 * width * vals / vals.max()\n            bodies += [fill(stats['coords'],\n                            -vals + pos,\n                            vals + pos,\n                            facecolor=fillcolor,\n                            alpha=0.3)]\n            means.append(stats['mean'])\n            mins.append(stats['min'])\n            maxes.append(stats['max'])\n            medians.append(stats['median'])\n            q = stats.get('quantiles')\n            if q is not None:\n                # If exist key quantiles, assume it's a list of floats\n                quantiles = np.concatenate((quantiles, q))\n        artists['bodies'] = bodies\n\n        # Render means\n        if showmeans:\n            artists['cmeans'] = perp_lines(means, pmins, pmaxes,\n                                           colors=edgecolor)\n\n        # Render extrema\n        if showextrema:\n            artists['cmaxes'] = perp_lines(maxes, pmins, pmaxes,\n                                           colors=edgecolor)\n            artists['cmins'] = perp_lines(mins, pmins, pmaxes,\n                                          colors=edgecolor)\n            artists['cbars'] = par_lines(positions, mins, maxes,\n                                         colors=edgecolor)\n\n        # Render medians\n        if showmedians:\n            artists['cmedians'] = perp_lines(medians,\n                                             pmins,\n                                             pmaxes,\n                                             colors=edgecolor)\n\n        # Render quantile values\n        if quantiles.size > 0:\n            # Recalculate ranges for statistics lines for quantiles.\n            # ppmins are the left end of quantiles lines\n            ppmins = np.asarray([])\n            # pmaxes are the right end of quantiles lines\n            ppmaxs = np.asarray([])\n            for stats, cmin, cmax in zip(vpstats, pmins, pmaxes):\n                q = stats.get('quantiles')\n                if q is not None:\n                    ppmins = np.concatenate((ppmins, [cmin] * np.size(q)))\n                    ppmaxs = np.concatenate((ppmaxs, [cmax] * np.size(q)))\n            # Start rendering\n            artists['cquantiles'] = perp_lines(quantiles, ppmins, ppmaxs,\n                                               colors=edgecolor)\n\n        return artists",
        "begin_line": 7786,
        "end_line": 7978,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__._logged_cached#216",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__._logged_cached(fmt, func=None)",
        "snippet": "def _logged_cached(fmt, func=None):\n    \"\"\"\n    Decorator that logs a function's return value, and memoizes that value.\n\n    After ::\n\n        @_logged_cached(fmt)\n        def func(): ...\n\n    the first call to *func* will log its return value at the DEBUG level using\n    %-format string *fmt*, and memoize it; later calls to *func* will directly\n    return that value.\n    \"\"\"\n    if func is None:  # Return the actual decorator.\n        return functools.partial(_logged_cached, fmt)\n\n    called = False\n    ret = None\n\n    @functools.wraps(func)\n    def wrapper():\n        nonlocal called, ret\n        if not called:\n            ret = func()\n            called = True\n            _log.debug(fmt, ret)\n        return ret\n\n    return wrapper",
        "begin_line": 216,
        "end_line": 244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__.wrapper#236",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.wrapper()",
        "snippet": "    def wrapper():\n        nonlocal called, ret\n        if not called:\n            ret = func()\n            called = True\n            _log.debug(fmt, ret)\n        return ret",
        "begin_line": 236,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__.impl#289",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.impl(args, regex, min_ver=None, ignore_exit_code=False)",
        "snippet": "    def impl(args, regex, min_ver=None, ignore_exit_code=False):\n        # Execute the subprocess specified by args; capture stdout and stderr.\n        # Search for a regex match in the output; if the match succeeds, the\n        # first group of the match is the version.\n        # Return an _ExecInfo if the executable exists, and has a version of\n        # at least min_ver (if set); else, raise ExecutableNotFoundError.\n        try:\n            output = subprocess.check_output(\n                args, stderr=subprocess.STDOUT,\n                universal_newlines=True, errors=\"replace\")\n        except subprocess.CalledProcessError as _cpe:\n            if ignore_exit_code:\n                output = _cpe.output\n            else:\n                raise ExecutableNotFoundError(str(_cpe)) from _cpe\n        except OSError as _ose:\n            raise ExecutableNotFoundError(str(_ose)) from _ose\n        match = re.search(regex, output)\n        if match:\n            version = LooseVersion(match.group(1))\n            if min_ver is not None and version < min_ver:\n                raise ExecutableNotFoundError(\n                    f\"You have {args[0]} version {version} but the minimum \"\n                    f\"version supported by Matplotlib is {min_ver}\")\n            return _ExecInfo(args[0], version)\n        else:\n            raise ExecutableNotFoundError(\n                f\"Failed to determine the version of {args[0]} from \"\n                f\"{' '.join(args)}, which output {output}\")",
        "begin_line": 289,
        "end_line": 317,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.__init__#631",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self.update(*args, **kwargs)",
        "begin_line": 631,
        "end_line": 632,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.__setitem__#634",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.__setitem__(self, key, val)",
        "snippet": "    def __setitem__(self, key, val):\n        try:\n            if key in _deprecated_map:\n                version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n                cbook.warn_deprecated(\n                    version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n                key = alt_key\n                val = alt_val(val)\n            elif key in _deprecated_remain_as_none and val is not None:\n                version, = _deprecated_remain_as_none[key]\n                cbook.warn_deprecated(\n                    version, name=key, obj_type=\"rcparam\")\n            elif key in _deprecated_ignore_map:\n                version, alt_key = _deprecated_ignore_map[key]\n                cbook.warn_deprecated(\n                    version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n                return\n            elif key == 'backend':\n                if val is rcsetup._auto_backend_sentinel:\n                    if 'backend' in self:\n                        return\n            try:\n                cval = self.validate[key](val)\n            except ValueError as ve:\n                raise ValueError(f\"Key {key}: {ve}\") from None\n            dict.__setitem__(self, key, cval)\n        except KeyError as err:\n            raise KeyError(\n                f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n                f\"a list of valid parameters)\") from err",
        "begin_line": 634,
        "end_line": 663,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010526315789473684,
            "pseudo_dstar_susp": 0.004761904761904762,
            "pseudo_tarantula_susp": 0.0027100271002710027,
            "pseudo_op2_susp": 0.004761904761904762,
            "pseudo_barinel_susp": 0.0027100271002710027
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.__getitem__#665",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.__getitem__(self, key)",
        "snippet": "    def __getitem__(self, key):\n        if key in _deprecated_map:\n            version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n            cbook.warn_deprecated(\n                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n            return inverse_alt(dict.__getitem__(self, alt_key))\n\n        elif key in _deprecated_ignore_map:\n            version, alt_key = _deprecated_ignore_map[key]\n            cbook.warn_deprecated(\n                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n            return dict.__getitem__(self, alt_key) if alt_key else None\n\n        elif key == \"backend\":\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                from matplotlib import pyplot as plt\n                plt.switch_backend(rcsetup._auto_backend_sentinel)\n\n        return dict.__getitem__(self, key)",
        "begin_line": 665,
        "end_line": 684,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02,
            "pseudo_dstar_susp": 0.006134969325153374,
            "pseudo_tarantula_susp": 0.0035335689045936395,
            "pseudo_op2_susp": 0.006134969325153374,
            "pseudo_barinel_susp": 0.0035335689045936395
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.__repr__#686",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.__repr__(self)",
        "snippet": "    def __repr__(self):\n        class_name = self.__class__.__name__\n        indent = len(class_name) + 1\n        with cbook._suppress_matplotlib_deprecation_warning():\n            repr_split = pprint.pformat(dict(self), indent=1,\n                                        width=80 - indent).split('\\n')\n        repr_indented = ('\\n' + ' ' * indent).join(repr_split)\n        return '{}({})'.format(class_name, repr_indented)",
        "begin_line": 686,
        "end_line": 693,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.__str__#695",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.__str__(self)",
        "snippet": "    def __str__(self):\n        return '\\n'.join(map('{0[0]}: {0[1]}'.format, sorted(self.items())))",
        "begin_line": 695,
        "end_line": 696,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.__iter__#698",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.__iter__(self)",
        "snippet": "    def __iter__(self):\n        \"\"\"Yield sorted list of keys.\"\"\"\n        with cbook._suppress_matplotlib_deprecation_warning():\n            yield from sorted(dict.__iter__(self))",
        "begin_line": 698,
        "end_line": 701,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02,
            "pseudo_dstar_susp": 0.0007288629737609329,
            "pseudo_tarantula_susp": 0.0035335689045936395,
            "pseudo_op2_susp": 0.0007288629737609329,
            "pseudo_barinel_susp": 0.0035335689045936395
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.__len__#703",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.__len__(self)",
        "snippet": "    def __len__(self):\n        return dict.__len__(self)",
        "begin_line": 703,
        "end_line": 704,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.find_all#706",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.find_all(self, pattern)",
        "snippet": "    def find_all(self, pattern):\n        \"\"\"\n        Return the subset of this RcParams dictionary whose keys match,\n        using :func:`re.search`, the given ``pattern``.\n\n        .. note::\n\n            Changes to the returned dictionary are *not* propagated to\n            the parent RcParams dictionary.\n\n        \"\"\"\n        pattern_re = re.compile(pattern)\n        return RcParams((key, value)\n                        for key, value in self.items()\n                        if pattern_re.search(key))",
        "begin_line": 706,
        "end_line": 720,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__.RcParams.copy#722",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.RcParams",
        "signature": "lib.matplotlib.__init__.RcParams.copy(self)",
        "snippet": "    def copy(self):\n        return {k: dict.__getitem__(self, k) for k in self}",
        "begin_line": 722,
        "end_line": 723,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02631578947368421,
            "pseudo_dstar_susp": 0.000708215297450425,
            "pseudo_tarantula_susp": 0.0035971223021582736,
            "pseudo_op2_susp": 0.0007052186177715092,
            "pseudo_barinel_susp": 0.0035971223021582736
        }
    },
    {
        "name": "lib.matplotlib.__init__.is_url#734",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.is_url(filename)",
        "snippet": "def is_url(filename):\n    \"\"\"Return True if string is an http, ftp, or file URL path.\"\"\"\n    return URL_REGEX.match(filename) is not None",
        "begin_line": 734,
        "end_line": 736,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__._open_file_or_url#740",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__._open_file_or_url(fname)",
        "snippet": "def _open_file_or_url(fname):\n    if not isinstance(fname, Path) and is_url(fname):\n        import urllib.request\n        with urllib.request.urlopen(fname) as f:\n            yield (line.decode('utf-8') for line in f)\n    else:\n        fname = os.path.expanduser(fname)\n        encoding = locale.getpreferredencoding(do_setlocale=False)\n        if encoding is None:\n            encoding = \"utf-8\"\n        with open(fname, encoding=encoding) as f:\n            yield f",
        "begin_line": 740,
        "end_line": 751,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__._rc_params_in_file#754",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__._rc_params_in_file(fname, fail_on_error=False)",
        "snippet": "def _rc_params_in_file(fname, fail_on_error=False):\n    \"\"\"\n    Construct a `RcParams` instance from file *fname*.\n\n    Unlike `rc_params_from_file`, the configuration class only contains the\n    parameters specified in the file (i.e. default values are not filled in).\n    \"\"\"\n    _error_details_fmt = 'line #%d\\n\\t\"%s\"\\n\\tin file \"%s\"'\n\n    rc_temp = {}\n    with _open_file_or_url(fname) as fd:\n        try:\n            for line_no, line in enumerate(fd, 1):\n                strippedline = line.split('#', 1)[0].strip()\n                if not strippedline:\n                    continue\n                tup = strippedline.split(':', 1)\n                if len(tup) != 2:\n                    error_details = _error_details_fmt % (line_no, line, fname)\n                    _log.warning('Illegal %s', error_details)\n                    continue\n                key, val = tup\n                key = key.strip()\n                val = val.strip()\n                if key in rc_temp:\n                    _log.warning('Duplicate key in file %r line #%d.',\n                                 fname, line_no)\n                rc_temp[key] = (val, line, line_no)\n        except UnicodeDecodeError:\n            _log.warning('Cannot decode configuration file %s with encoding '\n                         '%s, check LANG and LC_* variables.',\n                         fname,\n                         locale.getpreferredencoding(do_setlocale=False)\n                         or 'utf-8 (default)')\n            raise\n\n    config = RcParams()\n\n    for key, (val, line, line_no) in rc_temp.items():\n        if key in defaultParams:\n            if fail_on_error:\n                config[key] = val  # try to convert to proper type or raise\n            else:\n                try:\n                    config[key] = val  # try to convert to proper type or skip\n                except Exception as msg:\n                    error_details = _error_details_fmt % (line_no, line, fname)\n                    _log.warning('Bad val %r on %s\\n\\t%s',\n                                 val, error_details, msg)\n        elif key in _deprecated_ignore_map:\n            version, alt_key = _deprecated_ignore_map[key]\n            cbook.warn_deprecated(\n                version, name=key, alternative=alt_key,\n                addendum=\"Please update your matplotlibrc.\")\n        else:\n            version = 'master' if '.post' in __version__ else f'v{__version__}'\n            print(f\"\"\"\nBad key \"{key}\" on line {line_no} in\n{fname}.\nYou probably need to get an updated matplotlibrc file from\nhttps://github.com/matplotlib/matplotlib/blob/{version}/matplotlibrc.template\nor from the matplotlib source distribution\"\"\", file=sys.stderr)\n    return config",
        "begin_line": 754,
        "end_line": 816,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__.rc_params_from_file#819",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.rc_params_from_file(fname, fail_on_error=False, use_default_template=True)",
        "snippet": "def rc_params_from_file(fname, fail_on_error=False, use_default_template=True):\n    \"\"\"\n    Construct a `RcParams` from file *fname*.\n\n    Parameters\n    ----------\n    fname : str or path-like\n        Name of file parsed for Matplotlib settings.\n    fail_on_error : bool\n        If True, raise an error when the parser fails to convert a parameter.\n    use_default_template : bool\n        If True, initialize with default parameters before updating with those\n        in the given file. If False, the configuration class only contains the\n        parameters specified in the file. (Useful for updating dicts.)\n    \"\"\"\n    config_from_file = _rc_params_in_file(fname, fail_on_error)\n\n    if not use_default_template:\n        return config_from_file\n\n    iter_params = defaultParams.items()\n    with cbook._suppress_matplotlib_deprecation_warning():\n        config = RcParams([(key, default) for key, (default, _) in iter_params\n                           if key not in _all_deprecated])\n    config.update(config_from_file)\n\n    if config['datapath'] is None:\n        config['datapath'] = get_data_path()\n\n    if \"\".join(config['text.latex.preamble']):\n        _log.info(\"\"\"\n*****************************************************************\nYou have the following UNSUPPORTED LaTeX preamble customizations:\n%s\nPlease do not ask for support with these customizations active.\n*****************************************************************\n\"\"\", '\\n'.join(config['text.latex.preamble']))\n    _log.debug('loaded rc file %s', fname)\n\n    return config",
        "begin_line": 819,
        "end_line": 858,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__.rc#875",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.rc(group, **kwargs)",
        "snippet": "def rc(group, **kwargs):\n    \"\"\"\n    Set the current `.rcParams`.  *group* is the grouping for the rc, e.g.,\n    for ``lines.linewidth`` the group is ``lines``, for\n    ``axes.facecolor``, the group is ``axes``, and so on.  Group may\n    also be a list or tuple of group names, e.g., (*xtick*, *ytick*).\n    *kwargs* is a dictionary attribute name/value pairs, e.g.,::\n\n      rc('lines', linewidth=2, color='r')\n\n    sets the current `.rcParams` and is equivalent to::\n\n      rcParams['lines.linewidth'] = 2\n      rcParams['lines.color'] = 'r'\n\n    The following aliases are available to save typing for interactive users:\n\n    =====   =================\n    Alias   Property\n    =====   =================\n    'lw'    'linewidth'\n    'ls'    'linestyle'\n    'c'     'color'\n    'fc'    'facecolor'\n    'ec'    'edgecolor'\n    'mew'   'markeredgewidth'\n    'aa'    'antialiased'\n    =====   =================\n\n    Thus you could abbreviate the above call as::\n\n          rc('lines', lw=2, c='r')\n\n    Note you can use python's kwargs dictionary facility to store\n    dictionaries of default parameters.  e.g., you can customize the\n    font rc as follows::\n\n      font = {'family' : 'monospace',\n              'weight' : 'bold',\n              'size'   : 'larger'}\n      rc('font', **font)  # pass in the font dict as kwargs\n\n    This enables you to easily switch between several configurations.  Use\n    ``matplotlib.style.use('default')`` or :func:`~matplotlib.rcdefaults` to\n    restore the default `.rcParams` after changes.\n\n    Notes\n    -----\n    Similar functionality is available by using the normal dict interface, i.e.\n    ``rcParams.update({\"lines.linewidth\": 2, ...})`` (but ``rcParams.update``\n    does not support abbreviations or grouping).\n    \"\"\"\n\n    aliases = {\n        'lw':  'linewidth',\n        'ls':  'linestyle',\n        'c':   'color',\n        'fc':  'facecolor',\n        'ec':  'edgecolor',\n        'mew': 'markeredgewidth',\n        'aa':  'antialiased',\n        }\n\n    if isinstance(group, str):\n        group = (group,)\n    for g in group:\n        for k, v in kwargs.items():\n            name = aliases.get(k) or k\n            key = '%s.%s' % (g, name)\n            try:\n                rcParams[key] = v\n            except KeyError as err:\n                raise KeyError(('Unrecognized key \"%s\" for group \"%s\" and '\n                                'name \"%s\"') % (key, g, name)) from err",
        "begin_line": 875,
        "end_line": 948,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__.rcdefaults#951",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.rcdefaults()",
        "snippet": "def rcdefaults():\n    \"\"\"\n    Restore the `.rcParams` from Matplotlib's internal default style.\n\n    Style-blacklisted `.rcParams` (defined in\n    `matplotlib.style.core.STYLE_BLACKLIST`) are not updated.\n\n    See Also\n    --------\n    matplotlib.rc_file_defaults\n        Restore the `.rcParams` from the rc file originally loaded by\n        Matplotlib.\n    matplotlib.style.use\n        Use a specific style file.  Call ``style.use('default')`` to restore\n        the default style.\n    \"\"\"\n    # Deprecation warnings were already handled when creating rcParamsDefault,\n    # no need to reemit them here.\n    with cbook._suppress_matplotlib_deprecation_warning():\n        from .style.core import STYLE_BLACKLIST\n        rcParams.clear()\n        rcParams.update({k: v for k, v in rcParamsDefault.items()\n                         if k not in STYLE_BLACKLIST})",
        "begin_line": 951,
        "end_line": 973,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00411522633744856,
            "pseudo_dstar_susp": 0.0038461538461538464,
            "pseudo_tarantula_susp": 0.0020491803278688526,
            "pseudo_op2_susp": 0.00392156862745098,
            "pseudo_barinel_susp": 0.0020491803278688526
        }
    },
    {
        "name": "lib.matplotlib.__init__.rc_file#991",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.rc_file(fname, *, use_default_template=True)",
        "snippet": "def rc_file(fname, *, use_default_template=True):\n    \"\"\"\n    Update `.rcParams` from file.\n\n    Style-blacklisted `.rcParams` (defined in\n    `matplotlib.style.core.STYLE_BLACKLIST`) are not updated.\n\n    Parameters\n    ----------\n    fname : str\n        Name of file parsed for matplotlib settings.\n\n    use_default_template : bool\n        If True, initialize with default parameters before updating with those\n        in the given file. If False, the current configuration persists\n        and only the parameters specified in the file are updated.\n    \"\"\"\n    # Deprecation warnings were already handled in rc_params_from_file, no need\n    # to reemit them here.\n    with cbook._suppress_matplotlib_deprecation_warning():\n        from .style.core import STYLE_BLACKLIST\n        rc_from_file = rc_params_from_file(\n            fname, use_default_template=use_default_template)\n        rcParams.update({k: rc_from_file[k] for k in rc_from_file\n                         if k not in STYLE_BLACKLIST})",
        "begin_line": 991,
        "end_line": 1015,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__.rc_context.__init__#1053",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.rc_context",
        "signature": "lib.matplotlib.__init__.rc_context.__init__(self, rc=None, fname=None)",
        "snippet": "    def __init__(self, rc=None, fname=None):\n        self._orig = rcParams.copy()\n        try:\n            if fname:\n                rc_file(fname)\n            if rc:\n                rcParams.update(rc)\n        except Exception:\n            self.__fallback()\n            raise",
        "begin_line": 1053,
        "end_line": 1062,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.014285714285714285,
            "pseudo_dstar_susp": 0.004273504273504274,
            "pseudo_tarantula_susp": 0.003236245954692557,
            "pseudo_op2_susp": 0.004291845493562232,
            "pseudo_barinel_susp": 0.003236245954692557
        }
    },
    {
        "name": "lib.matplotlib.__init__.rc_context.__fallback#1064",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.rc_context",
        "signature": "lib.matplotlib.__init__.rc_context.__fallback(self)",
        "snippet": "    def __fallback(self):\n        # If anything goes wrong, revert to the original rcs.\n        updated_backend = self._orig['backend']\n        dict.update(rcParams, self._orig)\n        # except for the backend.  If the context block triggered resolving\n        # the auto backend resolution keep that value around\n        if self._orig['backend'] is rcsetup._auto_backend_sentinel:\n            rcParams['backend'] = updated_backend",
        "begin_line": 1064,
        "end_line": 1071,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00819672131147541,
            "pseudo_dstar_susp": 0.0007304601899196494,
            "pseudo_tarantula_susp": 0.0025252525252525255,
            "pseudo_op2_susp": 0.0007304601899196494,
            "pseudo_barinel_susp": 0.0025252525252525255
        }
    },
    {
        "name": "lib.matplotlib.__init__.rc_context.__enter__#1073",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.rc_context",
        "signature": "lib.matplotlib.__init__.rc_context.__enter__(self)",
        "snippet": "    def __enter__(self):\n        return self",
        "begin_line": 1073,
        "end_line": 1074,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006756756756756757,
            "pseudo_dstar_susp": 0.0007304601899196494,
            "pseudo_tarantula_susp": 0.0022935779816513763,
            "pseudo_op2_susp": 0.0007304601899196494,
            "pseudo_barinel_susp": 0.0022935779816513763
        }
    },
    {
        "name": "lib.matplotlib.__init__.rc_context.__exit__#1076",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__.rc_context",
        "signature": "lib.matplotlib.__init__.rc_context.__exit__(self, exc_type, exc_value, exc_tb)",
        "snippet": "    def __exit__(self, exc_type, exc_value, exc_tb):\n        self.__fallback()",
        "begin_line": 1076,
        "end_line": 1077,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006756756756756757,
            "pseudo_dstar_susp": 0.0007304601899196494,
            "pseudo_tarantula_susp": 0.0022935779816513763,
            "pseudo_op2_susp": 0.0007304601899196494,
            "pseudo_barinel_susp": 0.0022935779816513763
        }
    },
    {
        "name": "lib.matplotlib.__init__.use#1080",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.use(backend, *, force=True)",
        "snippet": "def use(backend, *, force=True):\n    \"\"\"\n    Select the backend used for rendering and GUI integration.\n\n    Parameters\n    ----------\n    backend : str\n        The backend to switch to.  This can either be one of the standard\n        backend names, which are case-insensitive:\n\n        - interactive backends:\n          GTK3Agg, GTK3Cairo, MacOSX, nbAgg,\n          Qt4Agg, Qt4Cairo, Qt5Agg, Qt5Cairo,\n          TkAgg, TkCairo, WebAgg, WX, WXAgg, WXCairo\n\n        - non-interactive backends:\n          agg, cairo, pdf, pgf, ps, svg, template\n\n        or a string of the form: ``module://my.module.name``.\n\n    force : bool, default: True\n        If True (the default), raise an `ImportError` if the backend cannot be\n        set up (either because it fails to import, or because an incompatible\n        GUI interactive framework is already running); if False, ignore the\n        failure.\n\n    See Also\n    --------\n    :ref:`backends`\n    matplotlib.get_backend\n    \"\"\"\n    name = validate_backend(backend)\n    if dict.__getitem__(rcParams, 'backend') == name:\n        # Nothing to do if the requested backend is already set\n        pass\n    else:\n        try:\n            from matplotlib import pyplot as plt\n            plt.switch_backend(name)\n        except ImportError:\n            if force:\n                raise",
        "begin_line": 1080,
        "end_line": 1121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.014285714285714285,
            "pseudo_dstar_susp": 0.0036101083032490976,
            "pseudo_tarantula_susp": 0.003236245954692557,
            "pseudo_op2_susp": 0.003676470588235294,
            "pseudo_barinel_susp": 0.003236245954692557
        }
    },
    {
        "name": "lib.matplotlib.__init__.get_backend#1128",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.get_backend()",
        "snippet": "def get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    return rcParams['backend']",
        "begin_line": 1128,
        "end_line": 1136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003728560775540641,
            "pseudo_dstar_susp": 0.0003450655624568668,
            "pseudo_tarantula_susp": 0.0007027406886858749,
            "pseudo_op2_susp": 0.0003450655624568668,
            "pseudo_barinel_susp": 0.0007027406886858749
        }
    },
    {
        "name": "lib.matplotlib.__init__.is_interactive#1146",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.is_interactive()",
        "snippet": "def is_interactive():\n    \"\"\"Return whether to redraw after every plotting command.\"\"\"\n    return rcParams['interactive']",
        "begin_line": 1146,
        "end_line": 1148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006016847172081829,
            "pseudo_dstar_susp": 0.0007861635220125787,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0007861635220125787,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.__init__._replacer#1234",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__._replacer(data, value)",
        "snippet": "def _replacer(data, value):\n    \"\"\"\n    Either returns ``data[value]`` or passes ``data`` back, converts either to\n    a sequence.\n    \"\"\"\n    try:\n        # if key isn't a string don't bother\n        if isinstance(value, str):\n            # try to use __getitem__\n            value = data[value]\n    except Exception:\n        # key does not exist, silently fall back to key\n        pass\n    return sanitize_sequence(value)",
        "begin_line": 1234,
        "end_line": 1247,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__._label_from_arg#1250",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__._label_from_arg(y, default_name)",
        "snippet": "def _label_from_arg(y, default_name):\n    try:\n        return y.name\n    except AttributeError:\n        if isinstance(default_name, str):\n            return default_name\n    return None",
        "begin_line": 1250,
        "end_line": 1256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004752851711026616,
            "pseudo_dstar_susp": 0.00040241448692152917,
            "pseudo_tarantula_susp": 0.0017482517482517483,
            "pseudo_op2_susp": 0.00040241448692152917,
            "pseudo_barinel_susp": 0.0017482517482517483
        }
    },
    {
        "name": "lib.matplotlib.__init__._add_data_doc#1277",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__._add_data_doc(docstring, replace_names)",
        "snippet": "def _add_data_doc(docstring, replace_names):\n    \"\"\"Add documentation for a *data* field to the given docstring.\n\n    Parameters\n    ----------\n    docstring : str\n        The input docstring.\n    replace_names : list of str or None\n        The list of parameter names which arguments should be replaced by\n        ``data[name]`` (if ``data[name]`` does not throw an exception).  If\n        None, replacement is attempted for all arguments.\n\n    Returns\n    -------\n        The augmented docstring.\n    \"\"\"\n    if (docstring is None\n            or replace_names is not None and len(replace_names) == 0):\n        return docstring\n    docstring = inspect.cleandoc(docstring)\n    repl = (\n        (\"    every other argument can also be string ``s``, which is\\n\"\n         \"    interpreted as ``data[s]`` (unless this raises an exception).\")\n        if replace_names is None else\n        (\"    the following arguments can also be string ``s``, which is\\n\"\n         \"    interpreted as ``data[s]`` (unless this raises an exception):\\n\"\n         \"    \" + \", \".join(map(\"*{}*\".format, replace_names))) + \".\")\n    addendum = _DATA_DOC_APPENDIX.format(replaced=repl)\n    if _DATA_DOC_TITLE not in docstring:\n        addendum = _DATA_DOC_TITLE + addendum\n    return docstring + addendum",
        "begin_line": 1277,
        "end_line": 1307,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.__init__._preprocess_data#1310",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__._preprocess_data(func=None, *, replace_names=None, label_namer=None)",
        "snippet": "def _preprocess_data(func=None, *, replace_names=None, label_namer=None):\n    \"\"\"\n    A decorator to add a 'data' kwarg to a function.\n\n    When applied::\n\n        @_preprocess_data()\n        def func(ax, *args, **kwargs): ...\n\n    the signature is modified to ``decorated(ax, *args, data=None, **kwargs)``\n    with the following behavior:\n\n    - if called with ``data=None``, forward the other arguments to ``func``;\n    - otherwise, *data* must be a mapping; for any argument passed in as a\n      string ``name``, replace the argument by ``data[name]`` (if this does not\n      throw an exception), then forward the arguments to ``func``.\n\n    In either case, any argument that is a `MappingView` is also converted to a\n    list.\n\n    Parameters\n    ----------\n    replace_names : list of str or None, default: None\n        The list of parameter names for which lookup into *data* should be\n        attempted. If None, replacement is attempted for all arguments.\n    label_namer : str, default: None\n        If set e.g. to \"namer\" (which must be a kwarg in the function's\n        signature -- not as ``**kwargs``), if the *namer* argument passed in is\n        a (string) key of *data* and no *label* kwarg is passed, then use the\n        (string) value of the *namer* as *label*. ::\n\n            @_preprocess_data(label_namer=\"foo\")\n            def func(foo, label=None): ...\n\n            func(\"key\", data={\"key\": value})\n            # is equivalent to\n            func.__wrapped__(value, label=\"key\")\n    \"\"\"\n\n    if func is None:  # Return the actual decorator.\n        return functools.partial(\n            _preprocess_data,\n            replace_names=replace_names, label_namer=label_namer)\n\n    sig = inspect.signature(func)\n    varargs_name = None\n    varkwargs_name = None\n    arg_names = []\n    params = list(sig.parameters.values())\n    for p in params:\n        if p.kind is Parameter.VAR_POSITIONAL:\n            varargs_name = p.name\n        elif p.kind is Parameter.VAR_KEYWORD:\n            varkwargs_name = p.name\n        else:\n            arg_names.append(p.name)\n    data_param = Parameter(\"data\", Parameter.KEYWORD_ONLY, default=None)\n    if varkwargs_name:\n        params.insert(-1, data_param)\n    else:\n        params.append(data_param)\n    new_sig = sig.replace(parameters=params)\n    arg_names = arg_names[1:]  # remove the first \"ax\" / self arg\n\n    assert {*arg_names}.issuperset(replace_names or []) or varkwargs_name, (\n        \"Matplotlib internal error: invalid replace_names ({!r}) for {!r}\"\n        .format(replace_names, func.__name__))\n    assert label_namer is None or label_namer in arg_names, (\n        \"Matplotlib internal error: invalid label_namer ({!r}) for {!r}\"\n        .format(label_namer, func.__name__))\n\n    @functools.wraps(func)\n    def inner(ax, *args, data=None, **kwargs):\n        if data is None:\n            return func(ax, *map(sanitize_sequence, args), **kwargs)\n\n        bound = new_sig.bind(ax, *args, **kwargs)\n        auto_label = (bound.arguments.get(label_namer)\n                      or bound.kwargs.get(label_namer))\n\n        for k, v in bound.arguments.items():\n            if k == varkwargs_name:\n                for k1, v1 in v.items():\n                    if replace_names is None or k1 in replace_names:\n                        v[k1] = _replacer(data, v1)\n            elif k == varargs_name:\n                if replace_names is None:\n                    bound.arguments[k] = tuple(_replacer(data, v1) for v1 in v)\n            else:\n                if replace_names is None or k in replace_names:\n                    bound.arguments[k] = _replacer(data, v)\n\n        new_args = bound.args\n        new_kwargs = bound.kwargs\n\n        args_and_kwargs = {**bound.arguments, **bound.kwargs}\n        if label_namer and \"label\" not in args_and_kwargs:\n            new_kwargs[\"label\"] = _label_from_arg(\n                args_and_kwargs.get(label_namer), auto_label)\n\n        return func(*new_args, **new_kwargs)\n\n    inner.__doc__ = _add_data_doc(inner.__doc__, replace_names)\n    inner.__signature__ = new_sig\n    return inner",
        "begin_line": 1310,
        "end_line": 1414,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004464285714285714,
            "pseudo_dstar_susp": 0.000390015600624025,
            "pseudo_tarantula_susp": 0.0014858841010401188,
            "pseudo_op2_susp": 0.000390015600624025,
            "pseudo_barinel_susp": 0.001483679525222552
        }
    },
    {
        "name": "lib.matplotlib.__init__.inner#1382",
        "src_path": "lib/matplotlib/__init__.py",
        "class_name": "lib.matplotlib.__init__",
        "signature": "lib.matplotlib.__init__.inner(ax, *args, data=None, **kwargs)",
        "snippet": "    def inner(ax, *args, data=None, **kwargs):\n        if data is None:\n            return func(ax, *map(sanitize_sequence, args), **kwargs)\n\n        bound = new_sig.bind(ax, *args, **kwargs)\n        auto_label = (bound.arguments.get(label_namer)\n                      or bound.kwargs.get(label_namer))\n\n        for k, v in bound.arguments.items():\n            if k == varkwargs_name:\n                for k1, v1 in v.items():\n                    if replace_names is None or k1 in replace_names:\n                        v[k1] = _replacer(data, v1)\n            elif k == varargs_name:\n                if replace_names is None:\n                    bound.arguments[k] = tuple(_replacer(data, v1) for v1 in v)\n            else:\n                if replace_names is None or k in replace_names:\n                    bound.arguments[k] = _replacer(data, v)\n\n        new_args = bound.args\n        new_kwargs = bound.kwargs\n\n        args_and_kwargs = {**bound.arguments, **bound.kwargs}\n        if label_namer and \"label\" not in args_and_kwargs:\n            new_kwargs[\"label\"] = _label_from_arg(\n                args_and_kwargs.get(label_namer), auto_label)\n\n        return func(*new_args, **new_kwargs)",
        "begin_line": 1382,
        "end_line": 1410,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mlab.window_none#76",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.window_none(x)",
        "snippet": "def window_none(x):\n    \"\"\"\n    No window function; simply return x.\n\n    See Also\n    --------\n    window_hanning : Another window algorithm.\n    \"\"\"\n    return x",
        "begin_line": 76,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.693491306354824e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mlab.apply_window#88",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.apply_window(x, window, axis=0, return_window=None)",
        "snippet": "def apply_window(x, window, axis=0, return_window=None):\n    \"\"\"\n    Apply the given window to the given 1D or 2D array along the given axis.\n\n    Parameters\n    ----------\n    x : 1D or 2D array or sequence\n        Array or sequence containing the data.\n\n    window : function or array.\n        Either a function to generate a window or an array with length\n        *x*.shape[*axis*]\n\n    axis : int\n        The axis over which to do the repetition.\n        Must be 0 or 1.  The default is 0\n\n    return_window : bool\n        If true, also return the 1D values of the window that was applied\n    \"\"\"\n    x = np.asarray(x)\n\n    if x.ndim < 1 or x.ndim > 2:\n        raise ValueError('only 1D or 2D arrays can be used')\n    if axis+1 > x.ndim:\n        raise ValueError('axis(=%s) out of bounds' % axis)\n\n    xshape = list(x.shape)\n    xshapetarg = xshape.pop(axis)\n\n    if np.iterable(window):\n        if len(window) != xshapetarg:\n            raise ValueError('The len(window) must be the same as the shape '\n                             'of x for the chosen axis')\n        windowVals = window\n    else:\n        windowVals = window(np.ones(xshapetarg, dtype=x.dtype))\n\n    if x.ndim == 1:\n        if return_window:\n            return windowVals * x, windowVals\n        else:\n            return windowVals * x\n\n    xshapeother = xshape.pop()\n\n    otheraxis = (axis+1) % 2\n\n    windowValsRep = stride_repeat(windowVals, xshapeother, axis=otheraxis)\n\n    if return_window:\n        return windowValsRep * x, windowVals\n    else:\n        return windowValsRep * x",
        "begin_line": 88,
        "end_line": 141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.714396735962697e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mlab.detrend#144",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.detrend(x, key=None, axis=None)",
        "snippet": "def detrend(x, key=None, axis=None):\n    \"\"\"\n    Return x with its trend removed.\n\n    Parameters\n    ----------\n    x : array or sequence\n        Array or sequence containing the data.\n\n    key : {'default', 'constant', 'mean', 'linear', 'none'} or function\n        The detrending algorithm to use. 'default', 'mean', and 'constant' are\n        the same as `detrend_mean`. 'linear' is the same as `detrend_linear`.\n        'none' is the same as `detrend_none`. The default is 'mean'. See the\n        corresponding functions for more details regarding the algorithms. Can\n        also be a function that carries out the detrend operation.\n\n    axis : int\n        The axis along which to do the detrending.\n\n    See Also\n    --------\n    detrend_mean : Implementation of the 'mean' algorithm.\n    detrend_linear : Implementation of the 'linear' algorithm.\n    detrend_none : Implementation of the 'none' algorithm.\n    \"\"\"\n    if key is None or key in ['constant', 'mean', 'default']:\n        return detrend(x, key=detrend_mean, axis=axis)\n    elif key == 'linear':\n        return detrend(x, key=detrend_linear, axis=axis)\n    elif key == 'none':\n        return detrend(x, key=detrend_none, axis=axis)\n    elif callable(key):\n        x = np.asarray(x)\n        if axis is not None and axis + 1 > x.ndim:\n            raise ValueError(f'axis(={axis}) out of bounds')\n        if (axis is None and x.ndim == 0) or (not axis and x.ndim == 1):\n            return key(x)\n        # try to use the 'axis' argument if the function supports it,\n        # otherwise use apply_along_axis to do it\n        try:\n            return key(x, axis=axis)\n        except TypeError:\n            return np.apply_along_axis(key, axis=axis, arr=x)\n    else:\n        raise ValueError(\n            f\"Unknown value for key: {key!r}, must be one of: 'default', \"\n            f\"'constant', 'mean', 'linear', or a function\")",
        "begin_line": 144,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.679901697258276e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mlab.detrend_mean#193",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.detrend_mean(x, axis=None)",
        "snippet": "def detrend_mean(x, axis=None):\n    \"\"\"\n    Return x minus the mean(x).\n\n    Parameters\n    ----------\n    x : array or sequence\n        Array or sequence containing the data\n        Can have any dimensionality\n\n    axis : int\n        The axis along which to take the mean.  See numpy.mean for a\n        description of this argument.\n\n    See Also\n    --------\n    detrend_linear : Another detrend algorithm.\n    detrend_none : Another detrend algorithm.\n    detrend : A wrapper around all the detrend algorithms.\n    \"\"\"\n    x = np.asarray(x)\n\n    if axis is not None and axis+1 > x.ndim:\n        raise ValueError('axis(=%s) out of bounds' % axis)\n\n    return x - x.mean(axis, keepdims=True)",
        "begin_line": 193,
        "end_line": 218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.716644802839726e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mlab.stride_windows#281",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.stride_windows(x, n, noverlap=None, axis=0)",
        "snippet": "def stride_windows(x, n, noverlap=None, axis=0):\n    \"\"\"\n    Get all windows of x with length n as a single array,\n    using strides to avoid data duplication.\n\n    .. warning::\n\n        It is not safe to write to the output array.  Multiple\n        elements may point to the same piece of memory,\n        so modifying one value may change others.\n\n    Parameters\n    ----------\n    x : 1D array or sequence\n        Array or sequence containing the data.\n\n    n : int\n        The number of data points in each window.\n\n    noverlap : int\n        The overlap between adjacent windows.\n        Default is 0 (no overlap)\n\n    axis : int\n        The axis along which the windows will run.\n\n    References\n    ----------\n    `stackoverflow: Rolling window for 1D arrays in Numpy?\n    <http://stackoverflow.com/a/6811241>`_\n    `stackoverflow: Using strides for an efficient moving average filter\n    <http://stackoverflow.com/a/4947453>`_\n    \"\"\"\n    if noverlap is None:\n        noverlap = 0\n\n    if noverlap >= n:\n        raise ValueError('noverlap must be less than n')\n    if n < 1:\n        raise ValueError('n cannot be less than 1')\n\n    x = np.asarray(x)\n\n    if x.ndim != 1:\n        raise ValueError('only 1-dimensional arrays can be used')\n    if n == 1 and noverlap == 0:\n        if axis == 0:\n            return x[np.newaxis]\n        else:\n            return x[np.newaxis].transpose()\n    if n > x.size:\n        raise ValueError('n cannot be greater than the length of x')\n\n    # np.lib.stride_tricks.as_strided easily leads to memory corruption for\n    # non integer shape and strides, i.e. noverlap or n. See #3845.\n    noverlap = int(noverlap)\n    n = int(n)\n\n    step = n - noverlap\n    if axis == 0:\n        shape = (n, (x.shape[-1]-noverlap)//step)\n        strides = (x.strides[0], step*x.strides[0])\n    else:\n        shape = ((x.shape[-1]-noverlap)//step, n)\n        strides = (step*x.strides[0], x.strides[0])\n    return np.lib.stride_tricks.as_strided(x, shape=shape, strides=strides)",
        "begin_line": 281,
        "end_line": 346,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mlab.stride_repeat#350",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.stride_repeat(x, n, axis=0)",
        "snippet": "def stride_repeat(x, n, axis=0):\n    \"\"\"\n    Repeat the values in an array in a memory-efficient manner.  Array x is\n    stacked vertically n times.\n\n    .. warning::\n\n        It is not safe to write to the output array.  Multiple\n        elements may point to the same piece of memory, so\n        modifying one value may change others.\n\n    Parameters\n    ----------\n    x : 1D array or sequence\n        Array or sequence containing the data.\n\n    n : int\n        The number of time to repeat the array.\n\n    axis : int\n        The axis along which the data will run.\n\n    References\n    ----------\n    `stackoverflow: Repeat NumPy array without replicating data?\n    <http://stackoverflow.com/a/5568169>`_\n    \"\"\"\n    if axis not in [0, 1]:\n        raise ValueError('axis must be 0 or 1')\n    x = np.asarray(x)\n    if x.ndim != 1:\n        raise ValueError('only 1-dimensional arrays can be used')\n\n    if n == 1:\n        if axis == 0:\n            return np.atleast_2d(x)\n        else:\n            return np.atleast_2d(x).T\n    if n < 1:\n        raise ValueError('n cannot be less than 1')\n\n    # np.lib.stride_tricks.as_strided easily leads to memory corruption for\n    # non integer shape and strides, i.e. n. See #3845.\n    n = int(n)\n\n    if axis == 0:\n        shape = (n, x.size)\n        strides = (0, x.strides[0])\n    else:\n        shape = (x.size, n)\n        strides = (x.strides[0], 0)\n\n    return np.lib.stride_tricks.as_strided(x, shape=shape, strides=strides)",
        "begin_line": 350,
        "end_line": 402,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mlab._spectral_helper#405",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab._spectral_helper(x, y=None, NFFT=None, Fs=None, detrend_func=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None, mode=None)",
        "snippet": "def _spectral_helper(x, y=None, NFFT=None, Fs=None, detrend_func=None,\n                     window=None, noverlap=None, pad_to=None,\n                     sides=None, scale_by_freq=None, mode=None):\n    \"\"\"\n    This is a helper function that implements the commonality between the\n    psd, csd, spectrogram and complex, magnitude, angle, and phase spectrums.\n    It is *NOT* meant to be used outside of mlab and may change at any time.\n    \"\"\"\n    if y is None:\n        # if y is None use x for y\n        same_data = True\n    else:\n        # The checks for if y is x are so that we can use the same function to\n        # implement the core of psd(), csd(), and spectrogram() without doing\n        # extra calculations.  We return the unaveraged Pxy, freqs, and t.\n        same_data = y is x\n\n    if Fs is None:\n        Fs = 2\n    if noverlap is None:\n        noverlap = 0\n    if detrend_func is None:\n        detrend_func = detrend_none\n    if window is None:\n        window = window_hanning\n\n    # if NFFT is set to None use the whole signal\n    if NFFT is None:\n        NFFT = 256\n\n    if mode is None or mode == 'default':\n        mode = 'psd'\n    cbook._check_in_list(\n        ['default', 'psd', 'complex', 'magnitude', 'angle', 'phase'],\n        mode=mode)\n\n    if not same_data and mode != 'psd':\n        raise ValueError(\"x and y must be equal if mode is not 'psd'\")\n\n    # Make sure we're dealing with a numpy array. If y and x were the same\n    # object to start with, keep them that way\n    x = np.asarray(x)\n    if not same_data:\n        y = np.asarray(y)\n\n    if sides is None or sides == 'default':\n        if np.iscomplexobj(x):\n            sides = 'twosided'\n        else:\n            sides = 'onesided'\n    cbook._check_in_list(['default', 'onesided', 'twosided'], sides=sides)\n\n    # zero pad x and y up to NFFT if they are shorter than NFFT\n    if len(x) < NFFT:\n        n = len(x)\n        x = np.resize(x, NFFT)\n        x[n:] = 0\n\n    if not same_data and len(y) < NFFT:\n        n = len(y)\n        y = np.resize(y, NFFT)\n        y[n:] = 0\n\n    if pad_to is None:\n        pad_to = NFFT\n\n    if mode != 'psd':\n        scale_by_freq = False\n    elif scale_by_freq is None:\n        scale_by_freq = True\n\n    # For real x, ignore the negative frequencies unless told otherwise\n    if sides == 'twosided':\n        numFreqs = pad_to\n        if pad_to % 2:\n            freqcenter = (pad_to - 1)//2 + 1\n        else:\n            freqcenter = pad_to//2\n        scaling_factor = 1.\n    elif sides == 'onesided':\n        if pad_to % 2:\n            numFreqs = (pad_to + 1)//2\n        else:\n            numFreqs = pad_to//2 + 1\n        scaling_factor = 2.\n\n    if not np.iterable(window):\n        window = window(np.ones(NFFT, x.dtype))\n    if len(window) != NFFT:\n        raise ValueError(\n            \"The window length must match the data's first dimension\")\n\n    result = stride_windows(x, NFFT, noverlap, axis=0)\n    result = detrend(result, detrend_func, axis=0)\n    result = result * window.reshape((-1, 1))\n    result = np.fft.fft(result, n=pad_to, axis=0)[:numFreqs, :]\n    freqs = np.fft.fftfreq(pad_to, 1/Fs)[:numFreqs]\n\n    if not same_data:\n        # if same_data is False, mode must be 'psd'\n        resultY = stride_windows(y, NFFT, noverlap)\n        resultY = detrend(resultY, detrend_func, axis=0)\n        resultY = resultY * window.reshape((-1, 1))\n        resultY = np.fft.fft(resultY, n=pad_to, axis=0)[:numFreqs, :]\n        result = np.conj(result) * resultY\n    elif mode == 'psd':\n        result = np.conj(result) * result\n    elif mode == 'magnitude':\n        result = np.abs(result) / np.abs(window).sum()\n    elif mode == 'angle' or mode == 'phase':\n        # we unwrap the phase later to handle the onesided vs. twosided case\n        result = np.angle(result)\n    elif mode == 'complex':\n        result /= np.abs(window).sum()\n\n    if mode == 'psd':\n\n        # Also include scaling factors for one-sided densities and dividing by\n        # the sampling frequency, if desired. Scale everything, except the DC\n        # component and the NFFT/2 component:\n\n        # if we have a even number of frequencies, don't scale NFFT/2\n        if not NFFT % 2:\n            slc = slice(1, -1, None)\n        # if we have an odd number, just don't scale DC\n        else:\n            slc = slice(1, None, None)\n\n        result[slc] *= scaling_factor\n\n        # MATLAB divides by the sampling frequency so that density function\n        # has units of dB/Hz and can be integrated by the plotted frequency\n        # values. Perform the same scaling here.\n        if scale_by_freq:\n            result /= Fs\n            # Scale the spectrum by the norm of the window to compensate for\n            # windowing loss; see Bendat & Piersol Sec 11.5.2.\n            result /= (np.abs(window)**2).sum()\n        else:\n            # In this case, preserve power in the segment, not amplitude\n            result /= np.abs(window).sum()**2\n\n    t = np.arange(NFFT/2, len(x) - NFFT/2 + 1, NFFT - noverlap)/Fs\n\n    if sides == 'twosided':\n        # center the frequency range at zero\n        freqs = np.concatenate((freqs[freqcenter:], freqs[:freqcenter]))\n        result = np.concatenate((result[freqcenter:, :],\n                                 result[:freqcenter, :]), 0)\n    elif not pad_to % 2:\n        # get the last value correctly, it is negative otherwise\n        freqs[-1] *= -1\n\n    # we unwrap the phase here to handle the onesided vs. twosided case\n    if mode == 'phase':\n        result = np.unwrap(result, axis=0)\n\n    return result, freqs, t",
        "begin_line": 405,
        "end_line": 562,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mlab._single_spectrum_helper#565",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab._single_spectrum_helper(mode, x, Fs=None, window=None, pad_to=None, sides=None)",
        "snippet": "def _single_spectrum_helper(\n        mode, x, Fs=None, window=None, pad_to=None, sides=None):\n    \"\"\"\n    This is a helper function that implements the commonality between the\n    complex, magnitude, angle, and phase spectrums.\n    It is *NOT* meant to be used outside of mlab and may change at any time.\n    \"\"\"\n    cbook._check_in_list(['complex', 'magnitude', 'angle', 'phase'], mode=mode)\n\n    if pad_to is None:\n        pad_to = len(x)\n\n    spec, freqs, _ = _spectral_helper(x=x, y=None, NFFT=len(x), Fs=Fs,\n                                      detrend_func=detrend_none, window=window,\n                                      noverlap=0, pad_to=pad_to,\n                                      sides=sides,\n                                      scale_by_freq=False,\n                                      mode=mode)\n    if mode != 'complex':\n        spec = spec.real\n\n    if spec.ndim == 2 and spec.shape[1] == 1:\n        spec = spec[:, 0]\n\n    return spec, freqs",
        "begin_line": 565,
        "end_line": 589,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mlab.csd#709",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.csd(x, y, NFFT=None, Fs=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None)",
        "snippet": "def csd(x, y, NFFT=None, Fs=None, detrend=None, window=None,\n        noverlap=None, pad_to=None, sides=None, scale_by_freq=None):\n    \"\"\"\n    Compute the cross-spectral density.\n\n    The cross spectral density :math:`P_{xy}` by Welch's average\n    periodogram method.  The vectors *x* and *y* are divided into\n    *NFFT* length segments.  Each segment is detrended by function\n    *detrend* and windowed by function *window*.  *noverlap* gives\n    the length of the overlap between segments.  The product of\n    the direct FFTs of *x* and *y* are averaged over each segment\n    to compute :math:`P_{xy}`, with a scaling to correct for power\n    loss due to windowing.\n\n    If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero\n    padded to *NFFT*.\n\n    Parameters\n    ----------\n    x, y : 1-D arrays or sequences\n        Arrays or sequences containing the data\n\n    %(Spectral)s\n\n    %(PSD)s\n\n    noverlap : int\n        The number of points of overlap between segments.\n        The default value is 0 (no overlap).\n\n    Returns\n    -------\n    Pxy : 1-D array\n        The values for the cross spectrum :math:`P_{xy}` before scaling (real\n        valued)\n\n    freqs : 1-D array\n        The frequencies corresponding to the elements in *Pxy*\n\n    References\n    ----------\n    Bendat & Piersol -- Random Data: Analysis and Measurement Procedures, John\n    Wiley & Sons (1986)\n\n    See Also\n    --------\n    psd : equivalent to setting ``y = x``.\n    \"\"\"\n    if NFFT is None:\n        NFFT = 256\n    Pxy, freqs, _ = _spectral_helper(x=x, y=y, NFFT=NFFT, Fs=Fs,\n                                     detrend_func=detrend, window=window,\n                                     noverlap=noverlap, pad_to=pad_to,\n                                     sides=sides, scale_by_freq=scale_by_freq,\n                                     mode='psd')\n\n    if Pxy.ndim == 2:\n        if Pxy.shape[1] > 1:\n            Pxy = Pxy.mean(axis=1)\n        else:\n            Pxy = Pxy[:, 0]\n    return Pxy, freqs",
        "begin_line": 709,
        "end_line": 770,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.422251911229867e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mlab.specgram#830",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab",
        "signature": "lib.matplotlib.mlab.specgram(x, NFFT=None, Fs=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None, mode=None)",
        "snippet": "def specgram(x, NFFT=None, Fs=None, detrend=None, window=None,\n             noverlap=None, pad_to=None, sides=None, scale_by_freq=None,\n             mode=None):\n    \"\"\"\n    Compute a spectrogram.\n\n    Compute and plot a spectrogram of data in x.  Data are split into\n    NFFT length segments and the spectrum of each section is\n    computed.  The windowing function window is applied to each\n    segment, and the amount of overlap of each segment is\n    specified with noverlap.\n\n    Parameters\n    ----------\n    x : array-like\n        1-D array or sequence.\n\n    %(Spectral)s\n\n    %(PSD)s\n\n    noverlap : int, optional\n        The number of points of overlap between blocks.  The default\n        value is 128.\n    mode : str, optional, default: 'psd'\n        What sort of spectrum to use:\n            'psd'\n                Returns the power spectral density.\n            'complex'\n                Returns the complex-valued frequency spectrum.\n            'magnitude'\n                Returns the magnitude spectrum.\n            'angle'\n                Returns the phase spectrum without unwrapping.\n            'phase'\n                Returns the phase spectrum with unwrapping.\n\n    Returns\n    -------\n    spectrum : array-like\n        2-D array, columns are the periodograms of successive segments.\n\n    freqs : array-like\n        1-D array, frequencies corresponding to the rows in *spectrum*.\n\n    t : array-like\n        1-D array, the times corresponding to midpoints of segments\n        (i.e the columns in *spectrum*).\n\n    See Also\n    --------\n    psd : differs in the overlap and in the return values.\n    complex_spectrum : similar, but with complex valued frequencies.\n    magnitude_spectrum : similar single segment when mode is 'magnitude'.\n    angle_spectrum : similar to single segment when mode is 'angle'.\n    phase_spectrum : similar to single segment when mode is 'phase'.\n\n    Notes\n    -----\n    detrend and scale_by_freq only apply when *mode* is set to 'psd'.\n\n    \"\"\"\n    if noverlap is None:\n        noverlap = 128  # default in _spectral_helper() is noverlap = 0\n    if NFFT is None:\n        NFFT = 256  # same default as in _spectral_helper()\n    if len(x) <= NFFT:\n        cbook._warn_external(\"Only one segment is calculated since parameter \"\n                             \"NFFT (=%d) >= signal length (=%d).\" %\n                             (NFFT, len(x)))\n\n    spec, freqs, t = _spectral_helper(x=x, y=None, NFFT=NFFT, Fs=Fs,\n                                      detrend_func=detrend, window=window,\n                                      noverlap=noverlap, pad_to=pad_to,\n                                      sides=sides,\n                                      scale_by_freq=scale_by_freq,\n                                      mode=mode)\n\n    if mode != 'complex':\n        spec = spec.real  # Needed since helper implements generically\n\n    return spec, freqs, t",
        "begin_line": 830,
        "end_line": 911,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.056719303899453e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mlab.GaussianKDE.__init__#1017",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab.GaussianKDE",
        "signature": "lib.matplotlib.mlab.GaussianKDE.__init__(self, dataset, bw_method=None)",
        "snippet": "    def __init__(self, dataset, bw_method=None):\n        self.dataset = np.atleast_2d(dataset)\n        if not np.array(self.dataset).size > 1:\n            raise ValueError(\"`dataset` input should have multiple elements.\")\n\n        self.dim, self.num_dp = np.array(self.dataset).shape\n\n        if bw_method is None:\n            pass\n        elif cbook._str_equal(bw_method, 'scott'):\n            self.covariance_factor = self.scotts_factor\n        elif cbook._str_equal(bw_method, 'silverman'):\n            self.covariance_factor = self.silverman_factor\n        elif isinstance(bw_method, Number):\n            self._bw_method = 'use constant'\n            self.covariance_factor = lambda: bw_method\n        elif callable(bw_method):\n            self._bw_method = bw_method\n            self.covariance_factor = lambda: self._bw_method(self)\n        else:\n            raise ValueError(\"`bw_method` should be 'scott', 'silverman', a \"\n                             \"scalar or a callable\")\n\n        # Computes the covariance matrix for each Gaussian kernel using\n        # covariance_factor().\n\n        self.factor = self.covariance_factor()\n        # Cache covariance and inverse covariance of the data\n        if not hasattr(self, '_data_inv_cov'):\n            self.data_covariance = np.atleast_2d(\n                np.cov(\n                    self.dataset,\n                    rowvar=1,\n                    bias=False))\n            self.data_inv_cov = np.linalg.inv(self.data_covariance)\n\n        self.covariance = self.data_covariance * self.factor ** 2\n        self.inv_cov = self.data_inv_cov / self.factor ** 2\n        self.norm_factor = (np.sqrt(np.linalg.det(2 * np.pi * self.covariance))\n                            * self.num_dp)",
        "begin_line": 1017,
        "end_line": 1056,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mlab.GaussianKDE.silverman_factor#1061",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab.GaussianKDE",
        "signature": "lib.matplotlib.mlab.GaussianKDE.silverman_factor(self)",
        "snippet": "    def silverman_factor(self):\n        return np.power(\n            self.num_dp * (self.dim + 2.0) / 4.0, -1. / (self.dim + 4))",
        "begin_line": 1061,
        "end_line": 1063,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.mlab.GaussianKDE.evaluate#1068",
        "src_path": "lib/matplotlib/mlab.py",
        "class_name": "lib.matplotlib.mlab.GaussianKDE",
        "signature": "lib.matplotlib.mlab.GaussianKDE.evaluate(self, points)",
        "snippet": "    def evaluate(self, points):\n        \"\"\"Evaluate the estimated pdf on a set of points.\n\n        Parameters\n        ----------\n        points : (# of dimensions, # of points)-array\n            Alternatively, a (# of dimensions,) vector can be passed in and\n            treated as a single point.\n\n        Returns\n        -------\n        values : (# of points,)-array\n            The values at each point.\n\n        Raises\n        ------\n        ValueError : if the dimensionality of the input points is different\n                     than the dimensionality of the KDE.\n\n        \"\"\"\n        points = np.atleast_2d(points)\n\n        dim, num_m = np.array(points).shape\n        if dim != self.dim:\n            raise ValueError(\"points have dimension {}, dataset has dimension \"\n                             \"{}\".format(dim, self.dim))\n\n        result = np.zeros(num_m)\n\n        if num_m >= self.num_dp:\n            # there are more points than data, so loop over data\n            for i in range(self.num_dp):\n                diff = self.dataset[:, i, np.newaxis] - points\n                tdiff = np.dot(self.inv_cov, diff)\n                energy = np.sum(diff * tdiff, axis=0) / 2.0\n                result = result + np.exp(-energy)\n        else:\n            # loop over points\n            for i in range(num_m):\n                diff = self.dataset - points[:, i, np.newaxis]\n                tdiff = np.dot(self.inv_cov, diff)\n                energy = np.sum(diff * tdiff, axis=0) / 2.0\n                result[i] = np.sum(np.exp(-energy), axis=0)\n\n        result = result / self.norm_factor\n\n        return result",
        "begin_line": 1068,
        "end_line": 1114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase.__init__#399",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase.__init__(self, ax, cmap=None, norm=None, alpha=None, values=None, boundaries=None, orientation='vertical', ticklocation='auto', extend='neither', spacing='uniform', ticks=None, format=None, drawedges=False, filled=True, extendfrac=None, extendrect=False, label='')",
        "snippet": "    def __init__(self, ax, cmap=None,\n                 norm=None,\n                 alpha=None,\n                 values=None,\n                 boundaries=None,\n                 orientation='vertical',\n                 ticklocation='auto',\n                 extend='neither',\n                 spacing='uniform',  # uniform or proportional\n                 ticks=None,\n                 format=None,\n                 drawedges=False,\n                 filled=True,\n                 extendfrac=None,\n                 extendrect=False,\n                 label='',\n                 ):\n        cbook._check_isinstance([colors.Colormap, None], cmap=cmap)\n        cbook._check_in_list(\n            ['vertical', 'horizontal'], orientation=orientation)\n        cbook._check_in_list(\n            ['auto', 'left', 'right', 'top', 'bottom'],\n            ticklocation=ticklocation)\n        cbook._check_in_list(\n            ['uniform', 'proportional'], spacing=spacing)\n        self.ax = ax\n        self._patch_ax()\n        if cmap is None:\n            cmap = cm.get_cmap()\n        if norm is None:\n            norm = colors.Normalize()\n        self.alpha = alpha\n        self.cmap = cmap\n        self.norm = norm\n        self.values = values\n        self.boundaries = boundaries\n        self.extend = extend\n        self._inside = cbook._check_getitem(\n            {'neither': slice(0, None), 'both': slice(1, -1),\n             'min': slice(1, None), 'max': slice(0, -1)},\n            extend=extend)\n        self.spacing = spacing\n        self.orientation = orientation\n        self.drawedges = drawedges\n        self.filled = filled\n        self.extendfrac = extendfrac\n        self.extendrect = extendrect\n        self.solids = None\n        self.lines = []\n\n        self.outline = mpatches.Polygon(\n            np.empty((0, 2)),\n            edgecolor=mpl.rcParams['axes.edgecolor'], facecolor='none',\n            linewidth=mpl.rcParams['axes.linewidth'], closed=True, zorder=2)\n        ax.add_artist(self.outline)\n        self.outline.set(clip_box=None, clip_path=None)\n        self.patch = mpatches.Polygon(\n            np.empty((0, 2)),\n            color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)\n        ax.add_artist(self.patch)\n\n        self.dividers = None\n        self.locator = None\n        self.formatter = None\n        self._manual_tick_data_values = None\n        self.__scale = None  # linear, log10 for now.  Hopefully more?\n\n        if ticklocation == 'auto':\n            ticklocation = 'bottom' if orientation == 'horizontal' else 'right'\n        self.ticklocation = ticklocation\n\n        self.set_label(label)\n        self._reset_locator_formatter_scale()\n\n        if np.iterable(ticks):\n            self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n        else:\n            self.locator = ticks    # Handle default in _ticker()\n\n        if isinstance(format, str):\n            self.formatter = ticker.FormatStrFormatter(format)\n        else:\n            self.formatter = format  # Assume it is a Formatter or None\n        self.draw_all()",
        "begin_line": 399,
        "end_line": 482,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._extend_lower#484",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._extend_lower(self)",
        "snippet": "    def _extend_lower(self):\n        \"\"\"Return whether the lower limit is open ended.\"\"\"\n        return self.extend in ('both', 'min')",
        "begin_line": 484,
        "end_line": 486,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._extend_upper#488",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._extend_upper(self)",
        "snippet": "    def _extend_upper(self):\n        \"\"\"Return whether the upper limit is open ended.\"\"\"\n        return self.extend in ('both', 'max')",
        "begin_line": 488,
        "end_line": 490,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._patch_ax#492",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._patch_ax(self)",
        "snippet": "    def _patch_ax(self):\n        # bind some methods to the axes to warn users\n        # against using those methods.\n        self.ax.set_xticks = _set_ticks_on_axis_warn\n        self.ax.set_yticks = _set_ticks_on_axis_warn",
        "begin_line": 492,
        "end_line": 496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase.draw_all#498",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase.draw_all(self)",
        "snippet": "    def draw_all(self):\n        \"\"\"\n        Calculate any free parameters based on the current cmap and norm,\n        and do all the drawing.\n        \"\"\"\n        # sets self._boundaries and self._values in real data units.\n        # takes into account extend values:\n        self._process_values()\n        # sets self.vmin and vmax in data units, but just for\n        # the part of the colorbar that is not part of the extend\n        # patch:\n        self._find_range()\n        # returns the X and Y mesh, *but* this was/is in normalized\n        # units:\n        X, Y = self._mesh()\n        C = self._values[:, np.newaxis]\n        # decide minor/major axis\n        self._config_axis()\n        self._config_axes(X, Y)\n        if self.filled:\n            self._add_solids(X, Y, C)",
        "begin_line": 498,
        "end_line": 518,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._config_axis#524",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._config_axis(self)",
        "snippet": "    def _config_axis(self):\n        \"\"\"Configure the ticks, ticklabels and label of the underlying Axes.\"\"\"\n        ax = self.ax\n\n        if self.orientation == 'vertical':\n            long_axis, short_axis = ax.yaxis, ax.xaxis\n            if mpl.rcParams['ytick.minor.visible']:\n                self.minorticks_on()\n        else:\n            long_axis, short_axis = ax.xaxis, ax.yaxis\n            if mpl.rcParams['xtick.minor.visible']:\n                self.minorticks_on()\n\n        long_axis.set_label_position(self.ticklocation)\n        long_axis.set_ticks_position(self.ticklocation)\n        short_axis.set_ticks([])\n        short_axis.set_ticks([], minor=True)\n        self._set_label()",
        "begin_line": 524,
        "end_line": 541,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._get_ticker_locator_formatter#543",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._get_ticker_locator_formatter(self)",
        "snippet": "    def _get_ticker_locator_formatter(self):\n        \"\"\"\n        Return the ``locator`` and ``formatter`` of the colorbar.\n\n        If they have not been defined (i.e. are *None*), suitable formatter\n        and locator instances will be created, attached to the respective\n        attributes and returned.\n        \"\"\"\n        locator = self.locator\n        formatter = self.formatter\n        if locator is None:\n            if self.boundaries is None:\n                if isinstance(self.norm, colors.NoNorm):\n                    nv = len(self._values)\n                    base = 1 + int(nv / 10)\n                    locator = ticker.IndexLocator(base=base, offset=0)\n                elif isinstance(self.norm, colors.BoundaryNorm):\n                    b = self.norm.boundaries\n                    locator = ticker.FixedLocator(b, nbins=10)\n                elif isinstance(self.norm, colors.LogNorm):\n                    locator = _ColorbarLogLocator(self)\n                elif isinstance(self.norm, colors.SymLogNorm):\n                    # The subs setting here should be replaced\n                    # by logic in the locator.\n                    locator = ticker.SymmetricalLogLocator(\n                                      subs=np.arange(1, 10),\n                                      linthresh=self.norm.linthresh,\n                                      base=10)\n                else:\n                    if mpl.rcParams['_internal.classic_mode']:\n                        locator = ticker.MaxNLocator()\n                    else:\n                        locator = _ColorbarAutoLocator(self)\n            else:\n                b = self._boundaries[self._inside]\n                locator = ticker.FixedLocator(b, nbins=10)\n\n        if formatter is None:\n            if isinstance(self.norm, colors.LogNorm):\n                formatter = ticker.LogFormatterSciNotation()\n            elif isinstance(self.norm, colors.SymLogNorm):\n                formatter = ticker.LogFormatterSciNotation(\n                                        linthresh=self.norm.linthresh)\n            else:\n                formatter = ticker.ScalarFormatter()\n        else:\n            formatter = self.formatter\n\n        self.locator = locator\n        self.formatter = formatter\n        _log.debug('locator: %r', locator)\n        return locator, formatter",
        "begin_line": 543,
        "end_line": 594,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._use_auto_colorbar_locator#596",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._use_auto_colorbar_locator(self)",
        "snippet": "    def _use_auto_colorbar_locator(self):\n        \"\"\"\n        Return if we should use an adjustable tick locator or a fixed\n        one.  (check is used twice so factored out here...)\n        \"\"\"\n        contouring = self.boundaries is not None and self.spacing == 'uniform'\n        return (type(self.norm) in [colors.Normalize, colors.LogNorm] and\n                not contouring)",
        "begin_line": 596,
        "end_line": 603,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._reset_locator_formatter_scale#605",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._reset_locator_formatter_scale(self)",
        "snippet": "    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        self.locator = None\n        self.formatter = None\n        if isinstance(self.norm, colors.LogNorm):\n            # *both* axes are made log so that determining the\n            # mid point is easier.\n            self.ax.set_xscale('log')\n            self.ax.set_yscale('log')\n            self.minorticks_on()\n            self.__scale = 'log'\n        else:\n            self.ax.set_xscale('linear')\n            self.ax.set_yscale('linear')\n            if type(self.norm) is colors.Normalize:\n                self.__scale = 'linear'\n            else:\n                self.__scale = 'manual'",
        "begin_line": 605,
        "end_line": 626,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase.update_ticks#628",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase.update_ticks(self)",
        "snippet": "    def update_ticks(self):\n        \"\"\"\n        Force the update of the ticks and ticklabels. This must be\n        called whenever the tick locator and/or tick formatter changes.\n        \"\"\"\n        ax = self.ax\n        # Get the locator and formatter; defaults to self.locator if not None.\n        locator, formatter = self._get_ticker_locator_formatter()\n        long_axis = ax.yaxis if self.orientation == 'vertical' else ax.xaxis\n        if self._use_auto_colorbar_locator():\n            _log.debug('Using auto colorbar locator %r on colorbar', locator)\n            long_axis.set_major_locator(locator)\n            long_axis.set_major_formatter(formatter)\n        else:\n            _log.debug('Using fixed locator on colorbar')\n            ticks, ticklabels, offset_string = self._ticker(locator, formatter)\n            long_axis.set_ticks(ticks)\n            long_axis.set_ticklabels(ticklabels)\n            long_axis.get_major_formatter().set_offset_string(offset_string)",
        "begin_line": 628,
        "end_line": 646,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase.get_ticks#673",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase.get_ticks(self, minor=False)",
        "snippet": "    def get_ticks(self, minor=False):\n        \"\"\"Return the x ticks as a list of locations.\"\"\"\n        if self._manual_tick_data_values is None:\n            ax = self.ax\n            long_axis = (\n                ax.yaxis if self.orientation == 'vertical' else ax.xaxis)\n            return long_axis.get_majorticklocs()\n        else:\n            # We made the axes manually, the old way, and the ylim is 0-1,\n            # so the majorticklocs are in those units, not data units.\n            return self._manual_tick_data_values",
        "begin_line": 673,
        "end_line": 683,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._config_axes#722",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._config_axes(self, X, Y)",
        "snippet": "    def _config_axes(self, X, Y):\n        \"\"\"Create an axes patch and outline.\"\"\"\n        ax = self.ax\n        ax.set_frame_on(False)\n        ax.set_navigate(False)\n        xy = self._outline(X, Y)\n        ax.ignore_existing_data_limits = True\n        ax.update_datalim(xy)\n        ax.set_xlim(*ax.dataLim.intervalx)\n        ax.set_ylim(*ax.dataLim.intervaly)\n        self.outline.set_xy(xy)\n        self.patch.set_xy(xy)\n        self.update_ticks()",
        "begin_line": 722,
        "end_line": 734,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.690362388111584e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._set_label#736",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._set_label(self)",
        "snippet": "    def _set_label(self):\n        if self.orientation == 'vertical':\n            self.ax.set_ylabel(self._label, **self._labelkw)\n        else:\n            self.ax.set_xlabel(self._label, **self._labelkw)\n        self.stale = True",
        "begin_line": 736,
        "end_line": 741,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase.set_label#743",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase.set_label(self, label, *, loc=None, **kwargs)",
        "snippet": "    def set_label(self, label, *, loc=None, **kwargs):\n        \"\"\"Add a label to the long axis of the colorbar.\"\"\"\n        _pos_xy = 'y' if self.orientation == 'vertical' else 'x'\n        _protected_kw = [_pos_xy, 'horizontalalignment', 'ha']\n        if any([k in kwargs for k in _protected_kw]):\n            if loc is not None:\n                raise TypeError(f'Specifying *loc* is disallowed when any of '\n                                f'its corresponding low level keyword '\n                                f'arguments {_protected_kw} are also supplied')\n            loc = 'center'\n        else:\n            if loc is None:\n                loc = mpl.rcParams['%saxis.labellocation' % _pos_xy]\n        if self.orientation == 'vertical':\n            cbook._check_in_list(('bottom', 'center', 'top'), loc=loc)\n        else:\n            cbook._check_in_list(('left', 'center', 'right'), loc=loc)\n        if loc in ['right', 'top']:\n            kwargs[_pos_xy] = 1.\n            kwargs['horizontalalignment'] = 'right'\n        elif loc in ['left', 'bottom']:\n            kwargs[_pos_xy] = 0.\n            kwargs['horizontalalignment'] = 'left'\n        self._label = label\n        self._labelkw = kwargs\n        self._set_label()",
        "begin_line": 743,
        "end_line": 768,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._outline#770",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._outline(self, X, Y)",
        "snippet": "    def _outline(self, X, Y):\n        \"\"\"\n        Return *x*, *y* arrays of colorbar bounding polygon,\n        taking orientation into account.\n        \"\"\"\n        N = X.shape[0]\n        ii = [0, 1, N - 2, N - 1, 2 * N - 1, 2 * N - 2, N + 1, N, 0]\n        x = X.T.reshape(-1)[ii]\n        y = Y.T.reshape(-1)[ii]\n        return (np.column_stack([y, x])\n                if self.orientation == 'horizontal' else\n                np.column_stack([x, y]))",
        "begin_line": 770,
        "end_line": 781,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._add_solids#793",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._add_solids(self, X, Y, C)",
        "snippet": "    def _add_solids(self, X, Y, C):\n        \"\"\"\n        Draw the colors using `~.axes.Axes.pcolormesh`;\n        optionally add separators.\n        \"\"\"\n        if self.orientation == 'vertical':\n            args = (X, Y, C)\n        else:\n            args = (np.transpose(Y), np.transpose(X), np.transpose(C))\n        kw = dict(cmap=self.cmap,\n                  norm=self.norm,\n                  alpha=self.alpha,\n                  edgecolors='None')\n        _log.debug('Setting pcolormesh')\n        col = self.ax.pcolormesh(*args, **kw, shading='flat')\n        # self.add_observer(col) # We should observe, not be observed...\n\n        if self.solids is not None:\n            self.solids.remove()\n        self.solids = col\n        if self.dividers is not None:\n            self.dividers.remove()\n            self.dividers = None\n        if self.drawedges:\n            linewidths = (0.5 * mpl.rcParams['axes.linewidth'],)\n            self.dividers = collections.LineCollection(\n                    self._edges(X, Y),\n                    colors=(mpl.rcParams['axes.edgecolor'],),\n                    linewidths=linewidths)\n            self.ax.add_collection(self.dividers)\n        elif len(self._y) >= self.n_rasterize:\n            self.solids.set_rasterized(True)",
        "begin_line": 793,
        "end_line": 824,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._ticker#869",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._ticker(self, locator, formatter)",
        "snippet": "    def _ticker(self, locator, formatter):\n        \"\"\"\n        Return the sequence of ticks (colorbar data locations),\n        ticklabels (strings), and the corresponding offset string.\n        \"\"\"\n        if isinstance(self.norm, colors.NoNorm) and self.boundaries is None:\n            intv = self._values[0], self._values[-1]\n        else:\n            intv = self.vmin, self.vmax\n        locator.create_dummy_axis(minpos=intv[0])\n        formatter.create_dummy_axis(minpos=intv[0])\n        locator.set_view_interval(*intv)\n        locator.set_data_interval(*intv)\n        formatter.set_view_interval(*intv)\n        formatter.set_data_interval(*intv)\n\n        b = np.array(locator())\n        if isinstance(locator, ticker.LogLocator):\n            eps = 1e-10\n            b = b[(b <= intv[1] * (1 + eps)) & (b >= intv[0] * (1 - eps))]\n        else:\n            eps = (intv[1] - intv[0]) * 1e-10\n            b = b[(b <= intv[1] + eps) & (b >= intv[0] - eps)]\n        self._manual_tick_data_values = b\n        ticks = self._locate(b)\n        ticklabels = formatter.format_ticks(b)\n        offset_string = formatter.get_offset()\n        return ticks, ticklabels, offset_string",
        "begin_line": 869,
        "end_line": 896,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._process_values#898",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._process_values(self, b=None)",
        "snippet": "    def _process_values(self, b=None):\n        \"\"\"\n        Set the :attr:`_boundaries` and :attr:`_values` attributes\n        based on the input boundaries and values.  Input boundaries\n        can be *self.boundaries* or the argument *b*.\n        \"\"\"\n        if b is None:\n            b = self.boundaries\n        if b is not None:\n            self._boundaries = np.asarray(b, dtype=float)\n            if self.values is None:\n                self._values = 0.5 * (self._boundaries[:-1]\n                                      + self._boundaries[1:])\n                if isinstance(self.norm, colors.NoNorm):\n                    self._values = (self._values + 0.00001).astype(np.int16)\n            else:\n                self._values = np.array(self.values)\n            return\n        if self.values is not None:\n            self._values = np.array(self.values)\n            if self.boundaries is None:\n                b = np.zeros(len(self.values) + 1)\n                b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])\n                b[0] = 2.0 * b[1] - b[2]\n                b[-1] = 2.0 * b[-2] - b[-3]\n                self._boundaries = b\n                return\n            self._boundaries = np.array(self.boundaries)\n            return\n        # Neither boundaries nor values are specified;\n        # make reasonable ones based on cmap and norm.\n        if isinstance(self.norm, colors.NoNorm):\n            b = self._uniform_y(self.cmap.N + 1) * self.cmap.N - 0.5\n            v = np.zeros(len(b) - 1, dtype=np.int16)\n            v[self._inside] = np.arange(self.cmap.N, dtype=np.int16)\n            if self._extend_lower():\n                v[0] = -1\n            if self._extend_upper():\n                v[-1] = self.cmap.N\n            self._boundaries = b\n            self._values = v\n            return\n        elif isinstance(self.norm, colors.BoundaryNorm):\n            b = list(self.norm.boundaries)\n            if self._extend_lower():\n                b = [b[0] - 1] + b\n            if self._extend_upper():\n                b = b + [b[-1] + 1]\n            b = np.array(b)\n            v = np.zeros(len(b) - 1)\n            bi = self.norm.boundaries\n            v[self._inside] = 0.5 * (bi[:-1] + bi[1:])\n            if self._extend_lower():\n                v[0] = b[0] - 1\n            if self._extend_upper():\n                v[-1] = b[-1] + 1\n            self._boundaries = b\n            self._values = v\n            return\n        else:\n            if not self.norm.scaled():\n                self.norm.vmin = 0\n                self.norm.vmax = 1\n\n            self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n                self.norm.vmin,\n                self.norm.vmax,\n                expander=0.1)\n\n            b = self.norm.inverse(self._uniform_y(self.cmap.N + 1))\n\n            if isinstance(self.norm, (colors.PowerNorm, colors.LogNorm)):\n                # If using a lognorm or powernorm, ensure extensions don't\n                # go negative\n                if self._extend_lower():\n                    b[0] = 0.9 * b[0]\n                if self._extend_upper():\n                    b[-1] = 1.1 * b[-1]\n            else:\n                if self._extend_lower():\n                    b[0] = b[0] - 1\n                if self._extend_upper():\n                    b[-1] = b[-1] + 1\n        self._process_values(b)",
        "begin_line": 898,
        "end_line": 981,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._find_range#983",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._find_range(self)",
        "snippet": "    def _find_range(self):\n        \"\"\"\n        Set :attr:`vmin` and :attr:`vmax` attributes to the first and\n        last boundary excluding extended end boundaries.\n        \"\"\"\n        b = self._boundaries[self._inside]\n        self.vmin = b[0]\n        self.vmax = b[-1]",
        "begin_line": 983,
        "end_line": 990,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._central_N#992",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._central_N(self)",
        "snippet": "    def _central_N(self):\n        \"\"\"Return the number of boundaries excluding end extensions.\"\"\"\n        nb = len(self._boundaries)\n        if self.extend == 'both':\n            nb -= 2\n        elif self.extend in ('min', 'max'):\n            nb -= 1\n        return nb",
        "begin_line": 992,
        "end_line": 999,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._get_extension_lengths#1013",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._get_extension_lengths(self, frac, automin, automax, default=0.05)",
        "snippet": "    def _get_extension_lengths(self, frac, automin, automax, default=0.05):\n        \"\"\"\n        Return the lengths of colorbar extensions.\n\n        This is a helper method for _uniform_y and _proportional_y.\n        \"\"\"\n        # Set the default value.\n        extendlength = np.array([default, default])\n        if isinstance(frac, str):\n            cbook._check_in_list(['auto'], extendfrac=frac.lower())\n            # Use the provided values when 'auto' is required.\n            extendlength[:] = [automin, automax]\n        elif frac is not None:\n            try:\n                # Try to set min and max extension fractions directly.\n                extendlength[:] = frac\n                # If frac is a sequence containing None then NaN may\n                # be encountered. This is an error.\n                if np.isnan(extendlength).any():\n                    raise ValueError()\n            except (TypeError, ValueError) as err:\n                # Raise an error on encountering an invalid value for frac.\n                raise ValueError('invalid value for extendfrac') from err\n        return extendlength",
        "begin_line": 1013,
        "end_line": 1036,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._uniform_y#1038",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._uniform_y(self, N)",
        "snippet": "    def _uniform_y(self, N):\n        \"\"\"\n        Return colorbar data coordinates for *N* uniformly\n        spaced boundaries, plus ends if required.\n        \"\"\"\n        if self.extend == 'neither':\n            y = np.linspace(0, 1, N)\n        else:\n            automin = automax = 1. / (N - 1.)\n            extendlength = self._get_extension_lengths(self.extendfrac,\n                                                       automin, automax,\n                                                       default=0.05)\n            if self.extend == 'both':\n                y = np.zeros(N + 2, 'd')\n                y[0] = 0. - extendlength[0]\n                y[-1] = 1. + extendlength[1]\n            elif self.extend == 'min':\n                y = np.zeros(N + 1, 'd')\n                y[0] = 0. - extendlength[0]\n            else:\n                y = np.zeros(N + 1, 'd')\n                y[-1] = 1. + extendlength[1]\n            y[self._inside] = np.linspace(0, 1, N)\n        return y",
        "begin_line": 1038,
        "end_line": 1061,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._proportional_y#1063",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._proportional_y(self)",
        "snippet": "    def _proportional_y(self):\n        \"\"\"\n        Return colorbar data coordinates for the boundaries of\n        a proportional colorbar.\n        \"\"\"\n        if isinstance(self.norm, colors.BoundaryNorm):\n            y = (self._boundaries - self._boundaries[0])\n            y = y / (self._boundaries[-1] - self._boundaries[0])\n        else:\n            y = self.norm(self._boundaries.copy())\n            y = np.ma.filled(y, np.nan)\n        if self.extend == 'min':\n            # Exclude leftmost interval of y.\n            clen = y[-1] - y[1]\n            automin = (y[2] - y[1]) / clen\n            automax = (y[-1] - y[-2]) / clen\n        elif self.extend == 'max':\n            # Exclude rightmost interval in y.\n            clen = y[-2] - y[0]\n            automin = (y[1] - y[0]) / clen\n            automax = (y[-2] - y[-3]) / clen\n        elif self.extend == 'both':\n            # Exclude leftmost and rightmost intervals in y.\n            clen = y[-2] - y[1]\n            automin = (y[2] - y[1]) / clen\n            automax = (y[-2] - y[-3]) / clen\n        if self.extend in ('both', 'min', 'max'):\n            extendlength = self._get_extension_lengths(self.extendfrac,\n                                                       automin, automax,\n                                                       default=0.05)\n        if self.extend in ('both', 'min'):\n            y[0] = 0. - extendlength[0]\n        if self.extend in ('both', 'max'):\n            y[-1] = 1. + extendlength[1]\n        yi = y[self._inside]\n        norm = colors.Normalize(yi[0], yi[-1])\n        y[self._inside] = np.ma.filled(norm(yi), np.nan)\n        return y",
        "begin_line": 1063,
        "end_line": 1100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._mesh#1102",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._mesh(self)",
        "snippet": "    def _mesh(self):\n        \"\"\"\n        Return ``(X, Y)``, the coordinate arrays for the colorbar pcolormesh.\n        These are suitable for a vertical colorbar; swapping and transposition\n        for a horizontal colorbar are done outside this function.\n\n        These are scaled between vmin and vmax.\n        \"\"\"\n        # copy the norm and change the vmin and vmax to the vmin and\n        # vmax of the colorbar, not the norm.  This allows the situation\n        # where the colormap has a narrower range than the colorbar, to\n        # accomodate extra contours:\n        norm = copy.copy(self.norm)\n        norm.vmin = self.vmin\n        norm.vmax = self.vmax\n        x = np.array([0.0, 1.0])\n        if self.spacing == 'uniform':\n            y = self._uniform_y(self._central_N())\n        else:\n            y = self._proportional_y()\n        xmid = np.array([0.5])\n        if self.__scale != 'manual':\n            y = norm.inverse(y)\n            x = norm.inverse(x)\n            xmid = norm.inverse(xmid)\n        else:\n            # if a norm doesn't have a named scale, or\n            # we are not using a norm\n            dv = self.vmax - self.vmin\n            x = x * dv + self.vmin\n            y = y * dv + self.vmin\n            xmid = xmid * dv + self.vmin\n        self._y = y\n        X, Y = np.meshgrid(x, y)\n        if self._extend_lower() and not self.extendrect:\n            X[0, :] = xmid\n        if self._extend_upper() and not self.extendrect:\n            X[-1, :] = xmid\n        return X, Y",
        "begin_line": 1102,
        "end_line": 1140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarBase._locate#1142",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarBase",
        "signature": "lib.matplotlib.colorbar.ColorbarBase._locate(self, x)",
        "snippet": "    def _locate(self, x):\n        \"\"\"\n        Given a set of color data values, return their\n        corresponding colorbar data coordinates.\n        \"\"\"\n        if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):\n            b = self._boundaries\n            xn = x\n        else:\n            # Do calculations using normalized coordinates so\n            # as to make the interpolation more accurate.\n            b = self.norm(self._boundaries, clip=False).filled()\n            xn = self.norm(x, clip=False).filled()\n\n        bunique = b\n        yunique = self._y\n        # trim extra b values at beginning and end if they are\n        # not unique.  These are here for extended colorbars, and are not\n        # wanted for the interpolation.\n        if b[0] == b[1]:\n            bunique = bunique[1:]\n            yunique = yunique[1:]\n        if b[-1] == b[-2]:\n            bunique = bunique[:-1]\n            yunique = yunique[:-1]\n\n        z = np.interp(xn, bunique, yunique)\n        return z",
        "begin_line": 1142,
        "end_line": 1169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar._add_disjoint_kwargs#1180",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar",
        "signature": "lib.matplotlib.colorbar._add_disjoint_kwargs(d, **kwargs)",
        "snippet": "def _add_disjoint_kwargs(d, **kwargs):\n    \"\"\"\n    Update dict *d* with entries in *kwargs*, which must be absent from *d*.\n    \"\"\"\n    for k, v in kwargs.items():\n        if k in d:\n            cbook.warn_deprecated(\n                \"3.3\", message=f\"The {k!r} parameter to Colorbar has no \"\n                \"effect because it is overridden by the mappable; it is \"\n                \"deprecated since %(since)s and will be removed %(removal)s.\")\n        d[k] = v",
        "begin_line": 1180,
        "end_line": 1190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.128098837681866e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.Colorbar.__init__#1203",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.Colorbar",
        "signature": "lib.matplotlib.colorbar.Colorbar.__init__(self, ax, mappable, **kwargs)",
        "snippet": "    def __init__(self, ax, mappable, **kwargs):\n        # Ensure the given mappable's norm has appropriate vmin and vmax set\n        # even if mappable.draw has not yet been called.\n        if mappable.get_array() is not None:\n            mappable.autoscale_None()\n\n        self.mappable = mappable\n        _add_disjoint_kwargs(kwargs, cmap=mappable.cmap, norm=mappable.norm)\n\n        if isinstance(mappable, contour.ContourSet):\n            cs = mappable\n            _add_disjoint_kwargs(\n                kwargs,\n                alpha=cs.get_alpha(),\n                boundaries=cs._levels,\n                values=cs.cvalues,\n                extend=cs.extend,\n                filled=cs.filled,\n            )\n            kwargs.setdefault(\n                'ticks', ticker.FixedLocator(cs.levels, nbins=10))\n            ColorbarBase.__init__(self, ax, **kwargs)\n            if not cs.filled:\n                self.add_lines(cs)\n        else:\n            if getattr(mappable.cmap, 'colorbar_extend', False) is not False:\n                kwargs.setdefault('extend', mappable.cmap.colorbar_extend)\n            if isinstance(mappable, martist.Artist):\n                _add_disjoint_kwargs(kwargs, alpha=mappable.get_alpha())\n            ColorbarBase.__init__(self, ax, **kwargs)",
        "begin_line": 1203,
        "end_line": 1232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.Colorbar.add_lines#1245",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.Colorbar",
        "signature": "lib.matplotlib.colorbar.Colorbar.add_lines(self, CS, erase=True)",
        "snippet": "    def add_lines(self, CS, erase=True):\n        \"\"\"\n        Add the lines from a non-filled `~.contour.ContourSet` to the colorbar.\n\n        Parameters\n        ----------\n        CS : `~.contour.ContourSet`\n            The line positions are taken from the ContourSet levels. The\n            ContourSet must not be filled.\n        erase : bool, default: True\n            Whether to remove any previously added lines.\n        \"\"\"\n        if not isinstance(CS, contour.ContourSet) or CS.filled:\n            raise ValueError('add_lines is only for a ContourSet of lines')\n        tcolors = [c[0] for c in CS.tcolors]\n        tlinewidths = [t[0] for t in CS.tlinewidths]\n        # The following was an attempt to get the colorbar lines\n        # to follow subsequent changes in the contour lines,\n        # but more work is needed: specifically, a careful\n        # look at event sequences, and at how\n        # to make one object track another automatically.\n        #tcolors = [col.get_colors()[0] for col in CS.collections]\n        #tlinewidths = [col.get_linewidth()[0] for lw in CS.collections]\n        ColorbarBase.add_lines(self, CS.levels, tcolors, tlinewidths,\n                               erase=erase)",
        "begin_line": 1245,
        "end_line": 1269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.Colorbar.update_normal#1271",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.Colorbar",
        "signature": "lib.matplotlib.colorbar.Colorbar.update_normal(self, mappable)",
        "snippet": "    def update_normal(self, mappable):\n        \"\"\"\n        Update solid patches, lines, etc.\n\n        This is meant to be called when the norm of the image or contour plot\n        to which this colorbar belongs changes.\n\n        If the norm on the mappable is different than before, this resets the\n        locator and formatter for the axis, so if these have been customized,\n        they will need to be customized again.  However, if the norm only\n        changes values of *vmin*, *vmax* or *cmap* then the old formatter\n        and locator will be preserved.\n        \"\"\"\n        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n        self.mappable = mappable\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            self._reset_locator_formatter_scale()\n\n        self.draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n        self.stale = True",
        "begin_line": 1271,
        "end_line": 1297,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.Colorbar.remove#1344",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.Colorbar",
        "signature": "lib.matplotlib.colorbar.Colorbar.remove(self)",
        "snippet": "    def remove(self):\n        \"\"\"\n        Remove this colorbar from the figure.\n\n        If the colorbar was created with ``use_gridspec=True`` the previous\n        gridspec is restored.\n        \"\"\"\n        ColorbarBase.remove(self)\n        self.mappable.callbacksSM.disconnect(self.mappable.colorbar_cid)\n        self.mappable.colorbar = None\n        self.mappable.colorbar_cid = None\n\n        try:\n            ax = self.mappable.axes\n        except AttributeError:\n            return\n\n        try:\n            gs = ax.get_subplotspec().get_gridspec()\n            subplotspec = gs.get_topmost_subplotspec()\n        except AttributeError:\n            # use_gridspec was False\n            pos = ax.get_position(original=True)\n            ax._set_position(pos)\n        else:\n            # use_gridspec was True\n            ax.set_subplotspec(subplotspec)",
        "begin_line": 1344,
        "end_line": 1370,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.make_axes#1374",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar",
        "signature": "lib.matplotlib.colorbar.make_axes(parents, location=None, orientation=None, fraction=0.15, shrink=1.0, aspect=20, **kw)",
        "snippet": "def make_axes(parents, location=None, orientation=None, fraction=0.15,\n              shrink=1.0, aspect=20, **kw):\n    \"\"\"\n    Create an `~.axes.Axes` suitable for a colorbar.\n\n    The axes is placed in the figure of the *parents* axes, by resizing and\n    repositioning *parents*.\n\n    Keyword arguments may include the following (with defaults):\n\n        location : None or {'left', 'right', 'top', 'bottom'}\n            The position, relative to *parents*, where the colorbar axes\n            should be created. If None, the value will either come from the\n            given ``orientation``, else it will default to 'right'.\n\n        orientation : None or {'vertical', 'horizontal'}\n            The orientation of the colorbar. Typically, this keyword shouldn't\n            be used, as it can be derived from the ``location`` keyword.\n\n    %s\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary to be\n    passed when creating the colorbar instance.\n    \"\"\"\n    locations = [\"left\", \"right\", \"top\", \"bottom\"]\n    if orientation is not None and location is not None:\n        raise TypeError('position and orientation are mutually exclusive. '\n                        'Consider setting the position to any of {}'\n                        .format(', '.join(locations)))\n\n    # provide a default location\n    if location is None and orientation is None:\n        location = 'right'\n\n    # allow the user to not specify the location by specifying the\n    # orientation instead\n    if location is None:\n        location = 'right' if orientation == 'vertical' else 'bottom'\n\n    cbook._check_in_list(locations, location=location)\n\n    default_location_settings = {'left':   {'anchor': (1.0, 0.5),\n                                            'panchor': (0.0, 0.5),\n                                            'pad': 0.10,\n                                            'orientation': 'vertical'},\n                                 'right':  {'anchor': (0.0, 0.5),\n                                            'panchor': (1.0, 0.5),\n                                            'pad': 0.05,\n                                            'orientation': 'vertical'},\n                                 'top':    {'anchor': (0.5, 0.0),\n                                            'panchor': (0.5, 1.0),\n                                            'pad': 0.05,\n                                            'orientation': 'horizontal'},\n                                 'bottom': {'anchor': (0.5, 1.0),\n                                            'panchor': (0.5, 0.0),\n                                            'pad': 0.15,  # backwards compat\n                                            'orientation': 'horizontal'},\n                                 }\n\n    loc_settings = default_location_settings[location]\n\n    # put appropriate values into the kw dict for passing back to\n    # the Colorbar class\n    kw['orientation'] = loc_settings['orientation']\n    kw['ticklocation'] = location\n\n    anchor = kw.pop('anchor', loc_settings['anchor'])\n    parent_anchor = kw.pop('panchor', loc_settings['panchor'])\n\n    parents_iterable = np.iterable(parents)\n    # turn parents into a list if it is not already. We do this w/ np\n    # because `plt.subplots` can return an ndarray and is natural to\n    # pass to `colorbar`.\n    parents = np.atleast_1d(parents).ravel()\n\n    # check if using constrained_layout:\n    try:\n        gs = parents[0].get_subplotspec().get_gridspec()\n        using_constrained_layout = (gs._layoutbox is not None)\n    except AttributeError:\n        using_constrained_layout = False\n\n    # defaults are not appropriate for constrained_layout:\n    pad0 = loc_settings['pad']\n    if using_constrained_layout:\n        pad0 = 0.02\n    pad = kw.pop('pad', pad0)\n\n    fig = parents[0].get_figure()\n    if not all(fig is ax.get_figure() for ax in parents):\n        raise ValueError('Unable to create a colorbar axes as not all '\n                         'parents share the same figure.')\n\n    # take a bounding box around all of the given axes\n    parents_bbox = mtransforms.Bbox.union(\n        [ax.get_position(original=True).frozen() for ax in parents])\n\n    pb = parents_bbox\n    if location in ('left', 'right'):\n        if location == 'left':\n            pbcb, _, pb1 = pb.splitx(fraction, fraction + pad)\n        else:\n            pb1, _, pbcb = pb.splitx(1 - fraction - pad, 1 - fraction)\n        pbcb = pbcb.shrunk(1.0, shrink).anchored(anchor, pbcb)\n    else:\n        if location == 'bottom':\n            pbcb, _, pb1 = pb.splity(fraction, fraction + pad)\n        else:\n            pb1, _, pbcb = pb.splity(1 - fraction - pad, 1 - fraction)\n        pbcb = pbcb.shrunk(shrink, 1.0).anchored(anchor, pbcb)\n\n        # define the aspect ratio in terms of y's per x rather than x's per y\n        aspect = 1.0 / aspect\n\n    # define a transform which takes us from old axes coordinates to\n    # new axes coordinates\n    shrinking_trans = mtransforms.BboxTransform(parents_bbox, pb1)\n\n    # transform each of the axes in parents using the new transform\n    for ax in parents:\n        new_posn = shrinking_trans.transform(ax.get_position(original=True))\n        new_posn = mtransforms.Bbox(new_posn)\n        ax._set_position(new_posn)\n        if parent_anchor is not False:\n            ax.set_anchor(parent_anchor)\n\n    cax = fig.add_axes(pbcb, label=\"<colorbar>\")\n\n    # OK, now make a layoutbox for the cb axis.  Later, we will use this\n    # to make the colorbar fit nicely.\n    if not using_constrained_layout:\n        # no layout boxes:\n        lb = None\n        lbpos = None\n        # and we need to set the aspect ratio by hand...\n        cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    else:\n        if not parents_iterable:\n            # this is a single axis...\n            ax = parents[0]\n            lb, lbpos = constrained_layout.layoutcolorbarsingle(\n                    ax, cax, shrink, aspect, location, pad=pad)\n        else:  # there is more than one parent, so lets use gridspec\n            # the colorbar will be a sibling of this gridspec, so the\n            # parent is the same parent as the gridspec.  Either the figure,\n            # or a subplotspec.\n\n            lb, lbpos = constrained_layout.layoutcolorbargridspec(\n                    parents, cax, shrink, aspect, location, pad)\n\n    cax._layoutbox = lb\n    cax._poslayoutbox = lbpos\n\n    return cax, kw",
        "begin_line": 1374,
        "end_line": 1527,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.make_axes_gridspec#1531",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar",
        "signature": "lib.matplotlib.colorbar.make_axes_gridspec(parent, *, fraction=0.15, shrink=1.0, aspect=20, **kw)",
        "snippet": "def make_axes_gridspec(parent, *, fraction=0.15, shrink=1.0, aspect=20, **kw):\n    \"\"\"\n    Create a `~.SubplotBase` suitable for a colorbar.\n\n    The axes is placed in the figure of the *parent* axes, by resizing and\n    repositioning *parent*.\n\n    This function is similar to `.make_axes`. Primary differences are\n\n    - `.make_axes_gridspec` only handles the *orientation* keyword\n      and cannot handle the \"location\" keyword.\n\n    - `.make_axes_gridspec` should only be used with a `.SubplotBase` parent.\n\n    - `.make_axes` creates an `~.axes.Axes`; `.make_axes_gridspec` creates a\n      `.SubplotBase`.\n\n    - `.make_axes` updates the position of the parent.  `.make_axes_gridspec`\n       replaces the ``grid_spec`` attribute of the parent with a new one.\n\n    While this function is meant to be compatible with `.make_axes`,\n    there could be some minor differences.\n\n    Keyword arguments may include the following (with defaults):\n\n        *orientation*\n            'vertical' or 'horizontal'\n\n    %s\n\n    All but the first of these are stripped from the input kw set.\n\n    Returns (cax, kw), the child axes and the reduced kw dictionary to be\n    passed when creating the colorbar instance.\n    \"\"\"\n\n    orientation = kw.setdefault('orientation', 'vertical')\n    kw['ticklocation'] = 'auto'\n\n    x1 = 1 - fraction\n\n    # for shrinking\n    pad_s = (1 - shrink) * 0.5\n    wh_ratios = [pad_s, shrink, pad_s]\n\n    # we need to none the tree of layoutboxes because\n    # constrained_layout can't remove and replace the tree\n    # hierarchy w/o a seg fault.\n    gs = parent.get_subplotspec().get_gridspec()\n    layoutbox.nonetree(gs._layoutbox)\n    gs_from_subplotspec = gridspec.GridSpecFromSubplotSpec\n    if orientation == 'vertical':\n        pad = kw.pop('pad', 0.05)\n        wh_space = 2 * pad / (1 - pad)\n        gs = gs_from_subplotspec(1, 2,\n                                 subplot_spec=parent.get_subplotspec(),\n                                 wspace=wh_space,\n                                 width_ratios=[x1 - pad, fraction])\n        gs2 = gs_from_subplotspec(3, 1,\n                                  subplot_spec=gs[1],\n                                  hspace=0.,\n                                  height_ratios=wh_ratios)\n        anchor = (0.0, 0.5)\n        panchor = (1.0, 0.5)\n    else:\n        pad = kw.pop('pad', 0.15)\n        wh_space = 2 * pad / (1 - pad)\n        gs = gs_from_subplotspec(2, 1,\n                                 subplot_spec=parent.get_subplotspec(),\n                                 hspace=wh_space,\n                                 height_ratios=[x1 - pad, fraction])\n        gs2 = gs_from_subplotspec(1, 3,\n                                  subplot_spec=gs[1],\n                                  wspace=0.,\n                                  width_ratios=wh_ratios)\n        aspect = 1 / aspect\n        anchor = (0.5, 1.0)\n        panchor = (0.5, 0.0)\n\n    parent.set_subplotspec(gs[0])\n    parent.update_params()\n    parent._set_position(parent.figbox)\n    parent.set_anchor(panchor)\n\n    fig = parent.get_figure()\n    cax = fig.add_subplot(gs2[1], label=\"<colorbar>\")\n    cax.set_aspect(aspect, anchor=anchor, adjustable='box')\n    return cax, kw",
        "begin_line": 1531,
        "end_line": 1618,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarPatch.__init__#1629",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarPatch",
        "signature": "lib.matplotlib.colorbar.ColorbarPatch.__init__(self, ax, mappable, **kw)",
        "snippet": "    def __init__(self, ax, mappable, **kw):\n        # we do not want to override the behaviour of solids\n        # so add a new attribute which will be a list of the\n        # colored patches in the colorbar\n        self.solids_patches = []\n        Colorbar.__init__(self, ax, mappable, **kw)",
        "begin_line": 1629,
        "end_line": 1634,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.ColorbarPatch._add_solids#1636",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar.ColorbarPatch",
        "signature": "lib.matplotlib.colorbar.ColorbarPatch._add_solids(self, X, Y, C)",
        "snippet": "    def _add_solids(self, X, Y, C):\n        \"\"\"\n        Draw the colors using `~matplotlib.patches.Patch`;\n        optionally add separators.\n        \"\"\"\n        n_segments = len(C)\n\n        # ensure there are sufficient hatches\n        hatches = self.mappable.hatches * n_segments\n\n        patches = []\n        for i in range(len(X) - 1):\n            val = C[i][0]\n            hatch = hatches[i]\n\n            xy = np.array([[X[i][0], Y[i][0]],\n                           [X[i][1], Y[i][0]],\n                           [X[i + 1][1], Y[i + 1][0]],\n                           [X[i + 1][0], Y[i + 1][1]]])\n\n            if self.orientation == 'horizontal':\n                # if horizontal swap the xs and ys\n                xy = xy[..., ::-1]\n\n            patch = mpatches.PathPatch(mpath.Path(xy),\n                                       facecolor=self.cmap(self.norm(val)),\n                                       hatch=hatch, linewidth=0,\n                                       antialiased=False, alpha=self.alpha)\n            self.ax.add_patch(patch)\n            patches.append(patch)\n\n        if self.solids_patches:\n            for solid in self.solids_patches:\n                solid.remove()\n\n        self.solids_patches = patches\n\n        if self.dividers is not None:\n            self.dividers.remove()\n            self.dividers = None\n\n        if self.drawedges:\n            self.dividers = collections.LineCollection(\n                    self._edges(X, Y),\n                    colors=(mpl.rcParams['axes.edgecolor'],),\n                    linewidths=(0.5 * mpl.rcParams['axes.linewidth'],))\n            self.ax.add_collection(self.dividers)",
        "begin_line": 1636,
        "end_line": 1682,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colorbar.colorbar_factory#1685",
        "src_path": "lib/matplotlib/colorbar.py",
        "class_name": "lib.matplotlib.colorbar",
        "signature": "lib.matplotlib.colorbar.colorbar_factory(cax, mappable, **kwargs)",
        "snippet": "def colorbar_factory(cax, mappable, **kwargs):\n    \"\"\"\n    Create a colorbar on the given axes for the given mappable.\n\n    .. note::\n        This is a low-level function to turn an existing axes into a colorbar\n        axes.  Typically, you'll want to use `~.Figure.colorbar` instead, which\n        automatically handles creation and placement of a suitable axes as\n        well.\n\n    Parameters\n    ----------\n    cax : `~matplotlib.axes.Axes`\n        The `~.axes.Axes` to turn into a colorbar.\n    mappable : `~matplotlib.cm.ScalarMappable`\n        The mappable to be described by the colorbar.\n    **kwargs\n        Keyword arguments are passed to the respective colorbar class.\n\n    Returns\n    -------\n    colorbar : `.Colorbar` or `.ColorbarPatch`\n        The created colorbar instance. `.ColorbarPatch` is only used if\n        *mappable* is a `.ContourSet` with hatches.\n    \"\"\"\n    # if the given mappable is a contourset with any hatching, use\n    # ColorbarPatch else use Colorbar\n    if (isinstance(mappable, contour.ContourSet)\n            and any(hatch is not None for hatch in mappable.hatches)):\n        cb = ColorbarPatch(cax, mappable, **kwargs)\n    else:\n        cb = Colorbar(cax, mappable, **kwargs)\n\n    cid = mappable.callbacksSM.connect('changed', cb.update_normal)\n    mappable.colorbar = cb\n    mappable.colorbar_cid = cid\n\n    return cb",
        "begin_line": 1685,
        "end_line": 1722,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._process_plot_format#32",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base",
        "signature": "lib.matplotlib.axes._base._process_plot_format(fmt)",
        "snippet": "def _process_plot_format(fmt):\n    \"\"\"\n    Convert a MATLAB style color/line style format string to a (*linestyle*,\n    *marker*, *color*) tuple.\n\n    Example format strings include:\n\n    * 'ko': black circles\n    * '.b': blue dots\n    * 'r--': red dashed lines\n    * 'C2--': the third color in the color cycle, dashed lines\n\n    See Also\n    --------\n    matplotlib.Line2D.lineStyles, matplotlib.colors.cnames\n        All possible styles and color format strings.\n    \"\"\"\n\n    linestyle = None\n    marker = None\n    color = None\n\n    # Is fmt just a colorspec?\n    try:\n        color = mcolors.to_rgba(fmt)\n\n        # We need to differentiate grayscale '1.0' from tri_down marker '1'\n        try:\n            fmtint = str(int(fmt))\n        except ValueError:\n            return linestyle, marker, color  # Yes\n        else:\n            if fmt != fmtint:\n                # user definitely doesn't want tri_down marker\n                return linestyle, marker, color  # Yes\n            else:\n                # ignore converted color\n                color = None\n    except ValueError:\n        pass  # No, not just a color.\n\n    i = 0\n    while i < len(fmt):\n        c = fmt[i]\n        if fmt[i:i+2] in mlines.lineStyles:  # First, the two-char styles.\n            if linestyle is not None:\n                raise ValueError(\n                    'Illegal format string \"%s\"; two linestyle symbols' % fmt)\n            linestyle = fmt[i:i+2]\n            i += 2\n        elif c in mlines.lineStyles:\n            if linestyle is not None:\n                raise ValueError(\n                    'Illegal format string \"%s\"; two linestyle symbols' % fmt)\n            linestyle = c\n            i += 1\n        elif c in mlines.lineMarkers:\n            if marker is not None:\n                raise ValueError(\n                    'Illegal format string \"%s\"; two marker symbols' % fmt)\n            marker = c\n            i += 1\n        elif c in mcolors.get_named_colors_mapping():\n            if color is not None:\n                raise ValueError(\n                    'Illegal format string \"%s\"; two color symbols' % fmt)\n            color = c\n            i += 1\n        elif c == 'C' and i < len(fmt) - 1:\n            color_cycle_number = int(fmt[i + 1])\n            color = mcolors.to_rgba(\"C{}\".format(color_cycle_number))\n            i += 2\n        else:\n            raise ValueError(\n                'Unrecognized character %c in format string' % c)\n\n    if linestyle is None and marker is None:\n        linestyle = mpl.rcParams['lines.linestyle']\n    if linestyle is None:\n        linestyle = 'None'\n    if marker is None:\n        marker = 'None'\n\n    return linestyle, marker, color",
        "begin_line": 32,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.276090374906894e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._process_plot_var_args.set_prop_cycle#142",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._process_plot_var_args",
        "signature": "lib.matplotlib.axes._base._process_plot_var_args.set_prop_cycle(self, *args, **kwargs)",
        "snippet": "    def set_prop_cycle(self, *args, **kwargs):\n        # Can't do `args == (None,)` as that crashes cycler.\n        if not (args or kwargs) or (len(args) == 1 and args[0] is None):\n            prop_cycler = mpl.rcParams['axes.prop_cycle']\n        else:\n            prop_cycler = cycler(*args, **kwargs)\n\n        self.prop_cycler = itertools.cycle(prop_cycler)\n        # This should make a copy\n        self._prop_keys = prop_cycler.keys",
        "begin_line": 142,
        "end_line": 151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003875968992248062,
            "pseudo_dstar_susp": 0.0053475935828877,
            "pseudo_tarantula_susp": 0.0006640106241699867,
            "pseudo_op2_susp": 0.005291005291005291,
            "pseudo_barinel_susp": 0.0006640106241699867
        }
    },
    {
        "name": "lib.matplotlib.axes._base._process_plot_var_args._makeline#251",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._process_plot_var_args",
        "signature": "lib.matplotlib.axes._base._process_plot_var_args._makeline(self, x, y, kw, kwargs)",
        "snippet": "    def _makeline(self, x, y, kw, kwargs):\n        kw = {**kw, **kwargs}  # Don't modify the original kw.\n        default_dict = self._getdefaults(set(), kw)\n        self._setdefaults(default_dict, kw)\n        seg = mlines.Line2D(x, y, **kw)\n        return seg",
        "begin_line": 251,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.883326763894364e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._process_plot_var_args._makefill#258",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._process_plot_var_args",
        "signature": "lib.matplotlib.axes._base._process_plot_var_args._makefill(self, x, y, kw, kwargs)",
        "snippet": "    def _makefill(self, x, y, kw, kwargs):\n        # Polygon doesn't directly support unitized inputs.\n        x = self.axes.convert_xunits(x)\n        y = self.axes.convert_yunits(y)\n\n        kw = kw.copy()  # Don't modify the original kw.\n        kwargs = kwargs.copy()\n\n        # Ignore 'marker'-related properties as they aren't Polygon\n        # properties, but they are Line2D properties, and so they are\n        # likely to appear in the default cycler construction.\n        # This is done here to the defaults dictionary as opposed to the\n        # other two dictionaries because we do want to capture when a\n        # *user* explicitly specifies a marker which should be an error.\n        # We also want to prevent advancing the cycler if there are no\n        # defaults needed after ignoring the given properties.\n        ignores = {'marker', 'markersize', 'markeredgecolor',\n                   'markerfacecolor', 'markeredgewidth'}\n        # Also ignore anything provided by *kwargs*.\n        for k, v in kwargs.items():\n            if v is not None:\n                ignores.add(k)\n\n        # Only using the first dictionary to use as basis\n        # for getting defaults for back-compat reasons.\n        # Doing it with both seems to mess things up in\n        # various places (probably due to logic bugs elsewhere).\n        default_dict = self._getdefaults(ignores, kw)\n        self._setdefaults(default_dict, kw)\n\n        # Looks like we don't want \"color\" to be interpreted to\n        # mean both facecolor and edgecolor for some reason.\n        # So the \"kw\" dictionary is thrown out, and only its\n        # 'color' value is kept and translated as a 'facecolor'.\n        # This design should probably be revisited as it increases\n        # complexity.\n        facecolor = kw.get('color', None)\n\n        # Throw out 'color' as it is now handled as a facecolor\n        default_dict.pop('color', None)\n\n        # To get other properties set from the cycler\n        # modify the kwargs dictionary.\n        self._setdefaults(default_dict, kwargs)\n\n        seg = mpatches.Polygon(np.column_stack((x, y)),\n                               facecolor=facecolor,\n                               fill=kwargs.get('fill', True),\n                               closed=kw['closed'])\n        seg.set(**kwargs)\n        return seg",
        "begin_line": 258,
        "end_line": 308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._process_plot_var_args._plot_args#310",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._process_plot_var_args",
        "signature": "lib.matplotlib.axes._base._process_plot_var_args._plot_args(self, tup, kwargs)",
        "snippet": "    def _plot_args(self, tup, kwargs):\n        if len(tup) > 1 and isinstance(tup[-1], str):\n            linestyle, marker, color = _process_plot_format(tup[-1])\n            tup = tup[:-1]\n        elif len(tup) == 3:\n            raise ValueError('third arg must be a format string')\n        else:\n            linestyle, marker, color = None, None, None\n\n        # Don't allow any None value; these would be up-converted to one\n        # element array of None which causes problems downstream.\n        if any(v is None for v in tup):\n            raise ValueError(\"x, y, and format string must not be None\")\n\n        kw = {}\n        for k, v in zip(('linestyle', 'marker', 'color'),\n                        (linestyle, marker, color)):\n            if v is not None:\n                kw[k] = v\n\n        if len(tup) == 2:\n            x = _check_1d(tup[0])\n            y = _check_1d(tup[-1])\n        else:\n            x, y = index_of(tup[-1])\n\n        if self.axes.xaxis is not None:\n            self.axes.xaxis.update_units(x)\n        if self.axes.yaxis is not None:\n            self.axes.yaxis.update_units(y)\n\n        if x.shape[0] != y.shape[0]:\n            raise ValueError(f\"x and y must have same first dimension, but \"\n                             f\"have shapes {x.shape} and {y.shape}\")\n        if x.ndim > 2 or y.ndim > 2:\n            raise ValueError(f\"x and y can be no greater than 2-D, but have \"\n                             f\"shapes {x.shape} and {y.shape}\")\n        if x.ndim == 1:\n            x = x[:, np.newaxis]\n        if y.ndim == 1:\n            y = y[:, np.newaxis]\n\n        if self.command == 'plot':\n            func = self._makeline\n        else:\n            kw['closed'] = kwargs.get('closed', True)\n            func = self._makefill\n\n        ncx, ncy = x.shape[1], y.shape[1]\n        if ncx > 1 and ncy > 1 and ncx != ncy:\n            raise ValueError(f\"x has {ncx} columns but y has {ncy} columns\")\n        return [func(x[:, j % ncx], y[:, j % ncy], kw, kwargs)\n                for j in range(max(ncx, ncy))]",
        "begin_line": 310,
        "end_line": 362,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005431830526887561,
            "pseudo_dstar_susp": 0.0004170141784820684,
            "pseudo_tarantula_susp": 0.0021645021645021645,
            "pseudo_op2_susp": 0.0004170141784820684,
            "pseudo_barinel_susp": 0.0021645021645021645
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.__init__#377",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.__init__(self, fig, rect, facecolor=None, frameon=True, sharex=None, sharey=None, label='', xscale=None, yscale=None, box_aspect=None, **kwargs)",
        "snippet": "    def __init__(self, fig, rect,\n                 facecolor=None,  # defaults to rc axes.facecolor\n                 frameon=True,\n                 sharex=None,  # use Axes instance's xaxis info\n                 sharey=None,  # use Axes instance's yaxis info\n                 label='',\n                 xscale=None,\n                 yscale=None,\n                 box_aspect=None,\n                 **kwargs\n                 ):\n        \"\"\"\n        Build an axes in a figure.\n\n        Parameters\n        ----------\n        fig : `~matplotlib.figure.Figure`\n            The axes is build in the `.Figure` *fig*.\n\n        rect : [left, bottom, width, height]\n            The axes is build in the rectangle *rect*. *rect* is in\n            `.Figure` coordinates.\n\n        sharex, sharey : `~.axes.Axes`, optional\n            The x or y `~.matplotlib.axis` is shared with the x or\n            y axis in the input `~.axes.Axes`.\n\n        frameon : bool, optional\n            True means that the axes frame is visible.\n\n        box_aspect : None, or a number, optional\n            Sets the aspect of the axes box. See `~.axes.Axes.set_box_aspect`\n            for details.\n\n        **kwargs\n            Other optional keyword arguments:\n\n            %(Axes)s\n\n        Returns\n        -------\n        axes : `~.axes.Axes`\n            The new `~.axes.Axes` object.\n        \"\"\"\n\n        martist.Artist.__init__(self)\n        if isinstance(rect, mtransforms.Bbox):\n            self._position = rect\n        else:\n            self._position = mtransforms.Bbox.from_bounds(*rect)\n        if self._position.width < 0 or self._position.height < 0:\n            raise ValueError('Width and height specified must be non-negative')\n        self._originalPosition = self._position.frozen()\n        self.axes = self\n        self._aspect = 'auto'\n        self._adjustable = 'box'\n        self._anchor = 'C'\n        self._stale_viewlim_x = False\n        self._stale_viewlim_y = False\n        self._sharex = sharex\n        self._sharey = sharey\n        if sharex is not None:\n            if not isinstance(sharex, _AxesBase):\n                raise TypeError('sharex must be an axes, not a bool')\n            self._shared_x_axes.join(self, sharex)\n        if sharey is not None:\n            if not isinstance(sharey, _AxesBase):\n                raise TypeError('sharey must be an axes, not a bool')\n            self._shared_y_axes.join(self, sharey)\n        self.set_label(label)\n        self.set_figure(fig)\n        self.set_box_aspect(box_aspect)\n        self.set_axes_locator(kwargs.get(\"axes_locator\", None))\n\n        self.spines = self._gen_axes_spines()\n\n        # this call may differ for non-sep axes, e.g., polar\n        self._init_axis()\n        if facecolor is None:\n            facecolor = mpl.rcParams['axes.facecolor']\n        self._facecolor = facecolor\n        self._frameon = frameon\n        self.set_axisbelow(mpl.rcParams['axes.axisbelow'])\n\n        self._rasterization_zorder = None\n        self.cla()\n\n        # funcs used to format x and y - fall back on major formatters\n        self.fmt_xdata = None\n        self.fmt_ydata = None\n\n        self.set_navigate(True)\n        self.set_navigate_mode(None)\n\n        if xscale:\n            self.set_xscale(xscale)\n        if yscale:\n            self.set_yscale(yscale)\n\n        self.update(kwargs)\n\n        if self.xaxis is not None:\n            self._xcid = self.xaxis.callbacks.connect(\n                'units finalize', lambda: self._on_units_changed(scalex=True))\n\n        if self.yaxis is not None:\n            self._ycid = self.yaxis.callbacks.connect(\n                'units finalize', lambda: self._on_units_changed(scaley=True))\n\n        rcParams = mpl.rcParams\n        self.tick_params(\n            top=rcParams['xtick.top'] and rcParams['xtick.minor.top'],\n            bottom=rcParams['xtick.bottom'] and rcParams['xtick.minor.bottom'],\n            labeltop=(rcParams['xtick.labeltop'] and\n                      rcParams['xtick.minor.top']),\n            labelbottom=(rcParams['xtick.labelbottom'] and\n                         rcParams['xtick.minor.bottom']),\n            left=rcParams['ytick.left'] and rcParams['ytick.minor.left'],\n            right=rcParams['ytick.right'] and rcParams['ytick.minor.right'],\n            labelleft=(rcParams['ytick.labelleft'] and\n                       rcParams['ytick.minor.left']),\n            labelright=(rcParams['ytick.labelright'] and\n                        rcParams['ytick.minor.right']),\n            which='minor')\n\n        self.tick_params(\n            top=rcParams['xtick.top'] and rcParams['xtick.major.top'],\n            bottom=rcParams['xtick.bottom'] and rcParams['xtick.major.bottom'],\n            labeltop=(rcParams['xtick.labeltop'] and\n                      rcParams['xtick.major.top']),\n            labelbottom=(rcParams['xtick.labelbottom'] and\n                         rcParams['xtick.major.bottom']),\n            left=rcParams['ytick.left'] and rcParams['ytick.major.left'],\n            right=rcParams['ytick.right'] and rcParams['ytick.major.right'],\n            labelleft=(rcParams['ytick.labelleft'] and\n                       rcParams['ytick.major.left']),\n            labelright=(rcParams['ytick.labelright'] and\n                        rcParams['ytick.major.right']),\n            which='major')\n\n        self._layoutbox = None\n        self._poslayoutbox = None",
        "begin_line": 377,
        "end_line": 518,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024154589371980675,
            "pseudo_dstar_susp": 0.001091703056768559,
            "pseudo_tarantula_susp": 0.0008210180623973727,
            "pseudo_op2_susp": 0.001091703056768559,
            "pseudo_barinel_susp": 0.0008210180623973727
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.__getstate__#520",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.__getstate__(self)",
        "snippet": "    def __getstate__(self):\n        # The renderer should be re-created by the figure, and then cached at\n        # that point.\n        state = super().__getstate__()\n        for key in ['_layoutbox', '_poslayoutbox']:\n            state[key] = None\n        # Prune the sharing & twinning info to only contain the current group.\n        for grouper_name in [\n                '_shared_x_axes', '_shared_y_axes', '_twinned_axes']:\n            grouper = getattr(self, grouper_name)\n            state[grouper_name] = (grouper.get_siblings(self)\n                                   if self in grouper else None)\n        return state",
        "begin_line": 520,
        "end_line": 532,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_window_extent#544",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_window_extent(self, *args, **kwargs)",
        "snippet": "    def get_window_extent(self, *args, **kwargs):\n        \"\"\"\n        Return the axes bounding box in display space; *args* and *kwargs*\n        are empty.\n\n        This bounding box does not include the spines, ticks, ticklables,\n        or other labels.  For a bounding box including these elements use\n        `~matplotlib.axes.Axes.get_tightbbox`.\n\n        See Also\n        --------\n        matplotlib.axes.Axes.get_tightbbox\n        matplotlib.axis.Axis.get_tightbbox\n        matplotlib.spines.get_window_extent\n\n        \"\"\"\n        return self.bbox",
        "begin_line": 544,
        "end_line": 560,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.46880030300161e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._init_axis#562",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._init_axis(self)",
        "snippet": "    def _init_axis(self):\n        # This is moved out of __init__ because non-separable axes don't use it\n        self.xaxis = maxis.XAxis(self)\n        self.spines['bottom'].register_axis(self.xaxis)\n        self.spines['top'].register_axis(self.xaxis)\n        self.yaxis = maxis.YAxis(self)\n        self.spines['left'].register_axis(self.yaxis)\n        self.spines['right'].register_axis(self.yaxis)\n        self._update_transScale()",
        "begin_line": 562,
        "end_line": 570,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017730496453900709,
            "pseudo_dstar_susp": 0.0009950248756218905,
            "pseudo_tarantula_susp": 0.0007102272727272727,
            "pseudo_op2_susp": 0.0009950248756218905,
            "pseudo_barinel_susp": 0.0007102272727272727
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_figure#572",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_figure(self, fig)",
        "snippet": "    def set_figure(self, fig):\n        \"\"\"\n        Set the `.Figure` for this `.Axes`.\n\n        Parameters\n        ----------\n        fig : `.Figure`\n        \"\"\"\n        martist.Artist.set_figure(self, fig)\n\n        self.bbox = mtransforms.TransformedBbox(self._position,\n                                                fig.transFigure)\n        # these will be updated later as data is added\n        self.dataLim = mtransforms.Bbox.null()\n        self._viewLim = mtransforms.Bbox.unit()\n        self.transScale = mtransforms.TransformWrapper(\n            mtransforms.IdentityTransform())\n\n        self._set_lim_and_transforms()",
        "begin_line": 572,
        "end_line": 590,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001564945226917058,
            "pseudo_dstar_susp": 0.0009633911368015414,
            "pseudo_tarantula_susp": 0.0006540222367560497,
            "pseudo_op2_susp": 0.0009633911368015414,
            "pseudo_barinel_susp": 0.0006540222367560497
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._unstale_viewLim#592",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._unstale_viewLim(self)",
        "snippet": "    def _unstale_viewLim(self):\n        # We should arrange to store this information once per share-group\n        # instead of on every axis.\n        scalex = any(ax._stale_viewlim_x\n                     for ax in self._shared_x_axes.get_siblings(self))\n        scaley = any(ax._stale_viewlim_y\n                     for ax in self._shared_y_axes.get_siblings(self))\n        if scalex or scaley:\n            for ax in self._shared_x_axes.get_siblings(self):\n                ax._stale_viewlim_x = False\n            for ax in self._shared_y_axes.get_siblings(self):\n                ax._stale_viewlim_y = False\n            self.autoscale_view(scalex=scalex, scaley=scaley)",
        "begin_line": 592,
        "end_line": 604,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00030175015087507544,
            "pseudo_dstar_susp": 0.00030129557095510696,
            "pseudo_tarantula_susp": 0.00031867431485022306,
            "pseudo_op2_susp": 0.00030129557095510696,
            "pseudo_barinel_susp": 0.00031867431485022306
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.viewLim#607",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.viewLim(self)",
        "snippet": "    def viewLim(self):\n        self._unstale_viewLim()\n        return self._viewLim",
        "begin_line": 607,
        "end_line": 609,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002778549597110308,
            "pseudo_dstar_susp": 0.0002778549597110308,
            "pseudo_tarantula_susp": 0.0002809778027535825,
            "pseudo_op2_susp": 0.0002778549597110308,
            "pseudo_barinel_susp": 0.0002809778027535825
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._request_autoscale_view#613",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._request_autoscale_view(self, tight=None, scalex=True, scaley=True)",
        "snippet": "    def _request_autoscale_view(self, tight=None, scalex=True, scaley=True):\n        if tight is not None:\n            self._tight = tight\n        if scalex:\n            self._stale_viewlim_x = True  # Else keep old state.\n        if scaley:\n            self._stale_viewlim_y = True",
        "begin_line": 613,
        "end_line": 619,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004224757076468103,
            "pseudo_dstar_susp": 0.0005847953216374269,
            "pseudo_tarantula_susp": 0.0010834236186348862,
            "pseudo_op2_susp": 0.0005847953216374269,
            "pseudo_barinel_susp": 0.0010893246187363835
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._set_lim_and_transforms#621",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._set_lim_and_transforms(self)",
        "snippet": "    def _set_lim_and_transforms(self):\n        \"\"\"\n        Set the *_xaxis_transform*, *_yaxis_transform*, *transScale*,\n        *transData*, *transLimits* and *transAxes* transformations.\n\n        .. note::\n\n            This method is primarily used by rectilinear projections of the\n            `~matplotlib.axes.Axes` class, and is meant to be overridden by\n            new kinds of projection axes that need different transformations\n            and limits. (See `~matplotlib.projections.polar.PolarAxes` for an\n            example.)\n        \"\"\"\n        self.transAxes = mtransforms.BboxTransformTo(self.bbox)\n\n        # Transforms the x and y axis separately by a scale factor.\n        # It is assumed that this part will have non-linear components\n        # (e.g., for a log scale).\n        self.transScale = mtransforms.TransformWrapper(\n            mtransforms.IdentityTransform())\n\n        # An affine transformation on the data, generally to limit the\n        # range of the axes\n        self.transLimits = mtransforms.BboxTransformFrom(\n            mtransforms.TransformedBbox(self._viewLim, self.transScale))\n\n        # The parentheses are important for efficiency here -- they\n        # group the last two (which are usually affines) separately\n        # from the first (which, with log-scaling can be non-affine).\n        self.transData = self.transScale + (self.transLimits + self.transAxes)\n\n        self._xaxis_transform = mtransforms.blended_transform_factory(\n            self.transData, self.transAxes)\n        self._yaxis_transform = mtransforms.blended_transform_factory(\n            self.transAxes, self.transData)",
        "begin_line": 621,
        "end_line": 655,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002197802197802198,
            "pseudo_dstar_susp": 0.0010471204188481676,
            "pseudo_tarantula_susp": 0.0012987012987012987,
            "pseudo_op2_susp": 0.0010471204188481676,
            "pseudo_barinel_susp": 0.0012987012987012987
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_xaxis_transform#657",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_xaxis_transform(self, which='grid')",
        "snippet": "    def get_xaxis_transform(self, which='grid'):\n        \"\"\"\n        Get the transformation used for drawing x-axis labels, ticks\n        and gridlines.  The x-direction is in data coordinates and the\n        y-direction is in axis coordinates.\n\n        .. note::\n\n            This transformation is primarily used by the\n            `~matplotlib.axis.Axis` class, and is meant to be\n            overridden by new kinds of projections that may need to\n            place axis elements in different locations.\n        \"\"\"\n        if which == 'grid':\n            return self._xaxis_transform\n        elif which == 'tick1':\n            # for cartesian projection, this is bottom spine\n            return self.spines['bottom'].get_spine_transform()\n        elif which == 'tick2':\n            # for cartesian projection, this is top spine\n            return self.spines['top'].get_spine_transform()\n        else:\n            raise ValueError('unknown value for which')",
        "begin_line": 657,
        "end_line": 679,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014925373134328358,
            "pseudo_dstar_susp": 0.000946073793755913,
            "pseudo_tarantula_susp": 0.0007358351729212656,
            "pseudo_op2_susp": 0.000946073793755913,
            "pseudo_barinel_susp": 0.0007358351729212656
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_xaxis_text1_transform#681",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_xaxis_text1_transform(self, pad_points)",
        "snippet": "    def get_xaxis_text1_transform(self, pad_points):\n        \"\"\"\n        Returns\n        -------\n        transform : Transform\n            The transform used for drawing x-axis labels, which will add\n            *pad_points* of padding (in points) between the axes and the label.\n            The x-direction is in data coordinates and the y-direction is in\n            axis corrdinates\n        valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n            The text vertical alignment.\n        halign : {'center', 'left', 'right'}\n            The text horizontal alignment.\n\n        Notes\n        -----\n        This transformation is primarily used by the `~matplotlib.axis.Axis`\n        class, and is meant to be overridden by new kinds of projections that\n        may need to place axis elements in different locations.\n        \"\"\"\n        labels_align = mpl.rcParams[\"xtick.alignment\"]\n        return (self.get_xaxis_transform(which='tick1') +\n                mtransforms.ScaledTranslation(0, -1 * pad_points / 72,\n                                              self.figure.dpi_scale_trans),\n                \"top\", labels_align)",
        "begin_line": 681,
        "end_line": 705,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029154518950437317,
            "pseudo_dstar_susp": 0.001152073732718894,
            "pseudo_tarantula_susp": 0.0009191176470588235,
            "pseudo_op2_susp": 0.001152073732718894,
            "pseudo_barinel_susp": 0.0009191176470588235
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_xaxis_text2_transform#707",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_xaxis_text2_transform(self, pad_points)",
        "snippet": "    def get_xaxis_text2_transform(self, pad_points):\n        \"\"\"\n        Returns\n        -------\n        transform : Transform\n            The transform used for drawing secondary x-axis labels, which will\n            add *pad_points* of padding (in points) between the axes and the\n            label.  The x-direction is in data coordinates and the y-direction\n            is in axis corrdinates\n        valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n            The text vertical alignment.\n        halign : {'center', 'left', 'right'}\n            The text horizontal alignment.\n\n        Notes\n        -----\n        This transformation is primarily used by the `~matplotlib.axis.Axis`\n        class, and is meant to be overridden by new kinds of projections that\n        may need to place axis elements in different locations.\n        \"\"\"\n        labels_align = mpl.rcParams[\"xtick.alignment\"]\n        return (self.get_xaxis_transform(which='tick2') +\n                mtransforms.ScaledTranslation(0, pad_points / 72,\n                                              self.figure.dpi_scale_trans),\n                \"bottom\", labels_align)",
        "begin_line": 707,
        "end_line": 731,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029239766081871343,
            "pseudo_dstar_susp": 0.0011534025374855825,
            "pseudo_tarantula_susp": 0.0009199632014719411,
            "pseudo_op2_susp": 0.0011534025374855825,
            "pseudo_barinel_susp": 0.0009199632014719411
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_yaxis_transform#733",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_yaxis_transform(self, which='grid')",
        "snippet": "    def get_yaxis_transform(self, which='grid'):\n        \"\"\"\n        Get the transformation used for drawing y-axis labels, ticks\n        and gridlines.  The x-direction is in axis coordinates and the\n        y-direction is in data coordinates.\n\n        .. note::\n\n            This transformation is primarily used by the\n            `~matplotlib.axis.Axis` class, and is meant to be\n            overridden by new kinds of projections that may need to\n            place axis elements in different locations.\n        \"\"\"\n        if which == 'grid':\n            return self._yaxis_transform\n        elif which == 'tick1':\n            # for cartesian projection, this is bottom spine\n            return self.spines['left'].get_spine_transform()\n        elif which == 'tick2':\n            # for cartesian projection, this is top spine\n            return self.spines['right'].get_spine_transform()\n        else:\n            raise ValueError('unknown value for which')",
        "begin_line": 733,
        "end_line": 755,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0030303030303030303,
            "pseudo_dstar_susp": 0.001160092807424594,
            "pseudo_tarantula_susp": 0.0009532888465204957,
            "pseudo_op2_susp": 0.001160092807424594,
            "pseudo_barinel_susp": 0.0009532888465204957
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_yaxis_text1_transform#757",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_yaxis_text1_transform(self, pad_points)",
        "snippet": "    def get_yaxis_text1_transform(self, pad_points):\n        \"\"\"\n        Returns\n        -------\n        transform : Transform\n            The transform used for drawing y-axis labels, which will add\n            *pad_points* of padding (in points) between the axes and the label.\n            The x-direction is in axis coordinates and the y-direction is in\n            data corrdinates\n        valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n            The text vertical alignment.\n        halign : {'center', 'left', 'right'}\n            The text horizontal alignment.\n\n        Notes\n        -----\n        This transformation is primarily used by the `~matplotlib.axis.Axis`\n        class, and is meant to be overridden by new kinds of projections that\n        may need to place axis elements in different locations.\n        \"\"\"\n        labels_align = mpl.rcParams[\"ytick.alignment\"]\n        return (self.get_yaxis_transform(which='tick1') +\n                mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,\n                                              self.figure.dpi_scale_trans),\n                labels_align, \"right\")",
        "begin_line": 757,
        "end_line": 781,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002512562814070352,
            "pseudo_dstar_susp": 0.0011049723756906078,
            "pseudo_tarantula_susp": 0.0009115770282588879,
            "pseudo_op2_susp": 0.0011049723756906078,
            "pseudo_barinel_susp": 0.0009115770282588879
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_yaxis_text2_transform#783",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_yaxis_text2_transform(self, pad_points)",
        "snippet": "    def get_yaxis_text2_transform(self, pad_points):\n        \"\"\"\n        Returns\n        -------\n        transform : Transform\n            The transform used for drawing secondart y-axis labels, which will\n            add *pad_points* of padding (in points) between the axes and the\n            label.  The x-direction is in axis coordinates and the y-direction\n            is in data corrdinates\n        valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n            The text vertical alignment.\n        halign : {'center', 'left', 'right'}\n            The text horizontal alignment.\n\n        Notes\n        -----\n        This transformation is primarily used by the `~matplotlib.axis.Axis`\n        class, and is meant to be overridden by new kinds of projections that\n        may need to place axis elements in different locations.\n        \"\"\"\n        labels_align = mpl.rcParams[\"ytick.alignment\"]\n        return (self.get_yaxis_transform(which='tick2') +\n                mtransforms.ScaledTranslation(pad_points / 72, 0,\n                                              self.figure.dpi_scale_trans),\n                labels_align, \"left\")",
        "begin_line": 783,
        "end_line": 807,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002881844380403458,
            "pseudo_dstar_susp": 0.0011494252873563218,
            "pseudo_tarantula_susp": 0.0009049773755656109,
            "pseudo_op2_susp": 0.0011494252873563218,
            "pseudo_barinel_susp": 0.0009049773755656109
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._update_transScale#809",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._update_transScale(self)",
        "snippet": "    def _update_transScale(self):\n        self.transScale.set(\n            mtransforms.blended_transform_factory(\n                self.xaxis.get_transform(), self.yaxis.get_transform()))\n        for line in getattr(self, \"lines\", []):  # Not set during init.\n            try:\n                line._transformed_path.invalidate()\n            except AttributeError:\n                pass",
        "begin_line": 809,
        "end_line": 817,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028653295128939827,
            "pseudo_dstar_susp": 0.0011467889908256881,
            "pseudo_tarantula_susp": 0.0009017132551848512,
            "pseudo_op2_susp": 0.0011467889908256881,
            "pseudo_barinel_susp": 0.0009017132551848512
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_position#819",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_position(self, original=False)",
        "snippet": "    def get_position(self, original=False):\n        \"\"\"\n        Get a copy of the axes rectangle as a `.Bbox`.\n\n        Parameters\n        ----------\n        original : bool\n            If ``True``, return the original position. Otherwise return the\n            active position. For an explanation of the positions see\n            `.set_position`.\n\n        Returns\n        -------\n        pos : `.Bbox`\n\n        \"\"\"\n        if original:\n            return self._originalPosition.frozen()\n        else:\n            locator = self.get_axes_locator()\n            if not locator:\n                self.apply_aspect()\n            return self._position.frozen()",
        "begin_line": 819,
        "end_line": 841,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._set_position#868",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._set_position(self, pos, which='both')",
        "snippet": "    def _set_position(self, pos, which='both'):\n        \"\"\"\n        private version of set_position.  Call this internally\n        to get the same functionality of `get_position`, but not\n        to take the axis out of the constrained_layout\n        hierarchy.\n        \"\"\"\n        if not isinstance(pos, mtransforms.BboxBase):\n            pos = mtransforms.Bbox.from_bounds(*pos)\n        for ax in self._twinned_axes.get_siblings(self):\n            if which in ('both', 'active'):\n                ax._position.set(pos)\n            if which in ('both', 'original'):\n                ax._originalPosition.set(pos)\n        self.stale = True",
        "begin_line": 868,
        "end_line": 882,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_axes_locator#895",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_axes_locator(self, locator)",
        "snippet": "    def set_axes_locator(self, locator):\n        \"\"\"\n        Set the axes locator.\n\n        Parameters\n        ----------\n        locator : Callable[[Axes, Renderer], Bbox]\n        \"\"\"\n        self._axes_locator = locator\n        self.stale = True",
        "begin_line": 895,
        "end_line": 904,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017699115044247787,
            "pseudo_dstar_susp": 0.0009940357852882703,
            "pseudo_tarantula_susp": 0.0007092198581560284,
            "pseudo_op2_susp": 0.0009940357852882703,
            "pseudo_barinel_susp": 0.0007092198581560284
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._set_artist_props#912",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._set_artist_props(self, a)",
        "snippet": "    def _set_artist_props(self, a):\n        \"\"\"set the boilerplate props for artists added to axes\"\"\"\n        a.set_figure(self.figure)\n        if not a.is_transform_set():\n            a.set_transform(self.transData)\n\n        a.axes = self\n        if a.mouseover:\n            self._mouseover_set.add(a)",
        "begin_line": 912,
        "end_line": 920,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022988505747126436,
            "pseudo_dstar_susp": 0.0010672358591248667,
            "pseudo_tarantula_susp": 0.0015337423312883436,
            "pseudo_op2_susp": 0.0010672358591248667,
            "pseudo_barinel_susp": 0.0015337423312883436
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._gen_axes_patch#922",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._gen_axes_patch(self)",
        "snippet": "    def _gen_axes_patch(self):\n        \"\"\"\n        Returns\n        -------\n        Patch\n            The patch used to draw the background of the axes.  It is also used\n            as the clipping path for any data elements on the axes.\n\n            In the standard axes, this is a rectangle, but in other projections\n            it may not be.\n\n        Notes\n        -----\n        Intended to be overridden by new projection types.\n        \"\"\"\n        return mpatches.Rectangle((0.0, 0.0), 1.0, 1.0)",
        "begin_line": 922,
        "end_line": 937,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003728560775540641,
            "pseudo_dstar_susp": 0.0003450655624568668,
            "pseudo_tarantula_susp": 0.0007027406886858749,
            "pseudo_op2_susp": 0.0003450655624568668,
            "pseudo_barinel_susp": 0.0007027406886858749
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.cla#957",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.cla(self)",
        "snippet": "    def cla(self):\n        \"\"\"Clear the current axes.\"\"\"\n        # Note: this is called by Axes.__init__()\n\n        # stash the current visibility state\n        if hasattr(self, 'patch'):\n            patch_visible = self.patch.get_visible()\n        else:\n            patch_visible = True\n\n        xaxis_visible = self.xaxis.get_visible()\n        yaxis_visible = self.yaxis.get_visible()\n\n        self.xaxis.cla()\n        self.yaxis.cla()\n\n        for name, spine in self.spines.items():\n            spine.cla()\n\n        self.ignore_existing_data_limits = True\n        self.callbacks = cbook.CallbackRegistry()\n\n        if self._sharex is not None:\n            # major and minor are axis.Ticker class instances with\n            # locator and formatter attributes\n            self.xaxis.major = self._sharex.xaxis.major\n            self.xaxis.minor = self._sharex.xaxis.minor\n            x0, x1 = self._sharex.get_xlim()\n            self.set_xlim(x0, x1, emit=False,\n                          auto=self._sharex.get_autoscalex_on())\n            self.xaxis._scale = self._sharex.xaxis._scale\n        else:\n            self.xaxis._set_scale('linear')\n            try:\n                self.set_xlim(0, 1)\n            except TypeError:\n                pass\n\n        if self._sharey is not None:\n            self.yaxis.major = self._sharey.yaxis.major\n            self.yaxis.minor = self._sharey.yaxis.minor\n            y0, y1 = self._sharey.get_ylim()\n            self.set_ylim(y0, y1, emit=False,\n                          auto=self._sharey.get_autoscaley_on())\n            self.yaxis._scale = self._sharey.yaxis._scale\n        else:\n            self.yaxis._set_scale('linear')\n            try:\n                self.set_ylim(0, 1)\n            except TypeError:\n                pass\n        # update the minor locator for x and y axis based on rcParams\n        if mpl.rcParams['xtick.minor.visible']:\n            self.xaxis.set_minor_locator(mticker.AutoMinorLocator())\n\n        if mpl.rcParams['ytick.minor.visible']:\n            self.yaxis.set_minor_locator(mticker.AutoMinorLocator())\n\n        if self._sharex is None:\n            self._autoscaleXon = True\n        if self._sharey is None:\n            self._autoscaleYon = True\n        self._xmargin = mpl.rcParams['axes.xmargin']\n        self._ymargin = mpl.rcParams['axes.ymargin']\n        self._tight = None\n        self._use_sticky_edges = True\n        self._update_transScale()  # needed?\n\n        self._get_lines = _process_plot_var_args(self)\n        self._get_patches_for_fill = _process_plot_var_args(self, 'fill')\n\n        self._gridOn = mpl.rcParams['axes.grid']\n        self.lines = []\n        self.patches = []\n        self.texts = []\n        self.tables = []\n        self.artists = []\n        self.images = []\n        self._mouseover_set = _OrderedSet()\n        self.child_axes = []\n        self._current_image = None  # strictly for pyplot via _sci, _gci\n        self.legend_ = None\n        self.collections = []  # collection.Collection instances\n        self.containers = []\n\n        self.grid(False)  # Disable grid on init to use rcParameter\n        self.grid(self._gridOn, which=mpl.rcParams['axes.grid.which'],\n                  axis=mpl.rcParams['axes.grid.axis'])\n        props = font_manager.FontProperties(\n            size=mpl.rcParams['axes.titlesize'],\n            weight=mpl.rcParams['axes.titleweight'])\n\n        self.title = mtext.Text(\n            x=0.5, y=1.0, text='',\n            fontproperties=props,\n            verticalalignment='baseline',\n            horizontalalignment='center',\n            )\n        self._left_title = mtext.Text(\n            x=0.0, y=1.0, text='',\n            fontproperties=props.copy(),\n            verticalalignment='baseline',\n            horizontalalignment='left', )\n        self._right_title = mtext.Text(\n            x=1.0, y=1.0, text='',\n            fontproperties=props.copy(),\n            verticalalignment='baseline',\n            horizontalalignment='right',\n            )\n        title_offset_points = mpl.rcParams['axes.titlepad']\n        # refactor this out so it can be called in ax.set_title if\n        # pad argument used...\n        self._set_title_offset_trans(title_offset_points)\n        # determine if the title position has been set manually:\n        self._autotitlepos = None\n\n        for _title in (self.title, self._left_title, self._right_title):\n            self._set_artist_props(_title)\n\n        # The patch draws the background of the axes.  We want this to be below\n        # the other artists.  We use the frame to draw the edges so we are\n        # setting the edgecolor to None.\n        self.patch = self._gen_axes_patch()\n        self.patch.set_figure(self.figure)\n        self.patch.set_facecolor(self._facecolor)\n        self.patch.set_edgecolor('None')\n        self.patch.set_linewidth(0)\n        self.patch.set_transform(self.transAxes)\n\n        self.set_axis_on()\n\n        self.xaxis.set_clip_path(self.patch)\n        self.yaxis.set_clip_path(self.patch)\n\n        self._shared_x_axes.clean()\n        self._shared_y_axes.clean()\n        if self._sharex:\n            self.xaxis.set_visible(xaxis_visible)\n            self.patch.set_visible(patch_visible)\n\n        if self._sharey:\n            self.yaxis.set_visible(yaxis_visible)\n            self.patch.set_visible(patch_visible)\n\n        self.stale = True",
        "begin_line": 957,
        "end_line": 1101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002457002457002457,
            "pseudo_dstar_susp": 0.0026595744680851063,
            "pseudo_tarantula_susp": 0.002398081534772182,
            "pseudo_op2_susp": 0.0026595744680851063,
            "pseudo_barinel_susp": 0.002398081534772182
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_facecolor#1107",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_facecolor(self)",
        "snippet": "    def get_facecolor(self):\n        \"\"\"Get the facecolor of the Axes.\"\"\"\n        return self.patch.get_facecolor()",
        "begin_line": 1107,
        "end_line": 1109,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._set_title_offset_trans#1123",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._set_title_offset_trans(self, title_offset_points)",
        "snippet": "    def _set_title_offset_trans(self, title_offset_points):\n        \"\"\"\n        Set the offset for the title either from :rc:`axes.titlepad`\n        or from set_title kwarg ``pad``.\n        \"\"\"\n        self.titleOffsetTrans = mtransforms.ScaledTranslation(\n                0.0, title_offset_points / 72,\n                self.figure.dpi_scale_trans)\n        for _title in (self.title, self._left_title, self._right_title):\n            _title.set_transform(self.transAxes + self.titleOffsetTrans)\n            _title.set_clip_box(None)",
        "begin_line": 1123,
        "end_line": 1133,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001321003963011889,
            "pseudo_dstar_susp": 0.002403846153846154,
            "pseudo_tarantula_susp": 0.0008077544426494346,
            "pseudo_op2_susp": 0.002403846153846154,
            "pseudo_barinel_susp": 0.0008077544426494346
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_prop_cycle#1135",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_prop_cycle(self, *args, **kwargs)",
        "snippet": "    def set_prop_cycle(self, *args, **kwargs):\n        \"\"\"\n        Set the property cycle of the Axes.\n\n        The property cycle controls the style properties such as color,\n        marker and linestyle of future plot commands. The style properties\n        of data already added to the Axes are not modified.\n\n        Call signatures::\n\n          set_prop_cycle(cycler)\n          set_prop_cycle(label=values[, label2=values2[, ...]])\n          set_prop_cycle(label, values)\n\n        Form 1 sets given `~cycler.Cycler` object.\n\n        Form 2 creates a `~cycler.Cycler` which cycles over one or more\n        properties simultaneously and set it as the property cycle of the\n        axes. If multiple properties are given, their value lists must have\n        the same length. This is just a shortcut for explicitly creating a\n        cycler and passing it to the function, i.e. it's short for\n        ``set_prop_cycle(cycler(label=values label2=values2, ...))``.\n\n        Form 3 creates a `~cycler.Cycler` for a single property and set it\n        as the property cycle of the axes. This form exists for compatibility\n        with the original `cycler.cycler` interface. Its use is discouraged\n        in favor of the kwarg form, i.e. ``set_prop_cycle(label=values)``.\n\n        Parameters\n        ----------\n        cycler : Cycler\n            Set the given Cycler. *None* resets to the cycle defined by the\n            current style.\n\n        label : str\n            The property key. Must be a valid `.Artist` property.\n            For example, 'color' or 'linestyle'. Aliases are allowed,\n            such as 'c' for 'color' and 'lw' for 'linewidth'.\n\n        values : iterable\n            Finite-length iterable of the property values. These values\n            are validated and will raise a ValueError if invalid.\n\n        Examples\n        --------\n        Setting the property cycle for a single property:\n\n        >>> ax.set_prop_cycle(color=['red', 'green', 'blue'])\n\n        Setting the property cycle for simultaneously cycling over multiple\n        properties (e.g. red circle, green plus, blue cross):\n\n        >>> ax.set_prop_cycle(color=['red', 'green', 'blue'],\n        ...                   marker=['o', '+', 'x'])\n\n        See Also\n        --------\n        matplotlib.rcsetup.cycler\n            Convenience function for creating validated cyclers for properties.\n        cycler.cycler\n            The original function for creating unvalidated cyclers.\n\n        \"\"\"\n        if args and kwargs:\n            raise TypeError(\"Cannot supply both positional and keyword \"\n                            \"arguments to this method.\")\n        # Can't do `args == (None,)` as that crashes cycler.\n        if len(args) == 1 and args[0] is None:\n            prop_cycle = None\n        else:\n            prop_cycle = cycler(*args, **kwargs)\n        self._get_lines.set_prop_cycle(prop_cycle)\n        self._get_patches_for_fill.set_prop_cycle(prop_cycle)",
        "begin_line": 1135,
        "end_line": 1207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_aspect#1209",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_aspect(self)",
        "snippet": "    def get_aspect(self):\n        return self._aspect",
        "begin_line": 1209,
        "end_line": 1210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038880248833592535,
            "pseudo_dstar_susp": 0.00035816618911174784,
            "pseudo_tarantula_susp": 0.0008305647840531562,
            "pseudo_op2_susp": 0.00035816618911174784,
            "pseudo_barinel_susp": 0.0008305647840531562
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_aspect#1212",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_aspect(self, aspect, adjustable=None, anchor=None, share=False)",
        "snippet": "    def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):\n        \"\"\"\n        Set the aspect of the axis scaling, i.e. the ratio of y-unit to x-unit.\n\n        Parameters\n        ----------\n        aspect : {'auto'} or num\n            Possible values:\n\n            ========   =================================================\n            value      description\n            ========   =================================================\n            'auto'     automatic; fill the position rectangle with data.\n            num        a circle will be stretched such that the height\n                       is *num* times the width.  'equal' is a synonym\n                       for ``aspect=1``, i.e. same scaling for x and y.\n            ========   =================================================\n\n        adjustable : None or {'box', 'datalim'}, optional\n            If not ``None``, this defines which parameter will be adjusted to\n            meet the required aspect. See `.set_adjustable` for further\n            details.\n\n        anchor : None or str or 2-tuple of float, optional\n            If not ``None``, this defines where the Axes will be drawn if there\n            is extra space due to aspect constraints. The most common way to\n            to specify the anchor are abbreviations of cardinal directions:\n\n            =====   =====================\n            value   description\n            =====   =====================\n            'C'     centered\n            'SW'    lower left corner\n            'S'     middle of bottom edge\n            'SE'    lower right corner\n            etc.\n            =====   =====================\n\n            See `.set_anchor` for further details.\n\n        share : bool, default: False\n            If ``True``, apply the settings to all shared Axes.\n\n        See Also\n        --------\n        matplotlib.axes.Axes.set_adjustable\n            defining the parameter to adjust in order to meet the required\n            aspect.\n        matplotlib.axes.Axes.set_anchor\n            defining the position in case of extra space.\n        \"\"\"\n        if cbook._str_equal(aspect, 'equal'):\n            aspect = 1\n        if not cbook._str_equal(aspect, 'auto'):\n            if self.name == '3d':\n                raise NotImplementedError(\n                    'It is not currently possible to manually set the aspect '\n                    'on 3D axes')\n            aspect = float(aspect)  # raise ValueError if necessary\n\n        if share:\n            axes = {*self._shared_x_axes.get_siblings(self),\n                    *self._shared_y_axes.get_siblings(self)}\n        else:\n            axes = [self]\n\n        for ax in axes:\n            ax._aspect = aspect\n\n        if adjustable is None:\n            adjustable = self._adjustable\n        self.set_adjustable(adjustable, share=share)  # Handle sharing.\n\n        if anchor is not None:\n            self.set_anchor(anchor, share=share)\n        self.stale = True",
        "begin_line": 1212,
        "end_line": 1287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003471017007983339,
            "pseudo_dstar_susp": 0.0003243593902043464,
            "pseudo_tarantula_susp": 0.00043821209465381246,
            "pseudo_op2_susp": 0.0003243593902043464,
            "pseudo_barinel_susp": 0.00043821209465381246
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_adjustable#1304",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_adjustable(self, adjustable, share=False)",
        "snippet": "    def set_adjustable(self, adjustable, share=False):\n        \"\"\"\n        Define which parameter the Axes will change to achieve a given aspect.\n\n        Parameters\n        ----------\n        adjustable : {'box', 'datalim'}\n            If 'box', change the physical dimensions of the Axes.\n            If 'datalim', change the ``x`` or ``y`` data limits.\n\n        share : bool, default: False\n            If ``True``, apply the settings to all shared Axes.\n\n        See Also\n        --------\n        matplotlib.axes.Axes.set_aspect\n            for a description of aspect handling.\n\n        Notes\n        -----\n        Shared Axes (of which twinned Axes are a special case)\n        impose restrictions on how aspect ratios can be imposed.\n        For twinned Axes, use 'datalim'.  For Axes that share both\n        x and y, use 'box'.  Otherwise, either 'datalim' or 'box'\n        may be used.  These limitations are partly a requirement\n        to avoid over-specification, and partly a result of the\n        particular implementation we are currently using, in\n        which the adjustments for aspect ratios are done sequentially\n        and independently on each Axes as it is drawn.\n        \"\"\"\n        cbook._check_in_list([\"box\", \"datalim\"], adjustable=adjustable)\n        if share:\n            axs = {*self._shared_x_axes.get_siblings(self),\n                   *self._shared_y_axes.get_siblings(self)}\n        else:\n            axs = [self]\n        if (adjustable == \"datalim\"\n                and any(getattr(ax.get_data_ratio, \"__func__\", None)\n                        != _AxesBase.get_data_ratio\n                        for ax in axs)):\n            # Limits adjustment by apply_aspect assumes that the axes' aspect\n            # ratio can be computed from the data limits and scales.\n            raise ValueError(\"Cannot set axes adjustable to 'datalim' for \"\n                             \"Axes which override 'get_data_ratio'\")\n        for ax in axs:\n            ax._adjustable = adjustable\n        self.stale = True",
        "begin_line": 1304,
        "end_line": 1350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003068425897514575,
            "pseudo_dstar_susp": 0.00030376670716889426,
            "pseudo_tarantula_susp": 0.000333000333000333,
            "pseudo_op2_susp": 0.00030376670716889426,
            "pseudo_barinel_susp": 0.000333000333000333
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_box_aspect#1366",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_box_aspect(self, aspect=None)",
        "snippet": "    def set_box_aspect(self, aspect=None):\n        \"\"\"\n        Set the axes box aspect. The box aspect is the ratio of the\n        axes height to the axes width in physical units. This is not to be\n        confused with the data aspect, set via `~.Axes.set_aspect`.\n\n        Parameters\n        ----------\n        aspect : None, or a number\n            Changes the physical dimensions of the Axes, such that the ratio\n            of the axes height to the axes width in physical units is equal to\n            *aspect*. If *None*, the axes geometry will not be adjusted.\n\n        Note that calling this function with a number changes the *adjustable*\n        to *datalim*.\n\n        See Also\n        --------\n        matplotlib.axes.Axes.set_aspect\n            for a description of aspect handling.\n        \"\"\"\n        axs = {*self._twinned_axes.get_siblings(self),\n               *self._twinned_axes.get_siblings(self)}\n\n        if aspect is not None:\n            aspect = float(aspect)\n            # when box_aspect is set to other than \u00b4None`,\n            # adjustable must be \"datalim\"\n            for ax in axs:\n                ax.set_adjustable(\"datalim\")\n\n        for ax in axs:\n            ax._box_aspect = aspect\n            ax.stale = True",
        "begin_line": 1366,
        "end_line": 1399,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001388888888888889,
            "pseudo_dstar_susp": 0.002551020408163265,
            "pseudo_tarantula_susp": 0.0005733944954128441,
            "pseudo_op2_susp": 0.002551020408163265,
            "pseudo_barinel_susp": 0.0005733944954128441
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_anchor#1414",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_anchor(self, anchor, share=False)",
        "snippet": "    def set_anchor(self, anchor, share=False):\n        \"\"\"\n        Define the anchor location.\n\n        The actual drawing area (active position) of the Axes may be smaller\n        than the Bbox (original position) when a fixed aspect is required. The\n        anchor defines where the drawing area will be located within the\n        available space.\n\n        Parameters\n        ----------\n        anchor : 2-tuple of floats or {'C', 'SW', 'S', 'SE', ...}\n            The anchor position may be either:\n\n            - a sequence (*cx*, *cy*). *cx* and *cy* may range from 0\n              to 1, where 0 is left or bottom and 1 is right or top.\n\n            - a string using cardinal directions as abbreviation:\n\n              - 'C' for centered\n              - 'S' (south) for bottom-center\n              - 'SW' (south west) for bottom-left\n              - etc.\n\n              Here is an overview of the possible positions:\n\n              +------+------+------+\n              | 'NW' | 'N'  | 'NE' |\n              +------+------+------+\n              | 'W'  | 'C'  | 'E'  |\n              +------+------+------+\n              | 'SW' | 'S'  | 'SE' |\n              +------+------+------+\n\n        share : bool, default: False\n            If ``True``, apply the settings to all shared Axes.\n\n        See Also\n        --------\n        matplotlib.axes.Axes.set_aspect\n            for a description of aspect handling.\n        \"\"\"\n        if not (anchor in mtransforms.Bbox.coefs or len(anchor) == 2):\n            raise ValueError('argument must be among %s' %\n                             ', '.join(mtransforms.Bbox.coefs))\n        if share:\n            axes = {*self._shared_x_axes.get_siblings(self),\n                    *self._shared_y_axes.get_siblings(self)}\n        else:\n            axes = [self]\n        for ax in axes:\n            ax._anchor = anchor\n\n        self.stale = True",
        "begin_line": 1414,
        "end_line": 1467,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_data_ratio#1469",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_data_ratio(self)",
        "snippet": "    def get_data_ratio(self):\n        \"\"\"\n        Return the aspect ratio of the scaled data.\n\n        Notes\n        -----\n        This method is intended to be overridden by new projection types.\n        \"\"\"\n        txmin, txmax = self.xaxis.get_transform().transform(self.get_xbound())\n        tymin, tymax = self.yaxis.get_transform().transform(self.get_ybound())\n        xsize = max(abs(txmax - txmin), 1e-30)\n        ysize = max(abs(tymax - tymin), 1e-30)\n        return ysize / xsize",
        "begin_line": 1469,
        "end_line": 1481,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.46880030300161e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.apply_aspect#1500",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.apply_aspect(self, position=None)",
        "snippet": "    def apply_aspect(self, position=None):\n        \"\"\"\n        Adjust the Axes for a specified data aspect ratio.\n\n        Depending on `.get_adjustable` this will modify either the\n        Axes box (position) or the view limits. In the former case,\n        `~matplotlib.axes.Axes.get_anchor` will affect the position.\n\n        Notes\n        -----\n        This is called automatically when each Axes is drawn.  You may need\n        to call it yourself if you need to update the Axes position and/or\n        view limits before the Figure is drawn.\n\n        See Also\n        --------\n        matplotlib.axes.Axes.set_aspect\n            for a description of aspect ratio handling.\n        matplotlib.axes.Axes.set_adjustable\n            defining the parameter to adjust in order to meet the required\n            aspect.\n        matplotlib.axes.Axes.set_anchor\n            defining the position in case of extra space.\n        \"\"\"\n        if position is None:\n            position = self.get_position(original=True)\n\n        aspect = self.get_aspect()\n\n        if aspect == 'auto' and self._box_aspect is None:\n            self._set_position(position, which='active')\n            return\n\n        fig_width, fig_height = self.get_figure().get_size_inches()\n        fig_aspect = fig_height / fig_width\n\n        if self._adjustable == 'box':\n            if self in self._twinned_axes:\n                raise RuntimeError(\"Adjustable 'box' is not allowed in a \"\n                                   \"twinned Axes; use 'datalim' instead\")\n            box_aspect = aspect * self.get_data_ratio()\n            pb = position.frozen()\n            pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)\n            self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')\n            return\n\n        # The following is only seen if self._adjustable == 'datalim'\n        if self._box_aspect is not None:\n            pb = position.frozen()\n            pb1 = pb.shrunk_to_aspect(self._box_aspect, pb, fig_aspect)\n            self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')\n            if aspect == \"auto\":\n                return\n\n        # reset active to original in case it had been changed by prior use\n        # of 'box'\n        if self._box_aspect is None:\n            self._set_position(position, which='active')\n        else:\n            position = pb1.anchored(self.get_anchor(), pb)\n\n        x_trf = self.xaxis.get_transform()\n        y_trf = self.yaxis.get_transform()\n        xmin, xmax = x_trf.transform(self.get_xbound())\n        ymin, ymax = y_trf.transform(self.get_ybound())\n        xsize = max(abs(xmax - xmin), 1e-30)\n        ysize = max(abs(ymax - ymin), 1e-30)\n\n        l, b, w, h = position.bounds\n        box_aspect = fig_aspect * (h / w)\n        data_ratio = box_aspect / aspect\n\n        y_expander = data_ratio * xsize / ysize - 1\n        # If y_expander > 0, the dy/dx viewLim ratio needs to increase\n        if abs(y_expander) < 0.005:\n            return\n\n        dL = self.dataLim\n        x0, x1 = x_trf.transform(dL.intervalx)\n        y0, y1 = y_trf.transform(dL.intervaly)\n        xr = 1.05 * (x1 - x0)\n        yr = 1.05 * (y1 - y0)\n\n        xmarg = xsize - xr\n        ymarg = ysize - yr\n        Ysize = data_ratio * xsize\n        Xsize = ysize / data_ratio\n        Xmarg = Xsize - xr\n        Ymarg = Ysize - yr\n        # Setting these targets to, e.g., 0.05*xr does not seem to help.\n        xm = 0\n        ym = 0\n\n        shared_x = self in self._shared_x_axes\n        shared_y = self in self._shared_y_axes\n        # Not sure whether we need this check:\n        if shared_x and shared_y:\n            raise RuntimeError(\"adjustable='datalim' is not allowed when both \"\n                               \"axes are shared\")\n\n        # If y is shared, then we are only allowed to change x, etc.\n        if shared_y:\n            adjust_y = False\n        else:\n            if xmarg > xm and ymarg > ym:\n                adjy = ((Ymarg > 0 and y_expander < 0) or\n                        (Xmarg < 0 and y_expander > 0))\n            else:\n                adjy = y_expander > 0\n            adjust_y = shared_x or adjy  # (Ymarg > xmarg)\n\n        if adjust_y:\n            yc = 0.5 * (ymin + ymax)\n            y0 = yc - Ysize / 2.0\n            y1 = yc + Ysize / 2.0\n            self.set_ybound(y_trf.inverted().transform([y0, y1]))\n        else:\n            xc = 0.5 * (xmin + xmax)\n            x0 = xc - Xsize / 2.0\n            x1 = xc + Xsize / 2.0\n            self.set_xbound(x_trf.inverted().transform([x0, x1]))",
        "begin_line": 1500,
        "end_line": 1620,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000708215297450425,
            "pseudo_dstar_susp": 0.0004268032437046522,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0004268032437046522,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.axis#1622",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.axis(self, *args, emit=True, **kwargs)",
        "snippet": "    def axis(self, *args, emit=True, **kwargs):\n        \"\"\"\n        Convenience method to get or set some axis properties.\n\n        Call signatures::\n\n          xmin, xmax, ymin, ymax = axis()\n          xmin, xmax, ymin, ymax = axis([xmin, xmax, ymin, ymax])\n          xmin, xmax, ymin, ymax = axis(option)\n          xmin, xmax, ymin, ymax = axis(**kwargs)\n\n        Parameters\n        ----------\n        xmin, xmax, ymin, ymax : float, optional\n            The axis limits to be set.  This can also be achieved using ::\n\n                ax.set(xlim=(xmin, xmax), ylim=(ymin, ymax))\n\n        option : bool or str\n            If a bool, turns axis lines and labels on or off. If a string,\n            possible values are:\n\n            ======== ==========================================================\n            Value    Description\n            ======== ==========================================================\n            'on'     Turn on axis lines and labels. Same as ``True``.\n            'off'    Turn off axis lines and labels. Same as ``False``.\n            'equal'  Set equal scaling (i.e., make circles circular) by\n                     changing axis limits. This is the same as\n                     ``ax.set_aspect('equal', adjustable='datalim')``.\n                     Explicit data limits may not be respected in this case.\n            'scaled' Set equal scaling (i.e., make circles circular) by\n                     changing dimensions of the plot box. This is the same as\n                     ``ax.set_aspect('equal', adjustable='box', anchor='C')``.\n                     Additionally, further autoscaling will be disabled.\n            'tight'  Set limits just large enough to show all data, then\n                     disable further autoscaling.\n            'auto'   Automatic scaling (fill plot box with data).\n            'normal' Same as 'auto'; deprecated.\n            'image'  'scaled' with axis limits equal to data limits.\n            'square' Square plot; similar to 'scaled', but initially forcing\n                     ``xmax-xmin == ymax-ymin``.\n            ======== ==========================================================\n\n        emit : bool, default: True\n            Whether observers are notified of the axis limit change.\n            This option is passed on to `~.Axes.set_xlim` and\n            `~.Axes.set_ylim`.\n\n        Returns\n        -------\n        xmin, xmax, ymin, ymax : float\n            The axis limits.\n\n        See also\n        --------\n        matplotlib.axes.Axes.set_xlim\n        matplotlib.axes.Axes.set_ylim\n        \"\"\"\n        if len(args) == 1 and isinstance(args[0], (str, bool)):\n            s = args[0]\n            if s is True:\n                s = 'on'\n            if s is False:\n                s = 'off'\n            s = s.lower()\n            if s == 'on':\n                self.set_axis_on()\n            elif s == 'off':\n                self.set_axis_off()\n            elif s in ('equal', 'tight', 'scaled', 'normal',\n                       'auto', 'image', 'square'):\n                if s == 'normal':\n                    cbook.warn_deprecated(\n                        \"3.1\", message=\"Passing 'normal' to axis() is \"\n                        \"deprecated since %(since)s; use 'auto' instead.\")\n                self.set_autoscale_on(True)\n                self.set_aspect('auto')\n                self.autoscale_view(tight=False)\n                # self.apply_aspect()\n                if s == 'equal':\n                    self.set_aspect('equal', adjustable='datalim')\n                elif s == 'scaled':\n                    self.set_aspect('equal', adjustable='box', anchor='C')\n                    self.set_autoscale_on(False)  # Req. by Mark Bakker\n                elif s == 'tight':\n                    self.autoscale_view(tight=True)\n                    self.set_autoscale_on(False)\n                elif s == 'image':\n                    self.autoscale_view(tight=True)\n                    self.set_autoscale_on(False)\n                    self.set_aspect('equal', adjustable='box', anchor='C')\n                elif s == 'square':\n                    self.set_aspect('equal', adjustable='box', anchor='C')\n                    self.set_autoscale_on(False)\n                    xlim = self.get_xlim()\n                    ylim = self.get_ylim()\n                    edge_size = max(np.diff(xlim), np.diff(ylim))[0]\n                    self.set_xlim([xlim[0], xlim[0] + edge_size],\n                                  emit=emit, auto=False)\n                    self.set_ylim([ylim[0], ylim[0] + edge_size],\n                                  emit=emit, auto=False)\n            else:\n                raise ValueError('Unrecognized string %s to axis; '\n                                 'try on or off' % s)\n        else:\n            if len(args) >= 1:\n                if len(args) != 1:\n                    cbook.warn_deprecated(\n                        \"3.2\", message=\"Passing more than one positional \"\n                        \"argument to axis() is deprecated and will raise a \"\n                        \"TypeError %(removal)s.\")\n                limits = args[0]\n                try:\n                    xmin, xmax, ymin, ymax = limits\n                except (TypeError, ValueError) as err:\n                    raise TypeError('the first argument to axis() must be an '\n                                    'interable of the form '\n                                    '[xmin, xmax, ymin, ymax]') from err\n            else:\n                xmin = kwargs.pop('xmin', None)\n                xmax = kwargs.pop('xmax', None)\n                ymin = kwargs.pop('ymin', None)\n                ymax = kwargs.pop('ymax', None)\n            xauto = (None  # Keep autoscale state as is.\n                     if xmin is None and xmax is None\n                     else False)  # Turn off autoscale.\n            yauto = (None\n                     if ymin is None and ymax is None\n                     else False)\n            self.set_xlim(xmin, xmax, emit=emit, auto=xauto)\n            self.set_ylim(ymin, ymax, emit=emit, auto=yauto)\n        if kwargs:\n            cbook.warn_deprecated(\n                \"3.1\", message=\"Passing unsupported keyword arguments to \"\n                \"axis() will raise a TypeError %(removal)s.\")\n        return (*self.get_xlim(), *self.get_ylim())",
        "begin_line": 1622,
        "end_line": 1758,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._sci#1798",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._sci(self, im)",
        "snippet": "    def _sci(self, im):\n        \"\"\"Set the current image.\n\n        This image will be the target of colormap functions like\n        `~.pyplot.viridis`, and other functions such as `~.pyplot.clim`.  The\n        current image is an attribute of the current axes.\n        \"\"\"\n        if isinstance(im, mpl.contour.ContourSet):\n            if im.collections[0] not in self.collections:\n                raise ValueError(\"ContourSet must be in current Axes\")\n        elif im not in self.images and im not in self.collections:\n            raise ValueError(\"Argument must be an image, collection, or \"\n                             \"ContourSet in this Axes\")\n        self._current_image = im",
        "begin_line": 1798,
        "end_line": 1811,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.has_data#1817",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.has_data(self)",
        "snippet": "    def has_data(self):\n        \"\"\"\n        Return *True* if any artists have been added to axes.\n\n        This should not be used to determine whether the *dataLim*\n        need to be updated, and may not actually be useful for\n        anything.\n        \"\"\"\n        return (\n            len(self.collections) +\n            len(self.images) +\n            len(self.lines) +\n            len(self.patches)) > 0",
        "begin_line": 1817,
        "end_line": 1829,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.add_artist#1831",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.add_artist(self, a)",
        "snippet": "    def add_artist(self, a):\n        \"\"\"\n        Add an `~.Artist` to the axes, and return the artist.\n\n        Use `add_artist` only for artists for which there is no dedicated\n        \"add\" method; and if necessary, use a method such as `update_datalim`\n        to manually update the dataLim if the artist is to be included in\n        autoscaling.\n\n        If no ``transform`` has been specified when creating the artist (e.g.\n        ``artist.get_transform() == None``) then the transform is set to\n        ``ax.transData``.\n        \"\"\"\n        a.axes = self\n        self.artists.append(a)\n        a._remove_method = self.artists.remove\n        self._set_artist_props(a)\n        a.set_clip_path(self.patch)\n        self.stale = True\n        return a",
        "begin_line": 1831,
        "end_line": 1850,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.46880030300161e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.add_collection#1870",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.add_collection(self, collection, autolim=True)",
        "snippet": "    def add_collection(self, collection, autolim=True):\n        \"\"\"\n        Add a `~.Collection` to the axes' collections; return the collection.\n        \"\"\"\n        label = collection.get_label()\n        if not label:\n            collection.set_label('_collection%d' % len(self.collections))\n        self.collections.append(collection)\n        collection._remove_method = self.collections.remove\n        self._set_artist_props(collection)\n\n        if collection.get_clip_path() is None:\n            collection.set_clip_path(self.patch)\n\n        if autolim:\n            # Make sure viewLim is not stale (mostly to match\n            # pre-lazy-autoscale behavior, which is not really better).\n            self._unstale_viewLim()\n            self.update_datalim(collection.get_datalim(self.transData))\n\n        self.stale = True\n        return collection",
        "begin_line": 1870,
        "end_line": 1891,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041736227045075126,
            "pseudo_dstar_susp": 0.0003787878787878788,
            "pseudo_tarantula_susp": 0.0010638297872340426,
            "pseudo_op2_susp": 0.0003787878787878788,
            "pseudo_barinel_susp": 0.0010638297872340426
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.add_image#1893",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.add_image(self, image)",
        "snippet": "    def add_image(self, image):\n        \"\"\"\n        Add an `~.AxesImage` to the axes' images; return the image.\n        \"\"\"\n        self._set_artist_props(image)\n        if not image.get_label():\n            image.set_label('_image%d' % len(self.images))\n        self.images.append(image)\n        image._remove_method = self.images.remove\n        self.stale = True\n        return image",
        "begin_line": 1893,
        "end_line": 1903,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005243838489774515,
            "pseudo_dstar_susp": 0.00041203131437989287,
            "pseudo_tarantula_susp": 0.002,
            "pseudo_op2_susp": 0.00041203131437989287,
            "pseudo_barinel_susp": 0.002
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._update_image_limits#1905",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._update_image_limits(self, image)",
        "snippet": "    def _update_image_limits(self, image):\n        xmin, xmax, ymin, ymax = image.get_extent()\n        self.axes.update_datalim(((xmin, ymin), (xmax, ymax)))",
        "begin_line": 1905,
        "end_line": 1907,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.add_line#1909",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.add_line(self, line)",
        "snippet": "    def add_line(self, line):\n        \"\"\"\n        Add a `.Line2D` to the axes' lines; return the line.\n        \"\"\"\n        self._set_artist_props(line)\n        if line.get_clip_path() is None:\n            line.set_clip_path(self.patch)\n\n        self._update_line_limits(line)\n        if not line.get_label():\n            line.set_label('_line%d' % len(self.lines))\n        self.lines.append(line)\n        line._remove_method = self.lines.remove\n        self.stale = True\n        return line",
        "begin_line": 1909,
        "end_line": 1923,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003136762860727729,
            "pseudo_dstar_susp": 0.00030826140567200987,
            "pseudo_tarantula_susp": 0.00035198873636043646,
            "pseudo_op2_susp": 0.00030826140567200987,
            "pseudo_barinel_susp": 0.00035198873636043646
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._add_text#1925",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._add_text(self, txt)",
        "snippet": "    def _add_text(self, txt):\n        \"\"\"\n        Add a `~.Text` to the axes' texts; return the text.\n        \"\"\"\n        self._set_artist_props(txt)\n        self.texts.append(txt)\n        txt._remove_method = self.texts.remove\n        self.stale = True\n        return txt",
        "begin_line": 1925,
        "end_line": 1933,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._update_line_limits#1935",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._update_line_limits(self, line)",
        "snippet": "    def _update_line_limits(self, line):\n        \"\"\"\n        Figures out the data limit of the given line, updating self.dataLim.\n        \"\"\"\n        path = line.get_path()\n        if path.vertices.size == 0:\n            return\n\n        line_trans = line.get_transform()\n\n        if line_trans == self.transData:\n            data_path = path\n\n        elif any(line_trans.contains_branch_seperately(self.transData)):\n            # identify the transform to go from line's coordinates\n            # to data coordinates\n            trans_to_data = line_trans - self.transData\n\n            # if transData is affine we can use the cached non-affine component\n            # of line's path. (since the non-affine part of line_trans is\n            # entirely encapsulated in trans_to_data).\n            if self.transData.is_affine:\n                line_trans_path = line._get_transformed_path()\n                na_path, _ = line_trans_path.get_transformed_path_and_affine()\n                data_path = trans_to_data.transform_path_affine(na_path)\n            else:\n                data_path = trans_to_data.transform_path(path)\n        else:\n            # for backwards compatibility we update the dataLim with the\n            # coordinate range of the given path, even though the coordinate\n            # systems are completely different. This may occur in situations\n            # such as when ax.transAxes is passed through for absolute\n            # positioning.\n            data_path = path\n\n        if data_path.vertices.size > 0:\n            updatex, updatey = line_trans.contains_branch_seperately(\n                self.transData)\n            self.dataLim.update_from_path(data_path,\n                                          self.ignore_existing_data_limits,\n                                          updatex=updatex,\n                                          updatey=updatey)\n            self.ignore_existing_data_limits = False",
        "begin_line": 1935,
        "end_line": 1977,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002937720329024677,
            "pseudo_dstar_susp": 0.00029342723004694836,
            "pseudo_tarantula_susp": 0.00030543677458766036,
            "pseudo_op2_susp": 0.00029342723004694836,
            "pseudo_barinel_susp": 0.00030543677458766036
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.add_patch#1979",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.add_patch(self, p)",
        "snippet": "    def add_patch(self, p):\n        \"\"\"\n        Add a `~.Patch` to the axes' patches; return the patch.\n        \"\"\"\n        self._set_artist_props(p)\n        if p.get_clip_path() is None:\n            p.set_clip_path(self.patch)\n        self._update_patch_limits(p)\n        self.patches.append(p)\n        p._remove_method = self.patches.remove\n        return p",
        "begin_line": 1979,
        "end_line": 1989,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006422607578676942,
            "pseudo_dstar_susp": 0.0005980861244019139,
            "pseudo_tarantula_susp": 0.0018726591760299626,
            "pseudo_op2_susp": 0.0005980861244019139,
            "pseudo_barinel_susp": 0.0018726591760299626
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._update_patch_limits#1991",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._update_patch_limits(self, patch)",
        "snippet": "    def _update_patch_limits(self, patch):\n        \"\"\"update the data limits for patch *p*\"\"\"\n        # hist can add zero height Rectangles, which is useful to keep\n        # the bins, counts and patches lined up, but it throws off log\n        # scaling.  We'll ignore rects with zero height or width in\n        # the auto-scaling\n\n        # cannot check for '==0' since unitized data may not compare to zero\n        # issue #2150 - we update the limits if patch has non zero width\n        # or height.\n        if (isinstance(patch, mpatches.Rectangle) and\n                ((not patch.get_width()) and (not patch.get_height()))):\n            return\n        vertices = patch.get_path().vertices\n        if vertices.size > 0:\n            xys = patch.get_patch_transform().transform(vertices)\n            if patch.get_data_transform() != self.transData:\n                patch_to_data = (patch.get_data_transform() -\n                                 self.transData)\n                xys = patch_to_data.transform(xys)\n\n            updatex, updatey = patch.get_transform().\\\n                contains_branch_seperately(self.transData)\n            self.update_datalim(xys, updatex=updatex,\n                                updatey=updatey)",
        "begin_line": 1991,
        "end_line": 2015,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005173305742369374,
            "pseudo_dstar_susp": 0.0005984440454817474,
            "pseudo_tarantula_susp": 0.00099601593625498,
            "pseudo_op2_susp": 0.0005984440454817474,
            "pseudo_barinel_susp": 0.0010030090270812437
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.add_table#2017",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.add_table(self, tab)",
        "snippet": "    def add_table(self, tab):\n        \"\"\"\n        Add a `~.Table` to the axes' tables; return the table.\n        \"\"\"\n        self._set_artist_props(tab)\n        self.tables.append(tab)\n        tab.set_clip_path(self.patch)\n        tab._remove_method = self.tables.remove\n        return tab",
        "begin_line": 2017,
        "end_line": 2025,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.add_container#2027",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.add_container(self, container)",
        "snippet": "    def add_container(self, container):\n        \"\"\"\n        Add a `~.Container` to the axes' containers; return the container.\n        \"\"\"\n        label = container.get_label()\n        if not label:\n            container.set_label('_container%d' % len(self.containers))\n        self.containers.append(container)\n        container._remove_method = self.containers.remove\n        return container",
        "begin_line": 2027,
        "end_line": 2036,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036496350364963502,
            "pseudo_dstar_susp": 0.0005998800239952009,
            "pseudo_tarantula_susp": 0.006756756756756757,
            "pseudo_op2_susp": 0.0005998800239952009,
            "pseudo_barinel_susp": 0.006756756756756757
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._on_units_changed#2038",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._on_units_changed(self, scalex=False, scaley=False)",
        "snippet": "    def _on_units_changed(self, scalex=False, scaley=False):\n        \"\"\"\n        Callback for processing changes to axis units.\n\n        Currently requests updates of data limits and view limits.\n        \"\"\"\n        self.relim()\n        self._request_autoscale_view(scalex=scalex, scaley=scaley)",
        "begin_line": 2038,
        "end_line": 2045,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.relim#2047",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.relim(self, visible_only=False)",
        "snippet": "    def relim(self, visible_only=False):\n        \"\"\"\n        Recompute the data limits based on current artists.\n\n        At present, `~.Collection` instances are not supported.\n\n        Parameters\n        ----------\n        visible_only : bool, default: False\n            Whether to exclude invisible artists.\n        \"\"\"\n        # Collections are deliberately not supported (yet); see\n        # the TODO note in artists.py.\n        self.dataLim.ignore(True)\n        self.dataLim.set_points(mtransforms.Bbox.null().get_points())\n        self.ignore_existing_data_limits = True\n\n        for line in self.lines:\n            if not visible_only or line.get_visible():\n                self._update_line_limits(line)\n\n        for p in self.patches:\n            if not visible_only or p.get_visible():\n                self._update_patch_limits(p)\n\n        for image in self.images:\n            if not visible_only or image.get_visible():\n                self._update_image_limits(image)",
        "begin_line": 2047,
        "end_line": 2074,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.update_datalim#2076",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.update_datalim(self, xys, updatex=True, updatey=True)",
        "snippet": "    def update_datalim(self, xys, updatex=True, updatey=True):\n        \"\"\"\n        Extend the `~.Axes.dataLim` Bbox to include the given points.\n\n        If no data is set currently, the Bbox will ignore its limits and set\n        the bound to be the bounds of the xydata (*xys*). Otherwise, it will\n        compute the bounds of the union of its current data and the data in\n        *xys*.\n\n        Parameters\n        ----------\n        xys : 2D array-like\n            The points to include in the data limits Bbox. This can be either\n            a list of (x, y) tuples or a Nx2 array.\n\n        updatex, updatey : bool, default: True\n            Whether to update the x/y limits.\n        \"\"\"\n        xys = np.asarray(xys)\n        if not len(xys):\n            return\n        self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,\n                                         updatex=updatex, updatey=updatey)\n        self.ignore_existing_data_limits = False",
        "begin_line": 2076,
        "end_line": 2099,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005431830526887561,
            "pseudo_dstar_susp": 0.0005592841163310962,
            "pseudo_tarantula_susp": 0.0016181229773462784,
            "pseudo_op2_susp": 0.0005592841163310962,
            "pseudo_barinel_susp": 0.0016181229773462784
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._process_unit_info#2114",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._process_unit_info(self, xdata=None, ydata=None, kwargs=None)",
        "snippet": "    def _process_unit_info(self, xdata=None, ydata=None, kwargs=None):\n        \"\"\"Look for unit *kwargs* and update the axis instances as necessary\"\"\"\n\n        def _process_single_axis(data, axis, unit_name, kwargs):\n            # Return if there's no axis set\n            if axis is None:\n                return kwargs\n\n            if data is not None:\n                # We only need to update if there is nothing set yet.\n                if not axis.have_units():\n                    axis.update_units(data)\n\n            # Check for units in the kwargs, and if present update axis\n            if kwargs is not None:\n                units = kwargs.pop(unit_name, axis.units)\n                if self.name == 'polar':\n                    polar_units = {'xunits': 'thetaunits', 'yunits': 'runits'}\n                    units = kwargs.pop(polar_units[unit_name], units)\n\n                if units != axis.units:\n                    axis.set_units(units)\n                    # If the units being set imply a different converter,\n                    # we need to update.\n                    if data is not None:\n                        axis.update_units(data)\n            return kwargs\n\n        kwargs = _process_single_axis(xdata, self.xaxis, 'xunits', kwargs)\n        kwargs = _process_single_axis(ydata, self.yaxis, 'yunits', kwargs)\n        return kwargs",
        "begin_line": 2114,
        "end_line": 2144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002380952380952381,
            "pseudo_dstar_susp": 0.0010845986984815619,
            "pseudo_tarantula_susp": 0.0015337423312883436,
            "pseudo_op2_susp": 0.0010845986984815619,
            "pseudo_barinel_susp": 0.0015337423312883436
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._process_single_axis#2117",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._process_single_axis(data, axis, unit_name, kwargs)",
        "snippet": "        def _process_single_axis(data, axis, unit_name, kwargs):\n            # Return if there's no axis set\n            if axis is None:\n                return kwargs\n\n            if data is not None:\n                # We only need to update if there is nothing set yet.\n                if not axis.have_units():\n                    axis.update_units(data)\n\n            # Check for units in the kwargs, and if present update axis\n            if kwargs is not None:\n                units = kwargs.pop(unit_name, axis.units)\n                if self.name == 'polar':\n                    polar_units = {'xunits': 'thetaunits', 'yunits': 'runits'}\n                    units = kwargs.pop(polar_units[unit_name], units)\n\n                if units != axis.units:\n                    axis.set_units(units)\n                    # If the units being set imply a different converter,\n                    # we need to update.\n                    if data is not None:\n                        axis.update_units(data)\n            return kwargs",
        "begin_line": 2117,
        "end_line": 2140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002145922746781116,
            "pseudo_dstar_susp": 0.0016181229773462784,
            "pseudo_tarantula_susp": 0.0007668711656441718,
            "pseudo_op2_susp": 0.0016181229773462784,
            "pseudo_barinel_susp": 0.0007668711656441718
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_autoscalex_on#2159",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_autoscalex_on(self)",
        "snippet": "    def get_autoscalex_on(self):\n        \"\"\"\n        Get whether autoscaling for the x-axis is applied on plot commands\n        \"\"\"\n        return self._autoscaleXon",
        "begin_line": 2159,
        "end_line": 2163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005431830526887561,
            "pseudo_dstar_susp": 0.0004170141784820684,
            "pseudo_tarantula_susp": 0.0021645021645021645,
            "pseudo_op2_susp": 0.0004170141784820684,
            "pseudo_barinel_susp": 0.0021645021645021645
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_autoscaley_on#2165",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_autoscaley_on(self)",
        "snippet": "    def get_autoscaley_on(self):\n        \"\"\"\n        Get whether autoscaling for the y-axis is applied on plot commands\n        \"\"\"\n        return self._autoscaleYon",
        "begin_line": 2165,
        "end_line": 2169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_autoscale_on#2171",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_autoscale_on(self, b)",
        "snippet": "    def set_autoscale_on(self, b):\n        \"\"\"\n        Set whether autoscaling is applied on plot commands\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._autoscaleXon = b\n        self._autoscaleYon = b",
        "begin_line": 2171,
        "end_line": 2180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_autoscalex_on#2182",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_autoscalex_on(self, b)",
        "snippet": "    def set_autoscalex_on(self, b):\n        \"\"\"\n        Set whether autoscaling for the x-axis is applied on plot commands\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._autoscaleXon = b",
        "begin_line": 2182,
        "end_line": 2190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_xmargin#2224",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_xmargin(self, m)",
        "snippet": "    def set_xmargin(self, m):\n        \"\"\"\n        Set padding of X data limits prior to autoscaling.\n\n        *m* times the data interval will be added to each\n        end of that interval before it is used in autoscaling.\n        For example, if your data is in the range [0, 2], a factor of\n        ``m = 0.1`` will result in a range [-0.2, 2.2].\n\n        Negative values -0.5 < m < 0 will result in clipping of the data range.\n        I.e. for a data range [0, 2], a factor of ``m = -0.1`` will result in\n        a range [0.2, 1.8].\n\n        Parameters\n        ----------\n        m : float greater than -0.5\n        \"\"\"\n        if m <= -0.5:\n            raise ValueError(\"margin must be greater than -0.5\")\n        self._xmargin = m\n        self.stale = True",
        "begin_line": 2224,
        "end_line": 2244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000708215297450425,
            "pseudo_dstar_susp": 0.0004268032437046522,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0004268032437046522,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_ymargin#2246",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_ymargin(self, m)",
        "snippet": "    def set_ymargin(self, m):\n        \"\"\"\n        Set padding of Y data limits prior to autoscaling.\n\n        *m* times the data interval will be added to each\n        end of that interval before it is used in autoscaling.\n        For example, if your data is in the range [0, 2], a factor of\n        ``m = 0.1`` will result in a range [-0.2, 2.2].\n\n        Negative values -0.5 < m < 0 will result in clipping of the data range.\n        I.e. for a data range [0, 2], a factor of ``m = -0.1`` will result in\n        a range [0.2, 1.8].\n\n        Parameters\n        ----------\n        m : float greater than -0.5\n        \"\"\"\n        if m <= -0.5:\n            raise ValueError(\"margin must be greater than -0.5\")\n        self._ymargin = m\n        self.stale = True",
        "begin_line": 2246,
        "end_line": 2266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003837298541826554,
            "pseudo_dstar_susp": 0.00035398230088495576,
            "pseudo_tarantula_susp": 0.0007751937984496124,
            "pseudo_op2_susp": 0.00035398230088495576,
            "pseudo_barinel_susp": 0.0007757951900698216
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.margins#2268",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.margins(self, *margins, x=None, y=None, tight=True)",
        "snippet": "    def margins(self, *margins, x=None, y=None, tight=True):\n        \"\"\"\n        Set or retrieve autoscaling margins.\n\n        The padding added to each limit of the axes is the *margin*\n        times the data interval. All input parameters must be floats\n        within the range [0, 1]. Passing both positional and keyword\n        arguments is invalid and will raise a TypeError. If no\n        arguments (positional or otherwise) are provided, the current\n        margins will remain in place and simply be returned.\n\n        Specifying any margin changes only the autoscaling; for example,\n        if *xmargin* is not None, then *xmargin* times the X data\n        interval will be added to each end of that interval before\n        it is used in autoscaling.\n\n        Parameters\n        ----------\n        *margins : float, optional\n            If a single positional argument is provided, it specifies\n            both margins of the x-axis and y-axis limits. If two\n            positional arguments are provided, they will be interpreted\n            as *xmargin*, *ymargin*. If setting the margin on a single\n            axis is desired, use the keyword arguments described below.\n\n        x, y : float, optional\n            Specific margin values for the x-axis and y-axis,\n            respectively. These cannot be used with positional\n            arguments, but can be used individually to alter on e.g.,\n            only the y-axis.\n\n        tight : bool or None, default: True\n            The *tight* parameter is passed to :meth:`autoscale_view`,\n            which is executed after a margin is changed; the default\n            here is *True*, on the assumption that when margins are\n            specified, no additional padding to match tick marks is\n            usually desired.  Set *tight* to *None* will preserve\n            the previous setting.\n\n        Returns\n        -------\n        xmargin, ymargin : float\n\n        Notes\n        -----\n        If a previously used Axes method such as :meth:`pcolor` has set\n        :attr:`use_sticky_edges` to `True`, only the limits not set by\n        the \"sticky artists\" will be modified. To force all of the\n        margins to be set, set :attr:`use_sticky_edges` to `False`\n        before calling :meth:`margins`.\n        \"\"\"\n\n        if margins and x is not None and y is not None:\n            raise TypeError('Cannot pass both positional and keyword '\n                            'arguments for x and/or y.')\n        elif len(margins) == 1:\n            x = y = margins[0]\n        elif len(margins) == 2:\n            x, y = margins\n        elif margins:\n            raise TypeError('Must pass a single positional argument for all '\n                            'margins, or one for each margin (x, y).')\n\n        if x is None and y is None:\n            if tight is not True:\n                cbook._warn_external(f'ignoring tight={tight!r} in get mode')\n            return self._xmargin, self._ymargin\n\n        if x is not None:\n            self.set_xmargin(x)\n        if y is not None:\n            self.set_ymargin(y)\n\n        self._request_autoscale_view(\n            tight=tight, scalex=(x is not None), scaley=(y is not None)\n        )",
        "begin_line": 2268,
        "end_line": 2343,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.autoscale#2360",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.autoscale(self, enable=True, axis='both', tight=None)",
        "snippet": "    def autoscale(self, enable=True, axis='both', tight=None):\n        \"\"\"\n        Autoscale the axis view to the data (toggle).\n\n        Convenience method for simple axis view autoscaling.\n        It turns autoscaling on or off, and then,\n        if autoscaling for either axis is on, it performs\n        the autoscaling on the specified axis or axes.\n\n        Parameters\n        ----------\n        enable : bool or None, default: True\n            True turns autoscaling on, False turns it off.\n            None leaves the autoscaling state unchanged.\n        axis : {'both', 'x', 'y'}, default: 'both'\n            Which axis to operate on.\n        tight : bool or None, default: None\n            If True, first set the margins to zero.  Then, this argument is\n            forwarded to `autoscale_view` (regardless of its value); see the\n            description of its behavior there.\n        \"\"\"\n        if enable is None:\n            scalex = True\n            scaley = True\n        else:\n            scalex = False\n            scaley = False\n            if axis in ['x', 'both']:\n                self._autoscaleXon = bool(enable)\n                scalex = self._autoscaleXon\n            if axis in ['y', 'both']:\n                self._autoscaleYon = bool(enable)\n                scaley = self._autoscaleYon\n        if tight and scalex:\n            self._xmargin = 0\n        if tight and scaley:\n            self._ymargin = 0\n        self._request_autoscale_view(tight=tight, scalex=scalex, scaley=scaley)",
        "begin_line": 2360,
        "end_line": 2397,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.autoscale_view#2399",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.autoscale_view(self, tight=None, scalex=True, scaley=True)",
        "snippet": "    def autoscale_view(self, tight=None, scalex=True, scaley=True):\n        \"\"\"\n        Autoscale the view limits using the data limits.\n\n        Parameters\n        ----------\n        tight : bool or None\n            If *True*, only expand the axis limits using the margins.  Note\n            that unlike for `autoscale`, ``tight=True`` does *not* set the\n            margins to zero.\n\n            If *False* and :rc:`axes.autolimit_mode` is 'round_numbers', then\n            after expansion by the margins, further expand the axis limits\n            using the axis major locator.\n\n            If None (the default), reuse the value set in the previous call to\n            `autoscale_view` (the initial value is False, but the default style\n            sets :rc:`axes.autolimit_mode` to 'data', in which case this\n            behaves like True).\n\n        scalex : bool, default: True\n            Whether to autoscale the x axis.\n\n        scaley : bool, default: True\n            Whether to autoscale the y axis.\n\n        Notes\n        -----\n        The autoscaling preserves any preexisting axis direction reversal.\n\n        The data limits are not updated automatically when artist data are\n        changed after the artist has been added to an Axes instance.  In that\n        case, use :meth:`matplotlib.axes.Axes.relim` prior to calling\n        autoscale_view.\n\n        If the views of the axes are fixed, e.g. via `set_xlim`, they will\n        not be changed by autoscale_view().\n        See :meth:`matplotlib.axes.Axes.autoscale` for an alternative.\n        \"\"\"\n        if tight is not None:\n            self._tight = bool(tight)\n\n        x_stickies = y_stickies = np.array([])\n        if self.use_sticky_edges:\n            # Only iterate over axes and artists if needed.  The check for\n            # ``hasattr(ax, \"lines\")`` is necessary because this can be called\n            # very early in the axes init process (e.g., for twin axes) when\n            # these attributes don't even exist yet, in which case\n            # `get_children` would raise an AttributeError.\n            if self._xmargin and scalex and self._autoscaleXon:\n                x_stickies = np.sort(np.concatenate([\n                    artist.sticky_edges.x\n                    for ax in self._shared_x_axes.get_siblings(self)\n                    if hasattr(ax, \"lines\")\n                    for artist in ax.get_children()]))\n            if self._ymargin and scaley and self._autoscaleYon:\n                y_stickies = np.sort(np.concatenate([\n                    artist.sticky_edges.y\n                    for ax in self._shared_y_axes.get_siblings(self)\n                    if hasattr(ax, \"lines\")\n                    for artist in ax.get_children()]))\n        if self.get_xscale().lower() == 'log':\n            x_stickies = x_stickies[x_stickies > 0]\n        if self.get_yscale().lower() == 'log':\n            y_stickies = y_stickies[y_stickies > 0]\n\n        def handle_single_axis(scale, autoscaleon, shared_axes, interval,\n                               minpos, axis, margin, stickies, set_bound):\n\n            if not (scale and autoscaleon):\n                return  # nothing to do...\n\n            shared = shared_axes.get_siblings(self)\n            dl = [ax.dataLim for ax in shared]\n            # ignore non-finite data limits if good limits exist\n            finite_dl = [d for d in dl if np.isfinite(d).all()]\n            if len(finite_dl):\n                # if finite limits exist for atleast one axis (and the\n                # other is infinite), restore the finite limits\n                x_finite = [d for d in dl\n                            if (np.isfinite(d.intervalx).all() and\n                                (d not in finite_dl))]\n                y_finite = [d for d in dl\n                            if (np.isfinite(d.intervaly).all() and\n                                (d not in finite_dl))]\n\n                dl = finite_dl\n                dl.extend(x_finite)\n                dl.extend(y_finite)\n\n            bb = mtransforms.BboxBase.union(dl)\n            x0, x1 = getattr(bb, interval)\n            # If x0 and x1 are non finite, use the locator to figure out\n            # default limits.\n            locator = axis.get_major_locator()\n            x0, x1 = locator.nonsingular(x0, x1)\n\n            # Prevent margin addition from crossing a sticky value.  Small\n            # tolerances (whose values come from isclose()) must be used due to\n            # floating point issues with streamplot.\n            def tol(x): return 1e-5 * abs(x) + 1e-8\n            # Index of largest element < x0 + tol, if any.\n            i0 = stickies.searchsorted(x0 + tol(x0)) - 1\n            x0bound = stickies[i0] if i0 != -1 else None\n            # Index of smallest element > x1 - tol, if any.\n            i1 = stickies.searchsorted(x1 - tol(x1))\n            x1bound = stickies[i1] if i1 != len(stickies) else None\n\n            # Add the margin in figure space and then transform back, to handle\n            # non-linear scales.\n            minpos = getattr(bb, minpos)\n            transform = axis.get_transform()\n            inverse_trans = transform.inverted()\n            x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minpos)\n            x0t, x1t = transform.transform([x0, x1])\n            delta = (x1t - x0t) * margin\n            if not np.isfinite(delta):\n                delta = 0  # If a bound isn't finite, set margin to zero.\n            x0, x1 = inverse_trans.transform([x0t - delta, x1t + delta])\n\n            # Apply sticky bounds.\n            if x0bound is not None:\n                x0 = max(x0, x0bound)\n            if x1bound is not None:\n                x1 = min(x1, x1bound)\n\n            if not self._tight:\n                x0, x1 = locator.view_limits(x0, x1)\n            set_bound(x0, x1)\n            # End of definition of internal function 'handle_single_axis'.\n\n        handle_single_axis(\n            scalex, self._autoscaleXon, self._shared_x_axes, 'intervalx',\n            'minposx', self.xaxis, self._xmargin, x_stickies, self.set_xbound)\n        handle_single_axis(\n            scaley, self._autoscaleYon, self._shared_y_axes, 'intervaly',\n            'minposy', self.yaxis, self._ymargin, y_stickies, self.set_ybound)",
        "begin_line": 2399,
        "end_line": 2535,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004418912947414936,
            "pseudo_dstar_susp": 0.0003891050583657588,
            "pseudo_tarantula_susp": 0.001455604075691412,
            "pseudo_op2_susp": 0.0003891050583657588,
            "pseudo_barinel_susp": 0.001455604075691412
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.handle_single_axis#2465",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.handle_single_axis(scale, autoscaleon, shared_axes, interval, minpos, axis, margin, stickies, set_bound)",
        "snippet": "        def handle_single_axis(scale, autoscaleon, shared_axes, interval,\n                               minpos, axis, margin, stickies, set_bound):\n\n            if not (scale and autoscaleon):\n                return  # nothing to do...\n\n            shared = shared_axes.get_siblings(self)\n            dl = [ax.dataLim for ax in shared]\n            # ignore non-finite data limits if good limits exist\n            finite_dl = [d for d in dl if np.isfinite(d).all()]\n            if len(finite_dl):\n                # if finite limits exist for atleast one axis (and the\n                # other is infinite), restore the finite limits\n                x_finite = [d for d in dl\n                            if (np.isfinite(d.intervalx).all() and\n                                (d not in finite_dl))]\n                y_finite = [d for d in dl\n                            if (np.isfinite(d.intervaly).all() and\n                                (d not in finite_dl))]\n\n                dl = finite_dl\n                dl.extend(x_finite)\n                dl.extend(y_finite)\n\n            bb = mtransforms.BboxBase.union(dl)\n            x0, x1 = getattr(bb, interval)\n            # If x0 and x1 are non finite, use the locator to figure out\n            # default limits.\n            locator = axis.get_major_locator()\n            x0, x1 = locator.nonsingular(x0, x1)\n\n            # Prevent margin addition from crossing a sticky value.  Small\n            # tolerances (whose values come from isclose()) must be used due to\n            # floating point issues with streamplot.\n            def tol(x): return 1e-5 * abs(x) + 1e-8\n            # Index of largest element < x0 + tol, if any.\n            i0 = stickies.searchsorted(x0 + tol(x0)) - 1\n            x0bound = stickies[i0] if i0 != -1 else None\n            # Index of smallest element > x1 - tol, if any.\n            i1 = stickies.searchsorted(x1 - tol(x1))\n            x1bound = stickies[i1] if i1 != len(stickies) else None\n\n            # Add the margin in figure space and then transform back, to handle\n            # non-linear scales.\n            minpos = getattr(bb, minpos)\n            transform = axis.get_transform()\n            inverse_trans = transform.inverted()\n            x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minpos)\n            x0t, x1t = transform.transform([x0, x1])\n            delta = (x1t - x0t) * margin\n            if not np.isfinite(delta):\n                delta = 0  # If a bound isn't finite, set margin to zero.\n            x0, x1 = inverse_trans.transform([x0t - delta, x1t + delta])\n\n            # Apply sticky bounds.\n            if x0bound is not None:\n                x0 = max(x0, x0bound)\n            if x1bound is not None:\n                x1 = min(x1, x1bound)\n\n            if not self._tight:\n                x0, x1 = locator.view_limits(x0, x1)\n            set_bound(x0, x1)",
        "begin_line": 2465,
        "end_line": 2527,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040290088638195,
            "pseudo_dstar_susp": 0.00036859565057132326,
            "pseudo_tarantula_susp": 0.000942507068803016,
            "pseudo_op2_susp": 0.00036859565057132326,
            "pseudo_barinel_susp": 0.000942507068803016
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.tol#2499",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.tol(x)",
        "snippet": "            def tol(x): return 1e-5 * abs(x) + 1e-8",
        "begin_line": 2499,
        "end_line": 2499,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000392156862745098,
            "pseudo_dstar_susp": 0.0003606202668589975,
            "pseudo_tarantula_susp": 0.0008561643835616438,
            "pseudo_op2_susp": 0.0003606202668589975,
            "pseudo_barinel_susp": 0.0008561643835616438
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._get_axis_list#2537",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._get_axis_list(self)",
        "snippet": "    def _get_axis_list(self):\n        return self.xaxis, self.yaxis",
        "begin_line": 2537,
        "end_line": 2538,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012422360248447205,
            "pseudo_dstar_susp": 0.002257336343115124,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.002257336343115124,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._update_title_position#2558",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._update_title_position(self, renderer)",
        "snippet": "    def _update_title_position(self, renderer):\n        \"\"\"\n        Update the title position based on the bounding box enclosing\n        all the ticklabels and x-axis spine and xlabel...\n        \"\"\"\n\n        if self._autotitlepos is not None and not self._autotitlepos:\n            _log.debug('title position was updated manually, not adjusting')\n            return\n\n        titles = (self.title, self._left_title, self._right_title)\n\n        if self._autotitlepos is None:\n            for title in titles:\n                x, y = title.get_position()\n                if not np.isclose(y, 1.0):\n                    self._autotitlepos = False\n                    _log.debug('not adjusting title pos because a title was '\n                               'already placed manually: %f', y)\n                    return\n            self._autotitlepos = True\n\n        for title in titles:\n            x, _ = title.get_position()\n            # need to start again in case of window resizing\n            title.set_position((x, 1.0))\n            # need to check all our twins too...\n            axs = self._twinned_axes.get_siblings(self)\n            # and all the children\n            for ax in self.child_axes:\n                if ax is not None:\n                    locator = ax.get_axes_locator()\n                    if locator:\n                        pos = locator(self, renderer)\n                        ax.apply_aspect(pos)\n                    else:\n                        ax.apply_aspect()\n                    axs = axs + [ax]\n            top = 0\n            for ax in axs:\n                if (ax.xaxis.get_ticks_position() in ['top', 'unknown']\n                        or ax.xaxis.get_label_position() == 'top'):\n                    bb = ax.xaxis.get_tightbbox(renderer)\n                else:\n                    bb = ax.get_window_extent(renderer)\n                if bb is not None:\n                    top = max(top, bb.ymax)\n            if title.get_window_extent(renderer).ymin < top:\n                _, y = self.transAxes.inverted().transform((0, top))\n                title.set_position((x, y))\n                # empirically, this doesn't always get the min to top,\n                # so we need to adjust again.\n                if title.get_window_extent(renderer).ymin < top:\n                    _, y = self.transAxes.inverted().transform(\n                        (0., 2 * top - title.get_window_extent(renderer).ymin))\n                    title.set_position((x, y))\n\n        ymax = max(title.get_position()[1] for title in titles)\n        for title in titles:\n            # now line up all the titles at the highest baseline.\n            x, _ = title.get_position()\n            title.set_position((x, ymax))",
        "begin_line": 2558,
        "end_line": 2619,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040551500405515005,
            "pseudo_dstar_susp": 0.00037037037037037035,
            "pseudo_tarantula_susp": 0.0009606147934678194,
            "pseudo_op2_susp": 0.00037037037037037035,
            "pseudo_barinel_susp": 0.0009606147934678194
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.draw#2625",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.draw(self, renderer=None, inframe=False)",
        "snippet": "    def draw(self, renderer=None, inframe=False):\n        # docstring inherited\n        if renderer is None:\n            cbook.warn_deprecated(\n                \"3.3\", message=\"Support for not passing the 'renderer' \"\n                \"parameter to Axes.draw() is deprecated since %(since)s and \"\n                \"will be removed %(removal)s.  Use axes.draw_artist(axes) \"\n                \"instead.\")\n            renderer = self.figure._cachedRenderer\n        if renderer is None:\n            raise RuntimeError('No renderer defined')\n        if not self.get_visible():\n            return\n        self._unstale_viewLim()\n\n        renderer.open_group('axes', gid=self.get_gid())\n\n        # prevent triggering call backs during the draw process\n        self._stale = True\n\n        # loop over self and child axes...\n        locator = self.get_axes_locator()\n        if locator:\n            pos = locator(self, renderer)\n            self.apply_aspect(pos)\n        else:\n            self.apply_aspect()\n\n        artists = self.get_children()\n        artists.remove(self.patch)\n\n        # the frame draws the edges around the axes patch -- we\n        # decouple these so the patch can be in the background and the\n        # frame in the foreground. Do this before drawing the axis\n        # objects so that the spine has the opportunity to update them.\n        if not (self.axison and self._frameon):\n            for spine in self.spines.values():\n                artists.remove(spine)\n\n        self._update_title_position(renderer)\n\n        if not self.axison or inframe:\n            for _axis in self._get_axis_list():\n                artists.remove(_axis)\n\n        if inframe:\n            artists.remove(self.title)\n            artists.remove(self._left_title)\n            artists.remove(self._right_title)\n\n        if not self.figure.canvas.is_saving():\n            artists = [a for a in artists\n                       if not a.get_animated() or a in self.images]\n        artists = sorted(artists, key=attrgetter('zorder'))\n\n        # rasterize artists with negative zorder\n        # if the minimum zorder is negative, start rasterization\n        rasterization_zorder = self._rasterization_zorder\n\n        if (rasterization_zorder is not None and\n                artists and artists[0].zorder < rasterization_zorder):\n            renderer.start_rasterizing()\n            artists_rasterized = [a for a in artists\n                                  if a.zorder < rasterization_zorder]\n            artists = [a for a in artists\n                       if a.zorder >= rasterization_zorder]\n        else:\n            artists_rasterized = []\n\n        # the patch draws the background rectangle -- the frame below\n        # will draw the edges\n        if self.axison and self._frameon:\n            self.patch.draw(renderer)\n\n        if artists_rasterized:\n            for a in artists_rasterized:\n                a.draw(renderer)\n            renderer.stop_rasterizing()\n\n        mimage._draw_list_compositing_images(renderer, self, artists)\n\n        renderer.close_group('axes')\n        self.stale = False",
        "begin_line": 2625,
        "end_line": 2707,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004361098996947231,
            "pseudo_dstar_susp": 0.0003875968992248062,
            "pseudo_tarantula_susp": 0.001422475106685633,
            "pseudo_op2_susp": 0.0003875968992248062,
            "pseudo_barinel_susp": 0.001422475106685633
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.draw_artist#2709",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.draw_artist(self, a)",
        "snippet": "    def draw_artist(self, a):\n        \"\"\"\n        This method can only be used after an initial draw which\n        caches the renderer.  It is used to efficiently update Axes\n        data (axis ticks, labels, etc are not updated).\n        \"\"\"\n        if self.figure._cachedRenderer is None:\n            raise AttributeError(\"draw_artist can only be used after an \"\n                                 \"initial draw which caches the renderer\")\n        a.draw(self.figure._cachedRenderer)",
        "begin_line": 2709,
        "end_line": 2718,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_frame_on#2741",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_frame_on(self)",
        "snippet": "    def get_frame_on(self):\n        \"\"\"Get whether the axes rectangle patch is drawn.\"\"\"\n        return self._frameon",
        "begin_line": 2741,
        "end_line": 2743,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_frame_on#2745",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_frame_on(self, b)",
        "snippet": "    def set_frame_on(self, b):\n        \"\"\"\n        Set whether the axes rectangle patch is drawn.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._frameon = b\n        self.stale = True",
        "begin_line": 2745,
        "end_line": 2754,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_axisbelow#2770",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_axisbelow(self, b)",
        "snippet": "    def set_axisbelow(self, b):\n        \"\"\"\n        Set whether axis ticks and gridlines are above or below most artists.\n\n        This controls the zorder of the ticks and gridlines. For more\n        information on the zorder see :doc:`/gallery/misc/zorder_demo`.\n\n        Parameters\n        ----------\n        b : bool or 'line'\n            Possible values:\n\n            - *True* (zorder = 0.5): Ticks and gridlines are below all Artists.\n            - 'line' (zorder = 1.5): Ticks and gridlines are above patches\n              (e.g. rectangles, with default zorder = 1) but still below lines\n              and markers (with their default zorder = 2).\n            - *False* (zorder = 2.5): Ticks and gridlines are above patches\n              and lines / markers.\n\n        See Also\n        --------\n        get_axisbelow\n        \"\"\"\n        self._axisbelow = axisbelow = validate_axisbelow(b)\n        if axisbelow is True:\n            zorder = 0.5\n        elif axisbelow is False:\n            zorder = 2.5\n        elif axisbelow == \"line\":\n            zorder = 1.5\n        else:\n            raise ValueError(\"Unexpected axisbelow value\")\n        for axis in self._get_axis_list():\n            axis.set_zorder(zorder)\n        self.stale = True",
        "begin_line": 2770,
        "end_line": 2804,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014947683109118087,
            "pseudo_dstar_susp": 0.002652519893899204,
            "pseudo_tarantula_susp": 0.0012987012987012987,
            "pseudo_op2_susp": 0.002652519893899204,
            "pseudo_barinel_susp": 0.0012987012987012987
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.grid#2807",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.grid(self, b=None, which='major', axis='both', **kwargs)",
        "snippet": "    def grid(self, b=None, which='major', axis='both', **kwargs):\n        \"\"\"\n        Configure the grid lines.\n\n        Parameters\n        ----------\n        b : bool or None, optional\n            Whether to show the grid lines. If any *kwargs* are supplied,\n            it is assumed you want the grid on and *b* will be set to True.\n\n            If *b* is *None* and there are no *kwargs*, this toggles the\n            visibility of the lines.\n\n        which : {'major', 'minor', 'both'}, optional\n            The grid lines to apply the changes on.\n\n        axis : {'both', 'x', 'y'}, optional\n            The axis to apply the changes on.\n\n        **kwargs : `.Line2D` properties\n            Define the line properties of the grid, e.g.::\n\n                grid(color='r', linestyle='-', linewidth=2)\n\n            Valid keyword arguments are:\n\n            %(_Line2D_docstr)s\n\n        Notes\n        -----\n        The axis is drawn as a unit, so the effective zorder for drawing the\n        grid is determined by the zorder of each axis, not by the zorder of the\n        `.Line2D` objects comprising the grid.  Therefore, to set grid zorder,\n        use `.set_axisbelow` or, for more control, call the\n        `~matplotlib.axis.Axis.set_zorder` method of each axis.\n        \"\"\"\n        if len(kwargs):\n            b = True\n        cbook._check_in_list(['x', 'y', 'both'], axis=axis)\n        if axis in ['x', 'both']:\n            self.xaxis.grid(b, which=which, **kwargs)\n        if axis in ['y', 'both']:\n            self.yaxis.grid(b, which=which, **kwargs)",
        "begin_line": 2807,
        "end_line": 2849,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001182033096926714,
            "pseudo_dstar_susp": 0.0020876826722338203,
            "pseudo_tarantula_susp": 0.0005205622071837585,
            "pseudo_op2_susp": 0.0020876826722338203,
            "pseudo_barinel_susp": 0.0005205622071837585
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.locator_params#2926",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.locator_params(self, axis='both', tight=None, **kwargs)",
        "snippet": "    def locator_params(self, axis='both', tight=None, **kwargs):\n        \"\"\"\n        Control behavior of major tick locators.\n\n        Because the locator is involved in autoscaling, `~.Axes.autoscale_view`\n        is called automatically after the parameters are changed.\n\n        Parameters\n        ----------\n        axis : {'both', 'x', 'y'}, default: 'both'\n            The axis on which to operate.\n\n        tight : bool or None, optional\n            Parameter passed to `~.Axes.autoscale_view`.\n            Default is None, for no change.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Remaining keyword arguments are passed to directly to the\n            ``set_params()`` method of the locator. Supported keywords depend\n            on the type of the locator. See for example\n            `~.ticker.MaxNLocator.set_params` for the `.ticker.MaxNLocator`\n            used by default for linear axes.\n\n        Examples\n        --------\n        When plotting small subplots, one might want to reduce the maximum\n        number of ticks and use tight bounds, for example::\n\n            ax.locator_params(tight=True, nbins=4)\n\n        \"\"\"\n        cbook._check_in_list(['x', 'y', 'both'], axis=axis)\n        update_x = axis in ['x', 'both']\n        update_y = axis in ['y', 'both']\n        if update_x:\n            self.xaxis.get_major_locator().set_params(**kwargs)\n        if update_y:\n            self.yaxis.get_major_locator().set_params(**kwargs)\n        self._request_autoscale_view(tight=tight,\n                                     scalex=update_x, scaley=update_y)",
        "begin_line": 2926,
        "end_line": 2967,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.tick_params#2969",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.tick_params(self, axis='both', **kwargs)",
        "snippet": "    def tick_params(self, axis='both', **kwargs):\n        \"\"\"Change the appearance of ticks, tick labels, and gridlines.\n\n        Tick properties that are not explicitly set using the keyword\n        arguments remain unchanged unless *reset* is True.\n\n        Parameters\n        ----------\n        axis : {'x', 'y', 'both'}, default: 'both'\n            The axis to which the parameters are applied.\n        which : {'major', 'minor', 'both'}, default: 'major'\n            The group of ticks to which the parameters are applied.\n        reset : bool, default: False\n            Whether to reset the ticks to defaults before updating them.\n\n        Other Parameters\n        ----------------\n        direction : {'in', 'out', 'inout'}\n            Puts ticks inside the axes, outside the axes, or both.\n        length : float\n            Tick length in points.\n        width : float\n            Tick width in points.\n        color : color\n            Tick color.\n        pad : float\n            Distance in points between tick and label.\n        labelsize : float or str\n            Tick label font size in points or as a string (e.g., 'large').\n        labelcolor : color\n            Tick label color.\n        colors : color\n            Tick color and label color.\n        zorder : float\n            Tick and label zorder.\n        bottom, top, left, right : bool\n            Whether to draw the respective ticks.\n        labelbottom, labeltop, labelleft, labelright : bool\n            Whether to draw the respective tick labels.\n        labelrotation : float\n            Tick label rotation\n        grid_color : color\n            Gridline color.\n        grid_alpha : float\n            Transparency of gridlines: 0 (transparent) to 1 (opaque).\n        grid_linewidth : float\n            Width of gridlines in points.\n        grid_linestyle : str\n            Any valid `.Line2D` line style spec.\n\n        Examples\n        --------\n        ::\n\n            ax.tick_params(direction='out', length=6, width=2, colors='r',\n                           grid_color='r', grid_alpha=0.5)\n\n        This will make all major ticks be red, pointing out of the box,\n        and with dimensions 6 points by 2 points.  Tick labels will\n        also be red.  Gridlines will be red and translucent.\n\n        \"\"\"\n        cbook._check_in_list(['x', 'y', 'both'], axis=axis)\n        if axis in ['x', 'both']:\n            xkw = dict(kwargs)\n            xkw.pop('left', None)\n            xkw.pop('right', None)\n            xkw.pop('labelleft', None)\n            xkw.pop('labelright', None)\n            self.xaxis.set_tick_params(**xkw)\n        if axis in ['y', 'both']:\n            ykw = dict(kwargs)\n            ykw.pop('top', None)\n            ykw.pop('bottom', None)\n            ykw.pop('labeltop', None)\n            ykw.pop('labelbottom', None)\n            self.yaxis.set_tick_params(**ykw)",
        "begin_line": 2969,
        "end_line": 3045,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012330456226880395,
            "pseudo_dstar_susp": 0.0022271714922048997,
            "pseudo_tarantula_susp": 0.0012610340479192938,
            "pseudo_op2_susp": 0.0022271714922048997,
            "pseudo_barinel_susp": 0.0012626262626262627
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_axis_off#3047",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_axis_off(self)",
        "snippet": "    def set_axis_off(self):\n        \"\"\"\n        Turn the x- and y-axis off.\n\n        This affects the axis lines, ticks, ticklabels, grid and axis labels.\n        \"\"\"\n        self.axison = False\n        self.stale = True",
        "begin_line": 3047,
        "end_line": 3054,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005817335660267597,
            "pseudo_dstar_susp": 0.00042176296921130323,
            "pseudo_tarantula_susp": 0.002398081534772182,
            "pseudo_op2_susp": 0.00042176296921130323,
            "pseudo_barinel_susp": 0.002398081534772182
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_axis_on#3056",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_axis_on(self)",
        "snippet": "    def set_axis_on(self):\n        \"\"\"\n        Turn the x- and y-axis on.\n\n        This affects the axis lines, ticks, ticklabels, grid and axis labels.\n        \"\"\"\n        self.axison = True\n        self.stale = True",
        "begin_line": 3056,
        "end_line": 3063,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012360939431396785,
            "pseudo_dstar_susp": 0.0022371364653243847,
            "pseudo_tarantula_susp": 0.0012610340479192938,
            "pseudo_op2_susp": 0.0022371364653243847,
            "pseudo_barinel_susp": 0.0012626262626262627
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.invert_xaxis#3067",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.invert_xaxis(self)",
        "snippet": "    def invert_xaxis(self):\n        \"\"\"\n        Invert the x-axis.\n\n        See Also\n        --------\n        xaxis_inverted\n        get_xlim, set_xlim\n        get_xbound, set_xbound\n        \"\"\"\n        self.xaxis.set_inverted(not self.xaxis.get_inverted())",
        "begin_line": 3067,
        "end_line": 3077,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.xaxis_inverted#3079",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.xaxis_inverted(self)",
        "snippet": "    def xaxis_inverted(self):\n        \"\"\"\n        Return whether the x-axis is inverted.\n\n        The axis is inverted if the left value is larger than the right value.\n\n        See Also\n        --------\n        invert_xaxis\n        get_xlim, set_xlim\n        get_xbound, set_xbound\n        \"\"\"\n        return self.xaxis.get_inverted()",
        "begin_line": 3079,
        "end_line": 3091,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003861003861003861,
            "pseudo_dstar_susp": 0.000355998576005696,
            "pseudo_tarantula_susp": 0.0008077544426494346,
            "pseudo_op2_susp": 0.000355998576005696,
            "pseudo_barinel_susp": 0.0008077544426494346
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_xbound#3093",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_xbound(self)",
        "snippet": "    def get_xbound(self):\n        \"\"\"\n        Return the lower and upper x-axis bounds, in increasing order.\n\n        See Also\n        --------\n        set_xbound\n        get_xlim, set_xlim\n        invert_xaxis, xaxis_inverted\n        \"\"\"\n        left, right = self.get_xlim()\n        if left < right:\n            return left, right\n        else:\n            return right, left",
        "begin_line": 3093,
        "end_line": 3107,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038880248833592535,
            "pseudo_dstar_susp": 0.00035816618911174784,
            "pseudo_tarantula_susp": 0.0008305647840531562,
            "pseudo_op2_susp": 0.00035816618911174784,
            "pseudo_barinel_susp": 0.0008305647840531562
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_xbound#3109",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_xbound(self, lower=None, upper=None)",
        "snippet": "    def set_xbound(self, lower=None, upper=None):\n        \"\"\"\n        Set the lower and upper numerical bounds of the x-axis.\n\n        This method will honor axes inversion regardless of parameter order.\n        It will not change the autoscaling setting (`.get_autoscalex_on()`).\n\n        Parameters\n        ----------\n        lower, upper : float or None\n            The lower and upper bounds. If *None*, the respective axis bound\n            is not modified.\n\n        See Also\n        --------\n        get_xbound\n        get_xlim, set_xlim\n        invert_xaxis, xaxis_inverted\n        \"\"\"\n        if upper is None and np.iterable(lower):\n            lower, upper = lower\n\n        old_lower, old_upper = self.get_xbound()\n        if lower is None:\n            lower = old_lower\n        if upper is None:\n            upper = old_upper\n\n        self.set_xlim(sorted((lower, upper),\n                             reverse=bool(self.xaxis_inverted())),\n                      auto=None)",
        "begin_line": 3109,
        "end_line": 3139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000392156862745098,
            "pseudo_dstar_susp": 0.0003606202668589975,
            "pseudo_tarantula_susp": 0.0008561643835616438,
            "pseudo_op2_susp": 0.0003606202668589975,
            "pseudo_barinel_susp": 0.0008561643835616438
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_xlim#3141",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_xlim(self)",
        "snippet": "    def get_xlim(self):\n        \"\"\"\n        Return the x-axis view limits.\n\n        Returns\n        -------\n        left, right : (float, float)\n            The current x-axis limits in data coordinates.\n\n        See Also\n        --------\n        set_xlim\n        set_xbound, get_xbound\n        invert_xaxis, xaxis_inverted\n\n        Notes\n        -----\n        The x-axis may be inverted, in which case the *left* value will\n        be greater than the *right* value.\n\n        \"\"\"\n        return tuple(self.viewLim.intervalx)",
        "begin_line": 3141,
        "end_line": 3162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003812428516965307,
            "pseudo_dstar_susp": 0.00035198873636043646,
            "pseudo_tarantula_susp": 0.0007564296520423601,
            "pseudo_op2_susp": 0.00035198873636043646,
            "pseudo_barinel_susp": 0.0007564296520423601
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._validate_converted_limits#3164",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._validate_converted_limits(self, limit, convert)",
        "snippet": "    def _validate_converted_limits(self, limit, convert):\n        \"\"\"\n        Raise ValueError if converted limits are non-finite.\n\n        Note that this function also accepts None as a limit argument.\n\n        Returns\n        -------\n        The limit value after call to convert(), or None if limit is None.\n        \"\"\"\n        if limit is not None:\n            converted_limit = convert(limit)\n            if (isinstance(converted_limit, Real)\n                    and not np.isfinite(converted_limit)):\n                raise ValueError(\"Axis limits cannot be NaN or Inf\")\n            return converted_limit",
        "begin_line": 3164,
        "end_line": 3179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009416195856873823,
            "pseudo_dstar_susp": 0.0015174506828528073,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0015174506828528073,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_xlim#3181",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_xlim(self, left=None, right=None, emit=True, auto=False, *, xmin=None, xmax=None)",
        "snippet": "    def set_xlim(self, left=None, right=None, emit=True, auto=False,\n                 *, xmin=None, xmax=None):\n        \"\"\"\n        Set the x-axis view limits.\n\n        Parameters\n        ----------\n        left : float, optional\n            The left xlim in data coordinates. Passing *None* leaves the\n            limit unchanged.\n\n            The left and right xlims may also be passed as the tuple\n            (*left*, *right*) as the first positional argument (or as\n            the *left* keyword argument).\n\n            .. ACCEPTS: (bottom: float, top: float)\n\n        right : float, optional\n            The right xlim in data coordinates. Passing *None* leaves the\n            limit unchanged.\n\n        emit : bool, default: True\n            Whether to notify observers of limit change.\n\n        auto : bool or None, default: False\n            Whether to turn on autoscaling of the x-axis. True turns on,\n            False turns off, None leaves unchanged.\n\n        xmin, xmax : float, optional\n            They are equivalent to left and right respectively,\n            and it is an error to pass both *xmin* and *left* or\n            *xmax* and *right*.\n\n        Returns\n        -------\n        left, right : (float, float)\n            The new x-axis limits in data coordinates.\n\n        See Also\n        --------\n        get_xlim\n        set_xbound, get_xbound\n        invert_xaxis, xaxis_inverted\n\n        Notes\n        -----\n        The *left* value may be greater than the *right* value, in which\n        case the x-axis values will decrease from left to right.\n\n        Examples\n        --------\n        >>> set_xlim(left, right)\n        >>> set_xlim((left, right))\n        >>> left, right = set_xlim(left, right)\n\n        One limit may be left unchanged.\n\n        >>> set_xlim(right=right_lim)\n\n        Limits may be passed in reverse order to flip the direction of\n        the x-axis. For example, suppose *x* represents the number of\n        years before present. The x-axis limits might be set like the\n        following so 5000 years ago is on the left of the plot and the\n        present is on the right.\n\n        >>> set_xlim(5000, 0)\n\n        \"\"\"\n        if right is None and np.iterable(left):\n            left, right = left\n        if xmin is not None:\n            if left is not None:\n                raise TypeError('Cannot pass both `xmin` and `left`')\n            left = xmin\n        if xmax is not None:\n            if right is not None:\n                raise TypeError('Cannot pass both `xmax` and `right`')\n            right = xmax\n\n        self._process_unit_info(xdata=(left, right))\n        left = self._validate_converted_limits(left, self.convert_xunits)\n        right = self._validate_converted_limits(right, self.convert_xunits)\n\n        if left is None or right is None:\n            # Axes init calls set_xlim(0, 1) before get_xlim() can be called,\n            # so only grab the limits if we really need them.\n            old_left, old_right = self.get_xlim()\n            if left is None:\n                left = old_left\n            if right is None:\n                right = old_right\n\n        if self.get_xscale() == 'log' and (left <= 0 or right <= 0):\n            # Axes init calls set_xlim(0, 1) before get_xlim() can be called,\n            # so only grab the limits if we really need them.\n            old_left, old_right = self.get_xlim()\n            if left <= 0:\n                cbook._warn_external(\n                    'Attempted to set non-positive left xlim on a '\n                    'log-scaled axis.\\n'\n                    'Invalid limit will be ignored.')\n                left = old_left\n            if right <= 0:\n                cbook._warn_external(\n                    'Attempted to set non-positive right xlim on a '\n                    'log-scaled axis.\\n'\n                    'Invalid limit will be ignored.')\n                right = old_right\n        if left == right:\n            cbook._warn_external(\n                f\"Attempting to set identical left == right == {left} results \"\n                f\"in singular transformations; automatically expanding.\")\n        reverse = left > right\n        left, right = self.xaxis.get_major_locator().nonsingular(left, right)\n        left, right = self.xaxis.limit_range_for_scale(left, right)\n        # cast to bool to avoid bad interaction between python 3.8 and np.bool_\n        left, right = sorted([left, right], reverse=bool(reverse))\n\n        self._viewLim.intervalx = (left, right)\n        if auto is not None:\n            self._autoscaleXon = bool(auto)\n\n        if emit:\n            self.callbacks.process('xlim_changed', self)\n            # Call all of the other x-axes that are shared with this one\n            for other in self._shared_x_axes.get_siblings(self):\n                if other is not self:\n                    other.set_xlim(self.viewLim.intervalx,\n                                   emit=False, auto=auto)\n                    if other.figure != self.figure:\n                        other.figure.canvas.draw_idle()\n        self.stale = True\n        return left, right",
        "begin_line": 3181,
        "end_line": 3313,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011695906432748538,
            "pseudo_dstar_susp": 0.0020491803278688526,
            "pseudo_tarantula_susp": 0.001455604075691412,
            "pseudo_op2_susp": 0.0020491803278688526,
            "pseudo_barinel_susp": 0.001455604075691412
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_xscale#3315",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_xscale(self)",
        "snippet": "    def get_xscale(self):\n        \"\"\"\n        Return the x-axis scale as string.\n\n        See Also\n        --------\n        set_xscale\n        \"\"\"\n        return self.xaxis.get_scale()",
        "begin_line": 3315,
        "end_line": 3323,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009416195856873823,
            "pseudo_dstar_susp": 0.0015174506828528073,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0015174506828528073,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_xscale#3325",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_xscale(self, value, **kwargs)",
        "snippet": "    def set_xscale(self, value, **kwargs):\n        \"\"\"\n        Set the x-axis scale.\n\n        Parameters\n        ----------\n        value : {\"linear\", \"log\", \"symlog\", \"logit\", ...}\n            The axis scale type to apply.\n\n        **kwargs\n            Different keyword arguments are accepted, depending on the scale.\n            See the respective class keyword arguments:\n\n            - `matplotlib.scale.LinearScale`\n            - `matplotlib.scale.LogScale`\n            - `matplotlib.scale.SymmetricalLogScale`\n            - `matplotlib.scale.LogitScale`\n\n        Notes\n        -----\n        By default, Matplotlib supports the above mentioned scales.\n        Additionally, custom scales may be registered using\n        `matplotlib.scale.register_scale`. These scales can then also\n        be used here.\n        \"\"\"\n        old_default_lims = (self.xaxis.get_major_locator()\n                            .nonsingular(-np.inf, np.inf))\n        g = self.get_shared_x_axes()\n        for ax in g.get_siblings(self):\n            ax.xaxis._set_scale(value, **kwargs)\n            ax._update_transScale()\n            ax.stale = True\n        new_default_lims = (self.xaxis.get_major_locator()\n                            .nonsingular(-np.inf, np.inf))\n        if old_default_lims != new_default_lims:\n            # Force autoscaling now, to take advantage of the scale locator's\n            # nonsingular() before it possibly gets swapped out by the user.\n            self.autoscale_view(scaley=False)",
        "begin_line": 3325,
        "end_line": 3362,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.714396735962697e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_xticks#3370",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_xticks(self, ticks, minor=False)",
        "snippet": "    def set_xticks(self, ticks, minor=False):\n        \"\"\"\n        Set the x ticks with list of *ticks*\n\n        Parameters\n        ----------\n        ticks : list\n            List of x-axis tick locations.\n        minor : bool, default: False\n            If ``False`` sets major ticks, if ``True`` sets minor ticks.\n        \"\"\"\n        ret = self.xaxis.set_ticks(ticks, minor=minor)\n        self.stale = True\n        return ret",
        "begin_line": 3370,
        "end_line": 3383,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.872327211427557e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_xticklabels#3407",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_xticklabels(self, minor=False, which=None)",
        "snippet": "    def get_xticklabels(self, minor=False, which=None):\n        \"\"\"\n        Get the x tick labels as a list of `~matplotlib.text.Text` instances.\n\n        Parameters\n        ----------\n        minor : bool, optional\n           If True return the minor ticklabels,\n           else return the major ticklabels.\n\n        which : None, ('minor', 'major', 'both')\n           Overrides *minor*.\n\n           Selects which ticklabels to return\n\n        Returns\n        -------\n        ret : list\n           List of `~matplotlib.text.Text` instances.\n\n        Notes\n        -----\n        The tick label strings are not populated until a ``draw``\n        method has been called.\n\n        See also: `~.pyplot.draw` and `~.FigureCanvasBase.draw`.\n        \"\"\"\n        return self.xaxis.get_ticklabels(minor=minor, which=which)",
        "begin_line": 3407,
        "end_line": 3434,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_xticklabels#3436",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_xticklabels(self, labels, fontdict=None, minor=False, **kwargs)",
        "snippet": "    def set_xticklabels(self, labels, fontdict=None, minor=False, **kwargs):\n        \"\"\"\n        Set the x-tick labels with list of string labels.\n\n        .. warning::\n            This method should only be used after fixing the tick positions\n            using `~.axes.Axes.set_xticks`. Otherwise, the labels may end up\n            in unexpected positions.\n\n        Parameters\n        ----------\n        labels : list of str\n            The label texts.\n\n        fontdict : dict, optional\n            A dictionary controlling the appearance of the ticklabels.\n            The default *fontdict* is::\n\n               {'fontsize': rcParams['axes.titlesize'],\n                'fontweight': rcParams['axes.titleweight'],\n                'verticalalignment': 'baseline',\n                'horizontalalignment': loc}\n\n        minor : bool, default: False\n            Whether to set the minor ticklabels rather than the major ones.\n\n        Returns\n        -------\n        labels : list of `~.Text`\n            The labels.\n\n        Other Parameters\n        -----------------\n        **kwargs : `~.text.Text` properties.\n        \"\"\"\n        if fontdict is not None:\n            kwargs.update(fontdict)\n        ret = self.xaxis.set_ticklabels(labels,\n                                        minor=minor, **kwargs)\n        self.stale = True\n        return ret",
        "begin_line": 3436,
        "end_line": 3476,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.invert_yaxis#3478",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.invert_yaxis(self)",
        "snippet": "    def invert_yaxis(self):\n        \"\"\"\n        Invert the y-axis.\n\n        See Also\n        --------\n        yaxis_inverted\n        get_ylim, set_ylim\n        get_ybound, set_ybound\n        \"\"\"\n        self.yaxis.set_inverted(not self.yaxis.get_inverted())",
        "begin_line": 3478,
        "end_line": 3488,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.yaxis_inverted#3490",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.yaxis_inverted(self)",
        "snippet": "    def yaxis_inverted(self):\n        \"\"\"\n        Return whether the y-axis is inverted.\n\n        The axis is inverted if the bottom value is larger than the top value.\n\n        See Also\n        --------\n        invert_yaxis\n        get_ylim, set_ylim\n        get_ybound, set_ybound\n        \"\"\"\n        return self.yaxis.get_inverted()",
        "begin_line": 3490,
        "end_line": 3502,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003861003861003861,
            "pseudo_dstar_susp": 0.000355998576005696,
            "pseudo_tarantula_susp": 0.0008077544426494346,
            "pseudo_op2_susp": 0.000355998576005696,
            "pseudo_barinel_susp": 0.0008077544426494346
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_ybound#3504",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_ybound(self)",
        "snippet": "    def get_ybound(self):\n        \"\"\"\n        Return the lower and upper y-axis bounds, in increasing order.\n\n        See Also\n        --------\n        set_ybound\n        get_ylim, set_ylim\n        invert_yaxis, yaxis_inverted\n        \"\"\"\n        bottom, top = self.get_ylim()\n        if bottom < top:\n            return bottom, top\n        else:\n            return top, bottom",
        "begin_line": 3504,
        "end_line": 3518,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00039761431411530816,
            "pseudo_dstar_susp": 0.0003650967506389193,
            "pseudo_tarantula_susp": 0.0009115770282588879,
            "pseudo_op2_susp": 0.0003650967506389193,
            "pseudo_barinel_susp": 0.0009115770282588879
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_ybound#3520",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_ybound(self, lower=None, upper=None)",
        "snippet": "    def set_ybound(self, lower=None, upper=None):\n        \"\"\"\n        Set the lower and upper numerical bounds of the y-axis.\n\n        This method will honor axes inversion regardless of parameter order.\n        It will not change the autoscaling setting (`.get_autoscaley_on()`).\n\n        Parameters\n        ----------\n        lower, upper : float or None\n            The lower and upper bounds. If *None*, the respective axis bound\n            is not modified.\n\n        See Also\n        --------\n        get_ybound\n        get_ylim, set_ylim\n        invert_yaxis, yaxis_inverted\n        \"\"\"\n        if upper is None and np.iterable(lower):\n            lower, upper = lower\n\n        old_lower, old_upper = self.get_ybound()\n        if lower is None:\n            lower = old_lower\n        if upper is None:\n            upper = old_upper\n\n        self.set_ylim(sorted((lower, upper),\n                             reverse=bool(self.yaxis_inverted())),\n                      auto=None)",
        "begin_line": 3520,
        "end_line": 3550,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000392156862745098,
            "pseudo_dstar_susp": 0.0003606202668589975,
            "pseudo_tarantula_susp": 0.0008561643835616438,
            "pseudo_op2_susp": 0.0003606202668589975,
            "pseudo_barinel_susp": 0.0008561643835616438
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_ylim#3552",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_ylim(self)",
        "snippet": "    def get_ylim(self):\n        \"\"\"\n        Return the y-axis view limits.\n\n        Returns\n        -------\n        bottom, top : (float, float)\n            The current y-axis limits in data coordinates.\n\n        See Also\n        --------\n        set_ylim\n        set_ybound, get_ybound\n        invert_yaxis, yaxis_inverted\n\n        Notes\n        -----\n        The y-axis may be inverted, in which case the *bottom* value\n        will be greater than the *top* value.\n\n        \"\"\"\n        return tuple(self.viewLim.intervaly)",
        "begin_line": 3552,
        "end_line": 3573,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00037778617302606723,
            "pseudo_dstar_susp": 0.00034916201117318437,
            "pseudo_tarantula_susp": 0.0007358351729212656,
            "pseudo_op2_susp": 0.00034916201117318437,
            "pseudo_barinel_susp": 0.0007358351729212656
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_ylim#3575",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_ylim(self, bottom=None, top=None, emit=True, auto=False, *, ymin=None, ymax=None)",
        "snippet": "    def set_ylim(self, bottom=None, top=None, emit=True, auto=False,\n                 *, ymin=None, ymax=None):\n        \"\"\"\n        Set the y-axis view limits.\n\n        Parameters\n        ----------\n        bottom : float, optional\n            The bottom ylim in data coordinates. Passing *None* leaves the\n            limit unchanged.\n\n            The bottom and top ylims may also be passed as the tuple\n            (*bottom*, *top*) as the first positional argument (or as\n            the *bottom* keyword argument).\n\n            .. ACCEPTS: (bottom: float, top: float)\n\n        top : float, optional\n            The top ylim in data coordinates. Passing *None* leaves the\n            limit unchanged.\n\n        emit : bool, default: True\n            Whether to notify observers of limit change.\n\n        auto : bool or None, default: False\n            Whether to turn on autoscaling of the y-axis. *True* turns on,\n            *False* turns off, *None* leaves unchanged.\n\n        ymin, ymax : scalar, optional\n            They are equivalent to bottom and top respectively,\n            and it is an error to pass both *ymin* and *bottom* or\n            *ymax* and *top*.\n\n        Returns\n        -------\n        bottom, top : (float, float)\n            The new y-axis limits in data coordinates.\n\n        See Also\n        --------\n        get_ylim\n        set_ybound, get_ybound\n        invert_yaxis, yaxis_inverted\n\n        Notes\n        -----\n        The *bottom* value may be greater than the *top* value, in which\n        case the y-axis values will decrease from *bottom* to *top*.\n\n        Examples\n        --------\n        >>> set_ylim(bottom, top)\n        >>> set_ylim((bottom, top))\n        >>> bottom, top = set_ylim(bottom, top)\n\n        One limit may be left unchanged.\n\n        >>> set_ylim(top=top_lim)\n\n        Limits may be passed in reverse order to flip the direction of\n        the y-axis. For example, suppose ``y`` represents depth of the\n        ocean in m. The y-axis limits might be set like the following\n        so 5000 m depth is at the bottom of the plot and the surface,\n        0 m, is at the top.\n\n        >>> set_ylim(5000, 0)\n        \"\"\"\n        if top is None and np.iterable(bottom):\n            bottom, top = bottom\n        if ymin is not None:\n            if bottom is not None:\n                raise TypeError('Cannot pass both `ymin` and `bottom`')\n            bottom = ymin\n        if ymax is not None:\n            if top is not None:\n                raise TypeError('Cannot pass both `ymax` and `top`')\n            top = ymax\n\n        self._process_unit_info(ydata=(bottom, top))\n        bottom = self._validate_converted_limits(bottom, self.convert_yunits)\n        top = self._validate_converted_limits(top, self.convert_yunits)\n\n        if bottom is None or top is None:\n            # Axes init calls set_ylim(0, 1) before get_ylim() can be called,\n            # so only grab the limits if we really need them.\n            old_bottom, old_top = self.get_ylim()\n            if bottom is None:\n                bottom = old_bottom\n            if top is None:\n                top = old_top\n\n        if self.get_yscale() == 'log' and (bottom <= 0 or top <= 0):\n            # Axes init calls set_xlim(0, 1) before get_xlim() can be called,\n            # so only grab the limits if we really need them.\n            old_bottom, old_top = self.get_ylim()\n            if bottom <= 0:\n                cbook._warn_external(\n                    'Attempted to set non-positive bottom ylim on a '\n                    'log-scaled axis.\\n'\n                    'Invalid limit will be ignored.')\n                bottom = old_bottom\n            if top <= 0:\n                cbook._warn_external(\n                    'Attempted to set non-positive top ylim on a '\n                    'log-scaled axis.\\n'\n                    'Invalid limit will be ignored.')\n                top = old_top\n        if bottom == top:\n            cbook._warn_external(\n                f\"Attempting to set identical bottom == top == {bottom} \"\n                f\"results in singular transformations; automatically \"\n                f\"expanding.\")\n        reverse = bottom > top\n        bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n        bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n        # cast to bool to avoid bad interaction between python 3.8 and np.bool_\n        bottom, top = sorted([bottom, top], reverse=bool(reverse))\n\n        self._viewLim.intervaly = (bottom, top)\n        if auto is not None:\n            self._autoscaleYon = bool(auto)\n\n        if emit:\n            self.callbacks.process('ylim_changed', self)\n            # Call all of the other y-axes that are shared with this one\n            for other in self._shared_y_axes.get_siblings(self):\n                if other is not self:\n                    other.set_ylim(self.viewLim.intervaly,\n                                   emit=False, auto=auto)\n                    if other.figure != self.figure:\n                        other.figure.canvas.draw_idle()\n        self.stale = True\n        return bottom, top",
        "begin_line": 3575,
        "end_line": 3707,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011695906432748538,
            "pseudo_dstar_susp": 0.0020491803278688526,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0020491803278688526,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_yscale#3709",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_yscale(self)",
        "snippet": "    def get_yscale(self):\n        \"\"\"\n        Return the y-axis scale as string.\n\n        See Also\n        --------\n        set_yscale\n        \"\"\"\n        return self.yaxis.get_scale()",
        "begin_line": 3709,
        "end_line": 3717,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009416195856873823,
            "pseudo_dstar_susp": 0.0015174506828528073,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0015174506828528073,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_yscale#3719",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_yscale(self, value, **kwargs)",
        "snippet": "    def set_yscale(self, value, **kwargs):\n        \"\"\"\n        Set the y-axis scale.\n\n        Parameters\n        ----------\n        value : {\"linear\", \"log\", \"symlog\", \"logit\", ...}\n            The axis scale type to apply.\n\n        **kwargs\n            Different keyword arguments are accepted, depending on the scale.\n            See the respective class keyword arguments:\n\n            - `matplotlib.scale.LinearScale`\n            - `matplotlib.scale.LogScale`\n            - `matplotlib.scale.SymmetricalLogScale`\n            - `matplotlib.scale.LogitScale`\n\n        Notes\n        -----\n        By default, Matplotlib supports the above mentioned scales.\n        Additionally, custom scales may be registered using\n        `matplotlib.scale.register_scale`. These scales can then also\n        be used here.\n        \"\"\"\n        old_default_lims = (self.yaxis.get_major_locator()\n                            .nonsingular(-np.inf, np.inf))\n        g = self.get_shared_y_axes()\n        for ax in g.get_siblings(self):\n            ax.yaxis._set_scale(value, **kwargs)\n            ax._update_transScale()\n            ax.stale = True\n        new_default_lims = (self.yaxis.get_major_locator()\n                            .nonsingular(-np.inf, np.inf))\n        if old_default_lims != new_default_lims:\n            # Force autoscaling now, to take advantage of the scale locator's\n            # nonsingular() before it possibly gets swapped out by the user.\n            self.autoscale_view(scalex=False)",
        "begin_line": 3719,
        "end_line": 3756,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.714396735962697e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_yticks#3764",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_yticks(self, ticks, minor=False)",
        "snippet": "    def set_yticks(self, ticks, minor=False):\n        \"\"\"\n        Set the y ticks with list of *ticks*\n\n        Parameters\n        ----------\n        ticks : list\n            List of y-axis tick locations\n        minor : bool, default: False\n            If ``False`` sets major ticks, if ``True`` sets minor ticks.\n        \"\"\"\n        ret = self.yaxis.set_ticks(ticks, minor=minor)\n        return ret",
        "begin_line": 3764,
        "end_line": 3776,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.73591333973967e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_yticklabels#3800",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_yticklabels(self, minor=False, which=None)",
        "snippet": "    def get_yticklabels(self, minor=False, which=None):\n        \"\"\"\n        Get the y tick labels as a list of `~matplotlib.text.Text` instances.\n\n        Parameters\n        ----------\n        minor : bool\n           If True return the minor ticklabels,\n           else return the major ticklabels\n\n        which : None, ('minor', 'major', 'both')\n           Overrides *minor*.\n\n           Selects which ticklabels to return\n\n        Returns\n        -------\n        ret : list\n           List of `~matplotlib.text.Text` instances.\n\n        Notes\n        -----\n        The tick label strings are not populated until a ``draw``\n        method has been called.\n\n        See also: `~.pyplot.draw` and `~.FigureCanvasBase.draw`.\n        \"\"\"\n        return self.yaxis.get_ticklabels(minor=minor, which=which)",
        "begin_line": 3800,
        "end_line": 3827,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_yticklabels#3829",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_yticklabels(self, labels, fontdict=None, minor=False, **kwargs)",
        "snippet": "    def set_yticklabels(self, labels, fontdict=None, minor=False, **kwargs):\n        \"\"\"\n        Set the y-tick labels with list of string labels.\n\n        .. warning::\n            This method should only be used after fixing the tick positions\n            using `~.axes.Axes.set_yticks`. Otherwise, the labels may end up\n            in unexpected positions.\n\n        Parameters\n        ----------\n        labels : list of str\n            The label texts.\n\n        fontdict : dict, optional\n            A dictionary controlling the appearance of the ticklabels.\n            The default *fontdict* is::\n\n               {'fontsize': rcParams['axes.titlesize'],\n                'fontweight': rcParams['axes.titleweight'],\n                'verticalalignment': 'baseline',\n                'horizontalalignment': loc}\n\n        minor : bool, default: False\n            Whether to set the minor ticklabels rather than the major ones.\n\n        Returns\n        -------\n        labels\n            A list of `~.text.Text` instances.\n\n        Other Parameters\n        ----------------\n        **kwargs : `~.text.Text` properties.\n        \"\"\"\n        if fontdict is not None:\n            kwargs.update(fontdict)\n        return self.yaxis.set_ticklabels(labels,\n                                         minor=minor, **kwargs)",
        "begin_line": 3829,
        "end_line": 3867,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.xaxis_date#3869",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.xaxis_date(self, tz=None)",
        "snippet": "    def xaxis_date(self, tz=None):\n        \"\"\"\n        Sets up x-axis ticks and labels that treat the x data as dates.\n\n        Parameters\n        ----------\n        tz : str or `datetime.tzinfo`, default: :rc:`timezone`\n            Timezone.\n        \"\"\"\n        # should be enough to inform the unit conversion interface\n        # dates are coming in\n        self.xaxis.axis_date(tz)",
        "begin_line": 3869,
        "end_line": 3880,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.yaxis_date#3882",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.yaxis_date(self, tz=None)",
        "snippet": "    def yaxis_date(self, tz=None):\n        \"\"\"\n        Sets up y-axis ticks and labels that treat the y data as dates.\n\n        Parameters\n        ----------\n        tz : str or `datetime.tzinfo`, default: :rc:`timezone`\n            Timezone.\n        \"\"\"\n        self.yaxis.axis_date(tz)",
        "begin_line": 3882,
        "end_line": 3891,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.format_xdata#3893",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.format_xdata(self, x)",
        "snippet": "    def format_xdata(self, x):\n        \"\"\"\n        Return *x* formatted as an x-value.\n\n        This function will use the `.fmt_xdata` attribute if it is not None,\n        else will fall back on the xaxis major formatter.\n        \"\"\"\n        return (self.fmt_xdata if self.fmt_xdata is not None\n                else self.xaxis.get_major_formatter().format_data_short)(x)",
        "begin_line": 3893,
        "end_line": 3901,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.format_ydata#3903",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.format_ydata(self, y)",
        "snippet": "    def format_ydata(self, y):\n        \"\"\"\n        Return *y* formatted as an y-value.\n\n        This function will use the `.fmt_ydata` attribute if it is not None,\n        else will fall back on the yaxis major formatter.\n        \"\"\"\n        return (self.fmt_ydata if self.fmt_ydata is not None\n                else self.yaxis.get_major_formatter().format_data_short)(y)",
        "begin_line": 3903,
        "end_line": 3911,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.format_coord#3913",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.format_coord(self, x, y)",
        "snippet": "    def format_coord(self, x, y):\n        \"\"\"Return a format string formatting the *x*, *y* coordinates.\"\"\"\n        if x is None:\n            xs = '???'\n        else:\n            xs = self.format_xdata(x)\n        if y is None:\n            ys = '???'\n        else:\n            ys = self.format_ydata(y)\n        return 'x=%s y=%s' % (xs, ys)",
        "begin_line": 3913,
        "end_line": 3923,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.minorticks_on#3925",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.minorticks_on(self)",
        "snippet": "    def minorticks_on(self):\n        \"\"\"\n        Display minor ticks on the axes.\n\n        Displaying minor ticks may reduce performance; you may turn them off\n        using `minorticks_off()` if drawing speed is a problem.\n        \"\"\"\n        for ax in (self.xaxis, self.yaxis):\n            scale = ax.get_scale()\n            if scale == 'log':\n                s = ax._scale\n                ax.set_minor_locator(mticker.LogLocator(s.base, s.subs))\n            elif scale == 'symlog':\n                s = ax._scale\n                ax.set_minor_locator(\n                    mticker.SymmetricalLogLocator(s._transform, s.subs))\n            else:\n                ax.set_minor_locator(mticker.AutoMinorLocator())",
        "begin_line": 3925,
        "end_line": 3942,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_navigate#3969",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_navigate(self, b)",
        "snippet": "    def set_navigate(self, b):\n        \"\"\"\n        Set whether the axes responds to navigation toolbar commands\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._navigate = b",
        "begin_line": 3969,
        "end_line": 3977,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011376564277588168,
            "pseudo_dstar_susp": 0.001953125,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.001953125,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.set_navigate_mode#3985",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.set_navigate_mode(self, b)",
        "snippet": "    def set_navigate_mode(self, b):\n        \"\"\"\n        Set the navigation toolbar button status;\n\n        .. warning::\n            this is not a user-API function.\n\n        \"\"\"\n        self._navigate_mode = b",
        "begin_line": 3985,
        "end_line": 3993,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011376564277588168,
            "pseudo_dstar_susp": 0.001953125,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.001953125,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._set_view_from_bbox#4029",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._set_view_from_bbox(self, bbox, direction='in', mode=None, twinx=False, twiny=False)",
        "snippet": "    def _set_view_from_bbox(self, bbox, direction='in',\n                            mode=None, twinx=False, twiny=False):\n        \"\"\"\n        Update view from a selection bbox.\n\n        .. note::\n\n            Intended to be overridden by new projection types, but if not, the\n            default implementation sets the view limits to the bbox directly.\n\n        Parameters\n        ----------\n        bbox : 4-tuple or 3 tuple\n            * If bbox is a 4 tuple, it is the selected bounding box limits,\n              in *display* coordinates.\n            * If bbox is a 3 tuple, it is an (xp, yp, scl) triple, where\n              (xp, yp) is the center of zooming and scl the scale factor to\n              zoom by.\n\n        direction : str\n            The direction to apply the bounding box.\n                * `'in'` - The bounding box describes the view directly, i.e.,\n                           it zooms in.\n                * `'out'` - The bounding box describes the size to make the\n                            existing view, i.e., it zooms out.\n\n        mode : str or None\n            The selection mode, whether to apply the bounding box in only the\n            `'x'` direction, `'y'` direction or both (`None`).\n\n        twinx : bool\n            Whether this axis is twinned in the *x*-direction.\n\n        twiny : bool\n            Whether this axis is twinned in the *y*-direction.\n        \"\"\"\n        Xmin, Xmax = self.get_xlim()\n        Ymin, Ymax = self.get_ylim()\n\n        if len(bbox) == 3:\n            # Zooming code\n            xp, yp, scl = bbox\n\n            # Should not happen\n            if scl == 0:\n                scl = 1.\n\n            # direction = 'in'\n            if scl > 1:\n                direction = 'in'\n            else:\n                direction = 'out'\n                scl = 1/scl\n\n            # get the limits of the axes\n            tranD2C = self.transData.transform\n            xmin, ymin = tranD2C((Xmin, Ymin))\n            xmax, ymax = tranD2C((Xmax, Ymax))\n\n            # set the range\n            xwidth = xmax - xmin\n            ywidth = ymax - ymin\n            xcen = (xmax + xmin)*.5\n            ycen = (ymax + ymin)*.5\n            xzc = (xp*(scl - 1) + xcen)/scl\n            yzc = (yp*(scl - 1) + ycen)/scl\n\n            bbox = [xzc - xwidth/2./scl, yzc - ywidth/2./scl,\n                    xzc + xwidth/2./scl, yzc + ywidth/2./scl]\n        elif len(bbox) != 4:\n            # should be len 3 or 4 but nothing else\n            cbook._warn_external(\n                \"Warning in _set_view_from_bbox: bounding box is not a tuple \"\n                \"of length 3 or 4. Ignoring the view change.\")\n            return\n\n        # Just grab bounding box\n        lastx, lasty, x, y = bbox\n\n        # zoom to rect\n        inverse = self.transData.inverted()\n        (lastx, lasty), (x, y) = inverse.transform([(lastx, lasty), (x, y)])\n\n        if twinx:\n            x0, x1 = Xmin, Xmax\n        else:\n            if Xmin < Xmax:\n                if x < lastx:\n                    x0, x1 = x, lastx\n                else:\n                    x0, x1 = lastx, x\n                if x0 < Xmin:\n                    x0 = Xmin\n                if x1 > Xmax:\n                    x1 = Xmax\n            else:\n                if x > lastx:\n                    x0, x1 = x, lastx\n                else:\n                    x0, x1 = lastx, x\n                if x0 > Xmin:\n                    x0 = Xmin\n                if x1 < Xmax:\n                    x1 = Xmax\n\n        if twiny:\n            y0, y1 = Ymin, Ymax\n        else:\n            if Ymin < Ymax:\n                if y < lasty:\n                    y0, y1 = y, lasty\n                else:\n                    y0, y1 = lasty, y\n                if y0 < Ymin:\n                    y0 = Ymin\n                if y1 > Ymax:\n                    y1 = Ymax\n            else:\n                if y > lasty:\n                    y0, y1 = y, lasty\n                else:\n                    y0, y1 = lasty, y\n                if y0 > Ymin:\n                    y0 = Ymin\n                if y1 < Ymax:\n                    y1 = Ymax\n\n        if direction == 'in':\n            if mode == 'x':\n                self.set_xlim((x0, x1))\n            elif mode == 'y':\n                self.set_ylim((y0, y1))\n            else:\n                self.set_xlim((x0, x1))\n                self.set_ylim((y0, y1))\n        elif direction == 'out':\n            if self.get_xscale() == 'log':\n                alpha = np.log(Xmax / Xmin) / np.log(x1 / x0)\n                rx1 = pow(Xmin / x0, alpha) * Xmin\n                rx2 = pow(Xmax / x0, alpha) * Xmin\n            else:\n                alpha = (Xmax - Xmin) / (x1 - x0)\n                rx1 = alpha * (Xmin - x0) + Xmin\n                rx2 = alpha * (Xmax - x0) + Xmin\n            if self.get_yscale() == 'log':\n                alpha = np.log(Ymax / Ymin) / np.log(y1 / y0)\n                ry1 = pow(Ymin / y0, alpha) * Ymin\n                ry2 = pow(Ymax / y0, alpha) * Ymin\n            else:\n                alpha = (Ymax - Ymin) / (y1 - y0)\n                ry1 = alpha * (Ymin - y0) + Ymin\n                ry2 = alpha * (Ymax - y0) + Ymin\n\n            if mode == 'x':\n                self.set_xlim((rx1, rx2))\n            elif mode == 'y':\n                self.set_ylim((ry1, ry2))\n            else:\n                self.set_xlim((rx1, rx2))\n                self.set_ylim((ry1, ry2))",
        "begin_line": 4029,
        "end_line": 4188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_children#4295",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_children(self)",
        "snippet": "    def get_children(self):\n        # docstring inherited.\n        return [\n            *self.collections,\n            *self.patches,\n            *self.lines,\n            *self.texts,\n            *self.artists,\n            *self.spines.values(),\n            *self._get_axis_list(),\n            self.title, self._left_title, self._right_title,\n            *self.tables,\n            *self.images,\n            *self.child_axes,\n            *([self.legend_] if self.legend_ is not None else []),\n            self.patch,\n        ]",
        "begin_line": 4295,
        "end_line": 4311,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003749531308586427,
            "pseudo_dstar_susp": 0.000346860908775581,
            "pseudo_tarantula_susp": 0.0007178750897343862,
            "pseudo_op2_susp": 0.000346860908775581,
            "pseudo_barinel_susp": 0.0007178750897343862
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.contains_point#4320",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.contains_point(self, point)",
        "snippet": "    def contains_point(self, point):\n        \"\"\"\n        Return whether *point* (pair of pixel coordinates) is inside the axes\n        patch.\n        \"\"\"\n        return self.patch.contains_point(point, radius=1.0)",
        "begin_line": 4320,
        "end_line": 4325,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_default_bbox_extra_artists#4327",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_default_bbox_extra_artists(self)",
        "snippet": "    def get_default_bbox_extra_artists(self):\n        \"\"\"\n        Return a default list of artists that are used for the bounding box\n        calculation.\n\n        Artists are excluded either by not being visible or\n        ``artist.set_in_layout(False)``.\n        \"\"\"\n\n        artists = self.get_children()\n\n        if not (self.axison and self._frameon):\n            # don't do bbox on spines if frame not on.\n            for spine in self.spines.values():\n                artists.remove(spine)\n\n        if not self.axison:\n            for _axis in self._get_axis_list():\n                artists.remove(_axis)\n\n        return [artist for artist in artists\n                if (artist.get_visible() and artist.get_in_layout())]",
        "begin_line": 4327,
        "end_line": 4348,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_tightbbox#4350",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_tightbbox(self, renderer, call_axes_locator=True, bbox_extra_artists=None)",
        "snippet": "    def get_tightbbox(self, renderer, call_axes_locator=True,\n                      bbox_extra_artists=None):\n        \"\"\"\n        Return the tight bounding box of the axes, including axis and their\n        decorators (xlabel, title, etc).\n\n        Artists that have ``artist.set_in_layout(False)`` are not included\n        in the bbox.\n\n        Parameters\n        ----------\n        renderer : `.RendererBase` subclass\n            renderer that will be used to draw the figures (i.e.\n            ``fig.canvas.get_renderer()``)\n\n        bbox_extra_artists : list of `.Artist` or ``None``\n            List of artists to include in the tight bounding box.  If\n            ``None`` (default), then all artist children of the axes are\n            included in the tight bounding box.\n\n        call_axes_locator : bool, default: True\n            If *call_axes_locator* is ``False``, it does not call the\n            ``_axes_locator`` attribute, which is necessary to get the correct\n            bounding box. ``call_axes_locator=False`` can be used if the\n            caller is only interested in the relative size of the tightbbox\n            compared to the axes bbox.\n\n        Returns\n        -------\n        bbox : `.BboxBase`\n            bounding box in figure pixel coordinates.\n\n        See Also\n        --------\n        matplotlib.axes.Axes.get_window_extent\n        matplotlib.axis.Axis.get_tightbbox\n        matplotlib.spines.Spine.get_window_extent\n        \"\"\"\n\n        bb = []\n\n        if not self.get_visible():\n            return None\n\n        locator = self.get_axes_locator()\n        if locator and call_axes_locator:\n            pos = locator(self, renderer)\n            self.apply_aspect(pos)\n        else:\n            self.apply_aspect()\n\n        if self.axison:\n            bb_xaxis = self.xaxis.get_tightbbox(renderer)\n            if bb_xaxis:\n                bb.append(bb_xaxis)\n\n            bb_yaxis = self.yaxis.get_tightbbox(renderer)\n            if bb_yaxis:\n                bb.append(bb_yaxis)\n\n        self._update_title_position(renderer)\n\n        axbbox = self.get_window_extent(renderer)\n        bb.append(axbbox)\n\n        for title in [self.title, self._left_title, self._right_title]:\n            if title.get_visible():\n                bb.append(title.get_window_extent(renderer))\n\n        bbox_artists = bbox_extra_artists\n        if bbox_artists is None:\n            bbox_artists = self.get_default_bbox_extra_artists()\n\n        for a in bbox_artists:\n            # Extra check here to quickly see if clipping is on and\n            # contained in the axes.  If it is, don't get the tightbbox for\n            # this artist because this can be expensive:\n            clip_extent = a._get_clipping_extent_bbox()\n            if clip_extent is not None:\n                clip_extent = mtransforms.Bbox.intersection(\n                    clip_extent, axbbox)\n                if np.all(clip_extent.extents == axbbox.extents):\n                    # clip extent is inside the axes bbox so don't check\n                    # this artist\n                    continue\n            bbox = a.get_tightbbox(renderer)\n            if (bbox is not None\n                    and 0 < bbox.width < np.inf\n                    and 0 < bbox.height < np.inf):\n                bb.append(bbox)\n\n        return mtransforms.Bbox.union(\n            [b for b in bb if b.width != 0 or b.height != 0])",
        "begin_line": 4350,
        "end_line": 4442,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase._make_twin_axes#4444",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase._make_twin_axes(self, *args, **kwargs)",
        "snippet": "    def _make_twin_axes(self, *args, **kwargs):\n        \"\"\"Make a twinx axes of self. This is used for twinx and twiny.\"\"\"\n        # Typically, SubplotBase._make_twin_axes is called instead of this.\n        if 'sharex' in kwargs and 'sharey' in kwargs:\n            raise ValueError(\"Twinned Axes may share only one axis\")\n        ax2 = self.figure.add_axes(self.get_position(True), *args, **kwargs)\n        self.set_adjustable('datalim')\n        ax2.set_adjustable('datalim')\n        self._twinned_axes.join(self, ax2)\n        return ax2",
        "begin_line": 4444,
        "end_line": 4453,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.twinx#4455",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.twinx(self)",
        "snippet": "    def twinx(self):\n        \"\"\"\n        Create a twin Axes sharing the xaxis.\n\n        Create a new Axes with an invisible x-axis and an independent\n        y-axis positioned opposite to the original one (i.e. at right). The\n        x-axis autoscale setting will be inherited from the original\n        Axes.  To ensure that the tick marks of both y-axes align, see\n        `~matplotlib.ticker.LinearLocator`.\n\n        Returns\n        -------\n        ax_twin : Axes\n            The newly created Axes instance\n\n        Notes\n        -----\n        For those who are 'picking' artists while using twinx, pick\n        events are only called for the artists in the top-most axes.\n        \"\"\"\n        ax2 = self._make_twin_axes(sharex=self)\n        ax2.yaxis.tick_right()\n        ax2.yaxis.set_label_position('right')\n        ax2.yaxis.set_offset_position('right')\n        ax2.set_autoscalex_on(self.get_autoscalex_on())\n        self.yaxis.tick_left()\n        ax2.xaxis.set_visible(False)\n        ax2.patch.set_visible(False)\n        return ax2",
        "begin_line": 4455,
        "end_line": 4483,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004589261128958238,
            "pseudo_dstar_susp": 0.0003966679888932963,
            "pseudo_tarantula_susp": 0.0016181229773462784,
            "pseudo_op2_susp": 0.0003966679888932963,
            "pseudo_barinel_susp": 0.0016181229773462784
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.twiny#4485",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.twiny(self)",
        "snippet": "    def twiny(self):\n        \"\"\"\n        Create a twin Axes sharing the yaxis.\n\n        Create a new Axes with an invisible y-axis and an independent\n        x-axis positioned opposite to the original one (i.e. at top). The\n        y-axis autoscale setting will be inherited from the original Axes.\n        To ensure that the tick marks of both x-axes align, see\n        `~matplotlib.ticker.LinearLocator`.\n\n        Returns\n        -------\n        ax_twin : Axes\n            The newly created Axes instance\n\n        Notes\n        -----\n        For those who are 'picking' artists while using twiny, pick\n        events are only called for the artists in the top-most axes.\n        \"\"\"\n        ax2 = self._make_twin_axes(sharey=self)\n        ax2.xaxis.tick_top()\n        ax2.xaxis.set_label_position('top')\n        ax2.set_autoscaley_on(self.get_autoscaley_on())\n        self.xaxis.tick_bottom()\n        ax2.yaxis.set_visible(False)\n        ax2.patch.set_visible(False)\n        return ax2",
        "begin_line": 4485,
        "end_line": 4512,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_shared_x_axes#4514",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_shared_x_axes(self)",
        "snippet": "    def get_shared_x_axes(self):\n        \"\"\"Return a reference to the shared axes Grouper object for x axes.\"\"\"\n        return self._shared_x_axes",
        "begin_line": 4514,
        "end_line": 4516,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._base._AxesBase.get_shared_y_axes#4518",
        "src_path": "lib/matplotlib/axes/_base.py",
        "class_name": "lib.matplotlib.axes._base._AxesBase",
        "signature": "lib.matplotlib.axes._base._AxesBase.get_shared_y_axes(self)",
        "snippet": "    def get_shared_y_axes(self):\n        \"\"\"Return a reference to the shared axes Grouper object for y axes.\"\"\"\n        return self._shared_y_axes",
        "begin_line": 4518,
        "end_line": 4520,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.714396735962697e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.ValidateInStrings.__call__#66",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup.ValidateInStrings",
        "signature": "lib.matplotlib.rcsetup.ValidateInStrings.__call__(self, s)",
        "snippet": "    def __call__(self, s):\n        if self._deprecated_since:\n            name, = (k for k, v in globals().items() if v is self)\n            cbook.warn_deprecated(\n                self._deprecated_since, name=name, obj_type=\"function\")\n        if self.ignorecase:\n            s = s.lower()\n        if s in self.valid:\n            return self.valid[s]\n        raise ValueError('Unrecognized %s string %r: valid strings are %s'\n                         % (self.key, s, list(self.valid.values())))",
        "begin_line": 66,
        "end_line": 76,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004048582995951417,
            "pseudo_dstar_susp": 0.16666666666666666,
            "pseudo_tarantula_susp": 0.000354735721887194,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.000354735721887194
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.f#80",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.f(s)",
        "snippet": "    def f(s):\n        if isinstance(s, str):\n            try:\n                return [scalar_validator(v.strip()) for v in s.split(',')\n                        if v.strip()]\n            except Exception:\n                if allow_stringlist:\n                    # Sometimes, a list of colors might be a single string\n                    # of single-letter colornames. So give that a shot.\n                    return [scalar_validator(v.strip())\n                            for v in s if v.strip()]\n                else:\n                    raise\n        # Allow any ordered sequence type -- generators, np.ndarray, pd.Series\n        # -- but not sets, whose iteration order is non-deterministic.\n        elif np.iterable(s) and not isinstance(s, (set, frozenset)):\n            # The condition on this list comprehension will preserve the\n            # behavior of filtering out any empty strings (behavior was\n            # from the original validate_stringlist()), while allowing\n            # any non-string/text scalar values such as numbers and arrays.\n            return [scalar_validator(v) for v in s\n                    if not isinstance(v, str) or v]\n        else:\n            raise ValueError(\"{!r} must be of type: str or non-dictionary \"\n                             \"iterable\".format(s))",
        "begin_line": 80,
        "end_line": 104,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004081632653061225,
            "pseudo_dstar_susp": 0.2,
            "pseudo_tarantula_susp": 0.0003526093088857546,
            "pseudo_op2_susp": 0.5,
            "pseudo_barinel_susp": 0.0003526093088857546
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_any#114",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_any(s)",
        "snippet": "def validate_any(s):\n    return s",
        "begin_line": 114,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007564296520423601,
            "pseudo_dstar_susp": 0.0064516129032258064,
            "pseudo_tarantula_susp": 0.00033101621979476995,
            "pseudo_op2_susp": 0.006578947368421052,
            "pseudo_barinel_susp": 0.00033101621979476995
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_bool#130",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_bool(b)",
        "snippet": "def validate_bool(b):\n    \"\"\"Convert b to ``bool`` or raise.\"\"\"\n    if isinstance(b, str):\n        b = b.lower()\n    if b in ('t', 'y', 'yes', 'on', 'true', '1', 1, True):\n        return True\n    elif b in ('f', 'n', 'no', 'off', 'false', '0', 0, False):\n        return False\n    else:\n        raise ValueError('Could not convert \"%s\" to bool' % b)",
        "begin_line": 130,
        "end_line": 139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0030864197530864196,
            "pseudo_dstar_susp": 0.01,
            "pseudo_tarantula_susp": 0.000392156862745098,
            "pseudo_op2_susp": 0.009615384615384616,
            "pseudo_barinel_susp": 0.000392156862745098
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_bool_maybe_none#143",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_bool_maybe_none(b)",
        "snippet": "def validate_bool_maybe_none(b):\n    \"\"\"Convert b to ``bool`` or raise, passing through *None*.\"\"\"\n    if isinstance(b, str):\n        b = b.lower()\n    if b is None or b == 'none':\n        return None\n    if b in ('t', 'y', 'yes', 'on', 'true', '1', 1, True):\n        return True\n    elif b in ('f', 'n', 'no', 'off', 'false', '0', 0, False):\n        return False\n    else:\n        raise ValueError('Could not convert \"%s\" to bool' % b)",
        "begin_line": 143,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._validate_tex_preamble#157",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._validate_tex_preamble(s)",
        "snippet": "def _validate_tex_preamble(s):\n    message = (\n        f\"Support for setting the 'text.latex.preamble' and 'pgf.preamble' \"\n        f\"rcParams to {s!r} is deprecated since %(since)s and will be \"\n        f\"removed %(removal)s; please set them to plain (possibly empty) \"\n        f\"strings instead.\")\n    if s is None or s == 'None':\n        cbook.warn_deprecated(\"3.3\", message=message)\n        return \"\"\n    try:\n        if isinstance(s, str):\n            return s\n        elif np.iterable(s):\n            cbook.warn_deprecated(\"3.3\", message=message)\n            return '\\n'.join(s)\n        else:\n            raise TypeError\n    except TypeError as e:\n        raise ValueError('Could not convert \"%s\" to string' % s) from e",
        "begin_line": 157,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00390625,
            "pseudo_dstar_susp": 0.027777777777777776,
            "pseudo_tarantula_susp": 0.0003562522265764161,
            "pseudo_op2_susp": 0.03333333333333333,
            "pseudo_barinel_susp": 0.0003562522265764161
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_axisbelow#178",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_axisbelow(s)",
        "snippet": "def validate_axisbelow(s):\n    try:\n        return validate_bool(s)\n    except ValueError:\n        if isinstance(s, str):\n            if s == 'line':\n                return 'line'\n            if s.lower().startswith('line'):\n                cbook.warn_deprecated(\n                    \"3.3\", message=f\"Support for setting axes.axisbelow to \"\n                    f\"{s!r} to mean 'line' is deprecated since %(since)s and \"\n                    f\"will be removed in %(removal)s; set it to 'line' \"\n                    \"instead.\")\n                return 'line'\n    raise ValueError('%s cannot be interpreted as'\n                     ' True, False, or \"line\"' % s)",
        "begin_line": 178,
        "end_line": 193,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003183699458771092,
            "pseudo_dstar_susp": 0.0007132667617689016,
            "pseudo_tarantula_susp": 0.00027917364600781687,
            "pseudo_op2_susp": 0.0007132667617689016,
            "pseudo_barinel_susp": 0.00027917364600781687
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_dpi#196",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_dpi(s)",
        "snippet": "def validate_dpi(s):\n    \"\"\"Confirm s is string 'figure' or convert s to float or raise.\"\"\"\n    if s == 'figure':\n        return s\n    try:\n        return float(s)\n    except ValueError as e:\n        raise ValueError(f'{s!r} is not string \"figure\" and '\n                         f'could not convert {s!r} to float') from e",
        "begin_line": 196,
        "end_line": 204,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014144271570014145,
            "pseudo_dstar_susp": 0.00819672131147541,
            "pseudo_tarantula_susp": 0.00034094783498124785,
            "pseudo_op2_susp": 0.008849557522123894,
            "pseudo_barinel_susp": 0.00034094783498124785
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validator#213",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validator(s)",
        "snippet": "    def validator(s):\n        if (allow_none and\n                (s is None or isinstance(s, str) and s.lower() == \"none\")):\n            return None\n        try:\n            return cls(s)\n        except ValueError as e:\n            raise ValueError(f'Could not convert {s!r} to {cls.__name__}') from e",
        "begin_line": 213,
        "end_line": 220,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008928571428571428,
            "pseudo_dstar_susp": 0.07142857142857142,
            "pseudo_tarantula_susp": 0.002352941176470588,
            "pseudo_op2_susp": 0.1111111111111111,
            "pseudo_barinel_susp": 0.002352941176470588
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_fonttype#242",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_fonttype(s)",
        "snippet": "def validate_fonttype(s):\n    \"\"\"\n    Confirm that this is a Postscript or PDF font type that we know how to\n    convert to.\n    \"\"\"\n    fonttypes = {'type3':    3,\n                 'truetype': 42}\n    try:\n        fonttype = validate_int(s)\n    except ValueError:\n        try:\n            return fonttypes[s.lower()]\n        except KeyError as e:\n            raise ValueError(\n                'Supported Postscript/PDF font types are %s' % list(fonttypes)) from e\n    else:\n        if fonttype not in fonttypes.values():\n            raise ValueError(\n                'Supported Postscript/PDF font types are %s' %\n                list(fonttypes.values()))\n        return fonttype",
        "begin_line": 242,
        "end_line": 262,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024813895781637717,
            "pseudo_dstar_susp": 0.01098901098901099,
            "pseudo_tarantula_susp": 0.0003471017007983339,
            "pseudo_op2_susp": 0.011363636363636364,
            "pseudo_barinel_susp": 0.0003471017007983339
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_backend#270",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_backend(s)",
        "snippet": "def validate_backend(s):\n    backend = (\n        s if s is _auto_backend_sentinel or s.startswith(\"module://\")\n        else _validate_standard_backends(s))\n    return backend",
        "begin_line": 270,
        "end_line": 274,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02,
            "pseudo_dstar_susp": 0.004484304932735426,
            "pseudo_tarantula_susp": 0.0035335689045936395,
            "pseudo_op2_susp": 0.0045045045045045045,
            "pseudo_barinel_susp": 0.0035335689045936395
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._make_nseq_validator#282",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._make_nseq_validator(cls, n=None, allow_none=False)",
        "snippet": "def _make_nseq_validator(cls, n=None, allow_none=False):\n\n    def validator(s):\n        \"\"\"Convert *n* objects using ``cls``, or raise.\"\"\"\n        if isinstance(s, str):\n            s = [x.strip() for x in s.split(',')]\n            if n is not None and len(s) != n:\n                raise ValueError(\n                    f'Expected exactly {n} comma-separated values, '\n                    f'but got {len(s)} comma-separated values: {s}')\n        else:\n            if n is not None and len(s) != n:\n                raise ValueError(\n                    f'Expected exactly {n} values, '\n                    f'but got {len(s)} values: {s}')\n        try:\n            return [cls(val) if not allow_none or val is not None else val\n                    for val in s]\n        except ValueError as e:\n            raise ValueError(\n                f'Could not convert all entries to {cls.__name__}s') from e\n\n    return validator",
        "begin_line": 282,
        "end_line": 304,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0037593984962406013,
            "pseudo_dstar_susp": 0.0007347538574577516,
            "pseudo_tarantula_susp": 0.002044989775051125,
            "pseudo_op2_susp": 0.0007347538574577516,
            "pseudo_barinel_susp": 0.002044989775051125
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validator#284",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validator(s)",
        "snippet": "    def validator(s):\n        \"\"\"Convert *n* objects using ``cls``, or raise.\"\"\"\n        if isinstance(s, str):\n            s = [x.strip() for x in s.split(',')]\n            if n is not None and len(s) != n:\n                raise ValueError(\n                    f'Expected exactly {n} comma-separated values, '\n                    f'but got {len(s)} comma-separated values: {s}')\n        else:\n            if n is not None and len(s) != n:\n                raise ValueError(\n                    f'Expected exactly {n} values, '\n                    f'but got {len(s)} values: {s}')\n        try:\n            return [cls(val) if not allow_none or val is not None else val\n                    for val in s]\n        except ValueError as e:\n            raise ValueError(\n                f'Could not convert all entries to {cls.__name__}s') from e",
        "begin_line": 284,
        "end_line": 302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008928571428571428,
            "pseudo_dstar_susp": 0.07142857142857142,
            "pseudo_tarantula_susp": 0.002352941176470588,
            "pseudo_op2_susp": 0.1111111111111111,
            "pseudo_barinel_susp": 0.002352941176470588
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_color_or_inherit#311",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_color_or_inherit(s)",
        "snippet": "def validate_color_or_inherit(s):\n    \"\"\"Return a valid color arg.\"\"\"\n    if s == 'inherit':\n        return s\n    return validate_color(s)",
        "begin_line": 311,
        "end_line": 315,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0030211480362537764,
            "pseudo_dstar_susp": 0.0033003300330033004,
            "pseudo_tarantula_susp": 0.001976284584980237,
            "pseudo_op2_susp": 0.003367003367003367,
            "pseudo_barinel_susp": 0.001976284584980237
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_color_or_auto#318",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_color_or_auto(s)",
        "snippet": "def validate_color_or_auto(s):\n    if s == 'auto':\n        return s\n    return validate_color(s)",
        "begin_line": 318,
        "end_line": 321,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.016666666666666666,
            "pseudo_dstar_susp": 0.0007434944237918215,
            "pseudo_tarantula_susp": 0.0033333333333333335,
            "pseudo_op2_susp": 0.0007434944237918215,
            "pseudo_barinel_susp": 0.0033333333333333335
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_color_for_prop_cycle#324",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_color_for_prop_cycle(s)",
        "snippet": "def validate_color_for_prop_cycle(s):\n    # N-th color cycle syntax can't go into the color cycle.\n    if isinstance(s, str) and re.match(\"^C[0-9]$\", s):\n        raise ValueError(f\"Cannot put cycle reference ({s!r}) in prop_cycler\")\n    return validate_color(s)",
        "begin_line": 324,
        "end_line": 328,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006993006993006993,
            "pseudo_dstar_susp": 0.0007342143906020558,
            "pseudo_tarantula_susp": 0.002331002331002331,
            "pseudo_op2_susp": 0.0007342143906020558,
            "pseudo_barinel_susp": 0.002331002331002331
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_color#331",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_color(s)",
        "snippet": "def validate_color(s):\n    \"\"\"Return a valid color arg.\"\"\"\n    if isinstance(s, str):\n        if s.lower() == 'none':\n            return 'none'\n        if len(s) == 6 or len(s) == 8:\n            stmp = '#' + s\n            if is_color_like(stmp):\n                return stmp\n\n    if is_color_like(s):\n        return s\n\n    # If it is still valid, it must be a tuple (as a string from matplotlibrc).\n    try:\n        color = ast.literal_eval(s)\n    except (SyntaxError, ValueError):\n        pass\n    else:\n        if is_color_like(color):\n            return color\n\n    raise ValueError(f'{s!r} does not look like a color arg')",
        "begin_line": 331,
        "end_line": 353,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.014285714285714285,
            "pseudo_dstar_susp": 0.003076923076923077,
            "pseudo_tarantula_susp": 0.003236245954692557,
            "pseudo_op2_susp": 0.003076923076923077,
            "pseudo_barinel_susp": 0.003236245954692557
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_aspect#362",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_aspect(s)",
        "snippet": "def validate_aspect(s):\n    if s in ('auto', 'equal'):\n        return s\n    try:\n        return float(s)\n    except ValueError as e:\n        raise ValueError('not a valid aspect specification') from e",
        "begin_line": 362,
        "end_line": 368,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.014285714285714285,
            "pseudo_dstar_susp": 0.003484320557491289,
            "pseudo_tarantula_susp": 0.003236245954692557,
            "pseudo_op2_susp": 0.0035587188612099642,
            "pseudo_barinel_susp": 0.003236245954692557
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_fontsize_None#371",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_fontsize_None(s)",
        "snippet": "def validate_fontsize_None(s):\n    if s is None or s == 'None':\n        return None\n    else:\n        return validate_fontsize(s)",
        "begin_line": 371,
        "end_line": 375,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.014285714285714285,
            "pseudo_dstar_susp": 0.0032679738562091504,
            "pseudo_tarantula_susp": 0.003236245954692557,
            "pseudo_op2_susp": 0.0033333333333333335,
            "pseudo_barinel_susp": 0.003236245954692557
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_fontsize#378",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_fontsize(s)",
        "snippet": "def validate_fontsize(s):\n    fontsizes = ['xx-small', 'x-small', 'small', 'medium', 'large',\n                 'x-large', 'xx-large', 'smaller', 'larger']\n    if isinstance(s, str):\n        s = s.lower()\n    if s in fontsizes:\n        return s\n    try:\n        return float(s)\n    except ValueError as e:\n        raise ValueError(\"%s is not a valid font size. Valid font sizes \"\n                         \"are %s.\" % (s, \", \".join(fontsizes))) from e",
        "begin_line": 378,
        "end_line": 389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.016666666666666666,
            "pseudo_dstar_susp": 0.003367003367003367,
            "pseudo_tarantula_susp": 0.0033333333333333335,
            "pseudo_op2_susp": 0.003436426116838488,
            "pseudo_barinel_susp": 0.0033333333333333335
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_fontweight#395",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_fontweight(s)",
        "snippet": "def validate_fontweight(s):\n    weights = [\n        'ultralight', 'light', 'normal', 'regular', 'book', 'medium', 'roman',\n        'semibold', 'demibold', 'demi', 'bold', 'heavy', 'extra bold', 'black']\n    # Note: Historically, weights have been case-sensitive in Matplotlib\n    if s in weights:\n        return s\n    try:\n        return int(s)\n    except (ValueError, TypeError) as e:\n        raise ValueError(f'{s} is not a valid font weight.') from e",
        "begin_line": 395,
        "end_line": 405,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.016666666666666666,
            "pseudo_dstar_susp": 0.0036231884057971015,
            "pseudo_tarantula_susp": 0.0033333333333333335,
            "pseudo_op2_susp": 0.0036900369003690036,
            "pseudo_barinel_susp": 0.0033333333333333335
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_font_properties#408",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_font_properties(s)",
        "snippet": "def validate_font_properties(s):\n    parse_fontconfig_pattern(s)\n    return s",
        "begin_line": 408,
        "end_line": 410,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.016666666666666666,
            "pseudo_dstar_susp": 0.0007451564828614009,
            "pseudo_tarantula_susp": 0.0033333333333333335,
            "pseudo_op2_susp": 0.0007451564828614009,
            "pseudo_barinel_susp": 0.0033333333333333335
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._validate_mathtext_fallback_to_cm#413",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._validate_mathtext_fallback_to_cm(b)",
        "snippet": "def _validate_mathtext_fallback_to_cm(b):\n    \"\"\"\n    Temporary validate for fallback_to_cm, while deprecated\n\n    \"\"\"\n    if isinstance(b, str):\n        b = b.lower()\n    if b is None or b == 'none':\n        return None\n    else:\n        cbook.warn_deprecated(\n            \"3.3\", message=\"Support for setting the 'mathtext.fallback_to_cm' rcParam \"\n            \"is deprecated since %(since)s and will be removed \"\n            \"%(removal)s; use 'mathtext.fallback : 'cm' instead.\")\n        return validate_bool_maybe_none(b)",
        "begin_line": 413,
        "end_line": 427,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02,
            "pseudo_dstar_susp": 0.0035587188612099642,
            "pseudo_tarantula_susp": 0.0035335689045936395,
            "pseudo_op2_susp": 0.0036231884057971015,
            "pseudo_barinel_susp": 0.0035335689045936395
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._validate_mathtext_fallback#430",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._validate_mathtext_fallback(s)",
        "snippet": "def _validate_mathtext_fallback(s):\n    _fallback_fonts = ['cm', 'stix', 'stixsans']\n    if isinstance(s, str):\n        s = s.lower()\n    if s is None or s == 'none':\n        return None\n    elif s.lower() in _fallback_fonts:\n        return s\n    else:\n        raise ValueError(f\"{s} is not a valid fallback font name. Valid fallback \"\n                         f\"font names are {','.join(_fallback_fonts)}. Passing \"\n                         f\"'None' will turn fallback off.\")",
        "begin_line": 430,
        "end_line": 441,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007751937984496124,
            "pseudo_dstar_susp": 0.0035335689045936395,
            "pseudo_tarantula_susp": 0.0024271844660194173,
            "pseudo_op2_susp": 0.0035971223021582736,
            "pseudo_barinel_susp": 0.0024271844660194173
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_whiskers#457",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_whiskers(s)",
        "snippet": "def validate_whiskers(s):\n    if s == 'range':\n        cbook.warn_deprecated(\n            \"3.2\", message=\"Support for setting the boxplot.whiskers rcParam \"\n            \"to 'range' is deprecated since %(since)s and will be removed \"\n            \"%(removal)s; set it to 0, 100 instead.\")\n        return 'range'\n    else:\n        try:\n            v = validate_nseq_float(2)(s)\n            return v\n        except (TypeError, ValueError):\n            try:\n                v = float(s)\n                return v\n            except ValueError as e:\n                raise ValueError(\"Not a valid whisker value ['range', float, \"\n                                 \"(float, float)]\") from e",
        "begin_line": 457,
        "end_line": 474,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00684931506849315,
            "pseudo_dstar_susp": 0.0043859649122807015,
            "pseudo_tarantula_susp": 0.002304147465437788,
            "pseudo_op2_susp": 0.004405286343612335,
            "pseudo_barinel_susp": 0.002304147465437788
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._update_savefig_format#492",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._update_savefig_format(value)",
        "snippet": "def _update_savefig_format(value):\n    # The old savefig.extension could also have a value of \"auto\", but\n    # the new savefig.format does not.  We need to fix this here.\n    value = validate_string(value)\n    if value == 'auto':\n        cbook.warn_deprecated(\n            \"3.2\", message=\"Support for setting the 'savefig.format' rcParam \"\n            \"to 'auto' is deprecated since %(since)s and will be removed \"\n            \"%(removal)s; set it to 'png' instead.\")\n        value = 'png'\n    return value",
        "begin_line": 492,
        "end_line": 502,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008695652173913044,
            "pseudo_dstar_susp": 0.004464285714285714,
            "pseudo_tarantula_susp": 0.002364066193853428,
            "pseudo_op2_susp": 0.004484304932735426,
            "pseudo_barinel_susp": 0.002364066193853428
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_ps_distiller#513",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_ps_distiller(s)",
        "snippet": "def validate_ps_distiller(s):\n    if isinstance(s, str):\n        s = s.lower()\n    if s in ('none', None, 'false', False):\n        return None\n    else:\n        return ValidateInStrings('ps.usedistiller', ['ghostscript', 'xpdf'])(s)",
        "begin_line": 513,
        "end_line": 519,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.016666666666666666,
            "pseudo_dstar_susp": 0.003436426116838488,
            "pseudo_tarantula_susp": 0.0033333333333333335,
            "pseudo_op2_susp": 0.0035087719298245615,
            "pseudo_barinel_susp": 0.0033333333333333335
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._validate_linestyle#530",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._validate_linestyle(ls)",
        "snippet": "def _validate_linestyle(ls):\n    \"\"\"\n    A validator for all possible line styles, the named ones *and*\n    the on-off ink sequences.\n    \"\"\"\n    if isinstance(ls, str):\n        try:  # Look first for a valid named line style, like '--' or 'solid'.\n            return _validate_named_linestyle(ls)\n        except ValueError:\n            pass\n        try:\n            ls = ast.literal_eval(ls)  # Parsing matplotlibrc.\n        except (SyntaxError, ValueError):\n            pass  # Will error with the ValueError at the end.\n\n    def _is_iterable_not_string_like(x):\n        # Explicitly exclude bytes/bytearrays so that they are not\n        # nonsensically interpreted as sequences of numbers (codepoints).\n        return np.iterable(x) and not isinstance(x, (str, bytes, bytearray))\n\n    # (offset, (on, off, on, off, ...))\n    if (_is_iterable_not_string_like(ls)\n            and len(ls) == 2\n            and isinstance(ls[0], (type(None), Number))\n            and _is_iterable_not_string_like(ls[1])\n            and len(ls[1]) % 2 == 0\n            and all(isinstance(elem, Number) for elem in ls[1])):\n        if ls[0] is None:\n            cbook.warn_deprecated(\n                \"3.3\", message=\"Passing the dash offset as None is deprecated \"\n                \"since %(since)s and support for it will be removed \"\n                \"%(removal)s; pass it as zero instead.\")\n            ls = (0, ls[1])\n        return ls\n    # For backcompat: (on, off, on, off, ...); the offset is implicitly None.\n    if (_is_iterable_not_string_like(ls)\n            and len(ls) % 2 == 0\n            and all(isinstance(elem, Number) for elem in ls)):\n        return (0, ls)\n    raise ValueError(f\"linestyle {ls!r} is not a valid on-off ink sequence.\")",
        "begin_line": 530,
        "end_line": 569,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01020408163265306,
            "pseudo_dstar_susp": 0.003703703703703704,
            "pseudo_tarantula_susp": 0.0024390243902439024,
            "pseudo_op2_susp": 0.0037735849056603774,
            "pseudo_barinel_susp": 0.0024390243902439024
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._deprecate_case_insensitive_join_cap#572",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._deprecate_case_insensitive_join_cap(s)",
        "snippet": "def _deprecate_case_insensitive_join_cap(s):\n    s_low = s.lower()\n    if s != s_low:\n        if s_low in ['miter', 'round', 'bevel']:\n            cbook.warn_deprecated(\n                \"3.3\", message=\"Case-insensitive capstyles are deprecated \"\n                \"since %(since)s and support for them will be removed \"\n                \"%(removal)s; please pass them in lowercase.\")\n        elif s_low in ['butt', 'round', 'projecting']:\n            cbook.warn_deprecated(\n                \"3.3\", message=\"Case-insensitive joinstyles are deprecated \"\n                \"since %(since)s and support for them will be removed \"\n                \"%(removal)s; please pass them in lowercase.\")\n        # Else, error out at the check_in_list stage.\n    return s_low",
        "begin_line": 572,
        "end_line": 586,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008849557522123894,
            "pseudo_dstar_susp": 0.006211180124223602,
            "pseudo_tarantula_susp": 0.0024330900243309003,
            "pseudo_op2_susp": 0.006289308176100629,
            "pseudo_barinel_susp": 0.0024330900243309003
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_joinstyle#589",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_joinstyle(s)",
        "snippet": "def validate_joinstyle(s):\n    s = _deprecate_case_insensitive_join_cap(s)\n    cbook._check_in_list(['miter', 'round', 'bevel'], joinstyle=s)\n    return s",
        "begin_line": 589,
        "end_line": 592,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009009009009009009,
            "pseudo_dstar_susp": 0.0034602076124567475,
            "pseudo_tarantula_susp": 0.002369668246445498,
            "pseudo_op2_susp": 0.0035335689045936395,
            "pseudo_barinel_susp": 0.002369668246445498
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_capstyle#595",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_capstyle(s)",
        "snippet": "def validate_capstyle(s):\n    s = _deprecate_case_insensitive_join_cap(s)\n    cbook._check_in_list(['butt', 'round', 'projecting'], capstyle=s)\n    return s",
        "begin_line": 595,
        "end_line": 598,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.014285714285714285,
            "pseudo_dstar_susp": 0.0037174721189591076,
            "pseudo_tarantula_susp": 0.003236245954692557,
            "pseudo_op2_susp": 0.003787878787878788,
            "pseudo_barinel_susp": 0.003236245954692557
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._validate_hinting#673",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._validate_hinting(s)",
        "snippet": "def _validate_hinting(s):\n    if s in (True, False):\n        cbook.warn_deprecated(\n            \"3.2\", message=\"Support for setting the text.hinting rcParam to \"\n            \"True or False is deprecated since %(since)s and will be removed \"\n            \"%(removal)s; set it to its synonyms 'auto' or 'none' instead.\")\n        return s\n    if s.lower() in ('auto', 'native', 'either', 'none'):\n        return s.lower()\n    raise ValueError(\"hinting should be 'auto', 'native', 'either' or 'none'\")",
        "begin_line": 673,
        "end_line": 682,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.014285714285714285,
            "pseudo_dstar_susp": 0.0007251631617113851,
            "pseudo_tarantula_susp": 0.003236245954692557,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.003236245954692557
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_bbox#710",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_bbox(s)",
        "snippet": "def validate_bbox(s):\n    if isinstance(s, str):\n        s = s.lower()\n        if s == 'tight':\n            return s\n        if s == 'standard':\n            return None\n        raise ValueError(\"bbox should be 'tight' or 'standard'\")\n    elif s is not None:\n        # Backwards compatibility. None is equivalent to 'standard'.\n        raise ValueError(\"bbox should be 'tight' or 'standard'\")\n    return s",
        "begin_line": 710,
        "end_line": 721,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.015151515151515152,
            "pseudo_dstar_susp": 0.00392156862745098,
            "pseudo_tarantula_susp": 0.0027548209366391185,
            "pseudo_op2_susp": 0.004,
            "pseudo_barinel_susp": 0.0027548209366391185
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_sketch#724",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_sketch(s)",
        "snippet": "def validate_sketch(s):\n    if isinstance(s, str):\n        s = s.lower()\n    if s == 'none' or s is None:\n        return None\n    try:\n        return tuple(validate_nseq_float(3)(s))\n    except ValueError:\n        raise ValueError(\"Expected a (scale, length, randomness) triplet\")",
        "begin_line": 724,
        "end_line": 732,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02631578947368421,
            "pseudo_dstar_susp": 0.00390625,
            "pseudo_tarantula_susp": 0.0035971223021582736,
            "pseudo_op2_susp": 0.00398406374501992,
            "pseudo_barinel_susp": 0.0035971223021582736
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._validate_greaterequal0_lessthan1#735",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._validate_greaterequal0_lessthan1(s)",
        "snippet": "def _validate_greaterequal0_lessthan1(s):\n    s = validate_float(s)\n    if 0 <= s < 1:\n        return s\n    else:\n        raise RuntimeError(f'Value must be >=0 and <1; got {s}')",
        "begin_line": 735,
        "end_line": 740,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.016666666666666666,
            "pseudo_dstar_susp": 0.003663003663003663,
            "pseudo_tarantula_susp": 0.0033333333333333335,
            "pseudo_op2_susp": 0.0037313432835820895,
            "pseudo_barinel_susp": 0.0033333333333333335
        }
    },
    {
        "name": "lib.matplotlib.rcsetup._validate_greaterequal0_lessequal1#743",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup._validate_greaterequal0_lessequal1(s)",
        "snippet": "def _validate_greaterequal0_lessequal1(s):\n    s = validate_float(s)\n    if 0 <= s <= 1:\n        return s\n    else:\n        raise RuntimeError(f'Value must be >=0 and <=1; got {s}')",
        "begin_line": 743,
        "end_line": 748,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007194244604316547,
            "pseudo_dstar_susp": 0.0038910505836575876,
            "pseudo_tarantula_susp": 0.002352941176470588,
            "pseudo_op2_susp": 0.003968253968253968,
            "pseudo_barinel_susp": 0.002352941176470588
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.cycler#813",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.cycler(*args, **kwargs)",
        "snippet": "def cycler(*args, **kwargs):\n    \"\"\"\n    Creates a `~cycler.Cycler` object much like :func:`cycler.cycler`,\n    but includes input validation.\n\n    Call signatures::\n\n      cycler(cycler)\n      cycler(label=values[, label2=values2[, ...]])\n      cycler(label, values)\n\n    Form 1 copies a given `~cycler.Cycler` object.\n\n    Form 2 creates a `~cycler.Cycler` which cycles over one or more\n    properties simultaneously. If multiple properties are given, their\n    value lists must have the same length.\n\n    Form 3 creates a `~cycler.Cycler` for a single property. This form\n    exists for compatibility with the original cycler. Its use is\n    discouraged in favor of the kwarg form, i.e. ``cycler(label=values)``.\n\n    Parameters\n    ----------\n    cycler : Cycler\n        Copy constructor for Cycler.\n\n    label : str\n        The property key. Must be a valid `.Artist` property.\n        For example, 'color' or 'linestyle'. Aliases are allowed,\n        such as 'c' for 'color' and 'lw' for 'linewidth'.\n\n    values : iterable\n        Finite-length iterable of the property values. These values\n        are validated and will raise a ValueError if invalid.\n\n    Returns\n    -------\n    cycler : Cycler\n        A new :class:`~cycler.Cycler` for the given properties.\n\n    Examples\n    --------\n    Creating a cycler for a single property:\n\n    >>> c = cycler(color=['red', 'green', 'blue'])\n\n    Creating a cycler for simultaneously cycling over multiple properties\n    (e.g. red circle, green plus, blue cross):\n\n    >>> c = cycler(color=['red', 'green', 'blue'],\n    ...            marker=['o', '+', 'x'])\n\n    \"\"\"\n    if args and kwargs:\n        raise TypeError(\"cycler() can only accept positional OR keyword \"\n                        \"arguments -- not both.\")\n    elif not args and not kwargs:\n        raise TypeError(\"cycler() must have positional OR keyword arguments\")\n\n    if len(args) == 1:\n        if not isinstance(args[0], Cycler):\n            raise TypeError(\"If only one positional argument given, it must \"\n                            \" be a Cycler instance.\")\n        return validate_cycler(args[0])\n    elif len(args) == 2:\n        pairs = [(args[0], args[1])]\n    elif len(args) > 2:\n        raise TypeError(\"No more than 2 positional arguments allowed\")\n    else:\n        pairs = kwargs.items()\n\n    validated = []\n    for prop, vals in pairs:\n        norm_prop = _prop_aliases.get(prop, prop)\n        validator = _prop_validators.get(norm_prop, None)\n        if validator is None:\n            raise TypeError(\"Unknown artist property: %s\" % prop)\n        vals = validator(vals)\n        # We will normalize the property names as well to reduce\n        # the amount of alias handling code elsewhere.\n        validated.append((norm_prop, vals))\n\n    return reduce(operator.add, (ccycler(k, v) for k, v in validated))",
        "begin_line": 813,
        "end_line": 895,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_cycler#898",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_cycler(s)",
        "snippet": "def validate_cycler(s):\n    \"\"\"Return a Cycler object from a string repr or the object itself.\"\"\"\n    if isinstance(s, str):\n        try:\n            # TODO: We might want to rethink this...\n            # While I think I have it quite locked down,\n            # it is execution of arbitrary code without\n            # sanitation.\n            # Combine this with the possibility that rcparams\n            # might come from the internet (future plans), this\n            # could be downright dangerous.\n            # I locked it down by only having the 'cycler()' function\n            # available.\n            # UPDATE: Partly plugging a security hole.\n            # I really should have read this:\n            # http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html\n            # We should replace this eval with a combo of PyParsing and\n            # ast.literal_eval()\n            if '.__' in s.replace(' ', ''):\n                raise ValueError(\"'%s' seems to have dunder methods. Raising\"\n                                 \" an exception for your safety\")\n            s = eval(s, {'cycler': cycler, '__builtins__': {}})\n        except BaseException as e:\n            raise ValueError(\"'%s' is not a valid cycler construction: %s\" %\n                             (s, e)) from e\n    # Should make sure what comes from the above eval()\n    # is a Cycler object.\n    if isinstance(s, Cycler):\n        cycler_inst = s\n    else:\n        raise ValueError(\"object was not a string or Cycler instance: %s\" % s)\n\n    unknowns = cycler_inst.keys - (set(_prop_validators) | set(_prop_aliases))\n    if unknowns:\n        raise ValueError(\"Unknown artist properties: %s\" % unknowns)\n\n    # Not a full validation, but it'll at least normalize property names\n    # A fuller validation would require v0.10 of cycler.\n    checker = set()\n    for prop in cycler_inst.keys:\n        norm_prop = _prop_aliases.get(prop, prop)\n        if norm_prop != prop and norm_prop in cycler_inst.keys:\n            raise ValueError(\"Cannot specify both '{0}' and alias '{1}'\"\n                             \" in the same prop_cycle\".format(norm_prop, prop))\n        if norm_prop in checker:\n            raise ValueError(\"Another property was already aliased to '{0}'.\"\n                             \" Collision normalizing '{1}'.\".format(norm_prop,\n                                                                    prop))\n        checker.update([norm_prop])\n\n    # This is just an extra-careful check, just in case there is some\n    # edge-case I haven't thought of.\n    assert len(checker) == len(cycler_inst.keys)\n\n    # Now, it should be safe to mutate this cycler\n    for prop in cycler_inst.keys:\n        norm_prop = _prop_aliases.get(prop, prop)\n        cycler_inst.change_key(prop, norm_prop)\n\n    for key, vals in cycler_inst.by_key().items():\n        _prop_validators[key](vals)\n\n    return cycler_inst",
        "begin_line": 898,
        "end_line": 960,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00684931506849315,
            "pseudo_dstar_susp": 0.004424778761061947,
            "pseudo_tarantula_susp": 0.002304147465437788,
            "pseudo_op2_susp": 0.0044444444444444444,
            "pseudo_barinel_susp": 0.002304147465437788
        }
    },
    {
        "name": "lib.matplotlib.rcsetup.validate_hist_bins#963",
        "src_path": "lib/matplotlib/rcsetup.py",
        "class_name": "lib.matplotlib.rcsetup",
        "signature": "lib.matplotlib.rcsetup.validate_hist_bins(s)",
        "snippet": "def validate_hist_bins(s):\n    valid_strs = [\"auto\", \"sturges\", \"fd\", \"doane\", \"scott\", \"rice\", \"sqrt\"]\n    if isinstance(s, str) and s in valid_strs:\n        return s\n    try:\n        return int(s)\n    except (TypeError, ValueError):\n        pass\n    try:\n        return validate_floatlist(s)\n    except ValueError:\n        pass\n    raise ValueError(\"'hist.bins' must be one of {}, an int or\"\n                     \" a sequence of floats\".format(valid_strs))",
        "begin_line": 963,
        "end_line": 976,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007936507936507936,
            "pseudo_dstar_susp": 0.0038022813688212928,
            "pseudo_tarantula_susp": 0.002320185614849188,
            "pseudo_op2_susp": 0.003875968992248062,
            "pseudo_barinel_susp": 0.002320185614849188
        }
    },
    {
        "name": "lib.matplotlib._constrained_layout.do_constrained_layout#79",
        "src_path": "lib/matplotlib/_constrained_layout.py",
        "class_name": "lib.matplotlib._constrained_layout",
        "signature": "lib.matplotlib._constrained_layout.do_constrained_layout(fig, renderer, h_pad, w_pad, hspace=None, wspace=None)",
        "snippet": "def do_constrained_layout(fig, renderer, h_pad, w_pad,\n                          hspace=None, wspace=None):\n    \"\"\"\n    Do the constrained_layout.  Called at draw time in\n     ``figure.constrained_layout()``\n\n    Parameters\n    ----------\n    fig : Figure\n      is the ``figure`` instance to do the layout in.\n\n    renderer : Renderer\n      the renderer to use.\n\n     h_pad, w_pad : float\n       are in figure-normalized units, and are a padding around the axes\n       elements.\n\n     hspace, wspace : float\n        are in fractions of the subplot sizes.\n\n    \"\"\"\n\n    # Steps:\n    #\n    # 1. get a list of unique gridspecs in this figure.  Each gridspec will be\n    # constrained separately.\n    # 2. Check for gaps in the gridspecs.  i.e. if not every axes slot in the\n    # gridspec has been filled.  If empty, add a ghost axis that is made so\n    # that it cannot be seen (though visible=True).  This is needed to make\n    # a blank spot in the layout.\n    # 3. Compare the tight_bbox of each axes to its `position`, and assume that\n    # the difference is the space needed by the elements around the edge of\n    # the axes (decorations) like the title, ticklabels, x-labels, etc.  This\n    # can include legends who overspill the axes boundaries.\n    # 4. Constrain gridspec elements to line up:\n    #     a) if colnum0 != colnumC, the two subplotspecs are stacked next to\n    #     each other, with the appropriate order.\n    #     b) if colnum0 == colnumC, line up the left or right side of the\n    #     _poslayoutbox (depending if it is the min or max num that is equal).\n    #     c) do the same for rows...\n    # 5. The above doesn't constrain relative sizes of the _poslayoutboxes\n    # at all, and indeed zero-size is a solution that the solver often finds\n    # more convenient than expanding the sizes.  Right now the solution is to\n    # compare subplotspec sizes (i.e. drowsC and drows0) and constrain the\n    # larger _poslayoutbox to be larger than the ratio of the sizes. i.e. if\n    # drows0 > drowsC, then ax._poslayoutbox > axc._poslayoutbox*drowsC/drows0.\n    # This works fine *if* the decorations are similar between the axes.\n    # If the larger subplotspec has much larger axes decorations, then the\n    # constraint above is incorrect.\n    #\n    # We need the greater than in the above, in general, rather than an equals\n    # sign.  Consider the case of the left column having 2 rows, and the right\n    # column having 1 row.  We want the top and bottom of the _poslayoutboxes\n    # to line up. So that means if there are decorations on the left column\n    # axes they will be smaller than half as large as the right hand axis.\n    #\n    # This can break down if the decoration size for the right hand axis (the\n    # margins) is very large.  There must be a math way to check for this case.\n\n    invTransFig = fig.transFigure.inverted().transform_bbox\n\n    # list of unique gridspecs that contain child axes:\n    gss = set()\n    for ax in fig.axes:\n        if hasattr(ax, 'get_subplotspec'):\n            gs = ax.get_subplotspec().get_gridspec()\n            if gs._layoutbox is not None:\n                gss.add(gs)\n    if len(gss) == 0:\n        cbook._warn_external('There are no gridspecs with layoutboxes. '\n                             'Possibly did not call parent GridSpec with the'\n                             ' figure= keyword')\n\n    if fig._layoutbox.constrained_layout_called < 1:\n        for gs in gss:\n            # fill in any empty gridspec slots w/ ghost axes...\n            _make_ghost_gridspec_slots(fig, gs)\n\n    for nnn in range(2):\n        # do the algorithm twice.  This has to be done because decorators\n        # change size after the first re-position (i.e. x/yticklabels get\n        # larger/smaller).  This second reposition tends to be much milder,\n        # so doing twice makes things work OK.\n        for ax in fig.axes:\n            _log.debug(ax._layoutbox)\n            if ax._layoutbox is not None:\n                # make margins for each layout box based on the size of\n                # the decorators.\n                _make_layout_margins(ax, renderer, h_pad, w_pad)\n\n        # do layout for suptitle.\n        suptitle = fig._suptitle\n        do_suptitle = (suptitle is not None and\n                       suptitle._layoutbox is not None and\n                       suptitle.get_in_layout())\n        if do_suptitle:\n            bbox = invTransFig(\n                suptitle.get_window_extent(renderer=renderer))\n            height = bbox.y1 - bbox.y0\n            if np.isfinite(height):\n                # reserve at top of figure include an h_pad above and below\n                suptitle._layoutbox.edit_height(height + h_pad * 2)\n\n        # OK, the above lines up ax._poslayoutbox with ax._layoutbox\n        # now we need to\n        #   1) arrange the subplotspecs.  We do it at this level because\n        #      the subplotspecs are meant to contain other dependent axes\n        #      like colorbars or legends.\n        #   2) line up the right and left side of the ax._poslayoutbox\n        #      that have the same subplotspec maxes.\n\n        if fig._layoutbox.constrained_layout_called < 1:\n            # arrange the subplotspecs...  This is all done relative to each\n            # other.  Some subplotspecs contain axes, and others contain\n            # gridspecs the ones that contain gridspecs are a set proportion\n            # of their parent gridspec.  The ones that contain axes are\n            # not so constrained.\n            figlb = fig._layoutbox\n            for child in figlb.children:\n                if child._is_gridspec_layoutbox():\n                    # This routine makes all the subplot spec containers\n                    # have the correct arrangement.  It just stacks the\n                    # subplot layoutboxes in the correct order...\n                    _arrange_subplotspecs(child, hspace=hspace, wspace=wspace)\n\n            for gs in gss:\n                _align_spines(fig, gs)\n\n        fig._layoutbox.constrained_layout_called += 1\n        fig._layoutbox.update_variables()\n\n        # check if any axes collapsed to zero.  If not, don't change positions:\n        if _axes_all_finite_sized(fig):\n            # Now set the position of the axes...\n            for ax in fig.axes:\n                if ax._layoutbox is not None:\n                    newpos = ax._poslayoutbox.get_rect()\n                    # Now set the new position.\n                    # ax.set_position will zero out the layout for\n                    # this axis, allowing users to hard-code the position,\n                    # so this does the same w/o zeroing layout.\n                    ax._set_position(newpos, which='original')\n            if do_suptitle:\n                newpos = suptitle._layoutbox.get_rect()\n                suptitle.set_y(1.0 - h_pad)\n            else:\n                if suptitle is not None and suptitle._layoutbox is not None:\n                    suptitle._layoutbox.edit_height(0)\n        else:\n            cbook._warn_external('constrained_layout not applied.  At least '\n                                 'one axes collapsed to zero width or height.')",
        "begin_line": 79,
        "end_line": 230,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.87959971633441e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._constrained_layout._make_ghost_gridspec_slots#233",
        "src_path": "lib/matplotlib/_constrained_layout.py",
        "class_name": "lib.matplotlib._constrained_layout",
        "signature": "lib.matplotlib._constrained_layout._make_ghost_gridspec_slots(fig, gs)",
        "snippet": "def _make_ghost_gridspec_slots(fig, gs):\n    \"\"\"\n    Check for unoccupied gridspec slots and make ghost axes for these\n    slots...  Do for each gs separately.  This is a pretty big kludge\n    but shouldn't have too much ill effect.  The worst is that\n    someone querying the figure will wonder why there are more\n    axes than they thought.\n    \"\"\"\n    nrows, ncols = gs.get_geometry()\n    hassubplotspec = np.zeros(nrows * ncols, dtype=bool)\n    axs = []\n    for ax in fig.axes:\n        if (hasattr(ax, 'get_subplotspec')\n                and ax._layoutbox is not None\n                and ax.get_subplotspec().get_gridspec() == gs):\n            axs += [ax]\n    for ax in axs:\n        ss0 = ax.get_subplotspec()\n        hassubplotspec[ss0.num1:(ss0.num2 + 1)] = True\n    for nn, hss in enumerate(hassubplotspec):\n        if not hss:\n            # this gridspec slot doesn't have an axis so we\n            # make a \"ghost\".\n            ax = fig.add_subplot(gs[nn])\n            ax.set_visible(False)",
        "begin_line": 233,
        "end_line": 257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.872327211427557e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._constrained_layout._make_layout_margins#260",
        "src_path": "lib/matplotlib/_constrained_layout.py",
        "class_name": "lib.matplotlib._constrained_layout",
        "signature": "lib.matplotlib._constrained_layout._make_layout_margins(ax, renderer, h_pad, w_pad)",
        "snippet": "def _make_layout_margins(ax, renderer, h_pad, w_pad):\n    \"\"\"\n    For each axes, make a margin between the *pos* layoutbox and the\n    *axes* layoutbox be a minimum size that can accommodate the\n    decorations on the axis.\n    \"\"\"\n    fig = ax.figure\n    invTransFig = fig.transFigure.inverted().transform_bbox\n    pos = ax.get_position(original=True)\n    tightbbox = ax.get_tightbbox(renderer=renderer)\n    if tightbbox is None:\n        bbox = pos\n    else:\n        bbox = invTransFig(tightbbox)\n\n    # this can go wrong:\n    if not (np.isfinite(bbox.width) and np.isfinite(bbox.height)):\n        # just abort, this is likely a bad set of coordinates that\n        # is transitory...\n        return\n    # use stored h_pad if it exists\n    h_padt = ax._poslayoutbox.h_pad\n    if h_padt is None:\n        h_padt = h_pad\n    w_padt = ax._poslayoutbox.w_pad\n    if w_padt is None:\n        w_padt = w_pad\n    ax._poslayoutbox.edit_left_margin_min(-bbox.x0 + pos.x0 + w_padt)\n    ax._poslayoutbox.edit_right_margin_min(bbox.x1 - pos.x1 + w_padt)\n    ax._poslayoutbox.edit_bottom_margin_min(-bbox.y0 + pos.y0 + h_padt)\n    ax._poslayoutbox.edit_top_margin_min(bbox.y1-pos.y1+h_padt)\n    _log.debug('left %f', (-bbox.x0 + pos.x0 + w_pad))\n    _log.debug('right %f', (bbox.x1 - pos.x1 + w_pad))\n    _log.debug('bottom %f', (-bbox.y0 + pos.y0 + h_padt))\n    _log.debug('bbox.y0 %f', bbox.y0)\n    _log.debug('pos.y0 %f', pos.y0)\n    # Sometimes its possible for the solver to collapse\n    # rather than expand axes, so they all have zero height\n    # or width.  This stops that...  It *should* have been\n    # taken into account w/ pref_width...\n    if fig._layoutbox.constrained_layout_called < 1:\n        ax._poslayoutbox.constrain_height_min(20, strength='weak')\n        ax._poslayoutbox.constrain_width_min(20, strength='weak')\n        ax._layoutbox.constrain_height_min(20, strength='weak')\n        ax._layoutbox.constrain_width_min(20, strength='weak')\n        ax._poslayoutbox.constrain_top_margin(0, strength='weak')\n        ax._poslayoutbox.constrain_bottom_margin(0, strength='weak')\n        ax._poslayoutbox.constrain_right_margin(0, strength='weak')\n        ax._poslayoutbox.constrain_left_margin(0, strength='weak')",
        "begin_line": 260,
        "end_line": 308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.000090000900009e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._constrained_layout._align_spines#311",
        "src_path": "lib/matplotlib/_constrained_layout.py",
        "class_name": "lib.matplotlib._constrained_layout",
        "signature": "lib.matplotlib._constrained_layout._align_spines(fig, gs)",
        "snippet": "def _align_spines(fig, gs):\n    \"\"\"\n    - Align right/left and bottom/top spines of appropriate subplots.\n    - Compare size of subplotspec including height and width ratios\n       and make sure that the axes spines are at least as large\n       as they should be.\n    \"\"\"\n    # for each gridspec...\n    nrows, ncols = gs.get_geometry()\n    width_ratios = gs.get_width_ratios()\n    height_ratios = gs.get_height_ratios()\n    if width_ratios is None:\n        width_ratios = np.ones(ncols)\n    if height_ratios is None:\n        height_ratios = np.ones(nrows)\n\n    # get axes in this gridspec....\n    axs = [ax for ax in fig.axes\n           if (hasattr(ax, 'get_subplotspec')\n               and ax._layoutbox is not None\n               and ax.get_subplotspec().get_gridspec() == gs)]\n    rownummin = np.zeros(len(axs), dtype=np.int8)\n    rownummax = np.zeros(len(axs), dtype=np.int8)\n    colnummin = np.zeros(len(axs), dtype=np.int8)\n    colnummax = np.zeros(len(axs), dtype=np.int8)\n    width = np.zeros(len(axs))\n    height = np.zeros(len(axs))\n\n    for n, ax in enumerate(axs):\n        ss0 = ax.get_subplotspec()\n        rownummin[n], colnummin[n] = divmod(ss0.num1, ncols)\n        rownummax[n], colnummax[n] = divmod(ss0.num2, ncols)\n        width[n] = np.sum(\n                width_ratios[colnummin[n]:(colnummax[n] + 1)])\n        height[n] = np.sum(\n                height_ratios[rownummin[n]:(rownummax[n] + 1)])\n\n    for nn, ax in enumerate(axs[:-1]):\n        # now compare ax to all the axs:\n        #\n        # If the subplotspecs have the same colnumXmax, then line\n        # up their right sides.  If they have the same min, then\n        # line up their left sides (and vertical equivalents).\n        rownum0min, colnum0min = rownummin[nn], colnummin[nn]\n        rownum0max, colnum0max = rownummax[nn], colnummax[nn]\n        width0, height0 = width[nn], height[nn]\n        alignleft = False\n        alignright = False\n        alignbot = False\n        aligntop = False\n        alignheight = False\n        alignwidth = False\n        for mm in range(nn+1, len(axs)):\n            axc = axs[mm]\n            rownumCmin, colnumCmin = rownummin[mm], colnummin[mm]\n            rownumCmax, colnumCmax = rownummax[mm], colnummax[mm]\n            widthC, heightC = width[mm], height[mm]\n            # Horizontally align axes spines if they have the\n            # same min or max:\n            if not alignleft and colnum0min == colnumCmin:\n                # we want the _poslayoutboxes to line up on left\n                # side of the axes spines...\n                layoutbox.align([ax._poslayoutbox, axc._poslayoutbox],\n                                'left')\n                alignleft = True\n            if not alignright and colnum0max == colnumCmax:\n                # line up right sides of _poslayoutbox\n                layoutbox.align([ax._poslayoutbox, axc._poslayoutbox],\n                                'right')\n                alignright = True\n            # Vertically align axes spines if they have the\n            # same min or max:\n            if not aligntop and rownum0min == rownumCmin:\n                # line up top of _poslayoutbox\n                _log.debug('rownum0min == rownumCmin')\n                layoutbox.align([ax._poslayoutbox, axc._poslayoutbox],\n                                'top')\n                aligntop = True\n            if not alignbot and rownum0max == rownumCmax:\n                # line up bottom of _poslayoutbox\n                _log.debug('rownum0max == rownumCmax')\n                layoutbox.align([ax._poslayoutbox, axc._poslayoutbox],\n                                'bottom')\n                alignbot = True\n            ###########\n            # Now we make the widths and heights of position boxes\n            # similar. (i.e the spine locations)\n            # This allows vertically stacked subplots to have\n            # different sizes if they occupy different amounts\n            # of the gridspec:  i.e.\n            # gs = gridspec.GridSpec(3, 1)\n            # ax1 = gs[0, :]\n            # ax2 = gs[1:, :]\n            # then drows0 = 1, and drowsC = 2, and ax2\n            # should be at least twice as large as ax1.\n            # But it can be more than twice as large because\n            # it needs less room for the labeling.\n            #\n            # For height, this only needs to be done if the\n            # subplots share a column.  For width if they\n            # share a row.\n\n            drowsC = (rownumCmax - rownumCmin + 1)\n            drows0 = (rownum0max - rownum0min + 1)\n            dcolsC = (colnumCmax - colnumCmin + 1)\n            dcols0 = (colnum0max - colnum0min + 1)\n\n            if not alignheight and drows0 == drowsC:\n                ax._poslayoutbox.constrain_height(\n                        axc._poslayoutbox.height * height0 / heightC)\n                alignheight = True\n            elif _in_same_column(colnum0min, colnum0max,\n                                 colnumCmin, colnumCmax):\n                if height0 > heightC:\n                    ax._poslayoutbox.constrain_height_min(\n                        axc._poslayoutbox.height * height0 / heightC)\n                    # these constraints stop the smaller axes from\n                    # being allowed to go to zero height...\n                    axc._poslayoutbox.constrain_height_min(\n                        ax._poslayoutbox.height * heightC /\n                        (height0*1.8))\n                elif height0 < heightC:\n                    axc._poslayoutbox.constrain_height_min(\n                        ax._poslayoutbox.height * heightC / height0)\n                    ax._poslayoutbox.constrain_height_min(\n                        ax._poslayoutbox.height * height0 /\n                        (heightC*1.8))\n            # widths...\n            if not alignwidth and dcols0 == dcolsC:\n                ax._poslayoutbox.constrain_width(\n                        axc._poslayoutbox.width * width0 / widthC)\n                alignwidth = True\n            elif _in_same_row(rownum0min, rownum0max,\n                              rownumCmin, rownumCmax):\n                if width0 > widthC:\n                    ax._poslayoutbox.constrain_width_min(\n                            axc._poslayoutbox.width * width0 / widthC)\n                    axc._poslayoutbox.constrain_width_min(\n                            ax._poslayoutbox.width * widthC /\n                            (width0*1.8))\n                elif width0 < widthC:\n                    axc._poslayoutbox.constrain_width_min(\n                            ax._poslayoutbox.width * widthC / width0)\n                    ax._poslayoutbox.constrain_width_min(\n                            axc._poslayoutbox.width * width0 /\n                            (widthC*1.8))",
        "begin_line": 311,
        "end_line": 456,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.19793966151582e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._constrained_layout._arrange_subplotspecs#459",
        "src_path": "lib/matplotlib/_constrained_layout.py",
        "class_name": "lib.matplotlib._constrained_layout",
        "signature": "lib.matplotlib._constrained_layout._arrange_subplotspecs(gs, hspace=0, wspace=0)",
        "snippet": "def _arrange_subplotspecs(gs, hspace=0, wspace=0):\n    \"\"\"Recursively arrange the subplotspec children of the given gridspec.\"\"\"\n    sschildren = []\n    for child in gs.children:\n        if child._is_subplotspec_layoutbox():\n            for child2 in child.children:\n                # check for gridspec children...\n                if child2._is_gridspec_layoutbox():\n                    _arrange_subplotspecs(child2, hspace=hspace, wspace=wspace)\n            sschildren += [child]\n    # now arrange the subplots...\n    for child0 in sschildren:\n        ss0 = child0.artist\n        nrows, ncols = ss0.get_gridspec().get_geometry()\n        rowNum0min, colNum0min = divmod(ss0.num1, ncols)\n        rowNum0max, colNum0max = divmod(ss0.num2, ncols)\n        sschildren = sschildren[1:]\n        for childc in sschildren:\n            ssc = childc.artist\n            rowNumCmin, colNumCmin = divmod(ssc.num1, ncols)\n            rowNumCmax, colNumCmax = divmod(ssc.num2, ncols)\n            # OK, this tells us the relative layout of ax\n            # with axc\n            thepad = wspace / ncols\n            if colNum0max < colNumCmin:\n                layoutbox.hstack([ss0._layoutbox, ssc._layoutbox],\n                                 padding=thepad)\n            if colNumCmax < colNum0min:\n                layoutbox.hstack([ssc._layoutbox, ss0._layoutbox],\n                                 padding=thepad)\n\n            ####\n            # vertical alignment\n            thepad = hspace / nrows\n            if rowNum0max < rowNumCmin:\n                layoutbox.vstack([ss0._layoutbox,\n                                 ssc._layoutbox],\n                                 padding=thepad)\n            if rowNumCmax < rowNum0min:\n                layoutbox.vstack([ssc._layoutbox,\n                                  ss0._layoutbox],\n                                  padding=thepad)",
        "begin_line": 459,
        "end_line": 500,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.compare.make_test_filename#25",
        "src_path": "lib/matplotlib/testing/compare.py",
        "class_name": "lib.matplotlib.testing.compare",
        "signature": "lib.matplotlib.testing.compare.make_test_filename(fname, purpose)",
        "snippet": "def make_test_filename(fname, purpose):\n    \"\"\"\n    Make a new filename by inserting *purpose* before the file's extension.\n    \"\"\"\n    base, ext = os.path.splitext(fname)\n    return '%s-%s%s' % (base, purpose, ext)",
        "begin_line": 25,
        "end_line": 30,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.245851749873198e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.compare.crop_to_same#287",
        "src_path": "lib/matplotlib/testing/compare.py",
        "class_name": "lib.matplotlib.testing.compare",
        "signature": "lib.matplotlib.testing.compare.crop_to_same(actual_path, actual_image, expected_path, expected_image)",
        "snippet": "def crop_to_same(actual_path, actual_image, expected_path, expected_image):\n    # clip the images to the same size -- this is useful only when\n    # comparing eps to pdf\n    if actual_path[-7:-4] == 'eps' and expected_path[-7:-4] == 'pdf':\n        aw, ah, ad = actual_image.shape\n        ew, eh, ed = expected_image.shape\n        actual_image = actual_image[int(aw / 2 - ew / 2):int(\n            aw / 2 + ew / 2), int(ah / 2 - eh / 2):int(ah / 2 + eh / 2)]\n    return actual_image, expected_image",
        "begin_line": 287,
        "end_line": 295,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.057971014492754e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.compare.calculate_rms#298",
        "src_path": "lib/matplotlib/testing/compare.py",
        "class_name": "lib.matplotlib.testing.compare",
        "signature": "lib.matplotlib.testing.compare.calculate_rms(expected_image, actual_image)",
        "snippet": "def calculate_rms(expected_image, actual_image):\n    \"\"\"\n    Calculate the per-pixel errors, then compute the root mean square error.\n    \"\"\"\n    if expected_image.shape != actual_image.shape:\n        raise ImageComparisonFailure(\n            \"Image sizes do not match expected size: {} \"\n            \"actual size {}\".format(expected_image.shape, actual_image.shape))\n    # Convert to float to avoid overflowing finite integer types.\n    return np.sqrt(((expected_image - actual_image).astype(float) ** 2).mean())",
        "begin_line": 298,
        "end_line": 307,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.compare.compare_images#314",
        "src_path": "lib/matplotlib/testing/compare.py",
        "class_name": "lib.matplotlib.testing.compare",
        "signature": "lib.matplotlib.testing.compare.compare_images(expected, actual, tol, in_decorator=False)",
        "snippet": "def compare_images(expected, actual, tol, in_decorator=False):\n    \"\"\"\n    Compare two \"image\" files checking differences within a tolerance.\n\n    The two given filenames may point to files which are convertible to\n    PNG via the `.converter` dictionary. The underlying RMS is calculated\n    with the `.calculate_rms` function.\n\n    Parameters\n    ----------\n    expected : str\n        The filename of the expected image.\n    actual : str\n        The filename of the actual image.\n    tol : float\n        The tolerance (a color value difference, where 255 is the\n        maximal difference).  The test fails if the average pixel\n        difference is greater than this value.\n    in_decorator : bool\n        Determines the output format. If called from image_comparison\n        decorator, this should be True. (default=False)\n\n    Returns\n    -------\n    comparison_result : None or dict or str\n        Return *None* if the images are equal within the given tolerance.\n\n        If the images differ, the return value depends on  *in_decorator*.\n        If *in_decorator* is true, a dict with the following entries is\n        returned:\n\n        - *rms*: The RMS of the image difference.\n        - *expected*: The filename of the expected image.\n        - *actual*: The filename of the actual image.\n        - *diff_image*: The filename of the difference image.\n        - *tol*: The comparison tolerance.\n\n        Otherwise, a human-readable multi-line string representation of this\n        information is returned.\n\n    Examples\n    --------\n    ::\n\n        img1 = \"./baseline/plot.png\"\n        img2 = \"./output/plot.png\"\n        compare_images(img1, img2, 0.001)\n\n    \"\"\"\n    actual = os.fspath(actual)\n    if not os.path.exists(actual):\n        raise Exception(\"Output image %s does not exist.\" % actual)\n    if os.stat(actual).st_size == 0:\n        raise Exception(\"Output image file %s is empty.\" % actual)\n\n    # Convert the image to png\n    expected = os.fspath(expected)\n    if not os.path.exists(expected):\n        raise IOError('Baseline image %r does not exist.' % expected)\n    extension = expected.split('.')[-1]\n    if extension != 'png':\n        actual = convert(actual, cache=False)\n        expected = convert(expected, cache=True)\n\n    # open the image files and remove the alpha channel (if it exists)\n    expected_image = np.asarray(PIL.Image.open(expected).convert(\"RGB\"))\n    actual_image = np.asarray(PIL.Image.open(actual).convert(\"RGB\"))\n\n    actual_image, expected_image = crop_to_same(\n        actual, actual_image, expected, expected_image)\n\n    diff_image = make_test_filename(actual, 'failed-diff')\n\n    if tol <= 0:\n        if np.array_equal(expected_image, actual_image):\n            return None\n\n    # convert to signed integers, so that the images can be subtracted without\n    # overflow\n    expected_image = expected_image.astype(np.int16)\n    actual_image = actual_image.astype(np.int16)\n\n    rms = calculate_rms(expected_image, actual_image)\n\n    if rms <= tol:\n        return None\n\n    save_diff_image(expected, actual, diff_image)\n\n    results = dict(rms=rms, expected=str(expected),\n                   actual=str(actual), diff=str(diff_image), tol=tol)\n\n    if not in_decorator:\n        # Then the results should be a string suitable for stdout.\n        template = ['Error: Image files did not match.',\n                    'RMS Value: {rms}',\n                    'Expected:  \\n    {expected}',\n                    'Actual:    \\n    {actual}',\n                    'Difference:\\n    {diff}',\n                    'Tolerance: \\n    {tol}', ]\n        results = '\\n  '.join([line.format(**results) for line in template])\n    return results",
        "begin_line": 314,
        "end_line": 415,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.compare.save_diff_image#418",
        "src_path": "lib/matplotlib/testing/compare.py",
        "class_name": "lib.matplotlib.testing.compare",
        "signature": "lib.matplotlib.testing.compare.save_diff_image(expected, actual, output)",
        "snippet": "def save_diff_image(expected, actual, output):\n    \"\"\"\n    Parameters\n    ----------\n    expected : str\n        File path of expected image.\n    actual : str\n        File path of actual image.\n    output : str\n        File path to save difference image to.\n    \"\"\"\n    # Drop alpha channels, similarly to compare_images.\n    expected_image = np.asarray(PIL.Image.open(expected).convert(\"RGB\"))\n    actual_image = np.asarray(PIL.Image.open(actual).convert(\"RGB\"))\n    actual_image, expected_image = crop_to_same(\n        actual, actual_image, expected, expected_image)\n    expected_image = np.array(expected_image).astype(float)\n    actual_image = np.array(actual_image).astype(float)\n    if expected_image.shape != actual_image.shape:\n        raise ImageComparisonFailure(\n            \"Image sizes do not match expected size: {} \"\n            \"actual size {}\".format(expected_image.shape, actual_image.shape))\n    abs_diff_image = np.abs(expected_image - actual_image)\n\n    # expand differences in luminance domain\n    abs_diff_image *= 255 * 10\n    save_image_np = np.clip(abs_diff_image, 0, 255).astype(np.uint8)\n    height, width, depth = save_image_np.shape\n\n    # The PDF renderer doesn't produce an alpha channel, but the\n    # matplotlib PNG writer requires one, so expand the array\n    if depth == 3:\n        with_alpha = np.empty((height, width, 4), dtype=np.uint8)\n        with_alpha[:, :, 0:3] = save_image_np\n        save_image_np = with_alpha\n\n    # Hard-code the alpha channel to fully solid\n    save_image_np[:, :, 3] = 255\n\n    PIL.Image.fromarray(save_image_np).save(output, format=\"png\")",
        "begin_line": 418,
        "end_line": 457,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.quiver.QuiverKey.__init__#201",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.QuiverKey",
        "signature": "lib.matplotlib.quiver.QuiverKey.__init__(self, Q, X, Y, U, label, *, angle=0, coordinates='axes', color=None, labelsep=0.1, labelpos='N', labelcolor=None, fontproperties=None, **kw)",
        "snippet": "    def __init__(self, Q, X, Y, U, label,\n                 *, angle=0, coordinates='axes', color=None, labelsep=0.1,\n                 labelpos='N', labelcolor=None, fontproperties=None,\n                 **kw):\n        \"\"\"\n        Add a key to a quiver plot.\n\n        The positioning of the key depends on *X*, *Y*, *coordinates*, and\n        *labelpos*.  If *labelpos* is 'N' or 'S', *X*, *Y* give the position of\n        the middle of the key arrow.  If *labelpos* is 'E', *X*, *Y* positions\n        the head, and if *labelpos* is 'W', *X*, *Y* positions the tail; in\n        either of these two cases, *X*, *Y* is somewhere in the middle of the\n        arrow+label key object.\n\n        Parameters\n        ----------\n        Q : `matplotlib.quiver.Quiver`\n            A `.Quiver` object as returned by a call to `~.Axes.quiver()`.\n        X, Y : float\n            The location of the key.\n        U : float\n            The length of the key.\n        label : str\n            The key label (e.g., length and units of the key).\n        angle : float, default: 0\n            The angle of the key arrow, in degrees anti-clockwise from the\n            x-axis.\n        coordinates : {'axes', 'figure', 'data', 'inches'}, default: 'axes'\n            Coordinate system and units for *X*, *Y*: 'axes' and 'figure' are\n            normalized coordinate systems with (0, 0) in the lower left and\n            (1, 1) in the upper right; 'data' are the axes data coordinates\n            (used for the locations of the vectors in the quiver plot itself);\n            'inches' is position in the figure in inches, with (0, 0) at the\n            lower left corner.\n        color : color\n            Overrides face and edge colors from *Q*.\n        labelpos : {'N', 'S', 'E', 'W'}\n            Position the label above, below, to the right, to the left of the\n            arrow, respectively.\n        labelsep : float, default: 0.1\n            Distance in inches between the arrow and the label.\n        labelcolor : color, default: :rc:`text.color`\n            Label color.\n        fontproperties : dict, optional\n            A dictionary with keyword arguments accepted by the\n            `~matplotlib.font_manager.FontProperties` initializer:\n            *family*, *style*, *variant*, *size*, *weight*.\n        **kwargs\n            Any additional keyword arguments are used to override vector\n            properties taken from *Q*.\n        \"\"\"\n        martist.Artist.__init__(self)\n        self.Q = Q\n        self.X = X\n        self.Y = Y\n        self.U = U\n        self.angle = angle\n        self.coord = coordinates\n        self.color = color\n        self.label = label\n        self._labelsep_inches = labelsep\n        self.labelsep = (self._labelsep_inches * Q.ax.figure.dpi)\n\n        # try to prevent closure over the real self\n        weak_self = weakref.ref(self)\n\n        def on_dpi_change(fig):\n            self_weakref = weak_self()\n            if self_weakref is not None:\n                self_weakref.labelsep = self_weakref._labelsep_inches * fig.dpi\n                # simple brute force update works because _init is called at\n                # the start of draw.\n                self_weakref._initialized = False\n\n        self._cid = Q.ax.figure.callbacks.connect('dpi_changed',\n                                                  on_dpi_change)\n\n        self.labelpos = labelpos\n        self.labelcolor = labelcolor\n        self.fontproperties = fontproperties or dict()\n        self.kw = kw\n        _fp = self.fontproperties\n        # boxprops = dict(facecolor='red')\n        self.text = mtext.Text(\n            text=label,  # bbox=boxprops,\n            horizontalalignment=self.halign[self.labelpos],\n            verticalalignment=self.valign[self.labelpos],\n            fontproperties=font_manager.FontProperties._from_any(_fp))\n\n        if self.labelcolor is not None:\n            self.text.set_color(self.labelcolor)\n        self._initialized = False\n        self.zorder = Q.zorder + 0.1",
        "begin_line": 201,
        "end_line": 293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.quiver.QuiverKey.remove#295",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.QuiverKey",
        "signature": "lib.matplotlib.quiver.QuiverKey.remove(self)",
        "snippet": "    def remove(self):\n        \"\"\"\n        Overload the remove method\n        \"\"\"\n        self.Q.ax.figure.callbacks.disconnect(self._cid)\n        self._cid = None\n        # pass the remove call up the stack\n        martist.Artist.remove(self)",
        "begin_line": 295,
        "end_line": 302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.quiver._parse_args#393",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver",
        "signature": "lib.matplotlib.quiver._parse_args(*args, caller_name='function')",
        "snippet": "def _parse_args(*args, caller_name='function'):\n    \"\"\"\n    Helper function to parse positional parameters for colored vector plots.\n\n    This is currently used for Quiver and Barbs.\n\n    Parameters\n    ----------\n    *args : list\n        list of 2-5 arguments. Depending on their number they are parsed to::\n\n            U, V\n            U, V, C\n            X, Y, U, V\n            X, Y, U, V, C\n\n    caller_name : str\n        Name of the calling method (used in error messages).\n    \"\"\"\n    X = Y = C = None\n\n    len_args = len(args)\n    if len_args == 2:\n        # The use of atleast_1d allows for handling scalar arguments while also\n        # keeping masked arrays\n        U, V = np.atleast_1d(*args)\n    elif len_args == 3:\n        U, V, C = np.atleast_1d(*args)\n    elif len_args == 4:\n        X, Y, U, V = np.atleast_1d(*args)\n    elif len_args == 5:\n        X, Y, U, V, C = np.atleast_1d(*args)\n    else:\n        raise TypeError(f'{caller_name} takes 2-5 positional arguments but '\n                        f'{len_args} were given')\n\n    nr, nc = (1, U.shape[0]) if U.ndim == 1 else U.shape\n\n    if X is not None:\n        X = X.ravel()\n        Y = Y.ravel()\n        if len(X) == nc and len(Y) == nr:\n            X, Y = [a.ravel() for a in np.meshgrid(X, Y)]\n        elif len(X) != len(Y):\n            raise ValueError('X and Y must be the same size, but '\n                             f'X.size is {X.size} and Y.size is {Y.size}.')\n    else:\n        indexgrid = np.meshgrid(np.arange(nc), np.arange(nr))\n        X, Y = [np.ravel(a) for a in indexgrid]\n    # Size validation for U, V, C is left to the set_UVC method.\n    return X, Y, U, V, C",
        "begin_line": 393,
        "end_line": 443,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.quiver.Quiver.__init__#473",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Quiver",
        "signature": "lib.matplotlib.quiver.Quiver.__init__(self, ax, *args, scale=None, headwidth=3, headlength=5, headaxislength=4.5, minshaft=1, minlength=1, units='width', scale_units=None, angles='uv', width=None, color='k', pivot='tail', **kw)",
        "snippet": "    def __init__(self, ax, *args,\n                 scale=None, headwidth=3, headlength=5, headaxislength=4.5,\n                 minshaft=1, minlength=1, units='width', scale_units=None,\n                 angles='uv', width=None, color='k', pivot='tail', **kw):\n        \"\"\"\n        The constructor takes one required argument, an Axes\n        instance, followed by the args and kwargs described\n        by the following pyplot interface documentation:\n        %s\n        \"\"\"\n        self.ax = ax\n        X, Y, U, V, C = _parse_args(*args, caller_name='quiver()')\n        self.X = X\n        self.Y = Y\n        self.XY = np.column_stack((X, Y))\n        self.N = len(X)\n        self.scale = scale\n        self.headwidth = headwidth\n        self.headlength = float(headlength)\n        self.headaxislength = headaxislength\n        self.minshaft = minshaft\n        self.minlength = minlength\n        self.units = units\n        self.scale_units = scale_units\n        self.angles = angles\n        self.width = width\n\n        if pivot.lower() == 'mid':\n            pivot = 'middle'\n        self.pivot = pivot.lower()\n        cbook._check_in_list(self._PIVOT_VALS, pivot=self.pivot)\n\n        self.transform = kw.pop('transform', ax.transData)\n        kw.setdefault('facecolors', color)\n        kw.setdefault('linewidths', (0,))\n        mcollections.PolyCollection.__init__(self, [], offsets=self.XY,\n                                             transOffset=self.transform,\n                                             closed=False,\n                                             **kw)\n        self.polykw = kw\n        self.set_UVC(U, V, C)\n        self._initialized = False\n\n        # try to prevent closure over the real self\n        weak_self = weakref.ref(self)\n\n        def on_dpi_change(fig):\n            self_weakref = weak_self()\n            if self_weakref is not None:\n                # vertices depend on width, span which in turn depend on dpi\n                self_weakref._new_UV = True\n                # simple brute force update works because _init is called at\n                # the start of draw.\n                self_weakref._initialized = False\n\n        self._cid = self.ax.figure.callbacks.connect('dpi_changed',\n                                                     on_dpi_change)",
        "begin_line": 473,
        "end_line": 529,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.quiver.Quiver._init#541",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Quiver",
        "signature": "lib.matplotlib.quiver.Quiver._init(self)",
        "snippet": "    def _init(self):\n        \"\"\"\n        Initialization delayed until first draw;\n        allow time for axes setup.\n        \"\"\"\n        # It seems that there are not enough event notifications\n        # available to have this work on an as-needed basis at present.\n        if True:  # not self._initialized:\n            trans = self._set_transform()\n            ax = self.ax\n            self.span = trans.inverted().transform_bbox(ax.bbox).width\n            if self.width is None:\n                sn = np.clip(math.sqrt(self.N), 8, 25)\n                self.width = 0.06 * self.span / sn\n\n            # _make_verts sets self.scale if not already specified\n            if not self._initialized and self.scale is None:\n                self._make_verts(self.U, self.V, self.angles)\n\n            self._initialized = True",
        "begin_line": 541,
        "end_line": 560,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.quiver.Quiver.get_datalim#562",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Quiver",
        "signature": "lib.matplotlib.quiver.Quiver.get_datalim(self, transData)",
        "snippet": "    def get_datalim(self, transData):\n        trans = self.get_transform()\n        transOffset = self.get_offset_transform()\n        full_transform = (trans - transData) + (transOffset - transData)\n        XY = full_transform.transform(self.XY)\n        bbox = transforms.Bbox.null()\n        bbox.update_from_data_xy(XY, ignore=True)\n        return bbox",
        "begin_line": 562,
        "end_line": 569,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.quiver.Quiver.draw#572",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Quiver",
        "signature": "lib.matplotlib.quiver.Quiver.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        self._init()\n        verts = self._make_verts(self.U, self.V, self.angles)\n        self.set_verts(verts, closed=False)\n        self._new_UV = False\n        mcollections.PolyCollection.draw(self, renderer)\n        self.stale = False",
        "begin_line": 572,
        "end_line": 578,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.quiver.Quiver.set_UVC#580",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Quiver",
        "signature": "lib.matplotlib.quiver.Quiver.set_UVC(self, U, V, C=None)",
        "snippet": "    def set_UVC(self, U, V, C=None):\n        # We need to ensure we have a copy, not a reference\n        # to an array that might change before draw().\n        U = ma.masked_invalid(U, copy=True).ravel()\n        V = ma.masked_invalid(V, copy=True).ravel()\n        if C is not None:\n            C = ma.masked_invalid(C, copy=True).ravel()\n        for name, var in zip(('U', 'V', 'C'), (U, V, C)):\n            if not (var is None or var.size == self.N or var.size == 1):\n                raise ValueError(f'Argument {name} has a size {var.size}'\n                                 f' which does not match {self.N},'\n                                 ' the number of arrow positions')\n\n        mask = ma.mask_or(U.mask, V.mask, copy=False, shrink=True)\n        if C is not None:\n            mask = ma.mask_or(mask, C.mask, copy=False, shrink=True)\n            if mask is ma.nomask:\n                C = C.filled()\n            else:\n                C = ma.array(C, mask=mask, copy=False)\n        self.U = U.filled(1)\n        self.V = V.filled(1)\n        self.Umask = mask\n        if C is not None:\n            self.set_array(C)\n        self._new_UV = True\n        self.stale = True",
        "begin_line": 580,
        "end_line": 606,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.quiver.Quiver._dots_per_unit#608",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Quiver",
        "signature": "lib.matplotlib.quiver.Quiver._dots_per_unit(self, units)",
        "snippet": "    def _dots_per_unit(self, units):\n        \"\"\"\n        Return a scale factor for converting from units to pixels\n        \"\"\"\n        ax = self.ax\n        if units in ('x', 'y', 'xy'):\n            if units == 'x':\n                dx0 = ax.viewLim.width\n                dx1 = ax.bbox.width\n            elif units == 'y':\n                dx0 = ax.viewLim.height\n                dx1 = ax.bbox.height\n            else:  # 'xy' is assumed\n                dxx0 = ax.viewLim.width\n                dxx1 = ax.bbox.width\n                dyy0 = ax.viewLim.height\n                dyy1 = ax.bbox.height\n                dx1 = np.hypot(dxx1, dyy1)\n                dx0 = np.hypot(dxx0, dyy0)\n            dx = dx1 / dx0\n        else:\n            if units == 'width':\n                dx = ax.bbox.width\n            elif units == 'height':\n                dx = ax.bbox.height\n            elif units == 'dots':\n                dx = 1.0\n            elif units == 'inches':\n                dx = ax.figure.dpi\n            else:\n                raise ValueError('unrecognized units')\n        return dx",
        "begin_line": 608,
        "end_line": 639,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.quiver.Barbs.__init__#939",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Barbs",
        "signature": "lib.matplotlib.quiver.Barbs.__init__(self, ax, *args, pivot='tip', length=7, barbcolor=None, flagcolor=None, sizes=None, fill_empty=False, barb_increments=None, rounding=True, flip_barb=False, **kw)",
        "snippet": "    def __init__(self, ax, *args,\n                 pivot='tip', length=7, barbcolor=None, flagcolor=None,\n                 sizes=None, fill_empty=False, barb_increments=None,\n                 rounding=True, flip_barb=False, **kw):\n        \"\"\"\n        The constructor takes one required argument, an Axes\n        instance, followed by the args and kwargs described\n        by the following pyplot interface documentation:\n        %(barbs_doc)s\n        \"\"\"\n        self.sizes = sizes or dict()\n        self.fill_empty = fill_empty\n        self.barb_increments = barb_increments or dict()\n        self.rounding = rounding\n        self.flip = np.atleast_1d(flip_barb)\n        transform = kw.pop('transform', ax.transData)\n        self._pivot = pivot\n        self._length = length\n        barbcolor = barbcolor\n        flagcolor = flagcolor\n\n        # Flagcolor and barbcolor provide convenience parameters for\n        # setting the facecolor and edgecolor, respectively, of the barb\n        # polygon.  We also work here to make the flag the same color as the\n        # rest of the barb by default\n\n        if None in (barbcolor, flagcolor):\n            kw['edgecolors'] = 'face'\n            if flagcolor:\n                kw['facecolors'] = flagcolor\n            elif barbcolor:\n                kw['facecolors'] = barbcolor\n            else:\n                # Set to facecolor passed in or default to black\n                kw.setdefault('facecolors', 'k')\n        else:\n            kw['edgecolors'] = barbcolor\n            kw['facecolors'] = flagcolor\n\n        # Explicitly set a line width if we're not given one, otherwise\n        # polygons are not outlined and we get no barbs\n        if 'linewidth' not in kw and 'lw' not in kw:\n            kw['linewidth'] = 1\n\n        # Parse out the data arrays from the various configurations supported\n        x, y, u, v, c = _parse_args(*args, caller_name='barbs()')\n        self.x = x\n        self.y = y\n        xy = np.column_stack((x, y))\n\n        # Make a collection\n        barb_size = self._length ** 2 / 4  # Empirically determined\n        mcollections.PolyCollection.__init__(self, [], (barb_size,),\n                                             offsets=xy,\n                                             transOffset=transform, **kw)\n        self.set_transform(transforms.IdentityTransform())\n\n        self.set_UVC(u, v, c)",
        "begin_line": 939,
        "end_line": 996,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.quiver.Barbs._make_barbs#1030",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Barbs",
        "signature": "lib.matplotlib.quiver.Barbs._make_barbs(self, u, v, nflags, nbarbs, half_barb, empty_flag, length, pivot, sizes, fill_empty, flip)",
        "snippet": "    def _make_barbs(self, u, v, nflags, nbarbs, half_barb, empty_flag, length,\n                    pivot, sizes, fill_empty, flip):\n        \"\"\"\n        This function actually creates the wind barbs.  *u* and *v*\n        are components of the vector in the *x* and *y* directions,\n        respectively.\n\n        *nflags*, *nbarbs*, and *half_barb*, empty_flag* are,\n        *respectively, the number of flags, number of barbs, flag for\n        *half a barb, and flag for empty barb, ostensibly obtained\n        *from :meth:`_find_tails`.\n\n        *length* is the length of the barb staff in points.\n\n        *pivot* specifies the point on the barb around which the\n        entire barb should be rotated.  Right now, valid options are\n        'tip' and 'middle'. Can also be a number, which shifts the start\n        of the barb that many points from the origin.\n\n        *sizes* is a dictionary of coefficients specifying the ratio\n        of a given feature to the length of the barb. These features\n        include:\n\n            - *spacing*: space between features (flags, full/half\n               barbs)\n\n            - *height*: distance from shaft of top of a flag or full\n               barb\n\n            - *width* - width of a flag, twice the width of a full barb\n\n            - *emptybarb* - radius of the circle used for low\n               magnitudes\n\n        *fill_empty* specifies whether the circle representing an\n        empty barb should be filled or not (this changes the drawing\n        of the polygon).\n\n        *flip* is a flag indicating whether the features should be flipped to\n        the other side of the barb (useful for winds in the southern\n        hemisphere).\n\n        This function returns list of arrays of vertices, defining a polygon\n        for each of the wind barbs.  These polygons have been rotated to\n        properly align with the vector direction.\n        \"\"\"\n\n        # These control the spacing and size of barb elements relative to the\n        # length of the shaft\n        spacing = length * sizes.get('spacing', 0.125)\n        full_height = length * sizes.get('height', 0.4)\n        full_width = length * sizes.get('width', 0.25)\n        empty_rad = length * sizes.get('emptybarb', 0.15)\n\n        # Controls y point where to pivot the barb.\n        pivot_points = dict(tip=0.0, middle=-length / 2.)\n\n        endx = 0.0\n        try:\n            endy = float(pivot)\n        except ValueError:\n            endy = pivot_points[pivot.lower()]\n\n        # Get the appropriate angle for the vector components.  The offset is\n        # due to the way the barb is initially drawn, going down the y-axis.\n        # This makes sense in a meteorological mode of thinking since there 0\n        # degrees corresponds to north (the y-axis traditionally)\n        angles = -(ma.arctan2(v, u) + np.pi / 2)\n\n        # Used for low magnitude.  We just get the vertices, so if we make it\n        # out here, it can be reused.  The center set here should put the\n        # center of the circle at the location(offset), rather than at the\n        # same point as the barb pivot; this seems more sensible.\n        circ = CirclePolygon((0, 0), radius=empty_rad).get_verts()\n        if fill_empty:\n            empty_barb = circ\n        else:\n            # If we don't want the empty one filled, we make a degenerate\n            # polygon that wraps back over itself\n            empty_barb = np.concatenate((circ, circ[::-1]))\n\n        barb_list = []\n        for index, angle in np.ndenumerate(angles):\n            # If the vector magnitude is too weak to draw anything, plot an\n            # empty circle instead\n            if empty_flag[index]:\n                # We can skip the transform since the circle has no preferred\n                # orientation\n                barb_list.append(empty_barb)\n                continue\n\n            poly_verts = [(endx, endy)]\n            offset = length\n\n            # Handle if this barb should be flipped\n            barb_height = -full_height if flip[index] else full_height\n\n            # Add vertices for each flag\n            for i in range(nflags[index]):\n                # The spacing that works for the barbs is a little to much for\n                # the flags, but this only occurs when we have more than 1\n                # flag.\n                if offset != length:\n                    offset += spacing / 2.\n                poly_verts.extend(\n                    [[endx, endy + offset],\n                     [endx + barb_height, endy - full_width / 2 + offset],\n                     [endx, endy - full_width + offset]])\n\n                offset -= full_width + spacing\n\n            # Add vertices for each barb.  These really are lines, but works\n            # great adding 3 vertices that basically pull the polygon out and\n            # back down the line\n            for i in range(nbarbs[index]):\n                poly_verts.extend(\n                    [(endx, endy + offset),\n                     (endx + barb_height, endy + offset + full_width / 2),\n                     (endx, endy + offset)])\n\n                offset -= spacing\n\n            # Add the vertices for half a barb, if needed\n            if half_barb[index]:\n                # If the half barb is the first on the staff, traditionally it\n                # is offset from the end to make it easy to distinguish from a\n                # barb with a full one\n                if offset == length:\n                    poly_verts.append((endx, endy + offset))\n                    offset -= 1.5 * spacing\n                poly_verts.extend(\n                    [(endx, endy + offset),\n                     (endx + barb_height / 2, endy + offset + full_width / 4),\n                     (endx, endy + offset)])\n\n            # Rotate the barb according the angle. Making the barb first and\n            # then rotating it made the math for drawing the barb really easy.\n            # Also, the transform framework makes doing the rotation simple.\n            poly_verts = transforms.Affine2D().rotate(-angle).transform(\n                poly_verts)\n            barb_list.append(poly_verts)\n\n        return barb_list",
        "begin_line": 1030,
        "end_line": 1172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.quiver.Barbs.set_UVC#1174",
        "src_path": "lib/matplotlib/quiver.py",
        "class_name": "lib.matplotlib.quiver.Barbs",
        "signature": "lib.matplotlib.quiver.Barbs.set_UVC(self, U, V, C=None)",
        "snippet": "    def set_UVC(self, U, V, C=None):\n        self.u = ma.masked_invalid(U, copy=False).ravel()\n        self.v = ma.masked_invalid(V, copy=False).ravel()\n\n        # Flip needs to have the same number of entries as everything else.\n        # Use broadcast_to to avoid a bloated array of identical values.\n        # (can't rely on actual broadcasting)\n        if len(self.flip) == 1:\n            flip = np.broadcast_to(self.flip, self.u.shape)\n        else:\n            flip = self.flip\n\n        if C is not None:\n            c = ma.masked_invalid(C, copy=False).ravel()\n            x, y, u, v, c, flip = cbook.delete_masked_points(\n                self.x.ravel(), self.y.ravel(), self.u, self.v, c,\n                flip.ravel())\n            _check_consistent_shapes(x, y, u, v, c, flip)\n        else:\n            x, y, u, v, flip = cbook.delete_masked_points(\n                self.x.ravel(), self.y.ravel(), self.u, self.v, flip.ravel())\n            _check_consistent_shapes(x, y, u, v, flip)\n\n        magnitude = np.hypot(u, v)\n        flags, barbs, halves, empty = self._find_tails(magnitude,\n                                                       self.rounding,\n                                                       **self.barb_increments)\n\n        # Get the vertices for each of the barbs\n\n        plot_barbs = self._make_barbs(u, v, flags, barbs, halves, empty,\n                                      self._length, self._pivot, self.sizes,\n                                      self.fill_empty, flip)\n        self.set_verts(plot_barbs)\n\n        # Set the color array\n        if C is not None:\n            self.set_array(c)\n\n        # Update the offsets in case the masked data changed\n        xy = np.column_stack((x, y))\n        self._offsets = xy\n        self.stale = True",
        "begin_line": 1174,
        "end_line": 1216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure._stale_figure_callback#41",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure",
        "signature": "lib.matplotlib.figure._stale_figure_callback(self, val)",
        "snippet": "def _stale_figure_callback(self, val):\n    if self.figure:\n        self.figure.stale = val",
        "begin_line": 41,
        "end_line": 43,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018083182640144665,
            "pseudo_dstar_susp": 0.00684931506849315,
            "pseudo_tarantula_susp": 0.00035561877667140827,
            "pseudo_op2_susp": 0.00684931506849315,
            "pseudo_barinel_susp": 0.00035561877667140827
        }
    },
    {
        "name": "lib.matplotlib.figure._AxesStack.__init__#60",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure._AxesStack",
        "signature": "lib.matplotlib.figure._AxesStack.__init__(self)",
        "snippet": "    def __init__(self):\n        super().__init__()\n        self._ind = 0",
        "begin_line": 60,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.123476848090982e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure._AxesStack.as_list#64",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure._AxesStack",
        "signature": "lib.matplotlib.figure._AxesStack.as_list(self)",
        "snippet": "    def as_list(self):\n        \"\"\"\n        Return a list of the Axes instances that have been added to the figure.\n        \"\"\"\n        ia_list = [a for k, a in self._elements]\n        ia_list.sort()\n        return [a for i, a in ia_list]",
        "begin_line": 64,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.946144211844694e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure._AxesStack.get#72",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure._AxesStack",
        "signature": "lib.matplotlib.figure._AxesStack.get(self, key)",
        "snippet": "    def get(self, key):\n        \"\"\"\n        Return the Axes instance that was added with *key*.\n        If it is not present, return *None*.\n        \"\"\"\n        item = dict(self._elements).get(key)\n        if item is None:\n            return None\n        cbook.warn_deprecated(\n            \"2.1\",\n            message=\"Adding an axes using the same arguments as a previous \"\n            \"axes currently reuses the earlier instance.  In a future \"\n            \"version, a new instance will always be created and returned.  \"\n            \"Meanwhile, this warning can be suppressed, and the future \"\n            \"behavior ensured, by passing a unique label to each axes \"\n            \"instance.\")\n        return item[1]",
        "begin_line": 72,
        "end_line": 88,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008130081300813009,
            "pseudo_dstar_susp": 0.0072992700729927005,
            "pseudo_tarantula_susp": 0.0006082725060827251,
            "pseudo_op2_susp": 0.007194244604316547,
            "pseudo_barinel_susp": 0.0006082725060827251
        }
    },
    {
        "name": "lib.matplotlib.figure._AxesStack._entry_from_axes#90",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure._AxesStack",
        "signature": "lib.matplotlib.figure._AxesStack._entry_from_axes(self, e)",
        "snippet": "    def _entry_from_axes(self, e):\n        ind, k = {a: (ind, k) for k, (ind, a) in self._elements}[e]\n        return (k, (ind, e))",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00398406374501992,
            "pseudo_dstar_susp": 0.012345679012345678,
            "pseudo_tarantula_susp": 0.0004100041000410004,
            "pseudo_op2_susp": 0.012345679012345678,
            "pseudo_barinel_susp": 0.0004100041000410004
        }
    },
    {
        "name": "lib.matplotlib.figure._AxesStack.remove#94",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure._AxesStack",
        "signature": "lib.matplotlib.figure._AxesStack.remove(self, a)",
        "snippet": "    def remove(self, a):\n        \"\"\"Remove the axes from the stack.\"\"\"\n        super().remove(self._entry_from_axes(a))",
        "begin_line": 94,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.634170547370028e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure._AxesStack.bubble#98",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure._AxesStack",
        "signature": "lib.matplotlib.figure._AxesStack.bubble(self, a)",
        "snippet": "    def bubble(self, a):\n        \"\"\"\n        Move the given axes, which must already exist in the\n        stack, to the top.\n        \"\"\"\n        return super().bubble(self._entry_from_axes(a))",
        "begin_line": 98,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.043478260869565216,
            "pseudo_dstar_susp": 0.08333333333333333,
            "pseudo_tarantula_susp": 0.0006277463904582549,
            "pseudo_op2_susp": 0.06666666666666667,
            "pseudo_barinel_susp": 0.0006277463904582549
        }
    },
    {
        "name": "lib.matplotlib.figure._AxesStack.add#105",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure._AxesStack",
        "signature": "lib.matplotlib.figure._AxesStack.add(self, key, a)",
        "snippet": "    def add(self, key, a):\n        \"\"\"\n        Add Axes *a*, with key *key*, to the stack, and return the stack.\n\n        If *key* is unhashable, replace it by a unique, arbitrary object.\n\n        If *a* is already on the stack, don't add it again, but\n        return *None*.\n        \"\"\"\n        # All the error checking may be unnecessary; but this method\n        # is called so seldom that the overhead is negligible.\n        cbook._check_isinstance(Axes, a=a)\n        try:\n            hash(key)\n        except TypeError:\n            key = object()\n\n        a_existing = self.get(key)\n        if a_existing is not None:\n            super().remove((key, a_existing))\n            cbook._warn_external(\n                \"key {!r} already existed; Axes is being replaced\".format(key))\n            # I don't think the above should ever happen.\n\n        if a in self:\n            return None\n        self._ind += 1\n        return super().push((key, (self._ind, a)))",
        "begin_line": 105,
        "end_line": 132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008771929824561403,
            "pseudo_dstar_susp": 0.025,
            "pseudo_tarantula_susp": 0.000526592943654555,
            "pseudo_op2_susp": 0.022222222222222223,
            "pseudo_barinel_susp": 0.000526592943654555
        }
    },
    {
        "name": "lib.matplotlib.figure._AxesStack.current_key_axes#134",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure._AxesStack",
        "signature": "lib.matplotlib.figure._AxesStack.current_key_axes(self)",
        "snippet": "    def current_key_axes(self):\n        \"\"\"\n        Return a tuple of ``(key, axes)`` for the active axes.\n\n        If no axes exists on the stack, then returns ``(None, None)``.\n        \"\"\"\n        if not len(self._elements):\n            return self._default, self._default\n        else:\n            key, (index, axes) = self._elements[self._pos]\n            return key, axes",
        "begin_line": 134,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035842293906810036,
            "pseudo_dstar_susp": 0.005208333333333333,
            "pseudo_tarantula_susp": 0.000585480093676815,
            "pseudo_op2_susp": 0.005154639175257732,
            "pseudo_barinel_susp": 0.000585480093676815
        }
    },
    {
        "name": "lib.matplotlib.figure._AxesStack.__call__#146",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure._AxesStack",
        "signature": "lib.matplotlib.figure._AxesStack.__call__(self)",
        "snippet": "    def __call__(self):\n        return self.current_key_axes()[1]",
        "begin_line": 146,
        "end_line": 147,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000724112961622013,
            "pseudo_dstar_susp": 0.0008237232289950577,
            "pseudo_tarantula_susp": 0.00041946308724832214,
            "pseudo_op2_susp": 0.0008237232289950577,
            "pseudo_barinel_susp": 0.00041946308724832214
        }
    },
    {
        "name": "lib.matplotlib.figure.SubplotParams.__init__#162",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.SubplotParams",
        "signature": "lib.matplotlib.figure.SubplotParams.__init__(self, left=None, bottom=None, right=None, top=None, wspace=None, hspace=None)",
        "snippet": "    def __init__(self, left=None, bottom=None, right=None, top=None,\n                 wspace=None, hspace=None):\n        \"\"\"\n        Defaults are given by :rc:`figure.subplot.[name]`.\n\n        Parameters\n        ----------\n        left : float\n            The position of the left edge of the subplots,\n            as a fraction of the figure width.\n        right : float\n            The position of the right edge of the subplots,\n            as a fraction of the figure width.\n        bottom : float\n            The position of the bottom edge of the subplots,\n            as a fraction of the figure height.\n        top : float\n            The position of the top edge of the subplots,\n            as a fraction of the figure height.\n        wspace : float\n            The width of the padding between subplots,\n            as a fraction of the average axes width.\n        hspace : float\n            The height of the padding between subplots,\n            as a fraction of the average axes height.\n        \"\"\"\n        self.validate = True\n        for key in [\"left\", \"bottom\", \"right\", \"top\", \"wspace\", \"hspace\"]:\n            setattr(self, key, mpl.rcParams[f\"figure.subplot.{key}\"])\n        self.update(left, bottom, right, top, wspace, hspace)",
        "begin_line": 162,
        "end_line": 191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0072992700729927005,
            "pseudo_dstar_susp": 0.007194244604316547,
            "pseudo_tarantula_susp": 0.0006013229104028864,
            "pseudo_op2_susp": 0.0070921985815602835,
            "pseudo_barinel_susp": 0.0006013229104028864
        }
    },
    {
        "name": "lib.matplotlib.figure.SubplotParams.update#193",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.SubplotParams",
        "signature": "lib.matplotlib.figure.SubplotParams.update(self, left=None, bottom=None, right=None, top=None, wspace=None, hspace=None)",
        "snippet": "    def update(self, left=None, bottom=None, right=None, top=None,\n               wspace=None, hspace=None):\n        \"\"\"\n        Update the dimensions of the passed parameters. *None* means unchanged.\n        \"\"\"\n        if self.validate:\n            if ((left if left is not None else self.left)\n                    >= (right if right is not None else self.right)):\n                raise ValueError('left cannot be >= right')\n            if ((bottom if bottom is not None else self.bottom)\n                    >= (top if top is not None else self.top)):\n                raise ValueError('bottom cannot be >= top')\n        if left is not None:\n            self.left = left\n        if right is not None:\n            self.right = right\n        if bottom is not None:\n            self.bottom = bottom\n        if top is not None:\n            self.top = top\n        if wspace is not None:\n            self.wspace = wspace\n        if hspace is not None:\n            self.hspace = hspace",
        "begin_line": 193,
        "end_line": 216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.104980424292088e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.__init__#249",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.__init__(self, figsize=None, dpi=None, facecolor=None, edgecolor=None, linewidth=0.0, frameon=None, subplotpars=None, tight_layout=None, constrained_layout=None)",
        "snippet": "    def __init__(self,\n                 figsize=None,\n                 dpi=None,\n                 facecolor=None,\n                 edgecolor=None,\n                 linewidth=0.0,\n                 frameon=None,\n                 subplotpars=None,  # rc figure.subplot.*\n                 tight_layout=None,  # rc figure.autolayout\n                 constrained_layout=None,  # rc figure.constrained_layout.use\n                 ):\n        \"\"\"\n        Parameters\n        ----------\n        figsize : 2-tuple of floats, default: :rc:`figure.figsize`\n            Figure dimension ``(width, height)`` in inches.\n\n        dpi : float, default: :rc:`figure.dpi`\n            Dots per inch.\n\n        facecolor : default: :rc:`figure.facecolor`\n            The figure patch facecolor.\n\n        edgecolor : default: :rc:`figure.edgecolor`\n            The figure patch edge color.\n\n        linewidth : float\n            The linewidth of the frame (i.e. the edge linewidth of the figure\n            patch).\n\n        frameon : bool, default: :rc:`figure.frameon`\n            If ``False``, suppress drawing the figure background patch.\n\n        subplotpars : `SubplotParams`\n            Subplot parameters. If not given, the default subplot\n            parameters :rc:`figure.subplot.*` are used.\n\n        tight_layout : bool or dict, default: :rc:`figure.autolayout`\n            If ``False`` use *subplotpars*. If ``True`` adjust subplot\n            parameters using `.tight_layout` with default padding.\n            When providing a dict containing the keys ``pad``, ``w_pad``,\n            ``h_pad``, and ``rect``, the default `.tight_layout` paddings\n            will be overridden.\n\n        constrained_layout : bool, default: :rc:`figure.constrained_layout.use`\n            If ``True`` use constrained layout to adjust positioning of plot\n            elements.  Like ``tight_layout``, but designed to be more\n            flexible.  See\n            :doc:`/tutorials/intermediate/constrainedlayout_guide`\n            for examples.  (Note: does not work with `add_subplot` or\n            `~.pyplot.subplot2grid`.)\n        \"\"\"\n        super().__init__()\n        # remove the non-figure artist _axes property\n        # as it makes no sense for a figure to be _in_ an axes\n        # this is used by the property methods in the artist base class\n        # which are over-ridden in this class\n        del self._axes\n        self.callbacks = cbook.CallbackRegistry()\n\n        if figsize is None:\n            figsize = mpl.rcParams['figure.figsize']\n        if dpi is None:\n            dpi = mpl.rcParams['figure.dpi']\n        if facecolor is None:\n            facecolor = mpl.rcParams['figure.facecolor']\n        if edgecolor is None:\n            edgecolor = mpl.rcParams['figure.edgecolor']\n        if frameon is None:\n            frameon = mpl.rcParams['figure.frameon']\n\n        if not np.isfinite(figsize).all() or (np.array(figsize) <= 0).any():\n            raise ValueError('figure size must be positive finite not '\n                             f'{figsize}')\n        self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)\n\n        self.dpi_scale_trans = Affine2D().scale(dpi)\n        # do not use property as it will trigger\n        self._dpi = dpi\n        self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)\n\n        self.transFigure = BboxTransformTo(self.bbox)\n\n        self.patch = Rectangle(\n            xy=(0, 0), width=1, height=1, visible=frameon,\n            facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,\n            # Don't let the figure patch influence bbox calculation.\n            in_layout=False)\n        self._set_artist_props(self.patch)\n        self.patch.set_antialiased(False)\n\n        FigureCanvasBase(self)  # Set self.canvas.\n        self._suptitle = None\n\n        if subplotpars is None:\n            subplotpars = SubplotParams()\n\n        self.subplotpars = subplotpars\n        # constrained_layout:\n        self._layoutbox = None\n        # set in set_constrained_layout_pads()\n        self.set_constrained_layout(constrained_layout)\n\n        self.set_tight_layout(tight_layout)\n\n        self._axstack = _AxesStack()  # track all figure axes and current axes\n        self.clf()\n        self._cachedRenderer = None\n\n        # groupers to keep track of x and y labels we want to align.\n        # see self.align_xlabels and self.align_ylabels and\n        # axis._get_tick_boxes_siblings\n        self._align_xlabel_grp = cbook.Grouper()\n        self._align_ylabel_grp = cbook.Grouper()\n\n        # list of child gridspecs for this figure\n        self._gridspecs = []",
        "begin_line": 249,
        "end_line": 365,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024271844660194173,
            "pseudo_dstar_susp": 0.0010940919037199124,
            "pseudo_tarantula_susp": 0.0008223684210526315,
            "pseudo_op2_susp": 0.0010940919037199124,
            "pseudo_barinel_susp": 0.0008223684210526315
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_axes#413",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_axes(self)",
        "snippet": "    def get_axes(self):\n        \"\"\"\n        Return a list of axes in the Figure. You can access and modify the\n        axes in the Figure through this list.\n\n        Do not modify the list itself. Instead, use `~Figure.add_axes`,\n        `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an axes.\n\n        Note: This is equivalent to the property `~.Figure.axes`.\n        \"\"\"\n        return self._axstack.as_list()",
        "begin_line": 413,
        "end_line": 423,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.999000099990002e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._set_dpi#436",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._set_dpi(self, dpi, forward=True)",
        "snippet": "    def _set_dpi(self, dpi, forward=True):\n        \"\"\"\n        Parameters\n        ----------\n        dpi : float\n\n        forward : bool\n            Passed on to `~.Figure.set_size_inches`\n        \"\"\"\n        self._dpi = dpi\n        self.dpi_scale_trans.clear().scale(dpi)\n        w, h = self.get_size_inches()\n        self.set_size_inches(w, h, forward=forward)\n        self.callbacks.process('dpi_changed', self)",
        "begin_line": 436,
        "end_line": 449,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.283851700779372e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_tight_layout#453",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_tight_layout(self)",
        "snippet": "    def get_tight_layout(self):\n        \"\"\"Return whether `.tight_layout` is called when drawing.\"\"\"\n        return self._tight",
        "begin_line": 453,
        "end_line": 455,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.530162965786715e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.set_tight_layout#457",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.set_tight_layout(self, tight)",
        "snippet": "    def set_tight_layout(self, tight):\n        \"\"\"\n        Set whether and how `.tight_layout` is called when drawing.\n\n        Parameters\n        ----------\n        tight : bool or dict with keys \"pad\", \"w_pad\", \"h_pad\", \"rect\" or None\n            If a bool, sets whether to call `.tight_layout` upon drawing.\n            If ``None``, use the ``figure.autolayout`` rcparam instead.\n            If a dict, pass it as kwargs to `.tight_layout`, overriding the\n            default paddings.\n        \"\"\"\n        if tight is None:\n            tight = mpl.rcParams['figure.autolayout']\n        self._tight = bool(tight)\n        self._tight_parameters = tight if isinstance(tight, dict) else {}\n        self.stale = True",
        "begin_line": 457,
        "end_line": 473,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006067961165048543,
            "pseudo_dstar_susp": 0.000794912559618442,
            "pseudo_tarantula_susp": 0.0003694126339120798,
            "pseudo_op2_susp": 0.000794912559618442,
            "pseudo_barinel_susp": 0.0003694126339120798
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_constrained_layout#475",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_constrained_layout(self)",
        "snippet": "    def get_constrained_layout(self):\n        \"\"\"\n        Return whether constrained layout is being used.\n\n        See :doc:`/tutorials/intermediate/constrainedlayout_guide`.\n        \"\"\"\n        return self._constrained",
        "begin_line": 475,
        "end_line": 481,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006150061500615006,
            "pseudo_dstar_susp": 0.0008045052292839903,
            "pseudo_tarantula_susp": 0.0007178750897343862,
            "pseudo_op2_susp": 0.0008045052292839903,
            "pseudo_barinel_susp": 0.0007178750897343862
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.set_constrained_layout#483",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.set_constrained_layout(self, constrained)",
        "snippet": "    def set_constrained_layout(self, constrained):\n        \"\"\"\n        Set whether ``constrained_layout`` is used upon drawing. If None,\n        :rc:`figure.constrained_layout.use` value will be used.\n\n        When providing a dict containing the keys `w_pad`, `h_pad`\n        the default ``constrained_layout`` paddings will be\n        overridden.  These pads are in inches and default to 3.0/72.0.\n        ``w_pad`` is the width padding and ``h_pad`` is the height padding.\n\n        See :doc:`/tutorials/intermediate/constrainedlayout_guide`.\n\n        Parameters\n        ----------\n        constrained : bool or dict or None\n        \"\"\"\n        self._constrained_layout_pads = dict()\n        self._constrained_layout_pads['w_pad'] = None\n        self._constrained_layout_pads['h_pad'] = None\n        self._constrained_layout_pads['wspace'] = None\n        self._constrained_layout_pads['hspace'] = None\n        if constrained is None:\n            constrained = mpl.rcParams['figure.constrained_layout.use']\n        self._constrained = bool(constrained)\n        if isinstance(constrained, dict):\n            self.set_constrained_layout_pads(**constrained)\n        else:\n            self.set_constrained_layout_pads()\n\n        self.stale = True",
        "begin_line": 483,
        "end_line": 512,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006583278472679394,
            "pseudo_dstar_susp": 0.00129366106080207,
            "pseudo_tarantula_susp": 0.0008077544426494346,
            "pseudo_op2_susp": 0.00129366106080207,
            "pseudo_barinel_susp": 0.0008077544426494346
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.set_constrained_layout_pads#514",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.set_constrained_layout_pads(self, **kwargs)",
        "snippet": "    def set_constrained_layout_pads(self, **kwargs):\n        \"\"\"\n        Set padding for ``constrained_layout``.  Note the kwargs can be passed\n        as a dictionary ``fig.set_constrained_layout(**paddict)``.\n\n        See :doc:`/tutorials/intermediate/constrainedlayout_guide`.\n\n        Parameters\n        ----------\n        w_pad : scalar\n            Width padding in inches.  This is the pad around axes\n            and is meant to make sure there is enough room for fonts to\n            look good.  Defaults to 3 pts = 0.04167 inches\n\n        h_pad : scalar\n            Height padding in inches. Defaults to 3 pts.\n\n        wspace : scalar\n            Width padding between subplots, expressed as a fraction of the\n            subplot width.  The total padding ends up being w_pad + wspace.\n\n        hspace : scalar\n            Height padding between subplots, expressed as a fraction of the\n            subplot width. The total padding ends up being h_pad + hspace.\n\n        \"\"\"\n\n        todo = ['w_pad', 'h_pad', 'wspace', 'hspace']\n        for td in todo:\n            if td in kwargs and kwargs[td] is not None:\n                self._constrained_layout_pads[td] = kwargs[td]\n            else:\n                self._constrained_layout_pads[td] = (\n                    mpl.rcParams['figure.constrained_layout.' + td])",
        "begin_line": 514,
        "end_line": 547,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014104372355430183,
            "pseudo_dstar_susp": 0.0009233610341643582,
            "pseudo_tarantula_susp": 0.000612369871402327,
            "pseudo_op2_susp": 0.0009233610341643582,
            "pseudo_barinel_susp": 0.000612369871402327
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_constrained_layout_pads#549",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_constrained_layout_pads(self, relative=False)",
        "snippet": "    def get_constrained_layout_pads(self, relative=False):\n        \"\"\"\n        Get padding for ``constrained_layout``.\n\n        Returns a list of ``w_pad, h_pad`` in inches and\n        ``wspace`` and ``hspace`` as fractions of the subplot.\n\n        See :doc:`/tutorials/intermediate/constrainedlayout_guide`.\n\n        Parameters\n        ----------\n        relative : bool\n            If `True`, then convert from inches to figure relative.\n        \"\"\"\n        w_pad = self._constrained_layout_pads['w_pad']\n        h_pad = self._constrained_layout_pads['h_pad']\n        wspace = self._constrained_layout_pads['wspace']\n        hspace = self._constrained_layout_pads['hspace']\n\n        if relative and (w_pad is not None or h_pad is not None):\n            renderer0 = layoutbox.get_renderer(self)\n            dpi = renderer0.dpi\n            w_pad = w_pad * dpi / renderer0.width\n            h_pad = h_pad * dpi / renderer0.height\n\n        return w_pad, h_pad, wspace, hspace",
        "begin_line": 549,
        "end_line": 574,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.autofmt_xdate#576",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.autofmt_xdate(self, bottom=0.2, rotation=30, ha='right', which='major')",
        "snippet": "    def autofmt_xdate(\n            self, bottom=0.2, rotation=30, ha='right', which='major'):\n        \"\"\"\n        Date ticklabels often overlap, so it is useful to rotate them\n        and right align them.  Also, a common use case is a number of\n        subplots with shared xaxes where the x-axis is date data.  The\n        ticklabels are often long, and it helps to rotate them on the\n        bottom subplot and turn them off on other subplots, as well as\n        turn off xlabels.\n\n        Parameters\n        ----------\n        bottom : scalar\n            The bottom of the subplots for `subplots_adjust`.\n        rotation : angle in degrees\n            The rotation of the xtick labels.\n        ha : str\n            The horizontal alignment of the xticklabels.\n        which : {'major', 'minor', 'both'}, default: 'major'\n            Selects which ticklabels to rotate.\n        \"\"\"\n        if which is None:\n            cbook.warn_deprecated(\n                \"3.3\", message=\"Support for passing which=None to mean \"\n                \"which='major' is deprecated since %(since)s and will be \"\n                \"removed %(removal)s.\")\n        allsubplots = all(hasattr(ax, 'is_last_row') for ax in self.axes)\n        if len(self.axes) == 1:\n            for label in self.axes[0].get_xticklabels(which=which):\n                label.set_ha(ha)\n                label.set_rotation(rotation)\n        else:\n            if allsubplots:\n                for ax in self.get_axes():\n                    if ax.is_last_row():\n                        for label in ax.get_xticklabels(which=which):\n                            label.set_ha(ha)\n                            label.set_rotation(rotation)\n                    else:\n                        for label in ax.get_xticklabels(which=which):\n                            label.set_visible(False)\n                        ax.set_xlabel('')\n\n        if allsubplots:\n            self.subplots_adjust(bottom=bottom)\n        self.stale = True",
        "begin_line": 576,
        "end_line": 621,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_children#623",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_children(self)",
        "snippet": "    def get_children(self):\n        \"\"\"Get a list of artists contained in the figure.\"\"\"\n        return [self.patch,\n                *self.artists,\n                *self.axes,\n                *self.lines,\n                *self.patches,\n                *self.texts,\n                *self.images,\n                *self.legends]",
        "begin_line": 623,
        "end_line": 632,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00027078256160303275,
            "pseudo_dstar_susp": 0.00027078256160303275,
            "pseudo_tarantula_susp": 0.00027078256160303275,
            "pseudo_op2_susp": 0.00027078256160303275,
            "pseudo_barinel_susp": 0.00027078256160303275
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.suptitle#654",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.suptitle(self, t, **kwargs)",
        "snippet": "    def suptitle(self, t, **kwargs):\n        \"\"\"\n        Add a centered title to the figure.\n\n        Parameters\n        ----------\n        t : str\n            The title text.\n\n        x : float, default 0.5\n            The x location of the text in figure coordinates.\n\n        y : float, default 0.98\n            The y location of the text in figure coordinates.\n\n        horizontalalignment, ha : {'center', 'left', right'}, default: 'center'\n            The horizontal alignment of the text relative to (*x*, *y*).\n\n        verticalalignment, va : {'top', 'center', 'bottom', 'baseline'}, \\\ndefault: 'top'\n            The vertical alignment of the text relative to (*x*, *y*).\n\n        fontsize, size : default: :rc:`figure.titlesize`\n            The font size of the text. See `.Text.set_size` for possible\n            values.\n\n        fontweight, weight : default: :rc:`figure.titleweight`\n            The font weight of the text. See `.Text.set_weight` for possible\n            values.\n\n        Returns\n        -------\n        text\n            The `.Text` instance of the title.\n\n        Other Parameters\n        ----------------\n        fontproperties : None or dict, optional\n            A dict of font properties. If *fontproperties* is given the\n            default values for font size and weight are taken from the\n            `.FontProperties` defaults. :rc:`figure.titlesize` and\n            :rc:`figure.titleweight` are ignored in this case.\n\n        **kwargs\n            Additional kwargs are `matplotlib.text.Text` properties.\n\n        Examples\n        --------\n        >>> fig.suptitle('This is the figure title', fontsize=12)\n        \"\"\"\n        manual_position = ('x' in kwargs or 'y' in kwargs)\n\n        x = kwargs.pop('x', 0.5)\n        y = kwargs.pop('y', 0.98)\n\n        if 'horizontalalignment' not in kwargs and 'ha' not in kwargs:\n            kwargs['horizontalalignment'] = 'center'\n        if 'verticalalignment' not in kwargs and 'va' not in kwargs:\n            kwargs['verticalalignment'] = 'top'\n\n        if 'fontproperties' not in kwargs:\n            if 'fontsize' not in kwargs and 'size' not in kwargs:\n                kwargs['size'] = mpl.rcParams['figure.titlesize']\n            if 'fontweight' not in kwargs and 'weight' not in kwargs:\n                kwargs['weight'] = mpl.rcParams['figure.titleweight']\n\n        sup = self.text(x, y, t, **kwargs)\n        if self._suptitle is not None:\n            self._suptitle.set_text(t)\n            self._suptitle.set_position((x, y))\n            self._suptitle.update_from(sup)\n            sup.remove()\n        else:\n            self._suptitle = sup\n            self._suptitle._layoutbox = None\n            if self._layoutbox is not None and not manual_position:\n                w_pad, h_pad, wspace, hspace =  \\\n                        self.get_constrained_layout_pads(relative=True)\n                figlb = self._layoutbox\n                self._suptitle._layoutbox = layoutbox.LayoutBox(\n                        parent=figlb, artist=self._suptitle,\n                        name=figlb.name+'.suptitle')\n                # stack the suptitle on top of all the children.\n                # Some day this should be on top of all the children in the\n                # gridspec only.\n                for child in figlb.children:\n                    if child is not self._suptitle._layoutbox:\n                        layoutbox.vstack([self._suptitle._layoutbox,\n                                          child],\n                                         padding=h_pad*2., strength='required')\n        self.stale = True\n        return self._suptitle",
        "begin_line": 654,
        "end_line": 745,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.999000099990002e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.set_canvas#747",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.set_canvas(self, canvas)",
        "snippet": "    def set_canvas(self, canvas):\n        \"\"\"\n        Set the canvas that contains the figure\n\n        Parameters\n        ----------\n        canvas : FigureCanvas\n        \"\"\"\n        self.canvas = canvas",
        "begin_line": 747,
        "end_line": 755,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.28332714444857e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.figimage#757",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None, vmin=None, vmax=None, origin=None, resize=False, **kwargs)",
        "snippet": "    def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,\n                 vmin=None, vmax=None, origin=None, resize=False, **kwargs):\n        \"\"\"\n        Add a non-resampled image to the figure.\n\n        The image is attached to the lower or upper left corner depending on\n        *origin*.\n\n        Parameters\n        ----------\n        X\n            The image data. This is an array of one of the following shapes:\n\n            - MxN: luminance (grayscale) values\n            - MxNx3: RGB values\n            - MxNx4: RGBA values\n\n        xo, yo : int\n            The *x*/*y* image offset in pixels.\n\n        alpha : None or float\n            The alpha blending value.\n\n        norm : `matplotlib.colors.Normalize`\n            A `.Normalize` instance to map the luminance to the\n            interval [0, 1].\n\n        cmap : str or `matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n            The colormap to use.\n\n        vmin, vmax : scalar\n            If *norm* is not given, these values set the data limits for the\n            colormap.\n\n        origin : {'upper', 'lower'}, default: :rc:`image.origin`\n            Indicates where the [0, 0] index of the array is in the upper left\n            or lower left corner of the axes.\n\n        resize : bool\n            If *True*, resize the figure to match the given image size.\n\n        Returns\n        -------\n        `matplotlib.image.FigureImage`\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.\n\n        Notes\n        -----\n        figimage complements the axes image (`~matplotlib.axes.Axes.imshow`)\n        which will be resampled to fit the current axes.  If you want\n        a resampled image to fill the entire figure, you can define an\n        `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].\n\n        Examples\n        --------\n        ::\n\n            f = plt.figure()\n            nx = int(f.get_figwidth() * f.dpi)\n            ny = int(f.get_figheight() * f.dpi)\n            data = np.random.random((ny, nx))\n            f.figimage(data)\n            plt.show()\n        \"\"\"\n        if resize:\n            dpi = self.get_dpi()\n            figsize = [x / dpi for x in (X.shape[1], X.shape[0])]\n            self.set_size_inches(figsize, forward=True)\n\n        im = mimage.FigureImage(self, cmap, norm, xo, yo, origin, **kwargs)\n        im.stale_callback = _stale_figure_callback\n\n        im.set_array(X)\n        im.set_alpha(alpha)\n        if norm is None:\n            im.set_clim(vmin, vmax)\n        self.images.append(im)\n        im._remove_method = self.images.remove\n        self.stale = True\n        return im",
        "begin_line": 757,
        "end_line": 840,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.set_size_inches#842",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.set_size_inches(self, w, h=None, forward=True)",
        "snippet": "    def set_size_inches(self, w, h=None, forward=True):\n        \"\"\"\n        Set the figure size in inches.\n\n        Call signatures::\n\n             fig.set_size_inches(w, h)  # OR\n             fig.set_size_inches((w, h))\n\n        Parameters\n        ----------\n        w : (float, float) or float\n            Width and height in inches (if height not specified as a separate\n            argument) or width.\n        h : float\n            Height in inches.\n        forward : bool, default: True\n            If ``True``, the canvas size is automatically updated, e.g.,\n            you can resize the figure window from the shell.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.get_size_inches\n        matplotlib.figure.Figure.set_figwidth\n        matplotlib.figure.Figure.set_figheight\n\n        Notes\n        -----\n        To transform from pixels to inches divide by `Figure.dpi`.\n        \"\"\"\n        if h is None:  # Got called with a single pair as argument.\n            w, h = w\n        size = np.array([w, h])\n        if not np.isfinite(size).all() or (size <= 0).any():\n            raise ValueError(f'figure size must be positive finite not {size}')\n        self.bbox_inches.p1 = size\n        if forward:\n            canvas = getattr(self, 'canvas')\n            if canvas is not None:\n                dpi_ratio = getattr(canvas, '_dpi_ratio', 1)\n                manager = getattr(canvas, 'manager', None)\n                if manager is not None:\n                    manager.resize(*(size * self.dpi / dpi_ratio).astype(int))\n        self.stale = True",
        "begin_line": 842,
        "end_line": 885,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00027731558513588466,
            "pseudo_dstar_susp": 0.00027731558513588466,
            "pseudo_tarantula_susp": 0.0002774694783573807,
            "pseudo_op2_susp": 0.00027731558513588466,
            "pseudo_barinel_susp": 0.0002774694783573807
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_size_inches#887",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_size_inches(self)",
        "snippet": "    def get_size_inches(self):\n        \"\"\"\n        Returns the current size of the figure in inches.\n\n        Returns\n        -------\n        size : ndarray\n           The size (width, height) of the figure in inches.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.set_size_inches\n        matplotlib.figure.Figure.get_figwidth\n        matplotlib.figure.Figure.get_figheight\n\n        Notes\n        -----\n        The size in pixels can be obtained by multiplying with `Figure.dpi`.\n        \"\"\"\n        return np.array(self.bbox_inches.p1)",
        "begin_line": 887,
        "end_line": 906,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_edgecolor#908",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_edgecolor(self)",
        "snippet": "    def get_edgecolor(self):\n        \"\"\"Get the edge color of the Figure rectangle.\"\"\"\n        return self.patch.get_edgecolor()",
        "begin_line": 908,
        "end_line": 910,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00027586206896551725,
            "pseudo_dstar_susp": 0.00027586206896551725,
            "pseudo_tarantula_susp": 0.0002760143527463428,
            "pseudo_op2_susp": 0.00027586206896551725,
            "pseudo_barinel_susp": 0.0002760143527463428
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_facecolor#912",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_facecolor(self)",
        "snippet": "    def get_facecolor(self):\n        \"\"\"Get the face color of the Figure rectangle.\"\"\"\n        return self.patch.get_facecolor()",
        "begin_line": 912,
        "end_line": 914,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.910273545397844e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.set_edgecolor#936",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.set_edgecolor(self, color)",
        "snippet": "    def set_edgecolor(self, color):\n        \"\"\"\n        Set the edge color of the Figure rectangle.\n\n        Parameters\n        ----------\n        color : color\n        \"\"\"\n        self.patch.set_edgecolor(color)",
        "begin_line": 936,
        "end_line": 944,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.set_figheight#984",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.set_figheight(self, val, forward=True)",
        "snippet": "    def set_figheight(self, val, forward=True):\n        \"\"\"\n        Set the height of the figure in inches.\n\n        Parameters\n        ----------\n        val : float\n        forward : bool\n            See `set_size_inches`.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.set_figwidth\n        matplotlib.figure.Figure.set_size_inches\n        \"\"\"\n        self.set_size_inches(self.get_figwidth(), val, forward=forward)",
        "begin_line": 984,
        "end_line": 999,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.add_artist#1016",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.add_artist(self, artist, clip=False)",
        "snippet": "    def add_artist(self, artist, clip=False):\n        \"\"\"\n        Add an `.Artist` to the figure.\n\n        Usually artists are added to axes objects using `.Axes.add_artist`;\n        this method can be used in the rare cases where one needs to add\n        artists directly to the figure instead.\n\n        Parameters\n        ----------\n        artist : `~matplotlib.artist.Artist`\n            The artist to add to the figure. If the added artist has no\n            transform previously set, its transform will be set to\n            ``figure.transFigure``.\n        clip : bool, default: False\n            Whether the added artist should be clipped by the figure patch.\n\n        Returns\n        -------\n        artist : The added `~matplotlib.artist.Artist`\n        \"\"\"\n        artist.set_figure(self)\n        self.artists.append(artist)\n        artist._remove_method = self.artists.remove\n\n        if not artist.is_transform_set():\n            artist.set_transform(self.transFigure)\n\n        if clip:\n            artist.set_clip_path(self.patch)\n\n        self.stale = True\n        return artist",
        "begin_line": 1016,
        "end_line": 1048,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.fixitems#1053",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.fixitems(items)",
        "snippet": "        def fixitems(items):\n            # items may have arrays and lists in them, so convert them\n            # to tuples for the key\n            ret = []\n            for k, v in items:\n                # some objects can define __getitem__ without being\n                # iterable and in those cases the conversion to tuples\n                # will fail. So instead of using the np.iterable(v) function\n                # we simply try and convert to a tuple, and proceed if not.\n                try:\n                    v = tuple(v)\n                except Exception:\n                    pass\n                ret.append((k, v))\n            return tuple(ret)",
        "begin_line": 1053,
        "end_line": 1067,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017482517482517483,
            "pseudo_dstar_susp": 0.0029069767441860465,
            "pseudo_tarantula_susp": 0.001443001443001443,
            "pseudo_op2_susp": 0.0029069767441860465,
            "pseudo_barinel_susp": 0.001443001443001443
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.fixlist#1069",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.fixlist(args)",
        "snippet": "        def fixlist(args):\n            ret = []\n            for a in args:\n                if np.iterable(a):\n                    a = tuple(a)\n                ret.append(a)\n            return tuple(ret)",
        "begin_line": 1069,
        "end_line": 1075,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018050541516245488,
            "pseudo_dstar_susp": 0.00186219739292365,
            "pseudo_tarantula_susp": 0.0007564296520423601,
            "pseudo_op2_susp": 0.00186219739292365,
            "pseudo_barinel_susp": 0.0007564296520423601
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._make_key#1050",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._make_key(self, *args, **kwargs)",
        "snippet": "    def _make_key(self, *args, **kwargs):\n        \"\"\"Make a hashable key out of args and kwargs.\"\"\"\n\n        def fixitems(items):\n            # items may have arrays and lists in them, so convert them\n            # to tuples for the key\n            ret = []\n            for k, v in items:\n                # some objects can define __getitem__ without being\n                # iterable and in those cases the conversion to tuples\n                # will fail. So instead of using the np.iterable(v) function\n                # we simply try and convert to a tuple, and proceed if not.\n                try:\n                    v = tuple(v)\n                except Exception:\n                    pass\n                ret.append((k, v))\n            return tuple(ret)\n\n        def fixlist(args):\n            ret = []\n            for a in args:\n                if np.iterable(a):\n                    a = tuple(a)\n                ret.append(a)\n            return tuple(ret)\n\n        key = fixlist(args), fixitems(kwargs.items())\n        return key",
        "begin_line": 1050,
        "end_line": 1078,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001890359168241966,
            "pseudo_dstar_susp": 0.002967359050445104,
            "pseudo_tarantula_susp": 0.0007097232079489,
            "pseudo_op2_susp": 0.002967359050445104,
            "pseudo_barinel_susp": 0.0007097232079489
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._process_projection_requirements#1080",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._process_projection_requirements(self, *args, polar=False, projection=None, **kwargs)",
        "snippet": "    def _process_projection_requirements(\n            self, *args, polar=False, projection=None, **kwargs):\n        \"\"\"\n        Handle the args/kwargs to add_axes/add_subplot/gca, returning::\n\n            (axes_proj_class, proj_class_kwargs, proj_stack_key)\n\n        which can be used for new axes initialization/identification.\n        \"\"\"\n        if polar:\n            if projection is not None and projection != 'polar':\n                raise ValueError(\n                    \"polar=True, yet projection=%r. \"\n                    \"Only one of these arguments should be supplied.\" %\n                    projection)\n            projection = 'polar'\n\n        if isinstance(projection, str) or projection is None:\n            projection_class = projections.get_projection_class(projection)\n        elif hasattr(projection, '_as_mpl_axes'):\n            projection_class, extra_kwargs = projection._as_mpl_axes()\n            kwargs.update(**extra_kwargs)\n        else:\n            raise TypeError('projection must be a string, None or implement a '\n                            '_as_mpl_axes method. Got %r' % projection)\n\n        # Make the key without projection kwargs, this is used as a unique\n        # lookup for axes instances\n        key = self._make_key(*args, **kwargs)\n\n        return projection_class, kwargs, key",
        "begin_line": 1080,
        "end_line": 1110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001215066828675577,
            "pseudo_dstar_susp": 0.0008976660682226212,
            "pseudo_tarantula_susp": 0.0005717552887364208,
            "pseudo_op2_susp": 0.0008976660682226212,
            "pseudo_barinel_susp": 0.0005717552887364208
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.add_axes#1113",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.add_axes(self, *args, **kwargs)",
        "snippet": "    def add_axes(self, *args, **kwargs):\n        \"\"\"\n        Add an axes to the figure.\n\n        Call signatures::\n\n            add_axes(rect, projection=None, polar=False, **kwargs)\n            add_axes(ax)\n\n        Parameters\n        ----------\n        rect : sequence of float\n            The dimensions [left, bottom, width, height] of the new axes. All\n            quantities are in fractions of figure width and height.\n\n        projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n'polar', 'rectilinear', str}, optional\n            The projection type of the `~.axes.Axes`. *str* is the name of\n            a custom projection, see `~matplotlib.projections`. The default\n            None results in a 'rectilinear' projection.\n\n        polar : bool, default: False\n            If True, equivalent to projection='polar'.\n\n        sharex, sharey : `~.axes.Axes`, optional\n            Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n            The axis will have the same limits, ticks, and scale as the axis\n            of the shared axes.\n\n        label : str\n            A label for the returned axes.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            This method also takes the keyword arguments for\n            the returned axes class. The keyword arguments for the\n            rectilinear axes class `~.axes.Axes` can be found in\n            the following table but there might also be other keyword\n            arguments if another projection is used, see the actual axes\n            class.\n\n            %(Axes)s\n\n        Returns\n        -------\n        axes : `~.axes.Axes` (or a subclass of `~.axes.Axes`)\n            The returned axes class depends on the projection used. It is\n            `~.axes.Axes` if rectilinear projection are used and\n            `.projections.polar.PolarAxes` if polar projection\n            are used.\n\n        Notes\n        -----\n        If the figure already has an axes with key (*args*,\n        *kwargs*) then it will simply make that axes current and\n        return it.  This behavior is deprecated. Meanwhile, if you do\n        not want this behavior (i.e., you want to force the creation of a\n        new axes), you must use a unique set of args and kwargs.  The axes\n        *label* attribute has been exposed for this purpose: if you want\n        two axes that are otherwise identical to be added to the figure,\n        make sure you give them unique labels.\n\n        In rare circumstances, `.add_axes` may be called with a single\n        argument, a axes instance already created in the present figure but\n        not in the figure's list of axes.\n\n        See Also\n        --------\n        .Figure.add_subplot\n        .pyplot.subplot\n        .pyplot.axes\n        .Figure.subplots\n        .pyplot.subplots\n\n        Examples\n        --------\n        Some simple examples::\n\n            rect = l, b, w, h\n            fig = plt.figure()\n            fig.add_axes(rect, label=label1)\n            fig.add_axes(rect, label=label2)\n            fig.add_axes(rect, frameon=False, facecolor='g')\n            fig.add_axes(rect, polar=True)\n            ax = fig.add_axes(rect, projection='polar')\n            fig.delaxes(ax)\n            fig.add_axes(ax)\n        \"\"\"\n\n        if not len(args):\n            cbook.warn_deprecated(\n                \"3.3\",\n                message=\"Calling add_axes() without argument is \"\n                \"deprecated. You may want to use add_suplot() \"\n                \"instead.\")\n            return\n\n        # shortcut the projection \"key\" modifications later on, if an axes\n        # with the exact args/kwargs exists, return it immediately.\n        key = self._make_key(*args, **kwargs)\n        ax = self._axstack.get(key)\n        if ax is not None:\n            self.sca(ax)\n            return ax\n\n        if isinstance(args[0], Axes):\n            a = args[0]\n            if a.get_figure() is not self:\n                raise ValueError(\n                    \"The Axes must have been created in the present figure\")\n        else:\n            rect = args[0]\n            if not np.isfinite(rect).all():\n                raise ValueError('all entries in rect must be finite '\n                                 'not {}'.format(rect))\n            projection_class, kwargs, key = \\\n                self._process_projection_requirements(*args, **kwargs)\n\n            # check that an axes of this type doesn't already exist, if it\n            # does, set it as active and return it\n            ax = self._axstack.get(key)\n            if isinstance(ax, projection_class):\n                self.sca(ax)\n                return ax\n\n            # create the new axes using the axes class given\n            a = projection_class(self, rect, **kwargs)\n\n        return self._add_axes_internal(key, a)",
        "begin_line": 1113,
        "end_line": 1242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.add_subplot#1245",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.add_subplot(self, *args, **kwargs)",
        "snippet": "    def add_subplot(self, *args, **kwargs):\n        \"\"\"\n        Add an `~.axes.Axes` to the figure as part of a subplot arrangement.\n\n        Call signatures::\n\n           add_subplot(nrows, ncols, index, **kwargs)\n           add_subplot(pos, **kwargs)\n           add_subplot(ax)\n           add_subplot()\n\n        Parameters\n        ----------\n        *args, int or (int, int, int) or `SubplotSpec`, default: (1, 1, 1)\n            The position of the subplot described by one of\n\n            - Three integers (*nrows*, *ncols*, *index*). The subplot will\n              take the *index* position on a grid with *nrows* rows and\n              *ncols* columns. *index* starts at 1 in the upper left corner\n              and increases to the right.\n            - A 3-digit integer. The digits are interpreted as if given\n              separately as three single-digit integers, i.e.\n              ``fig.add_subplot(235)`` is the same as\n              ``fig.add_subplot(2, 3, 5)``. Note that this can only be used\n              if there are no more than 9 subplots.\n            - A `.SubplotSpec`.\n\n            In rare circumstances, `.add_subplot` may be called with a single\n            argument, a subplot axes instance already created in the\n            present figure but not in the figure's list of axes.\n\n        projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n'polar', 'rectilinear', str}, optional\n            The projection type of the subplot (`~.axes.Axes`). *str* is the\n            name of a custom projection, see `~matplotlib.projections`. The\n            default None results in a 'rectilinear' projection.\n\n        polar : bool, default: False\n            If True, equivalent to projection='polar'.\n\n        sharex, sharey : `~.axes.Axes`, optional\n            Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n            The axis will have the same limits, ticks, and scale as the axis\n            of the shared axes.\n\n        label : str\n            A label for the returned axes.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            This method also takes the keyword arguments for the returned axes\n            base class; except for the *figure* argument. The keyword arguments\n            for the rectilinear base class `~.axes.Axes` can be found in\n            the following table but there might also be other keyword\n            arguments if another projection is used.\n\n            %(Axes)s\n\n        Returns\n        -------\n        axes : `.axes.SubplotBase`, or another subclass of `~.axes.Axes`\n\n            The axes of the subplot. The returned axes base class depends on\n            the projection used. It is `~.axes.Axes` if rectilinear projection\n            are used and `.projections.polar.PolarAxes` if polar projection\n            are used. The returned axes is then a subplot subclass of the\n            base class.\n\n        Notes\n        -----\n        If the figure already has a subplot with key (*args*,\n        *kwargs*) then it will simply make that subplot current and\n        return it.  This behavior is deprecated. Meanwhile, if you do\n        not want this behavior (i.e., you want to force the creation of a\n        new subplot), you must use a unique set of args and kwargs.  The axes\n        *label* attribute has been exposed for this purpose: if you want\n        two subplots that are otherwise identical to be added to the figure,\n        make sure you give them unique labels.\n\n        See Also\n        --------\n        .Figure.add_axes\n        .pyplot.subplot\n        .pyplot.axes\n        .Figure.subplots\n        .pyplot.subplots\n\n        Examples\n        --------\n        ::\n\n            fig = plt.figure()\n\n            fig.add_subplot(231)\n            ax1 = fig.add_subplot(2, 3, 1)  # equivalent but more general\n\n            fig.add_subplot(232, frameon=False)  # subplot with no frame\n            fig.add_subplot(233, projection='polar')  # polar subplot\n            fig.add_subplot(234, sharex=ax1)  # subplot sharing x-axis with ax1\n            fig.add_subplot(235, facecolor=\"red\")  # red subplot\n\n            ax1.remove()  # delete ax1 from the figure\n            fig.add_subplot(ax1)  # add ax1 back to the figure\n        \"\"\"\n        if 'figure' in kwargs:\n            # Axes itself allows for a 'figure' kwarg, but since we want to\n            # bind the created Axes to self, it is not allowed here.\n            raise TypeError(\n                \"add_subplot() got an unexpected keyword argument 'figure'\")\n\n        nargs = len(args)\n        if nargs == 0:\n            args = (1, 1, 1)\n        elif nargs == 1:\n            if isinstance(args[0], Integral):\n                if not 100 <= args[0] <= 999:\n                    raise ValueError(f\"Integer subplot specification must be \"\n                                     f\"a three-digit number, not {args[0]}\")\n                args = tuple(map(int, str(args[0])))\n            elif isinstance(args[0], (SubplotBase, SubplotSpec)):\n                pass  # no further validation or normalization needed\n            else:\n                raise TypeError('Positional arguments are not a valid '\n                                'position specification.')\n        elif nargs == 3:\n            for arg in args:\n                if not isinstance(arg, Integral):\n                    cbook.warn_deprecated(\n                        \"3.3\",\n                        message=\"Passing non-integers as three-element \"\n                                \"position specification is deprecated.\")\n            args = tuple(map(int, args))\n        else:\n            raise TypeError(f'add_subplot() takes 1 or 3 positional arguments '\n                            f'but {nargs} were given')\n\n        if isinstance(args[0], SubplotBase):\n            ax = args[0]\n            if ax.get_figure() is not self:\n                raise ValueError(\"The Subplot must have been created in \"\n                                 \"the present figure\")\n            # make a key for the subplot (which includes the axes object id\n            # in the hash)\n            key = self._make_key(*args, **kwargs)\n        else:\n            projection_class, kwargs, key = \\\n                self._process_projection_requirements(*args, **kwargs)\n\n            # try to find the axes with this key in the stack\n            ax = self._axstack.get(key)\n\n            if ax is not None:\n                if isinstance(ax, projection_class):\n                    # the axes already existed, so set it as active & return\n                    self.sca(ax)\n                    return ax\n                else:\n                    # Undocumented convenience behavior:\n                    # subplot(111); subplot(111, projection='polar')\n                    # will replace the first with the second.\n                    # Without this, add_subplot would be simpler and\n                    # more similar to add_axes.\n                    self._axstack.remove(ax)\n\n            ax = subplot_class_factory(projection_class)(self, *args, **kwargs)\n\n        return self._add_axes_internal(key, ax)",
        "begin_line": 1245,
        "end_line": 1412,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014265335235378032,
            "pseudo_dstar_susp": 0.0026041666666666665,
            "pseudo_tarantula_susp": 0.0009671179883945841,
            "pseudo_op2_susp": 0.0026041666666666665,
            "pseudo_barinel_susp": 0.0009671179883945841
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._add_axes_internal#1414",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._add_axes_internal(self, key, ax)",
        "snippet": "    def _add_axes_internal(self, key, ax):\n        \"\"\"Private helper for `add_axes` and `add_subplot`.\"\"\"\n        self._axstack.add(key, ax)\n        self.sca(ax)\n        ax._remove_method = self.delaxes\n        self.stale = True\n        ax.stale_callback = _stale_figure_callback\n        return ax",
        "begin_line": 1414,
        "end_line": 1421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012658227848101266,
            "pseudo_dstar_susp": 0.002325581395348837,
            "pseudo_tarantula_susp": 0.0014084507042253522,
            "pseudo_op2_susp": 0.002325581395348837,
            "pseudo_barinel_susp": 0.0014084507042253522
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.subplots#1423",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.subplots(self, nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True, subplot_kw=None, gridspec_kw=None)",
        "snippet": "    def subplots(self, nrows=1, ncols=1, sharex=False, sharey=False,\n                 squeeze=True, subplot_kw=None, gridspec_kw=None):\n        \"\"\"\n        Add a set of subplots to this figure.\n\n        This utility wrapper makes it convenient to create common layouts of\n        subplots in a single call.\n\n        Parameters\n        ----------\n        nrows, ncols : int, default: 1\n            Number of rows/columns of the subplot grid.\n\n        sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False\n            Controls sharing of properties among x (*sharex*) or y (*sharey*)\n            axes:\n\n            - True or 'all': x- or y-axis will be shared among all subplots.\n            - False or 'none': each subplot x- or y-axis will be independent.\n            - 'row': each subplot row will share an x- or y-axis.\n            - 'col': each subplot column will share an x- or y-axis.\n\n            When subplots have a shared x-axis along a column, only the x tick\n            labels of the bottom subplot are created. Similarly, when subplots\n            have a shared y-axis along a row, only the y tick labels of the\n            first column subplot are created. To later turn other subplots'\n            ticklabels on, use `~matplotlib.axes.Axes.tick_params`.\n\n        squeeze : bool, default: True\n            - If True, extra dimensions are squeezed out from the returned\n              array of Axes:\n\n              - if only one subplot is constructed (nrows=ncols=1), the\n                resulting single Axes object is returned as a scalar.\n              - for Nx1 or 1xM subplots, the returned object is a 1D numpy\n                object array of Axes objects.\n              - for NxM, subplots with N>1 and M>1 are returned as a 2D array.\n\n            - If False, no squeezing at all is done: the returned Axes object\n              is always a 2D array containing Axes instances, even if it ends\n              up being 1x1.\n\n        subplot_kw : dict, optional\n            Dict with keywords passed to the `.Figure.add_subplot` call used to\n            create each subplot.\n\n        gridspec_kw : dict, optional\n            Dict with keywords passed to the\n            `~matplotlib.gridspec.GridSpec` constructor used to create\n            the grid the subplots are placed on.\n\n        Returns\n        -------\n        ax : `~.axes.Axes` or array of Axes\n            *ax* can be either a single `~matplotlib.axes.Axes` object or\n            an array of Axes objects if more than one subplot was created. The\n            dimensions of the resulting array can be controlled with the\n            squeeze keyword, see above.\n\n        Examples\n        --------\n        ::\n\n            # First create some toy data:\n            x = np.linspace(0, 2*np.pi, 400)\n            y = np.sin(x**2)\n\n            # Create a figure\n            plt.figure()\n\n            # Create a subplot\n            ax = fig.subplots()\n            ax.plot(x, y)\n            ax.set_title('Simple plot')\n\n            # Create two subplots and unpack the output array immediately\n            ax1, ax2 = fig.subplots(1, 2, sharey=True)\n            ax1.plot(x, y)\n            ax1.set_title('Sharing Y axis')\n            ax2.scatter(x, y)\n\n            # Create four polar axes and access them through the returned array\n            axes = fig.subplots(2, 2, subplot_kw=dict(polar=True))\n            axes[0, 0].plot(x, y)\n            axes[1, 1].scatter(x, y)\n\n            # Share a X axis with each column of subplots\n            fig.subplots(2, 2, sharex='col')\n\n            # Share a Y axis with each row of subplots\n            fig.subplots(2, 2, sharey='row')\n\n            # Share both X and Y axes with all subplots\n            fig.subplots(2, 2, sharex='all', sharey='all')\n\n            # Note that this is the same as\n            fig.subplots(2, 2, sharex=True, sharey=True)\n\n        See Also\n        --------\n        .pyplot.subplots\n        .Figure.add_subplot\n        .pyplot.subplot\n        \"\"\"\n\n        if isinstance(sharex, bool):\n            sharex = \"all\" if sharex else \"none\"\n        if isinstance(sharey, bool):\n            sharey = \"all\" if sharey else \"none\"\n        # This check was added because it is very easy to type\n        # `subplots(1, 2, 1)` when `subplot(1, 2, 1)` was intended.\n        # In most cases, no error will ever occur, but mysterious behavior\n        # will result because what was intended to be the subplot index is\n        # instead treated as a bool for sharex.\n        if isinstance(sharex, Integral):\n            cbook._warn_external(\n                \"sharex argument to subplots() was an integer.  Did you \"\n                \"intend to use subplot() (without 's')?\")\n        cbook._check_in_list([\"all\", \"row\", \"col\", \"none\"],\n                             sharex=sharex, sharey=sharey)\n        if subplot_kw is None:\n            subplot_kw = {}\n        if gridspec_kw is None:\n            gridspec_kw = {}\n        # don't mutate kwargs passed by user...\n        subplot_kw = subplot_kw.copy()\n        gridspec_kw = gridspec_kw.copy()\n\n        if self.get_constrained_layout():\n            gs = GridSpec(nrows, ncols, figure=self, **gridspec_kw)\n        else:\n            # this should turn constrained_layout off if we don't want it\n            gs = GridSpec(nrows, ncols, figure=None, **gridspec_kw)\n        self._gridspecs.append(gs)\n\n        # Create array to hold all axes.\n        axarr = np.empty((nrows, ncols), dtype=object)\n        for row in range(nrows):\n            for col in range(ncols):\n                shared_with = {\"none\": None, \"all\": axarr[0, 0],\n                               \"row\": axarr[row, 0], \"col\": axarr[0, col]}\n                subplot_kw[\"sharex\"] = shared_with[sharex]\n                subplot_kw[\"sharey\"] = shared_with[sharey]\n                axarr[row, col] = self.add_subplot(gs[row, col], **subplot_kw)\n\n        # turn off redundant tick labeling\n        if sharex in [\"col\", \"all\"]:\n            # turn off all but the bottom row\n            for ax in axarr[:-1, :].flat:\n                ax.xaxis.set_tick_params(which='both',\n                                         labelbottom=False, labeltop=False)\n                ax.xaxis.offsetText.set_visible(False)\n        if sharey in [\"row\", \"all\"]:\n            # turn off all but the first column\n            for ax in axarr[:, 1:].flat:\n                ax.yaxis.set_tick_params(which='both',\n                                         labelleft=False, labelright=False)\n                ax.yaxis.offsetText.set_visible(False)\n\n        if squeeze:\n            # Discarding unneeded dimensions that equal 1.  If we only have one\n            # subplot, just return it instead of a 1-element array.\n            return axarr.item() if axarr.size == 1 else axarr.squeeze()\n        else:\n            # Returned axis array will be always 2-d, even if nrows=ncols=1.\n            return axarr",
        "begin_line": 1423,
        "end_line": 1588,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004734848484848485,
            "pseudo_dstar_susp": 0.0006613756613756613,
            "pseudo_tarantula_susp": 0.0007751937984496124,
            "pseudo_op2_susp": 0.0006613756613756613,
            "pseudo_barinel_susp": 0.0007757951900698216
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._reset_locators_and_formatters#1595",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._reset_locators_and_formatters(axis)",
        "snippet": "        def _reset_locators_and_formatters(axis):\n            # Set the formatters and locators to be associated with axis\n            # (where previously they may have been associated with another\n            # Axis isntance)\n            #\n            # Because set_major_formatter() etc. force isDefault_* to be False,\n            # we have to manually check if the original formatter was a\n            # default and manually set isDefault_* if that was the case.\n            majfmt = axis.get_major_formatter()\n            isDefault = majfmt.axis.isDefault_majfmt\n            axis.set_major_formatter(majfmt)\n            if isDefault:\n                majfmt.axis.isDefault_majfmt = True\n\n            majloc = axis.get_major_locator()\n            isDefault = majloc.axis.isDefault_majloc\n            axis.set_major_locator(majloc)\n            if isDefault:\n                majloc.axis.isDefault_majloc = True\n\n            minfmt = axis.get_minor_formatter()\n            isDefault = majloc.axis.isDefault_minfmt\n            axis.set_minor_formatter(minfmt)\n            if isDefault:\n                minfmt.axis.isDefault_minfmt = True\n\n            minloc = axis.get_minor_locator()\n            isDefault = majloc.axis.isDefault_minloc\n            axis.set_minor_locator(minloc)\n            if isDefault:\n                minloc.axis.isDefault_minloc = True",
        "begin_line": 1595,
        "end_line": 1625,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._break_share_link#1627",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._break_share_link(ax, grouper)",
        "snippet": "        def _break_share_link(ax, grouper):\n            siblings = grouper.get_siblings(ax)\n            if len(siblings) > 1:\n                grouper.remove(ax)\n                for last_ax in siblings:\n                    if ax is not last_ax:\n                        return last_ax\n            return None",
        "begin_line": 1627,
        "end_line": 1634,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.delaxes#1590",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.delaxes(self, ax)",
        "snippet": "    def delaxes(self, ax):\n        \"\"\"\n        Remove the `~.axes.Axes` *ax* from the figure; update the current axes.\n        \"\"\"\n\n        def _reset_locators_and_formatters(axis):\n            # Set the formatters and locators to be associated with axis\n            # (where previously they may have been associated with another\n            # Axis isntance)\n            #\n            # Because set_major_formatter() etc. force isDefault_* to be False,\n            # we have to manually check if the original formatter was a\n            # default and manually set isDefault_* if that was the case.\n            majfmt = axis.get_major_formatter()\n            isDefault = majfmt.axis.isDefault_majfmt\n            axis.set_major_formatter(majfmt)\n            if isDefault:\n                majfmt.axis.isDefault_majfmt = True\n\n            majloc = axis.get_major_locator()\n            isDefault = majloc.axis.isDefault_majloc\n            axis.set_major_locator(majloc)\n            if isDefault:\n                majloc.axis.isDefault_majloc = True\n\n            minfmt = axis.get_minor_formatter()\n            isDefault = majloc.axis.isDefault_minfmt\n            axis.set_minor_formatter(minfmt)\n            if isDefault:\n                minfmt.axis.isDefault_minfmt = True\n\n            minloc = axis.get_minor_locator()\n            isDefault = majloc.axis.isDefault_minloc\n            axis.set_minor_locator(minloc)\n            if isDefault:\n                minloc.axis.isDefault_minloc = True\n\n        def _break_share_link(ax, grouper):\n            siblings = grouper.get_siblings(ax)\n            if len(siblings) > 1:\n                grouper.remove(ax)\n                for last_ax in siblings:\n                    if ax is not last_ax:\n                        return last_ax\n            return None\n\n        self._axstack.remove(ax)\n        self._axobservers.process(\"_axes_change_event\", self)\n        self.stale = True\n\n        last_ax = _break_share_link(ax, ax._shared_y_axes)\n        if last_ax is not None:\n            _reset_locators_and_formatters(last_ax.yaxis)\n\n        last_ax = _break_share_link(ax, ax._shared_x_axes)\n        if last_ax is not None:\n            _reset_locators_and_formatters(last_ax.xaxis)",
        "begin_line": 1590,
        "end_line": 1646,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.clf#1648",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.clf(self, keep_observers=False)",
        "snippet": "    def clf(self, keep_observers=False):\n        \"\"\"\n        Clear the figure.\n\n        Set *keep_observers* to True if, for example,\n        a gui widget is tracking the axes in the figure.\n        \"\"\"\n        self.suppressComposite = None\n        self.callbacks = cbook.CallbackRegistry()\n\n        for ax in tuple(self.axes):  # Iterate over the copy.\n            ax.cla()\n            self.delaxes(ax)         # removes ax from self._axstack\n\n        toolbar = getattr(self.canvas, 'toolbar', None)\n        if toolbar is not None:\n            toolbar.update()\n        self._axstack.clear()\n        self.artists = []\n        self.lines = []\n        self.patches = []\n        self.texts = []\n        self.images = []\n        self.legends = []\n        if not keep_observers:\n            self._axobservers = cbook.CallbackRegistry()\n        self._suptitle = None\n        if self.get_constrained_layout():\n            layoutbox.nonetree(self._layoutbox)\n        self.stale = True",
        "begin_line": 1648,
        "end_line": 1677,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006821282401091405,
            "pseudo_dstar_susp": 0.001375515818431912,
            "pseudo_tarantula_susp": 0.00039184952978056425,
            "pseudo_op2_susp": 0.001375515818431912,
            "pseudo_barinel_susp": 0.00039184952978056425
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.draw#1684",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        # docstring inherited\n        self._cachedRenderer = renderer\n\n        # draw the figure bounding box, perhaps none for white figure\n        if not self.get_visible():\n            return\n\n        artists = self.get_children()\n        artists.remove(self.patch)\n        artists = sorted(\n            (artist for artist in artists if not artist.get_animated()),\n            key=lambda artist: artist.get_zorder())\n\n        for ax in self.axes:\n            locator = ax.get_axes_locator()\n            if locator:\n                pos = locator(ax, renderer)\n                ax.apply_aspect(pos)\n            else:\n                ax.apply_aspect()\n\n            for child in ax.get_children():\n                if hasattr(child, 'apply_aspect'):\n                    locator = child.get_axes_locator()\n                    if locator:\n                        pos = locator(child, renderer)\n                        child.apply_aspect(pos)\n                    else:\n                        child.apply_aspect()\n\n        try:\n            renderer.open_group('figure', gid=self.get_gid())\n            if self.get_constrained_layout() and self.axes:\n                self.execute_constrained_layout(renderer)\n            if self.get_tight_layout() and self.axes:\n                try:\n                    self.tight_layout(**self._tight_parameters)\n                except ValueError:\n                    pass\n                    # ValueError can occur when resizing a window.\n\n            self.patch.draw(renderer)\n            mimage._draw_list_compositing_images(\n                renderer, self, artists, self.suppressComposite)\n\n            renderer.close_group('figure')\n        finally:\n            self.stale = False\n\n        self.canvas.draw_event(renderer)",
        "begin_line": 1684,
        "end_line": 1734,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002959455460195324,
            "pseudo_dstar_susp": 0.0002955956251847473,
            "pseudo_tarantula_susp": 0.00030864197530864197,
            "pseudo_op2_susp": 0.0002955956251847473,
            "pseudo_barinel_susp": 0.00030864197530864197
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.draw_artist#1736",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.draw_artist(self, a)",
        "snippet": "    def draw_artist(self, a):\n        \"\"\"\n        Draw `.Artist` instance *a* only.\n\n        This can only be called after the figure has been drawn.\n        \"\"\"\n        if self._cachedRenderer is None:\n            raise AttributeError(\"draw_artist can only be used after an \"\n                                 \"initial draw which caches the renderer\")\n        a.draw(self._cachedRenderer)",
        "begin_line": 1736,
        "end_line": 1745,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.legend#1752",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.legend(self, *args, **kwargs)",
        "snippet": "    def legend(self, *args, **kwargs):\n        \"\"\"\n        Place a legend on the figure.\n\n        To make a legend from existing artists on every axes::\n\n          legend()\n\n        To make a legend for a list of lines and labels::\n\n          legend(\n              (line1, line2, line3),\n              ('label1', 'label2', 'label3'),\n              loc='upper right')\n\n        These can also be specified by keyword::\n\n          legend(\n              handles=(line1, line2, line3),\n              labels=('label1', 'label2', 'label3'),\n              loc='upper right')\n\n        Parameters\n        ----------\n        handles : list of `.Artist`, optional\n            A list of Artists (lines, patches) to be added to the legend.\n            Use this together with *labels*, if you need full control on what\n            is shown in the legend and the automatic mechanism described above\n            is not sufficient.\n\n            The length of handles and labels should be the same in this\n            case. If they are not, they are truncated to the smaller length.\n\n        labels : list of str, optional\n            A list of labels to show next to the artists.\n            Use this together with *handles*, if you need full control on what\n            is shown in the legend and the automatic mechanism described above\n            is not sufficient.\n\n        Other Parameters\n        ----------------\n        %(_legend_kw_doc)s\n\n        Returns\n        -------\n        `~matplotlib.legend.Legend`\n\n        Notes\n        -----\n        Some artists are not supported by this function.  See\n        :doc:`/tutorials/intermediate/legend_guide` for details.\n        \"\"\"\n\n        handles, labels, extra_args, kwargs = mlegend._parse_legend_args(\n                self.axes,\n                *args,\n                **kwargs)\n        # check for third arg\n        if len(extra_args):\n            # cbook.warn_deprecated(\n            #     \"2.1\",\n            #     message=\"Figure.legend will accept no more than two \"\n            #     \"positional arguments in the future.  Use \"\n            #     \"'fig.legend(handles, labels, loc=location)' \"\n            #     \"instead.\")\n            # kwargs['loc'] = extra_args[0]\n            # extra_args = extra_args[1:]\n            pass\n        l = mlegend.Legend(self, handles, labels, *extra_args, **kwargs)\n        self.legends.append(l)\n        l._remove_method = self.legends.remove\n        self.stale = True\n        return l",
        "begin_line": 1752,
        "end_line": 1824,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.text#1827",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.text(self, x, y, s, fontdict=None, **kwargs)",
        "snippet": "    def text(self, x, y, s, fontdict=None, **kwargs):\n        \"\"\"\n        Add text to figure.\n\n        Parameters\n        ----------\n        x, y : float\n            The position to place the text. By default, this is in figure\n            coordinates, floats in [0, 1]. The coordinate system can be changed\n            using the *transform* keyword.\n\n        s : str\n            The text string.\n\n        fontdict : dict, optional\n            A dictionary to override the default text properties. If not given,\n            the defaults are determined by :rc:`font.*`. Properties passed as\n            *kwargs* override the corresponding ones given in *fontdict*.\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.text.Text` properties\n            Other miscellaneous text parameters.\n\n            %(Text)s\n\n        Returns\n        -------\n        text : `~.text.Text`\n\n        See Also\n        --------\n        .Axes.text\n        .pyplot.text\n        \"\"\"\n        effective_kwargs = {\n            'transform': self.transFigure,\n            **(fontdict if fontdict is not None else {}),\n            **kwargs,\n        }\n        text = Text(x=x, y=y, text=s, **effective_kwargs)\n        text.set_figure(self)\n        text.stale_callback = _stale_figure_callback\n\n        self.texts.append(text)\n        text._remove_method = self.texts.remove\n        self.stale = True\n        return text",
        "begin_line": 1827,
        "end_line": 1874,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.946144211844694e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._set_artist_props#1876",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._set_artist_props(self, a)",
        "snippet": "    def _set_artist_props(self, a):\n        if a != self:\n            a.set_figure(self)\n        a.stale_callback = _stale_figure_callback\n        a.set_transform(self.transFigure)",
        "begin_line": 1876,
        "end_line": 1880,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006510416666666666,
            "pseudo_dstar_susp": 0.0012690355329949238,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0012690355329949238,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.gca#1883",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.gca(self, **kwargs)",
        "snippet": "    def gca(self, **kwargs):\n        \"\"\"\n        Get the current axes, creating one if necessary.\n\n        The following kwargs are supported for ensuring the returned axes\n        adheres to the given projection etc., and for axes creation if\n        the active axes does not exist:\n\n        %(Axes)s\n\n        \"\"\"\n        ckey, cax = self._axstack.current_key_axes()\n        # if there exists an axes on the stack see if it matches\n        # the desired axes configuration\n        if cax is not None:\n\n            # if no kwargs are given just return the current axes\n            # this is a convenience for gca() on axes such as polar etc.\n            if not kwargs:\n                return cax\n\n            # if the user has specified particular projection detail\n            # then build up a key which can represent this\n            else:\n                projection_class, _, key = \\\n                    self._process_projection_requirements(**kwargs)\n\n                # let the returned axes have any gridspec by removing it from\n                # the key\n                ckey = ckey[1:]\n                key = key[1:]\n\n                # if the cax matches this key then return the axes, otherwise\n                # continue and a new axes will be created\n                if key == ckey and isinstance(cax, projection_class):\n                    return cax\n                else:\n                    cbook._warn_external('Requested projection is different '\n                                         'from current axis projection, '\n                                         'creating new axis with requested '\n                                         'projection.')\n\n        # no axes found, so create one which spans the figure\n        return self.add_subplot(1, 1, 1, **kwargs)",
        "begin_line": 1883,
        "end_line": 1926,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007616146230007616,
            "pseudo_dstar_susp": 0.0006997900629811056,
            "pseudo_tarantula_susp": 0.0010482180293501049,
            "pseudo_op2_susp": 0.0006968641114982578,
            "pseudo_barinel_susp": 0.0010482180293501049
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.sca#1928",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.sca(self, a)",
        "snippet": "    def sca(self, a):\n        \"\"\"Set the current axes to be *a* and return *a*.\"\"\"\n        self._axstack.bubble(a)\n        self._axobservers.process(\"_axes_change_event\", self)\n        return a",
        "begin_line": 1928,
        "end_line": 1932,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013605442176870747,
            "pseudo_dstar_susp": 0.0024752475247524753,
            "pseudo_tarantula_susp": 0.0005672149744753262,
            "pseudo_op2_susp": 0.0024752475247524753,
            "pseudo_barinel_susp": 0.0005672149744753262
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure._gci#1934",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure._gci(self)",
        "snippet": "    def _gci(self):\n        # Helper for `~matplotlib.pyplot.gci`.  Do not use elsewhere.\n        \"\"\"\n        Get the current colorable artist.\n\n        Specifically, returns the current `.ScalarMappable` instance (`.Image`\n        created by `imshow` or `figimage`, `.Collection` created by `pcolor` or\n        `scatter`, etc.), or *None* if no such instance has been defined.\n\n        The current image is an attribute of the current axes, or the nearest\n        earlier axes in the current figure that contains an image.\n\n        Notes\n        -----\n        Historically, the only colorable artists were images; hence the name\n        ``gci`` (get current image).\n        \"\"\"\n        # Look first for an image in the current Axes:\n        cax = self._axstack.current_key_axes()[1]\n        if cax is None:\n            return None\n        im = cax._gci()\n        if im is not None:\n            return im\n\n        # If there is no image in the current Axes, search for\n        # one in a previously created Axes.  Whether this makes\n        # sense is debatable, but it is the documented behavior.\n        for ax in reversed(self.axes):\n            im = ax._gci()\n            if im is not None:\n                return im\n        return None",
        "begin_line": 1934,
        "end_line": 1966,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.__getstate__#1968",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.__getstate__(self)",
        "snippet": "    def __getstate__(self):\n        state = super().__getstate__()\n\n        # The canvas cannot currently be pickled, but this has the benefit\n        # of meaning that a figure can be detached from one canvas, and\n        # re-attached to another.\n        for attr_to_pop in ('canvas', '_cachedRenderer'):\n            state.pop(attr_to_pop, None)\n\n        # add version information to the state\n        state['__mpl_version__'] = _mpl_version\n\n        # check whether the figure manager (if any) is registered with pyplot\n        from matplotlib import _pylab_helpers\n        if getattr(self.canvas, 'manager', None) \\\n                in _pylab_helpers.Gcf.figs.values():\n            state['_restore_to_pylab'] = True\n\n        # set all the layoutbox information to None.  kiwisolver objects can't\n        # be pickled, so we lose the layout options at this point.\n        state.pop('_layoutbox', None)\n        # suptitle:\n        if self._suptitle is not None:\n            self._suptitle._layoutbox = None\n\n        return state",
        "begin_line": 1968,
        "end_line": 1993,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.__setstate__#1995",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.__setstate__(self, state)",
        "snippet": "    def __setstate__(self, state):\n        version = state.pop('__mpl_version__')\n        restore_to_pylab = state.pop('_restore_to_pylab', False)\n\n        if version != _mpl_version:\n            cbook._warn_external(\n                f\"This figure was saved with matplotlib version {version} and \"\n                f\"is unlikely to function correctly.\")\n\n        self.__dict__ = state\n\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n        self._layoutbox = None\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n\n            # XXX The following is a copy and paste from pyplot. Consider\n            # factoring to pylab_helpers\n\n            if self.get_label():\n                mgr.set_window_title(self.get_label())\n\n            # make this figure current on button press event\n            def make_active(event):\n                pylab_helpers.Gcf.set_active(mgr)\n\n            mgr._cidgcf = mgr.canvas.mpl_connect('button_press_event',\n                                                 make_active)\n\n            pylab_helpers.Gcf.set_active(mgr)\n            self.number = num\n\n            plt.draw_if_interactive()\n        self.stale = True",
        "begin_line": 1995,
        "end_line": 2035,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.add_axobserver#2037",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.add_axobserver(self, func)",
        "snippet": "    def add_axobserver(self, func):\n        \"\"\"Whenever the axes state change, ``func(self)`` will be called.\"\"\"\n        # Connect a wrapper lambda and not func itself, to avoid it being\n        # weakref-collected.\n        self._axobservers.connect(\"_axes_change_event\", lambda arg: func(arg))",
        "begin_line": 2037,
        "end_line": 2041,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004923682914820286,
            "pseudo_dstar_susp": 0.0005402485143165856,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.0005402485143165856,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.savefig#2043",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.savefig(self, fname, *, transparent=None, **kwargs)",
        "snippet": "    def savefig(self, fname, *, transparent=None, **kwargs):\n        \"\"\"\n        Save the current figure.\n\n        Call signature::\n\n          savefig(fname, dpi=None, facecolor='w', edgecolor='w',\n                  orientation='portrait', papertype=None, format=None,\n                  transparent=False, bbox_inches=None, pad_inches=0.1,\n                  frameon=None, metadata=None)\n\n        The available output formats depend on the backend being used.\n\n        Parameters\n        ----------\n        fname : str or PathLike or file-like object\n            A path, or a Python file-like object, or\n            possibly some backend-dependent object such as\n            `matplotlib.backends.backend_pdf.PdfPages`.\n\n            If *format* is set, it determines the output format, and the file\n            is saved as *fname*.  Note that *fname* is used verbatim, and there\n            is no attempt to make the extension, if any, of *fname* match\n            *format*, and no extension is appended.\n\n            If *format* is not set, then the format is inferred from the\n            extension of *fname*, if there is one.  If *format* is not\n            set and *fname* has no extension, then the file is saved with\n            :rc:`savefig.format` and the appropriate extension is appended to\n            *fname*.\n\n        Other Parameters\n        ----------------\n        dpi : float or 'figure', default: :rc:`savefig.dpi`\n            The resolution in dots per inch.  If 'figure', use the figure's\n            dpi value.\n\n        quality : int, default: :rc:`savefig.jpeg_quality`\n            Applicable only if *format* is 'jpg' or 'jpeg', ignored otherwise.\n\n            The image quality, on a scale from 1 (worst) to 95 (best).\n            Values above 95 should be avoided; 100 disables portions of\n            the JPEG compression algorithm, and results in large files\n            with hardly any gain in image quality.\n\n            This parameter is deprecated.\n\n        optimize : bool, default: False\n            Applicable only if *format* is 'jpg' or 'jpeg', ignored otherwise.\n\n            Whether the encoder should make an extra pass over the image\n            in order to select optimal encoder settings.\n\n            This parameter is deprecated.\n\n        progressive : bool, default: False\n            Applicable only if *format* is 'jpg' or 'jpeg', ignored otherwise.\n\n            Whether the image should be stored as a progressive JPEG file.\n\n            This parameter is deprecated.\n\n        facecolor : color, default: :rc:`savefig.facecolor`\n            The facecolor of the figure.\n\n        edgecolor : color, default: :rc:`savefig.edgecolor`\n            The edgecolor of the figure.\n\n        orientation : {'landscape', 'portrait'}\n            Currently only supported by the postscript backend.\n\n        papertype : str\n            One of 'letter', 'legal', 'executive', 'ledger', 'a0' through\n            'a10', 'b0' through 'b10'. Only supported for postscript\n            output.\n\n        format : str\n            The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when\n            this is unset is documented under *fname*.\n\n        transparent : bool\n            If *True*, the axes patches will all be transparent; the\n            figure patch will also be transparent unless facecolor\n            and/or edgecolor are specified via kwargs.\n            This is useful, for example, for displaying\n            a plot on top of a colored background on a web page.  The\n            transparency of these patches will be restored to their\n            original values upon exit of this function.\n\n        bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`\n            Bounding box in inches: only the given portion of the figure is\n            saved.  If 'tight', try to figure out the tight bbox of the figure.\n\n        pad_inches : scalar, optional\n            Amount of padding around the figure when bbox_inches is\n            'tight'. If None, use savefig.pad_inches\n\n        bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional\n            A list of extra artists that will be considered when the\n            tight bbox is calculated.\n\n        backend : str, optional\n            Use a non-default backend to render the file, e.g. to render a\n            png file with the \"cairo\" backend rather than the default \"agg\",\n            or a pdf file with the \"pgf\" backend rather than the default\n            \"pdf\".  Note that the default backend is normally sufficient.  See\n            :ref:`the-builtin-backends` for a list of valid backends for each\n            file format.  Custom backends can be referenced as \"module://...\".\n\n        metadata : dict, optional\n            Key/value pairs to store in the image metadata. The supported keys\n            and defaults depend on the image format and backend:\n\n            - 'png' with Agg backend: See the parameter ``metadata`` of\n              `~.FigureCanvasAgg.print_png`.\n            - 'pdf' with pdf backend: See the parameter ``metadata`` of\n              `~.backend_pdf.PdfPages`.\n            - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.\n\n        pil_kwargs : dict, optional\n            Additional keyword arguments that are passed to\n            `PIL.Image.Image.save` when saving the figure.\n        \"\"\"\n\n        kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])\n        if transparent is None:\n            transparent = mpl.rcParams['savefig.transparent']\n\n        if transparent:\n            kwargs.setdefault('facecolor', 'none')\n            kwargs.setdefault('edgecolor', 'none')\n            original_axes_colors = []\n            for ax in self.axes:\n                patch = ax.patch\n                original_axes_colors.append((patch.get_facecolor(),\n                                             patch.get_edgecolor()))\n                patch.set_facecolor('none')\n                patch.set_edgecolor('none')\n        else:\n            kwargs.setdefault('facecolor', mpl.rcParams['savefig.facecolor'])\n            kwargs.setdefault('edgecolor', mpl.rcParams['savefig.edgecolor'])\n\n        self.canvas.print_figure(fname, **kwargs)\n\n        if transparent:\n            for ax, cc in zip(self.axes, original_axes_colors):\n                ax.patch.set_facecolor(cc[0])\n                ax.patch.set_edgecolor(cc[1])",
        "begin_line": 2043,
        "end_line": 2190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00027739251040221914,
            "pseudo_dstar_susp": 0.00027739251040221914,
            "pseudo_tarantula_susp": 0.0002775464890369137,
            "pseudo_op2_susp": 0.00027739251040221914,
            "pseudo_barinel_susp": 0.0002775464890369137
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.colorbar#2193",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.colorbar(self, mappable, cax=None, ax=None, use_gridspec=True, **kw)",
        "snippet": "    def colorbar(self, mappable, cax=None, ax=None, use_gridspec=True, **kw):\n        \"\"\"\n        Create a colorbar for a ScalarMappable instance, *mappable*.\n\n        Documentation for the pyplot thin wrapper:\n        %(colorbar_doc)s\n        \"\"\"\n        if ax is None:\n            ax = self.gca()\n\n        # Store the value of gca so that we can set it back later on.\n        current_ax = self.gca()\n\n        if cax is None:\n            if use_gridspec and isinstance(ax, SubplotBase)  \\\n                     and (not self.get_constrained_layout()):\n                cax, kw = cbar.make_axes_gridspec(ax, **kw)\n            else:\n                cax, kw = cbar.make_axes(ax, **kw)\n\n        # need to remove kws that cannot be passed to Colorbar\n        NON_COLORBAR_KEYS = ['fraction', 'pad', 'shrink', 'aspect', 'anchor',\n                             'panchor']\n        cb_kw = {k: v for k, v in kw.items() if k not in NON_COLORBAR_KEYS}\n        cb = cbar.colorbar_factory(cax, mappable, **cb_kw)\n\n        self.sca(current_ax)\n        self.stale = True\n        return cb",
        "begin_line": 2193,
        "end_line": 2221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.subplots_adjust#2223",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.subplots_adjust(self, left=None, bottom=None, right=None, top=None, wspace=None, hspace=None)",
        "snippet": "    def subplots_adjust(self, left=None, bottom=None, right=None, top=None,\n                        wspace=None, hspace=None):\n        \"\"\"\n        Update the `SubplotParams` with *kwargs* (defaulting to rc when\n        *None*), and update the subplot locations.\n        \"\"\"\n        if self.get_constrained_layout():\n            self.set_constrained_layout(False)\n            cbook._warn_external(\"This figure was using \"\n                                 \"constrained_layout==True, but that is \"\n                                 \"incompatible with subplots_adjust and or \"\n                                 \"tight_layout: setting \"\n                                 \"constrained_layout==False. \")\n        self.subplotpars.update(left, bottom, right, top, wspace, hspace)\n        for ax in self.axes:\n            if not isinstance(ax, SubplotBase):\n                # Check if sharing a subplots axis\n                if isinstance(ax._sharex, SubplotBase):\n                    ax._sharex.update_params()\n                    ax.set_position(ax._sharex.figbox)\n                elif isinstance(ax._sharey, SubplotBase):\n                    ax._sharey.update_params()\n                    ax.set_position(ax._sharey.figbox)\n            else:\n                ax.update_params()\n                ax.set_position(ax.figbox)\n        self.stale = True",
        "begin_line": 2223,
        "end_line": 2249,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_default_bbox_extra_artists#2318",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_default_bbox_extra_artists(self)",
        "snippet": "    def get_default_bbox_extra_artists(self):\n        bbox_artists = [artist for artist in self.get_children()\n                        if (artist.get_visible() and artist.get_in_layout())]\n        for ax in self.axes:\n            if ax.get_visible():\n                bbox_artists.extend(ax.get_default_bbox_extra_artists())\n        return bbox_artists",
        "begin_line": 2318,
        "end_line": 2324,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.get_tightbbox#2326",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.get_tightbbox(self, renderer, bbox_extra_artists=None)",
        "snippet": "    def get_tightbbox(self, renderer, bbox_extra_artists=None):\n        \"\"\"\n        Return a (tight) bounding box of the figure in inches.\n\n        Artists that have ``artist.set_in_layout(False)`` are not included\n        in the bbox.\n\n        Parameters\n        ----------\n        renderer : `.RendererBase` subclass\n            renderer that will be used to draw the figures (i.e.\n            ``fig.canvas.get_renderer()``)\n\n        bbox_extra_artists : list of `.Artist` or ``None``\n            List of artists to include in the tight bounding box.  If\n            ``None`` (default), then all artist children of each axes are\n            included in the tight bounding box.\n\n        Returns\n        -------\n        bbox : `.BboxBase`\n            containing the bounding box (in figure inches).\n        \"\"\"\n\n        bb = []\n        if bbox_extra_artists is None:\n            artists = self.get_default_bbox_extra_artists()\n        else:\n            artists = bbox_extra_artists\n\n        for a in artists:\n            bbox = a.get_tightbbox(renderer)\n            if bbox is not None and (bbox.width != 0 or bbox.height != 0):\n                bb.append(bbox)\n\n        for ax in self.axes:\n            if ax.get_visible():\n                # some axes don't take the bbox_extra_artists kwarg so we\n                # need this conditional....\n                try:\n                    bbox = ax.get_tightbbox(\n                        renderer, bbox_extra_artists=bbox_extra_artists)\n                except TypeError:\n                    bbox = ax.get_tightbbox(renderer)\n                bb.append(bbox)\n        bb = [b for b in bb\n              if (np.isfinite(b.width) and np.isfinite(b.height)\n                  and (b.width != 0 or b.height != 0))]\n\n        if len(bb) == 0:\n            return self.bbox_inches\n\n        _bbox = Bbox.union(bb)\n\n        bbox_inches = TransformedBbox(_bbox, Affine2D().scale(1 / self.dpi))\n\n        return bbox_inches",
        "begin_line": 2326,
        "end_line": 2382,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.init_layoutbox#2384",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.init_layoutbox(self)",
        "snippet": "    def init_layoutbox(self):\n        \"\"\"Initialize the layoutbox for use in constrained_layout.\"\"\"\n        if self._layoutbox is None:\n            self._layoutbox = layoutbox.LayoutBox(\n                parent=None, name='figlb', artist=self)\n            self._layoutbox.constrain_geometry(0., 0., 1., 1.)",
        "begin_line": 2384,
        "end_line": 2389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.910273545397844e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.execute_constrained_layout#2391",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.execute_constrained_layout(self, renderer=None)",
        "snippet": "    def execute_constrained_layout(self, renderer=None):\n        \"\"\"\n        Use ``layoutbox`` to determine pos positions within axes.\n\n        See also `.set_constrained_layout_pads`.\n        \"\"\"\n\n        from matplotlib._constrained_layout import do_constrained_layout\n\n        _log.debug('Executing constrainedlayout')\n        if self._layoutbox is None:\n            cbook._warn_external(\"Calling figure.constrained_layout, but \"\n                                 \"figure not setup to do constrained layout. \"\n                                 \" You either called GridSpec without the \"\n                                 \"fig keyword, you are using plt.subplot, \"\n                                 \"or you need to call figure or subplots \"\n                                 \"with the constrained_layout=True kwarg.\")\n            return\n        w_pad, h_pad, wspace, hspace = self.get_constrained_layout_pads()\n        # convert to unit-relative lengths\n        fig = self\n        width, height = fig.get_size_inches()\n        w_pad = w_pad / width\n        h_pad = h_pad / height\n        if renderer is None:\n            renderer = layoutbox.get_renderer(fig)\n        do_constrained_layout(fig, renderer, h_pad, w_pad, hspace, wspace)",
        "begin_line": 2391,
        "end_line": 2417,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.tight_layout#2420",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.tight_layout(self, renderer=None, pad=1.08, h_pad=None, w_pad=None, rect=None)",
        "snippet": "    def tight_layout(self, renderer=None, pad=1.08, h_pad=None, w_pad=None,\n                     rect=None):\n        \"\"\"\n        Automatically adjust subplot parameters to give specified padding.\n\n        To exclude an artist on the axes from the bounding box calculation\n        that determines the subplot parameters (i.e. legend, or annotation),\n        set ``a.set_in_layout(False)`` for that artist.\n\n        Parameters\n        ----------\n        renderer : subclass of `~.backend_bases.RendererBase`, optional\n            Defaults to the renderer for the figure.  Deprecated.\n        pad : float, optional\n            Padding between the figure edge and the edges of subplots,\n            as a fraction of the font size.\n        h_pad, w_pad : float, optional\n            Padding (height/width) between edges of adjacent subplots,\n            as a fraction of the font size.  Defaults to *pad*.\n        rect : tuple (left, bottom, right, top), optional\n            A rectangle (left, bottom, right, top) in the normalized\n            figure coordinate that the whole subplots area (including\n            labels) will fit into. Default is (0, 0, 1, 1).\n\n        See Also\n        --------\n        .Figure.set_tight_layout\n        .pyplot.tight_layout\n        \"\"\"\n\n        from .tight_layout import (\n            get_renderer, get_subplotspec_list, get_tight_layout_figure)\n\n        subplotspec_list = get_subplotspec_list(self.axes)\n        if None in subplotspec_list:\n            cbook._warn_external(\"This figure includes Axes that are not \"\n                                 \"compatible with tight_layout, so results \"\n                                 \"might be incorrect.\")\n\n        if renderer is None:\n            renderer = get_renderer(self)\n\n        kwargs = get_tight_layout_figure(\n            self, self.axes, subplotspec_list, renderer,\n            pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)\n        if kwargs:\n            self.subplots_adjust(**kwargs)",
        "begin_line": 2420,
        "end_line": 2466,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.align_xlabels#2468",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.align_xlabels(self, axs=None)",
        "snippet": "    def align_xlabels(self, axs=None):\n        \"\"\"\n        Align the ylabels of subplots in the same subplot column if label\n        alignment is being done automatically (i.e. the label position is\n        not manually set).\n\n        Alignment persists for draw events after this is called.\n\n        If a label is on the bottom, it is aligned with labels on axes that\n        also have their label on the bottom and that have the same\n        bottom-most subplot row.  If the label is on the top,\n        it is aligned with labels on axes with the same top-most row.\n\n        Parameters\n        ----------\n        axs : list of `~matplotlib.axes.Axes`\n            Optional list of (or ndarray) `~matplotlib.axes.Axes`\n            to align the xlabels.\n            Default is to align all axes on the figure.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.align_ylabels\n\n        matplotlib.figure.Figure.align_labels\n\n        Notes\n        -----\n        This assumes that ``axs`` are from the same `.GridSpec`, so that\n        their `.SubplotSpec` positions correspond to figure positions.\n\n        Examples\n        --------\n        Example with rotated xtick labels::\n\n            fig, axs = plt.subplots(1, 2)\n            for tick in axs[0].get_xticklabels():\n                tick.set_rotation(55)\n            axs[0].set_xlabel('XLabel 0')\n            axs[1].set_xlabel('XLabel 1')\n            fig.align_xlabels()\n\n        \"\"\"\n\n        if axs is None:\n            axs = self.axes\n        axs = np.asarray(axs).ravel()\n        for ax in axs:\n            _log.debug(' Working on: %s', ax.get_xlabel())\n            ss = ax.get_subplotspec()\n            nrows, ncols, row0, row1, col0, col1 = ss.get_rows_columns()\n            labpo = ax.xaxis.get_label_position()  # top or bottom\n\n            # loop through other axes, and search for label positions\n            # that are same as this one, and that share the appropriate\n            # row number.\n            #  Add to a grouper associated with each axes of sibblings.\n            # This list is inspected in `axis.draw` by\n            # `axis._update_label_position`.\n            for axc in axs:\n                if axc.xaxis.get_label_position() == labpo:\n                    ss = axc.get_subplotspec()\n                    nrows, ncols, rowc0, rowc1, colc, col1 = \\\n                            ss.get_rows_columns()\n                    if (labpo == 'bottom' and rowc1 == row1 or\n                        labpo == 'top' and rowc0 == row0):\n                        # grouper for groups of xlabels to align\n                        self._align_xlabel_grp.join(ax, axc)",
        "begin_line": 2468,
        "end_line": 2535,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.align_ylabels#2537",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.align_ylabels(self, axs=None)",
        "snippet": "    def align_ylabels(self, axs=None):\n        \"\"\"\n        Align the ylabels of subplots in the same subplot column if label\n        alignment is being done automatically (i.e. the label position is\n        not manually set).\n\n        Alignment persists for draw events after this is called.\n\n        If a label is on the left, it is aligned with labels on axes that\n        also have their label on the left and that have the same\n        left-most subplot column.  If the label is on the right,\n        it is aligned with labels on axes with the same right-most column.\n\n        Parameters\n        ----------\n        axs : list of `~matplotlib.axes.Axes`\n            Optional list (or ndarray) of `~matplotlib.axes.Axes`\n            to align the ylabels.\n            Default is to align all axes on the figure.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.align_xlabels\n\n        matplotlib.figure.Figure.align_labels\n\n        Notes\n        -----\n        This assumes that ``axs`` are from the same `.GridSpec`, so that\n        their `.SubplotSpec` positions correspond to figure positions.\n\n        Examples\n        --------\n        Example with large yticks labels::\n\n            fig, axs = plt.subplots(2, 1)\n            axs[0].plot(np.arange(0, 1000, 50))\n            axs[0].set_ylabel('YLabel 0')\n            axs[1].set_ylabel('YLabel 1')\n            fig.align_ylabels()\n\n        \"\"\"\n\n        if axs is None:\n            axs = self.axes\n        axs = np.asarray(axs).ravel()\n        for ax in axs:\n            _log.debug(' Working on: %s', ax.get_ylabel())\n            ss = ax.get_subplotspec()\n            nrows, ncols, row0, row1, col0, col1 = ss.get_rows_columns()\n            labpo = ax.yaxis.get_label_position()  # left or right\n            # loop through other axes, and search for label positions\n            # that are same as this one, and that share the appropriate\n            # column number.\n            # Add to a list associated with each axes of sibblings.\n            # This list is inspected in `axis.draw` by\n            # `axis._update_label_position`.\n            for axc in axs:\n                if axc != ax:\n                    if axc.yaxis.get_label_position() == labpo:\n                        ss = axc.get_subplotspec()\n                        nrows, ncols, row0, row1, colc0, colc1 = \\\n                                ss.get_rows_columns()\n                        if (labpo == 'left' and colc0 == col0 or\n                            labpo == 'right' and colc1 == col1):\n                            # grouper for groups of ylabels to align\n                            self._align_ylabel_grp.join(ax, axc)",
        "begin_line": 2537,
        "end_line": 2603,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.align_labels#2605",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.align_labels(self, axs=None)",
        "snippet": "    def align_labels(self, axs=None):\n        \"\"\"\n        Align the xlabels and ylabels of subplots with the same subplots\n        row or column (respectively) if label alignment is being\n        done automatically (i.e. the label position is not manually set).\n\n        Alignment persists for draw events after this is called.\n\n        Parameters\n        ----------\n        axs : list of `~matplotlib.axes.Axes`\n            Optional list (or ndarray) of `~matplotlib.axes.Axes`\n            to align the labels.\n            Default is to align all axes on the figure.\n\n        See Also\n        --------\n        matplotlib.figure.Figure.align_xlabels\n\n        matplotlib.figure.Figure.align_ylabels\n        \"\"\"\n        self.align_xlabels(axs=axs)\n        self.align_ylabels(axs=axs)",
        "begin_line": 2605,
        "end_line": 2627,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.Figure.add_gridspec#2629",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure.Figure",
        "signature": "lib.matplotlib.figure.Figure.add_gridspec(self, nrows, ncols, **kwargs)",
        "snippet": "    def add_gridspec(self, nrows, ncols, **kwargs):\n        \"\"\"\n        Return a `.GridSpec` that has this figure as a parent.  This allows\n        complex layout of axes in the figure.\n\n        Parameters\n        ----------\n        nrows : int\n            Number of rows in grid.\n\n        ncols : int\n            Number or columns in grid.\n\n        Returns\n        -------\n        gridspec : `.GridSpec`\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Keyword arguments are passed to `.GridSpec`.\n\n        See Also\n        --------\n        matplotlib.pyplot.subplots\n\n        Examples\n        --------\n        Adding a subplot that spans two rows::\n\n            fig = plt.figure()\n            gs = fig.add_gridspec(2, 2)\n            ax1 = fig.add_subplot(gs[0, 0])\n            ax2 = fig.add_subplot(gs[1, 0])\n            # spans two rows:\n            ax3 = fig.add_subplot(gs[:, 1])\n\n        \"\"\"\n\n        _ = kwargs.pop('figure', None)  # pop in case user has added this...\n        gs = GridSpec(nrows=nrows, ncols=ncols, figure=self, **kwargs)\n        self._gridspecs.append(gs)\n        return gs",
        "begin_line": 2629,
        "end_line": 2671,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.figure.figaspect#2674",
        "src_path": "lib/matplotlib/figure.py",
        "class_name": "lib.matplotlib.figure",
        "signature": "lib.matplotlib.figure.figaspect(arg)",
        "snippet": "def figaspect(arg):\n    \"\"\"\n    Calculate the width and height for a figure with a specified aspect ratio.\n\n    While the height is taken from :rc:`figure.figsize`, the width is\n    adjusted to match the desired aspect ratio. Additionally, it is ensured\n    that the width is in the range [4., 16.] and the height is in the range\n    [2., 16.]. If necessary, the default height is adjusted to ensure this.\n\n    Parameters\n    ----------\n    arg : scalar or 2d array\n        If a scalar, this defines the aspect ratio (i.e. the ratio height /\n        width).\n        In case of an array the aspect ratio is number of rows / number of\n        columns, so that the array could be fitted in the figure undistorted.\n\n    Returns\n    -------\n    width, height\n        The figure size in inches.\n\n    Notes\n    -----\n    If you want to create an axes within the figure, that still preserves the\n    aspect ratio, be sure to create it with equal width and height. See\n    examples below.\n\n    Thanks to Fernando Perez for this function.\n\n    Examples\n    --------\n    Make a figure twice as tall as it is wide::\n\n        w, h = figaspect(2.)\n        fig = Figure(figsize=(w, h))\n        ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\n        ax.imshow(A, **kwargs)\n\n    Make a figure with the proper aspect for an array::\n\n        A = rand(5, 3)\n        w, h = figaspect(A)\n        fig = Figure(figsize=(w, h))\n        ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\n        ax.imshow(A, **kwargs)\n    \"\"\"\n\n    isarray = hasattr(arg, 'shape') and not np.isscalar(arg)\n\n    # min/max sizes to respect when autoscaling.  If John likes the idea, they\n    # could become rc parameters, for now they're hardwired.\n    figsize_min = np.array((4.0, 2.0))  # min length for width/height\n    figsize_max = np.array((16.0, 16.0))  # max length for width/height\n\n    # Extract the aspect ratio of the array\n    if isarray:\n        nr, nc = arg.shape[:2]\n        arr_ratio = nr / nc\n    else:\n        arr_ratio = arg\n\n    # Height of user figure defaults\n    fig_height = mpl.rcParams['figure.figsize'][1]\n\n    # New size for the figure, keeping the aspect ratio of the caller\n    newsize = np.array((fig_height / arr_ratio, fig_height))\n\n    # Sanity checks, don't drop either dimension below figsize_min\n    newsize /= min(1.0, *(newsize / figsize_min))\n\n    # Avoid humongous windows as well\n    newsize /= max(1.0, *(newsize / figsize_max))\n\n    # Finally, if we have a really funky aspect ratio, break it but respect\n    # the min/max dimensions (we don't want figures 10 feet tall!)\n    newsize = np.clip(newsize, figsize_min, figsize_max)\n    return newsize",
        "begin_line": 2674,
        "end_line": 2751,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates._dt64_to_ordinalf#239",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates",
        "signature": "lib.matplotlib.dates._dt64_to_ordinalf(d)",
        "snippet": "def _dt64_to_ordinalf(d):\n    \"\"\"\n    Convert `numpy.datetime64` or an ndarray of those types to Gregorian\n    date as UTC float.  Roundoff is via float64 precision.  Practically:\n    microseconds for dates between 290301 BC, 294241 AD, milliseconds for\n    larger dates (see `numpy.datetime64`).  Nanoseconds aren't possible\n    because we do times compared to ``0001-01-01T00:00:00`` (plus one day).\n    \"\"\"\n\n    # the \"extra\" ensures that we at least allow the dynamic range out to\n    # seconds.  That should get out to +/-2e11 years.\n    extra = (d - d.astype('datetime64[s]')).astype('timedelta64[ns]')\n    t0 = np.datetime64('0001-01-01T00:00:00', 's')\n    dt = (d.astype('datetime64[s]') - t0).astype(np.float64)\n    dt += extra.astype(np.float64) / 1.0e9\n    dt = dt / SEC_PER_DAY + 1.0\n\n    NaT_int = np.datetime64('NaT').astype(np.int64)\n    d_int = d.astype(np.int64)\n    try:\n        dt[d_int == NaT_int] = np.nan\n    except TypeError:\n        if d_int == NaT_int:\n            dt = np.nan\n    return dt",
        "begin_line": 239,
        "end_line": 263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003355704697986577,
            "pseudo_dstar_susp": 0.004524886877828055,
            "pseudo_tarantula_susp": 0.0007651109410864575,
            "pseudo_op2_susp": 0.004048582995951417,
            "pseudo_barinel_susp": 0.0007651109410864575
        }
    },
    {
        "name": "lib.matplotlib.dates._from_ordinalf#266",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates",
        "signature": "lib.matplotlib.dates._from_ordinalf(x, tz=None)",
        "snippet": "def _from_ordinalf(x, tz=None):\n    \"\"\"\n    Convert Gregorian float of the date, preserving hours, minutes,\n    seconds and microseconds.  Return value is a `.datetime`.\n\n    The input date *x* is a float in ordinal days at UTC, and the output will\n    be the specified `.datetime` object corresponding to that time in\n    timezone *tz*, or if *tz* is ``None``, in the timezone specified in\n    :rc:`timezone`.\n    \"\"\"\n    if tz is None:\n        tz = _get_rc_timezone()\n\n    ix, remainder = divmod(x, 1)\n    ix = int(ix)\n    if ix < 1:\n        raise ValueError('Cannot convert {} to a date.  This often happens if '\n                         'non-datetime values are passed to an axis that '\n                         'expects datetime objects.'.format(ix))\n    dt = datetime.datetime.fromordinal(ix).replace(tzinfo=UTC)\n\n    # Since the input date *x* float is unable to preserve microsecond\n    # precision of time representation in non-antique years, the\n    # resulting datetime is rounded to the nearest multiple of\n    # `musec_prec`. A value of 20 is appropriate for current dates.\n    musec_prec = 20\n    remainder_musec = int(round(remainder * MUSECONDS_PER_DAY / musec_prec)\n                          * musec_prec)\n\n    # For people trying to plot with full microsecond precision, enable\n    # an early-year workaround\n    if x < 30 * 365:\n        remainder_musec = int(round(remainder * MUSECONDS_PER_DAY))\n\n    # add hours, minutes, seconds, microseconds\n    dt += datetime.timedelta(microseconds=remainder_musec)\n    return dt.astimezone(tz)",
        "begin_line": 266,
        "end_line": 302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.date2num#337",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates",
        "signature": "lib.matplotlib.dates.date2num(d)",
        "snippet": "def date2num(d):\n    \"\"\"\n    Convert datetime objects to Matplotlib dates.\n\n    Parameters\n    ----------\n    d : `datetime.datetime` or `numpy.datetime64` or sequences of these\n\n    Returns\n    -------\n    float or sequence of floats\n        Number of days (fraction part represents hours, minutes, seconds, ms)\n        since 0001-01-01 00:00:00 UTC, plus one.\n\n    Notes\n    -----\n    The addition of one here is a historical artifact. Also, note that the\n    Gregorian calendar is assumed; this is not universal practice.\n    For details see the module docstring.\n    \"\"\"\n    if hasattr(d, \"values\"):\n        # this unpacks pandas series or dataframes...\n        d = d.values\n    if not np.iterable(d):\n        if (isinstance(d, np.datetime64) or\n                (isinstance(d, np.ndarray) and\n                 np.issubdtype(d.dtype, np.datetime64))):\n            return _dt64_to_ordinalf(d)\n        return _to_ordinalf(d)\n\n    else:\n        d = np.asarray(d)\n        if np.issubdtype(d.dtype, np.datetime64):\n            return _dt64_to_ordinalf(d)\n        if not d.size:\n            return d\n        return _to_ordinalf_np_vectorized(d)",
        "begin_line": 337,
        "end_line": 373,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004280821917808219,
            "pseudo_dstar_susp": 0.0003837298541826554,
            "pseudo_tarantula_susp": 0.0012987012987012987,
            "pseudo_op2_susp": 0.0003837298541826554,
            "pseudo_barinel_susp": 0.0012987012987012987
        }
    },
    {
        "name": "lib.matplotlib.dates.drange#464",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates",
        "signature": "lib.matplotlib.dates.drange(dstart, dend, delta)",
        "snippet": "def drange(dstart, dend, delta):\n    \"\"\"\n    Return a sequence of equally spaced Matplotlib dates.\n\n    The dates start at *dstart* and reach up to, but not including *dend*.\n    They are spaced by *delta*.\n\n    Parameters\n    ----------\n    dstart, dend : `~datetime.datetime`\n        The date limits.\n    delta : `datetime.timedelta`\n        Spacing of the dates.\n\n    Returns\n    -------\n    drange : `numpy.array`\n        A list floats representing Matplotlib dates.\n\n    \"\"\"\n    f1 = date2num(dstart)\n    f2 = date2num(dend)\n    step = delta.total_seconds() / SEC_PER_DAY\n\n    # calculate the difference between dend and dstart in times of delta\n    num = int(np.ceil((f2 - f1) / step))\n\n    # calculate end of the interval which will be generated\n    dinterval_end = dstart + num * delta\n\n    # ensure, that an half open interval will be generated [dstart, dend)\n    if dinterval_end >= dend:\n        # if the endpoint is greater than dend, just subtract one delta\n        dinterval_end -= delta\n        num -= 1\n\n    f2 = date2num(dinterval_end)  # new float-endpoint\n    return np.linspace(f1, f2, num + 1)",
        "begin_line": 464,
        "end_line": 501,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.DateFormatter.__init__#517",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.DateFormatter",
        "signature": "lib.matplotlib.dates.DateFormatter.__init__(self, fmt, tz=None)",
        "snippet": "    def __init__(self, fmt, tz=None):\n        \"\"\"\n        Parameters\n        ----------\n        fmt : str\n            `~datetime.datetime.strftime` format string\n        tz : `datetime.tzinfo`, default: :rc:`timezone`\n            Ticks timezone.\n        \"\"\"\n        if tz is None:\n            tz = _get_rc_timezone()\n        self.fmt = fmt\n        self.tz = tz",
        "begin_line": 517,
        "end_line": 529,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038880248833592535,
            "pseudo_dstar_susp": 0.00035816618911174784,
            "pseudo_tarantula_susp": 0.0008305647840531562,
            "pseudo_op2_susp": 0.00035816618911174784,
            "pseudo_barinel_susp": 0.0008305647840531562
        }
    },
    {
        "name": "lib.matplotlib.dates.AutoDateFormatter.__init__#820",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.AutoDateFormatter",
        "signature": "lib.matplotlib.dates.AutoDateFormatter.__init__(self, locator, tz=None, defaultfmt='%Y-%m-%d')",
        "snippet": "    def __init__(self, locator, tz=None, defaultfmt='%Y-%m-%d'):\n        \"\"\"\n        Autoformat the date labels.  The default format is the one to use\n        if none of the values in ``self.scaled`` are greater than the unit\n        returned by ``locator._get_unit()``.\n        \"\"\"\n        self._locator = locator\n        self._tz = tz\n        self.defaultfmt = defaultfmt\n        self._formatter = DateFormatter(self.defaultfmt, tz)\n        rcParams = matplotlib.rcParams\n        self.scaled = {\n            DAYS_PER_YEAR: rcParams['date.autoformatter.year'],\n            DAYS_PER_MONTH: rcParams['date.autoformatter.month'],\n            1: rcParams['date.autoformatter.day'],\n            1 / HOURS_PER_DAY: rcParams['date.autoformatter.hour'],\n            1 / MINUTES_PER_DAY: rcParams['date.autoformatter.minute'],\n            1 / SEC_PER_DAY: rcParams['date.autoformatter.second'],\n            1 / MUSECONDS_PER_DAY: rcParams['date.autoformatter.microsecond']\n        }",
        "begin_line": 820,
        "end_line": 839,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00037778617302606723,
            "pseudo_dstar_susp": 0.00034916201117318437,
            "pseudo_tarantula_susp": 0.0007358351729212656,
            "pseudo_op2_susp": 0.00034916201117318437,
            "pseudo_barinel_susp": 0.0007358351729212656
        }
    },
    {
        "name": "lib.matplotlib.dates.AutoDateFormatter._set_locator#841",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.AutoDateFormatter",
        "signature": "lib.matplotlib.dates.AutoDateFormatter._set_locator(self, locator)",
        "snippet": "    def _set_locator(self, locator):\n        self._locator = locator",
        "begin_line": 841,
        "end_line": 842,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.rrulewrapper._update_rrule#877",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.rrulewrapper",
        "signature": "lib.matplotlib.dates.rrulewrapper._update_rrule(self, **kwargs)",
        "snippet": "    def _update_rrule(self, **kwargs):\n        tzinfo = self._base_tzinfo\n\n        # rrule does not play nicely with time zones - especially pytz time\n        # zones, it's best to use naive zones and attach timezones once the\n        # datetimes are returned\n        if 'dtstart' in kwargs:\n            dtstart = kwargs['dtstart']\n            if dtstart.tzinfo is not None:\n                if tzinfo is None:\n                    tzinfo = dtstart.tzinfo\n                else:\n                    dtstart = dtstart.astimezone(tzinfo)\n\n                kwargs['dtstart'] = dtstart.replace(tzinfo=None)\n\n        if 'until' in kwargs:\n            until = kwargs['until']\n            if until.tzinfo is not None:\n                if tzinfo is not None:\n                    until = until.astimezone(tzinfo)\n                else:\n                    raise ValueError('until cannot be aware if dtstart '\n                                     'is naive and tzinfo is None')\n\n                kwargs['until'] = until.replace(tzinfo=None)\n\n        self._construct = kwargs.copy()\n        self._tzinfo = tzinfo\n        self._rrule = rrule(**self._construct)",
        "begin_line": 877,
        "end_line": 906,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.rrulewrapper._attach_tzinfo#908",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.rrulewrapper",
        "signature": "lib.matplotlib.dates.rrulewrapper._attach_tzinfo(self, dt, tzinfo)",
        "snippet": "    def _attach_tzinfo(self, dt, tzinfo):\n        # pytz zones are attached by \"localizing\" the datetime\n        if hasattr(tzinfo, 'localize'):\n            return tzinfo.localize(dt, is_dst=True)\n\n        return dt.replace(tzinfo=tzinfo)",
        "begin_line": 908,
        "end_line": 913,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.769622029290537e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.rrulewrapper._aware_return_wrapper#915",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.rrulewrapper",
        "signature": "lib.matplotlib.dates.rrulewrapper._aware_return_wrapper(self, f, returns_list=False)",
        "snippet": "    def _aware_return_wrapper(self, f, returns_list=False):\n        \"\"\"Decorator function that allows rrule methods to handle tzinfo.\"\"\"\n        # This is only necessary if we're actually attaching a tzinfo\n        if self._tzinfo is None:\n            return f\n\n        # All datetime arguments must be naive. If they are not naive, they are\n        # converted to the _tzinfo zone before dropping the zone.\n        def normalize_arg(arg):\n            if isinstance(arg, datetime.datetime) and arg.tzinfo is not None:\n                if arg.tzinfo is not self._tzinfo:\n                    arg = arg.astimezone(self._tzinfo)\n\n                return arg.replace(tzinfo=None)\n\n            return arg\n\n        def normalize_args(args, kwargs):\n            args = tuple(normalize_arg(arg) for arg in args)\n            kwargs = {kw: normalize_arg(arg) for kw, arg in kwargs.items()}\n\n            return args, kwargs\n\n        # There are two kinds of functions we care about - ones that return\n        # dates and ones that return lists of dates.\n        if not returns_list:\n            def inner_func(*args, **kwargs):\n                args, kwargs = normalize_args(args, kwargs)\n                dt = f(*args, **kwargs)\n                return self._attach_tzinfo(dt, self._tzinfo)\n        else:\n            def inner_func(*args, **kwargs):\n                args, kwargs = normalize_args(args, kwargs)\n                dts = f(*args, **kwargs)\n                return [self._attach_tzinfo(dt, self._tzinfo) for dt in dts]\n\n        return functools.wraps(f)(inner_func)",
        "begin_line": 915,
        "end_line": 951,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.rrulewrapper.normalize_args#932",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.rrulewrapper",
        "signature": "lib.matplotlib.dates.rrulewrapper.normalize_args(args, kwargs)",
        "snippet": "        def normalize_args(args, kwargs):\n            args = tuple(normalize_arg(arg) for arg in args)\n            kwargs = {kw: normalize_arg(arg) for kw, arg in kwargs.items()}\n\n            return args, kwargs",
        "begin_line": 932,
        "end_line": 936,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.rrulewrapper.inner_func#946",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.rrulewrapper",
        "signature": "lib.matplotlib.dates.rrulewrapper.inner_func(*args, **kwargs)",
        "snippet": "            def inner_func(*args, **kwargs):\n                args, kwargs = normalize_args(args, kwargs)\n                dts = f(*args, **kwargs)\n                return [self._attach_tzinfo(dt, self._tzinfo) for dt in dts]",
        "begin_line": 946,
        "end_line": 949,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.rrulewrapper.__getattr__#953",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.rrulewrapper",
        "signature": "lib.matplotlib.dates.rrulewrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        if name in self.__dict__:\n            return self.__dict__[name]\n\n        f = getattr(self._rrule, name)\n\n        if name in {'after', 'before'}:\n            return self._aware_return_wrapper(f)\n        elif name in {'xafter', 'xbefore', 'between'}:\n            return self._aware_return_wrapper(f, returns_list=True)\n        else:\n            return f",
        "begin_line": 953,
        "end_line": 964,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.DateLocator.__init__#979",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.DateLocator",
        "signature": "lib.matplotlib.dates.DateLocator.__init__(self, tz=None)",
        "snippet": "    def __init__(self, tz=None):\n        \"\"\"\n        Parameters\n        ----------\n        tz : `datetime.tzinfo`\n        \"\"\"\n        if tz is None:\n            tz = _get_rc_timezone()\n        self.tz = tz",
        "begin_line": 979,
        "end_line": 987,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.dates.DateLocator.viewlim_to_dt#1010",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.DateLocator",
        "signature": "lib.matplotlib.dates.DateLocator.viewlim_to_dt(self)",
        "snippet": "    def viewlim_to_dt(self):\n        \"\"\"\n        Converts the view interval to datetime objects.\n        \"\"\"\n        vmin, vmax = self.axis.get_view_interval()\n        if vmin > vmax:\n            vmin, vmax = vmax, vmin\n        if vmin < 1:\n            raise ValueError('view limit minimum {} is less than 1 and '\n                             'is an invalid Matplotlib date value. This '\n                             'often happens if you pass a non-datetime '\n                             'value to an axis that has datetime units'\n                             .format(vmin))\n        return num2date(vmin, self.tz), num2date(vmax, self.tz)",
        "begin_line": 1010,
        "end_line": 1023,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.RRuleLocator.__init__#1060",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.RRuleLocator",
        "signature": "lib.matplotlib.dates.RRuleLocator.__init__(self, o, tz=None)",
        "snippet": "    def __init__(self, o, tz=None):\n        DateLocator.__init__(self, tz)\n        self.rule = o",
        "begin_line": 1060,
        "end_line": 1062,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.RRuleLocator.tick_values#1073",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.RRuleLocator",
        "signature": "lib.matplotlib.dates.RRuleLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        delta = relativedelta(vmax, vmin)\n\n        # We need to cap at the endpoints of valid datetime\n        try:\n            start = vmin - delta\n        except (ValueError, OverflowError):\n            start = _from_ordinalf(1.0)\n\n        try:\n            stop = vmax + delta\n        except (ValueError, OverflowError):\n            # The magic number!\n            stop = _from_ordinalf(3652059.9999999)\n\n        self.rule.set(dtstart=start, until=stop)\n\n        dates = self.rule.between(vmin, vmax, True)\n        if len(dates) == 0:\n            return date2num([vmin, vmax])\n        return self.raise_if_exceeds(date2num(dates))",
        "begin_line": 1073,
        "end_line": 1093,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.RRuleLocator._get_unit#1095",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.RRuleLocator",
        "signature": "lib.matplotlib.dates.RRuleLocator._get_unit(self)",
        "snippet": "    def _get_unit(self):\n        \"\"\"\n        Return how many days a unit of the locator is; used for\n        intelligent autoscaling.\n        \"\"\"\n        freq = self.rule._rrule._freq\n        return self.get_unit_generic(freq)",
        "begin_line": 1095,
        "end_line": 1101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.RRuleLocator.get_unit_generic#1104",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.RRuleLocator",
        "signature": "lib.matplotlib.dates.RRuleLocator.get_unit_generic(freq)",
        "snippet": "    def get_unit_generic(freq):\n        if freq == YEARLY:\n            return DAYS_PER_YEAR\n        elif freq == MONTHLY:\n            return DAYS_PER_MONTH\n        elif freq == WEEKLY:\n            return DAYS_PER_WEEK\n        elif freq == DAILY:\n            return 1.0\n        elif freq == HOURLY:\n            return 1.0 / HOURS_PER_DAY\n        elif freq == MINUTELY:\n            return 1.0 / MINUTES_PER_DAY\n        elif freq == SECONDLY:\n            return 1.0 / SEC_PER_DAY\n        else:\n            # error\n            return -1   # or should this just return '1'?",
        "begin_line": 1104,
        "end_line": 1121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.RRuleLocator._get_interval#1123",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.RRuleLocator",
        "signature": "lib.matplotlib.dates.RRuleLocator._get_interval(self)",
        "snippet": "    def _get_interval(self):\n        return self.rule._rrule._interval",
        "begin_line": 1123,
        "end_line": 1124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.AutoDateLocator.__init__#1197",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.AutoDateLocator",
        "signature": "lib.matplotlib.dates.AutoDateLocator.__init__(self, tz=None, minticks=5, maxticks=None, interval_multiples=True)",
        "snippet": "    def __init__(self, tz=None, minticks=5, maxticks=None,\n                 interval_multiples=True):\n        \"\"\"\n        Parameters\n        ----------\n        tz : `datetime.tzinfo`\n            Ticks timezone.\n        minticks : int\n            The minimum number of ticks desired; controls whether ticks occur\n            yearly, monthly, etc.\n        maxticks : int\n            The maximum number of ticks desired; controls the interval between\n            ticks (ticking every other, every 3, etc.).  For fine-grained\n            control, this can be a dictionary mapping individual rrule\n            frequency constants (YEARLY, MONTHLY, etc.) to their own maximum\n            number of ticks.  This can be used to keep the number of ticks\n            appropriate to the format chosen in `AutoDateFormatter`. Any\n            frequency not specified in this dictionary is given a default\n            value.\n        interval_multiples : bool, default: True\n            Whether ticks should be chosen to be multiple of the interval,\n            locking them to 'nicer' locations.  For example, this will force\n            the ticks to be at hours 0, 6, 12, 18 when hourly ticking is done\n            at 6 hour intervals.\n        \"\"\"\n        DateLocator.__init__(self, tz)\n        self._locator = YearLocator(tz=tz)\n        self._freq = YEARLY\n        self._freqs = [YEARLY, MONTHLY, DAILY, HOURLY, MINUTELY,\n                       SECONDLY, MICROSECONDLY]\n        self.minticks = minticks\n\n        self.maxticks = {YEARLY: 11, MONTHLY: 12, DAILY: 11, HOURLY: 12,\n                         MINUTELY: 11, SECONDLY: 11, MICROSECONDLY: 8}\n        if maxticks is not None:\n            try:\n                self.maxticks.update(maxticks)\n            except TypeError:\n                # Assume we were given an integer. Use this as the maximum\n                # number of ticks for every frequency and create a\n                # dictionary for this\n                self.maxticks = dict.fromkeys(self._freqs, maxticks)\n        self.interval_multiples = interval_multiples\n        self.intervald = {\n            YEARLY:   [1, 2, 4, 5, 10, 20, 40, 50, 100, 200, 400, 500,\n                       1000, 2000, 4000, 5000, 10000],\n            MONTHLY:  [1, 2, 3, 4, 6],\n            DAILY:    [1, 2, 3, 7, 14, 21],\n            HOURLY:   [1, 2, 3, 4, 6, 12],\n            MINUTELY: [1, 5, 10, 15, 30],\n            SECONDLY: [1, 5, 10, 15, 30],\n            MICROSECONDLY: [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000,\n                            5000, 10000, 20000, 50000, 100000, 200000, 500000,\n                            1000000]}\n        if interval_multiples:\n            # Swap \"3\" for \"4\" in the DAILY list; If we use 3 we get bad\n            # tick loc for months w/ 31 days: 1, 4, ..., 28, 31, 1\n            # If we use 4 then we get: 1, 5, ... 25, 29, 1\n            self.intervald[DAILY] = [1, 2, 4, 7, 14, 21]\n\n        self._byranges = [None, range(1, 13), range(1, 32),\n                          range(0, 24), range(0, 60), range(0, 60), None]",
        "begin_line": 1197,
        "end_line": 1258,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.dates.AutoDateLocator.__call__#1260",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.AutoDateLocator",
        "signature": "lib.matplotlib.dates.AutoDateLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        \"\"\"Return the locations of the ticks.\"\"\"\n        self.refresh()\n        return self._locator()",
        "begin_line": 1260,
        "end_line": 1263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.910273545397844e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.AutoDateLocator.nonsingular#1268",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.AutoDateLocator",
        "signature": "lib.matplotlib.dates.AutoDateLocator.nonsingular(self, vmin, vmax)",
        "snippet": "    def nonsingular(self, vmin, vmax):\n        # whatever is thrown at us, we can scale the unit.\n        # But default nonsingular date plots at an ~4 year period.\n        if not np.isfinite(vmin) or not np.isfinite(vmax):\n            # Except if there is no data, then use 2000-2010 as default.\n            return (date2num(datetime.date(2000, 1, 1)),\n                    date2num(datetime.date(2010, 1, 1)))\n        if vmax < vmin:\n            vmin, vmax = vmax, vmin\n        if vmin == vmax:\n            vmin = vmin - DAYS_PER_YEAR * 2\n            vmax = vmax + DAYS_PER_YEAR * 2\n        return vmin, vmax",
        "begin_line": 1268,
        "end_line": 1280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.AutoDateLocator.set_axis#1282",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.AutoDateLocator",
        "signature": "lib.matplotlib.dates.AutoDateLocator.set_axis(self, axis)",
        "snippet": "    def set_axis(self, axis):\n        DateLocator.set_axis(self, axis)\n        self._locator.set_axis(axis)",
        "begin_line": 1282,
        "end_line": 1284,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.dates.AutoDateLocator.refresh#1286",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.AutoDateLocator",
        "signature": "lib.matplotlib.dates.AutoDateLocator.refresh(self)",
        "snippet": "    def refresh(self):\n        # docstring inherited\n        dmin, dmax = self.viewlim_to_dt()\n        self._locator = self.get_locator(dmin, dmax)",
        "begin_line": 1286,
        "end_line": 1289,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.649770781074301e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.AutoDateLocator._get_unit#1291",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.AutoDateLocator",
        "signature": "lib.matplotlib.dates.AutoDateLocator._get_unit(self)",
        "snippet": "    def _get_unit(self):\n        if self._freq in [MICROSECONDLY]:\n            return 1. / MUSECONDS_PER_DAY\n        else:\n            return RRuleLocator.get_unit_generic(self._freq)",
        "begin_line": 1291,
        "end_line": 1295,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.AutoDateLocator.get_locator#1304",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.AutoDateLocator",
        "signature": "lib.matplotlib.dates.AutoDateLocator.get_locator(self, dmin, dmax)",
        "snippet": "    def get_locator(self, dmin, dmax):\n        \"\"\"Pick the best locator based on a distance.\"\"\"\n        delta = relativedelta(dmax, dmin)\n        tdelta = dmax - dmin\n\n        # take absolute difference\n        if dmin > dmax:\n            delta = -delta\n            tdelta = -tdelta\n\n        # The following uses a mix of calls to relativedelta and timedelta\n        # methods because there is incomplete overlap in the functionality of\n        # these similar functions, and it's best to avoid doing our own math\n        # whenever possible.\n        numYears = float(delta.years)\n        numMonths = numYears * MONTHS_PER_YEAR + delta.months\n        numDays = tdelta.days   # Avoids estimates of days/month, days/year\n        numHours = numDays * HOURS_PER_DAY + delta.hours\n        numMinutes = numHours * MIN_PER_HOUR + delta.minutes\n        numSeconds = np.floor(tdelta.total_seconds())\n        numMicroseconds = np.floor(tdelta.total_seconds() * 1e6)\n\n        nums = [numYears, numMonths, numDays, numHours, numMinutes,\n                numSeconds, numMicroseconds]\n\n        use_rrule_locator = [True] * 6 + [False]\n\n        # Default setting of bymonth, etc. to pass to rrule\n        # [unused (for year), bymonth, bymonthday, byhour, byminute,\n        #  bysecond, unused (for microseconds)]\n        byranges = [None, 1, 1, 0, 0, 0, None]\n\n        # Loop over all the frequencies and try to find one that gives at\n        # least a minticks tick positions.  Once this is found, look for\n        # an interval from an list specific to that frequency that gives no\n        # more than maxticks tick positions. Also, set up some ranges\n        # (bymonth, etc.) as appropriate to be passed to rrulewrapper.\n        for i, (freq, num) in enumerate(zip(self._freqs, nums)):\n            # If this particular frequency doesn't give enough ticks, continue\n            if num < self.minticks:\n                # Since we're not using this particular frequency, set\n                # the corresponding by_ to None so the rrule can act as\n                # appropriate\n                byranges[i] = None\n                continue\n\n            # Find the first available interval that doesn't give too many\n            # ticks\n            for interval in self.intervald[freq]:\n                if num <= interval * (self.maxticks[freq] - 1):\n                    break\n            else:\n                # We went through the whole loop without breaking, default to\n                # the last interval in the list and raise a warning\n                cbook._warn_external(\n                    f\"AutoDateLocator was unable to pick an appropriate \"\n                    f\"interval for this date range. It may be necessary to \"\n                    f\"add an interval value to the AutoDateLocator's \"\n                    f\"intervald dictionary. Defaulting to {interval}.\")\n\n            # Set some parameters as appropriate\n            self._freq = freq\n\n            if self._byranges[i] and self.interval_multiples:\n                byranges[i] = self._byranges[i][::interval]\n                if i in (DAILY, WEEKLY):\n                    if interval == 14:\n                        # just make first and 15th.  Avoids 30th.\n                        byranges[i] = [1, 15]\n                    elif interval == 7:\n                        byranges[i] = [1, 8, 15, 22]\n\n                interval = 1\n            else:\n                byranges[i] = self._byranges[i]\n            break\n        else:\n            raise ValueError('No sensible date limit could be found in the '\n                             'AutoDateLocator.')\n\n        if (freq == YEARLY) and self.interval_multiples:\n            locator = YearLocator(interval, tz=self.tz)\n        elif use_rrule_locator[i]:\n            _, bymonth, bymonthday, byhour, byminute, bysecond, _ = byranges\n            rrule = rrulewrapper(self._freq, interval=interval,\n                                 dtstart=dmin, until=dmax,\n                                 bymonth=bymonth, bymonthday=bymonthday,\n                                 byhour=byhour, byminute=byminute,\n                                 bysecond=bysecond)\n\n            locator = RRuleLocator(rrule, self.tz)\n        else:\n            locator = MicrosecondLocator(interval, tz=self.tz)\n            if dmin.year > 20 and interval < 1000:\n                cbook._warn_external(\n                    'Plotting microsecond time intervals is not well '\n                    'supported; please see the MicrosecondLocator '\n                    'documentation for details.')\n\n        locator.set_axis(self.axis)\n\n        if self.axis is not None:\n            locator.set_view_interval(*self.axis.get_view_interval())\n            locator.set_data_interval(*self.axis.get_data_interval())\n        return locator",
        "begin_line": 1304,
        "end_line": 1408,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.YearLocator.__init__#1423",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.YearLocator",
        "signature": "lib.matplotlib.dates.YearLocator.__init__(self, base=1, month=1, day=1, tz=None)",
        "snippet": "    def __init__(self, base=1, month=1, day=1, tz=None):\n        \"\"\"\n        Mark years that are multiple of base on a given month and day\n        (default jan 1).\n        \"\"\"\n        DateLocator.__init__(self, tz)\n        self.base = ticker._Edge_integer(base, 0)\n        self.replaced = {'month':  month,\n                         'day':    day,\n                         'hour':   0,\n                         'minute': 0,\n                         'second': 0,\n                         }\n        if not hasattr(tz, 'localize'):\n            # if tz is pytz, we need to do this w/ the localize fcn,\n            # otherwise datetime.replace works fine...\n            self.replaced['tzinfo'] = tz",
        "begin_line": 1423,
        "end_line": 1439,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00035174111853675694,
            "pseudo_dstar_susp": 0.00032829940906106366,
            "pseudo_tarantula_susp": 0.0004601932811780948,
            "pseudo_op2_susp": 0.00032829940906106366,
            "pseudo_barinel_susp": 0.0004601932811780948
        }
    },
    {
        "name": "lib.matplotlib.dates.YearLocator.__call__#1441",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.YearLocator",
        "signature": "lib.matplotlib.dates.YearLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        # if no data have been set, this will tank with a ValueError\n        try:\n            dmin, dmax = self.viewlim_to_dt()\n        except ValueError:\n            return []\n\n        return self.tick_values(dmin, dmax)",
        "begin_line": 1441,
        "end_line": 1448,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.714396735962697e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.YearLocator.tick_values#1450",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.YearLocator",
        "signature": "lib.matplotlib.dates.YearLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        ymin = self.base.le(vmin.year) * self.base.step\n        ymax = self.base.ge(vmax.year) * self.base.step\n\n        vmin = vmin.replace(year=ymin, **self.replaced)\n        if hasattr(self.tz, 'localize'):\n            # look after pytz\n            if not vmin.tzinfo:\n                vmin = self.tz.localize(vmin, is_dst=True)\n\n        ticks = [vmin]\n\n        while True:\n            dt = ticks[-1]\n            if dt.year >= ymax:\n                return date2num(ticks)\n            year = dt.year + self.base.step\n            dt = dt.replace(year=year, **self.replaced)\n            if hasattr(self.tz, 'localize'):\n                # look after pytz\n                if not dt.tzinfo:\n                    dt = self.tz.localize(dt, is_dst=True)\n\n            ticks.append(dt)",
        "begin_line": 1450,
        "end_line": 1473,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.DayLocator.__init__#1552",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.DayLocator",
        "signature": "lib.matplotlib.dates.DayLocator.__init__(self, bymonthday=None, interval=1, tz=None)",
        "snippet": "    def __init__(self, bymonthday=None, interval=1, tz=None):\n        \"\"\"\n        Mark every day in *bymonthday*; *bymonthday* can be an int or sequence.\n\n        Default is to tick every day of the month: ``bymonthday=range(1, 32)``.\n        \"\"\"\n        if interval != int(interval) or interval < 1:\n            raise ValueError(\"interval must be an integer greater than 0\")\n        if bymonthday is None:\n            bymonthday = range(1, 32)\n        elif isinstance(bymonthday, np.ndarray):\n            # This fixes a bug in dateutil <= 2.3 which prevents the use of\n            # numpy arrays in (among other things) the bymonthday, byweekday\n            # and bymonth parameters.\n            bymonthday = [x.item() for x in bymonthday.astype(int)]\n\n        rule = rrulewrapper(DAILY, bymonthday=bymonthday,\n                            interval=interval, **self.hms0d)\n        RRuleLocator.__init__(self, rule, tz)",
        "begin_line": 1552,
        "end_line": 1570,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.MinuteLocator.__init__#1597",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.MinuteLocator",
        "signature": "lib.matplotlib.dates.MinuteLocator.__init__(self, byminute=None, interval=1, tz=None)",
        "snippet": "    def __init__(self, byminute=None, interval=1, tz=None):\n        \"\"\"\n        Mark every minute in *byminute*; *byminute* can be an int or\n        sequence.  Default is to tick every minute: ``byminute=range(60)``\n\n        *interval* is the interval between each iteration.  For\n        example, if ``interval=2``, mark every second occurrence.\n        \"\"\"\n        if byminute is None:\n            byminute = range(60)\n\n        rule = rrulewrapper(MINUTELY, byminute=byminute, interval=interval,\n                            bysecond=0)\n        RRuleLocator.__init__(self, rule, tz)",
        "begin_line": 1597,
        "end_line": 1610,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.MicrosecondLocator.__init__#1652",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.MicrosecondLocator",
        "signature": "lib.matplotlib.dates.MicrosecondLocator.__init__(self, interval=1, tz=None)",
        "snippet": "    def __init__(self, interval=1, tz=None):\n        \"\"\"\n        *interval* is the interval between each iteration.  For\n        example, if ``interval=2``, mark every second microsecond.\n\n        \"\"\"\n        self._interval = interval\n        self._wrapped_locator = ticker.MultipleLocator(interval)\n        self.tz = tz",
        "begin_line": 1652,
        "end_line": 1660,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.999000099990002e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.MicrosecondLocator.set_axis#1662",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.MicrosecondLocator",
        "signature": "lib.matplotlib.dates.MicrosecondLocator.set_axis(self, axis)",
        "snippet": "    def set_axis(self, axis):\n        self._wrapped_locator.set_axis(axis)\n        return DateLocator.set_axis(self, axis)",
        "begin_line": 1662,
        "end_line": 1664,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.999000099990002e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.MicrosecondLocator.__call__#1674",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.MicrosecondLocator",
        "signature": "lib.matplotlib.dates.MicrosecondLocator.__call__(self)",
        "snippet": "    def __call__(self):\n        # if no data have been set, this will tank with a ValueError\n        try:\n            dmin, dmax = self.viewlim_to_dt()\n        except ValueError:\n            return []\n\n        return self.tick_values(dmin, dmax)",
        "begin_line": 1674,
        "end_line": 1681,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.999000099990002e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.MicrosecondLocator.tick_values#1683",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.MicrosecondLocator",
        "signature": "lib.matplotlib.dates.MicrosecondLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        nmin, nmax = date2num((vmin, vmax))\n        nmin *= MUSECONDS_PER_DAY\n        nmax *= MUSECONDS_PER_DAY\n        ticks = self._wrapped_locator.tick_values(nmin, nmax)\n        ticks = [tick / MUSECONDS_PER_DAY for tick in ticks]\n        return ticks",
        "begin_line": 1683,
        "end_line": 1689,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.dates.DateConverter.axisinfo#1788",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.DateConverter",
        "signature": "lib.matplotlib.dates.DateConverter.axisinfo(unit, axis)",
        "snippet": "    def axisinfo(unit, axis):\n        \"\"\"\n        Return the `~matplotlib.units.AxisInfo` for *unit*.\n\n        *unit* is a tzinfo instance or None.\n        The *axis* argument is required but not used.\n        \"\"\"\n        tz = unit\n\n        majloc = AutoDateLocator(tz=tz)\n        majfmt = AutoDateFormatter(majloc, tz=tz)\n        datemin = datetime.date(2000, 1, 1)\n        datemax = datetime.date(2010, 1, 1)\n\n        return units.AxisInfo(majloc=majloc, majfmt=majfmt, label='',\n                              default_limits=(datemin, datemax))",
        "begin_line": 1788,
        "end_line": 1803,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00036483035388544326,
            "pseudo_dstar_susp": 0.00033852403520649965,
            "pseudo_tarantula_susp": 0.0006385696040868455,
            "pseudo_op2_susp": 0.00033852403520649965,
            "pseudo_barinel_susp": 0.0006385696040868455
        }
    },
    {
        "name": "lib.matplotlib.dates.DateConverter.convert#1806",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.DateConverter",
        "signature": "lib.matplotlib.dates.DateConverter.convert(value, unit, axis)",
        "snippet": "    def convert(value, unit, axis):\n        \"\"\"\n        If *value* is not already a number or sequence of numbers, convert it\n        with `date2num`.\n\n        The *unit* and *axis* arguments are not used.\n        \"\"\"\n        return date2num(value)",
        "begin_line": 1806,
        "end_line": 1813,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00037778617302606723,
            "pseudo_dstar_susp": 0.00034916201117318437,
            "pseudo_tarantula_susp": 0.0007358351729212656,
            "pseudo_op2_susp": 0.00034916201117318437,
            "pseudo_barinel_susp": 0.0007358351729212656
        }
    },
    {
        "name": "lib.matplotlib.dates.DateConverter.default_units#1816",
        "src_path": "lib/matplotlib/dates.py",
        "class_name": "lib.matplotlib.dates.DateConverter",
        "signature": "lib.matplotlib.dates.DateConverter.default_units(x, axis)",
        "snippet": "    def default_units(x, axis):\n        \"\"\"\n        Return the tzinfo instance of *x* or of its first element, or None\n        \"\"\"\n        if isinstance(x, np.ndarray):\n            x = x.ravel()\n\n        try:\n            x = cbook.safe_first_element(x)\n        except (TypeError, StopIteration):\n            pass\n\n        try:\n            return x.tzinfo\n        except AttributeError:\n            pass\n        return None",
        "begin_line": 1816,
        "end_line": 1832,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003749531308586427,
            "pseudo_dstar_susp": 0.000346860908775581,
            "pseudo_tarantula_susp": 0.0007178750897343862,
            "pseudo_op2_susp": 0.000346860908775581,
            "pseudo_barinel_susp": 0.0007178750897343862
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg._update_methods#107",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg._update_methods(self)",
        "snippet": "    def _update_methods(self):\n        self.draw_gouraud_triangle = self._renderer.draw_gouraud_triangle\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.draw_markers = self._renderer.draw_markers\n        self.draw_path_collection = self._renderer.draw_path_collection\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n        self.get_content_extents = self._renderer.get_content_extents",
        "begin_line": 107,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_rgba_minimized#117",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_rgba_minimized(self)",
        "snippet": "    def tostring_rgba_minimized(self):\n        extents = self.get_content_extents()\n        bbox = [[extents[0], self.height - (extents[1] + extents[3])],\n                [extents[0] + extents[2], self.height - extents[1]]]\n        region = self.copy_from_bbox(bbox)\n        return np.array(region), extents",
        "begin_line": 117,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path#124",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path(self, gc, path, transform, rgbFace=None)",
        "snippet": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        nmax = mpl.rcParams['agg.path.chunksize']  # here at least for testing\n        npts = path.vertices.shape[0]\n\n        if (npts > nmax > 100 and path.should_simplify and\n                rgbFace is None and gc.get_hatch() is None):\n            nch = np.ceil(npts / nmax)\n            chsize = int(np.ceil(npts / nch))\n            i0 = np.arange(0, npts, chsize)\n            i1 = np.zeros_like(i0)\n            i1[:-1] = i0[1:] - 1\n            i1[-1] = npts\n            for ii0, ii1 in zip(i0, i1):\n                v = path.vertices[ii0:ii1, :]\n                c = path.codes\n                if c is not None:\n                    c = c[ii0:ii1]\n                    c[0] = Path.MOVETO  # move to end of last chunk\n                p = Path(v, c)\n                try:\n                    self._renderer.draw_path(gc, p, transform, rgbFace)\n                except OverflowError as err:\n                    raise OverflowError(\n                        \"Exceeded cell block limit (set 'agg.path.chunksize' \"\n                        \"rcparam)\") from err\n        else:\n            try:\n                self._renderer.draw_path(gc, path, transform, rgbFace)\n            except OverflowError as err:\n                raise OverflowError(\"Exceeded cell block limit (set \"\n                                    \"'agg.path.chunksize' rcparam)\") from err",
        "begin_line": 124,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg._get_agg_font#242",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg._get_agg_font(self, prop)",
        "snippet": "    def _get_agg_font(self, prop):\n        \"\"\"\n        Get the font for text instance t, caching for efficiency\n        \"\"\"\n        fname = findfont(prop)\n        font = get_font(fname)\n\n        font.clear()\n        size = prop.get_size_in_points()\n        font.set_size(size, self.dpi)\n\n        return font",
        "begin_line": 242,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.246901949416625e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.buffer_rgba#259",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.buffer_rgba(self)",
        "snippet": "    def buffer_rgba(self):\n        return memoryview(self._renderer)",
        "begin_line": 259,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.RendererAgg.option_image_nocomposite#271",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.RendererAgg",
        "signature": "lib.matplotlib.backends.backend_agg.RendererAgg.option_image_nocomposite(self)",
        "snippet": "    def option_image_nocomposite(self):\n        # docstring inherited\n\n        # It is generally faster to composite each image directly to\n        # the Figure, and there's no file size benefit to compositing\n        # with the Agg backend\n        return True",
        "begin_line": 271,
        "end_line": 277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.draw#374",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg",
        "signature": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.draw(self)",
        "snippet": "    def draw(self):\n        # docstring inherited\n        self.renderer = self.get_renderer(cleared=True)\n        # Acquire a lock on the shared font cache.\n        with RendererAgg.lock, \\\n             (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self.figure.draw(self.renderer)\n            # A GUI class may be need to update a window using this draw, so\n            # don't forget to call the superclass.\n            super().draw()",
        "begin_line": 374,
        "end_line": 384,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.get_renderer#386",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg",
        "signature": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.get_renderer(self, cleared=False)",
        "snippet": "    def get_renderer(self, cleared=False):\n        l, b, w, h = self.figure.bbox.bounds\n        key = w, h, self.figure.dpi\n        reuse_renderer = (hasattr(self, \"renderer\")\n                          and getattr(self, \"_lastKey\", None) == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, self.figure.dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer",
        "begin_line": 386,
        "end_line": 396,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.buffer_rgba#416",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg",
        "signature": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.buffer_rgba(self)",
        "snippet": "    def buffer_rgba(self):\n        \"\"\"\n        Get the image as a `memoryview` to the renderer's buffer.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.buffer_rgba()",
        "begin_line": 416,
        "end_line": 423,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png#433",
        "src_path": "lib/matplotlib/backends/backend_agg.py",
        "class_name": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg",
        "signature": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png(self, filename_or_obj, *args, metadata=None, pil_kwargs=None, **kwargs)",
        "snippet": "    def print_png(self, filename_or_obj, *args,\n                  metadata=None, pil_kwargs=None,\n                  **kwargs):\n        \"\"\"\n        Write the figure to a PNG file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or PathLike or file-like object\n            The file to write to.\n\n        metadata : dict, optional\n            Metadata in the PNG file as key-value pairs of bytes or latin-1\n            encodable strings.\n            According to the PNG specification, keys must be shorter than 79\n            chars.\n\n            The `PNG specification`_ defines some common keywords that may be\n            used as appropriate:\n\n            - Title: Short (one line) title or caption for image.\n            - Author: Name of image's creator.\n            - Description: Description of image (possibly long).\n            - Copyright: Copyright notice.\n            - Creation Time: Time of original image creation\n              (usually RFC 1123 format).\n            - Software: Software used to create the image.\n            - Disclaimer: Legal disclaimer.\n            - Warning: Warning of nature of content.\n            - Source: Device used to create the image.\n            - Comment: Miscellaneous comment;\n              conversion from other image format.\n\n            Other keywords may be invented for other purposes.\n\n            If 'Software' is not given, an autogenerated value for matplotlib\n            will be used.\n\n            For more details see the `PNG specification`_.\n\n            .. _PNG specification: \\\n                https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords\n\n        pil_kwargs : dict, optional\n            Keyword arguments passed to `PIL.Image.Image.save`.\n\n            If the 'pnginfo' key is present, it completely overrides\n            *metadata*, including the default 'Software' key.\n        \"\"\"\n\n        if metadata is None:\n            metadata = {}\n        if pil_kwargs is None:\n            pil_kwargs = {}\n        metadata = {\n            \"Software\":\n                f\"matplotlib version{mpl.__version__}, http://matplotlib.org/\",\n            **metadata,\n        }\n        FigureCanvasAgg.draw(self)\n        # Only use the metadata kwarg if pnginfo is not set, because the\n        # semantics of duplicate keys in pnginfo is unclear.\n        if \"pnginfo\" not in pil_kwargs:\n            pnginfo = PngInfo()\n            for k, v in metadata.items():\n                pnginfo.add_text(k, v)\n            pil_kwargs[\"pnginfo\"] = pnginfo\n        pil_kwargs.setdefault(\"dpi\", (self.figure.dpi, self.figure.dpi))\n        (Image.fromarray(np.asarray(self.buffer_rgba()))\n         .save(filename_or_obj, format=\"png\", **pil_kwargs))",
        "begin_line": 433,
        "end_line": 502,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cm.register_cmap#79",
        "src_path": "lib/matplotlib/cm.py",
        "class_name": "lib.matplotlib.cm",
        "signature": "lib.matplotlib.cm.register_cmap(name=None, cmap=None, data=None, lut=None)",
        "snippet": "def register_cmap(name=None, cmap=None, data=None, lut=None):\n    \"\"\"\n    Add a colormap to the set recognized by :func:`get_cmap`.\n\n    It can be used in two ways::\n\n        register_cmap(name='swirly', cmap=swirly_cmap)\n\n        register_cmap(name='choppy', data=choppydata, lut=128)\n\n    In the first case, *cmap* must be a :class:`matplotlib.colors.Colormap`\n    instance.  The *name* is optional; if absent, the name will\n    be the :attr:`~matplotlib.colors.Colormap.name` attribute of the *cmap*.\n\n    The second case is deprecated. Here, the three arguments are passed to\n    the :class:`~matplotlib.colors.LinearSegmentedColormap` initializer,\n    and the resulting colormap is registered. Instead of this implicit\n    colormap creation, create a `.LinearSegmentedColormap` and use the first\n    case: ``register_cmap(cmap=LinearSegmentedColormap(name, data, lut))``.\n    \"\"\"\n    cbook._check_isinstance((str, None), name=name)\n    if name is None:\n        try:\n            name = cmap.name\n        except AttributeError as err:\n            raise ValueError(\"Arguments must include a name or a \"\n                             \"Colormap\") from err\n    if isinstance(cmap, colors.Colormap):\n        cmap_d[name] = cmap\n        return\n    if lut is not None or data is not None:\n        cbook.warn_deprecated(\n            \"3.3\",\n            message=\"Passing raw data via parameters data and lut to \"\n                    \"register_cmap() is deprecated. Instead use: \"\n                    \"register_cmap(\"\n                    \"cmap=LinearSegmentedColormap(name, data, lut))\")\n    # For the remainder, let exceptions propagate.\n    if lut is None:\n        lut = mpl.rcParams['image.lut']\n    cmap = colors.LinearSegmentedColormap(name, data, lut)\n    cmap_d[name] = cmap",
        "begin_line": 79,
        "end_line": 120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.000090000900009e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cm.get_cmap#123",
        "src_path": "lib/matplotlib/cm.py",
        "class_name": "lib.matplotlib.cm",
        "signature": "lib.matplotlib.cm.get_cmap(name=None, lut=None)",
        "snippet": "def get_cmap(name=None, lut=None):\n    \"\"\"\n    Get a colormap instance, defaulting to rc values if *name* is None.\n\n    Colormaps added with :func:`register_cmap` take precedence over\n    built-in colormaps.\n\n    Parameters\n    ----------\n    name : `matplotlib.colors.Colormap` or str or None, default: None\n        If a `.Colormap` instance, it will be returned.  Otherwise, the name of\n        a colormap known to Matplotlib, which will be resampled by *lut*.  The\n        default, None, means :rc:`image.cmap`.\n    lut : int or None, default: None\n        If *name* is not already a Colormap instance and *lut* is not None, the\n        colormap will be resampled to have *lut* entries in the lookup table.\n    \"\"\"\n    if name is None:\n        name = mpl.rcParams['image.cmap']\n    if isinstance(name, colors.Colormap):\n        return name\n    cbook._check_in_list(sorted(cmap_d), name=name)\n    if lut is None:\n        return cmap_d[name]\n    else:\n        return cmap_d[name]._resample(lut)",
        "begin_line": 123,
        "end_line": 148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.641754546843955e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cm.ScalarMappable.to_rgba#202",
        "src_path": "lib/matplotlib/cm.py",
        "class_name": "lib.matplotlib.cm.ScalarMappable",
        "signature": "lib.matplotlib.cm.ScalarMappable.to_rgba(self, x, alpha=None, bytes=False, norm=True)",
        "snippet": "    def to_rgba(self, x, alpha=None, bytes=False, norm=True):\n        \"\"\"\n        Return a normalized rgba array corresponding to *x*.\n\n        In the normal case, *x* is a 1-D or 2-D sequence of scalars, and\n        the corresponding ndarray of rgba values will be returned,\n        based on the norm and colormap set for this ScalarMappable.\n\n        There is one special case, for handling images that are already\n        rgb or rgba, such as might have been read from an image file.\n        If *x* is an ndarray with 3 dimensions,\n        and the last dimension is either 3 or 4, then it will be\n        treated as an rgb or rgba array, and no mapping will be done.\n        The array can be uint8, or it can be floating point with\n        values in the 0-1 range; otherwise a ValueError will be raised.\n        If it is a masked array, the mask will be ignored.\n        If the last dimension is 3, the *alpha* kwarg (defaulting to 1)\n        will be used to fill in the transparency.  If the last dimension\n        is 4, the *alpha* kwarg is ignored; it does not\n        replace the pre-existing alpha.  A ValueError will be raised\n        if the third dimension is other than 3 or 4.\n\n        In either case, if *bytes* is *False* (default), the rgba\n        array will be floats in the 0-1 range; if it is *True*,\n        the returned rgba array will be uint8 in the 0 to 255 range.\n\n        If norm is False, no normalization of the input data is\n        performed, and it is assumed to be in the range (0-1).\n\n        \"\"\"\n        # First check for special case, image input:\n        try:\n            if x.ndim == 3:\n                if x.shape[2] == 3:\n                    if alpha is None:\n                        alpha = 1\n                    if x.dtype == np.uint8:\n                        alpha = np.uint8(alpha * 255)\n                    m, n = x.shape[:2]\n                    xx = np.empty(shape=(m, n, 4), dtype=x.dtype)\n                    xx[:, :, :3] = x\n                    xx[:, :, 3] = alpha\n                elif x.shape[2] == 4:\n                    xx = x\n                else:\n                    raise ValueError(\"Third dimension must be 3 or 4\")\n                if xx.dtype.kind == 'f':\n                    if norm and (xx.max() > 1 or xx.min() < 0):\n                        raise ValueError(\"Floating point image RGB values \"\n                                         \"must be in the 0..1 range.\")\n                    if bytes:\n                        xx = (xx * 255).astype(np.uint8)\n                elif xx.dtype == np.uint8:\n                    if not bytes:\n                        xx = xx.astype(np.float32) / 255\n                else:\n                    raise ValueError(\"Image RGB array must be uint8 or \"\n                                     \"floating point; found %s\" % xx.dtype)\n                return xx\n        except AttributeError:\n            # e.g., x is not an ndarray; so try mapping it\n            pass\n\n        # This is the normal case, mapping a scalar array:\n        x = ma.asarray(x)\n        if norm:\n            x = self.norm(x)\n        rgba = self.cmap(x, alpha=alpha, bytes=bytes)\n        return rgba",
        "begin_line": 202,
        "end_line": 270,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cm.ScalarMappable.set_array#272",
        "src_path": "lib/matplotlib/cm.py",
        "class_name": "lib.matplotlib.cm.ScalarMappable",
        "signature": "lib.matplotlib.cm.ScalarMappable.set_array(self, A)",
        "snippet": "    def set_array(self, A):\n        \"\"\"Set the image array from numpy array *A*.\n\n        Parameters\n        ----------\n        A : ndarray\n        \"\"\"\n        self._A = A\n        self.update_dict['array'] = True",
        "begin_line": 272,
        "end_line": 280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.148631029986962e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cm.ScalarMappable.set_norm#345",
        "src_path": "lib/matplotlib/cm.py",
        "class_name": "lib.matplotlib.cm.ScalarMappable",
        "signature": "lib.matplotlib.cm.ScalarMappable.set_norm(self, norm)",
        "snippet": "    def set_norm(self, norm):\n        \"\"\"\n        Set the normalization instance.\n\n        Parameters\n        ----------\n        norm : `.Normalize` or None\n\n        Notes\n        -----\n        If there are any colorbars using the mappable for this norm, setting\n        the norm of the mappable will reset the norm, locator, and formatters\n        on the colorbar to default.\n        \"\"\"\n        cbook._check_isinstance((colors.Normalize, None), norm=norm)\n        in_init = self.norm is None\n        if norm is None:\n            norm = colors.Normalize()\n        self.norm = norm\n        if not in_init:\n            self.changed()  # Things are not set up properly yet.",
        "begin_line": 345,
        "end_line": 365,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.714396735962697e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cm.ScalarMappable.check_update#394",
        "src_path": "lib/matplotlib/cm.py",
        "class_name": "lib.matplotlib.cm.ScalarMappable",
        "signature": "lib.matplotlib.cm.ScalarMappable.check_update(self, checker)",
        "snippet": "    def check_update(self, checker):\n        \"\"\"\n        If mappable has changed since the last check,\n        return True; else return False\n        \"\"\"\n        if self.update_dict[checker]:\n            self.update_dict[checker] = False\n            return True\n        return False",
        "begin_line": 394,
        "end_line": 402,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cm.ScalarMappable.changed#404",
        "src_path": "lib/matplotlib/cm.py",
        "class_name": "lib.matplotlib.cm.ScalarMappable",
        "signature": "lib.matplotlib.cm.ScalarMappable.changed(self)",
        "snippet": "    def changed(self):\n        \"\"\"\n        Call this whenever the mappable is changed to notify all the\n        callbackSM listeners to the 'changed' signal\n        \"\"\"\n        self.callbacksSM.process('changed', self)\n\n        for key in self.update_dict:\n            self.update_dict[key] = True\n        self.stale = True",
        "begin_line": 404,
        "end_line": 413,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.escape_comment#79",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg",
        "signature": "lib.matplotlib.backends.backend_svg.escape_comment(s)",
        "snippet": "def escape_comment(s):\n    s = escape_cdata(s)\n    return _escape_xml_comment.sub('- ', s)",
        "begin_line": 79,
        "end_line": 81,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00847457627118644,
            "pseudo_dstar_susp": 0.000628140703517588,
            "pseudo_tarantula_susp": 0.0036496350364963502,
            "pseudo_op2_susp": 0.000628140703517588,
            "pseudo_barinel_susp": 0.0036496350364963502
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.short_float_fmt#93",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg",
        "signature": "lib.matplotlib.backends.backend_svg.short_float_fmt(x)",
        "snippet": "def short_float_fmt(x):\n    \"\"\"\n    Create a short string representation of a float, which is %f\n    formatting with trailing zeros and the decimal point removed.\n    \"\"\"\n    return '{0:f}'.format(x).rstrip('0').rstrip('.')",
        "begin_line": 93,
        "end_line": 98,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008547008547008548,
            "pseudo_dstar_susp": 0.0006693440428380187,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.0006693440428380187,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.XMLWriter.__flush#117",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.XMLWriter",
        "signature": "lib.matplotlib.backends.backend_svg.XMLWriter.__flush(self, indent=True)",
        "snippet": "    def __flush(self, indent=True):\n        # flush internal buffers\n        if self.__open:\n            if indent:\n                self.__write(\">\\n\")\n            else:\n                self.__write(\">\")\n            self.__open = 0\n        if self.__data:\n            data = ''.join(self.__data)\n            self.__write(escape_cdata(data))\n            self.__data = []",
        "begin_line": 117,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000708215297450425,
            "pseudo_dstar_susp": 0.0004268032437046522,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0004268032437046522,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.generate_transform#244",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg",
        "signature": "lib.matplotlib.backends.backend_svg.generate_transform(transform_list=[])",
        "snippet": "def generate_transform(transform_list=[]):\n    if len(transform_list):\n        output = StringIO()\n        for type, value in transform_list:\n            if (type == 'scale' and (value == (1,) or value == (1, 1))\n                    or type == 'translate' and value == (0, 0)\n                    or type == 'rotate' and value == (0,)):\n                continue\n            if type == 'matrix' and isinstance(value, Affine2DBase):\n                value = value.to_values()\n            output.write('%s(%s)' % (\n                type, ' '.join(short_float_fmt(x) for x in value)))\n        return output.getvalue()\n    return ''",
        "begin_line": 244,
        "end_line": 257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01818181818181818,
            "pseudo_dstar_susp": 0.0006435006435006435,
            "pseudo_tarantula_susp": 0.006622516556291391,
            "pseudo_op2_susp": 0.0006435006435006435,
            "pseudo_barinel_susp": 0.006622516556291391
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.generate_css#260",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg",
        "signature": "lib.matplotlib.backends.backend_svg.generate_css(attrib={})",
        "snippet": "def generate_css(attrib={}):\n    if attrib:\n        output = StringIO()\n        attrib = sorted(attrib.items())\n        for k, v in attrib:\n            k = escape_attrib(k)\n            v = escape_attrib(v)\n            output.write(\"%s:%s;\" % (k, v))\n        return output.getvalue()\n    return ''",
        "begin_line": 260,
        "end_line": 269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__#276",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__(self, width, height, svgwriter, basename=None, image_dpi=72)",
        "snippet": "    def __init__(self, width, height, svgwriter, basename=None, image_dpi=72):\n        self.width = width\n        self.height = height\n        self.writer = XMLWriter(svgwriter)\n        self.image_dpi = image_dpi  # actual dpi at which we rasterize stuff\n\n        self._groupd = {}\n        self.basename = basename\n        self._image_counter = itertools.count()\n        self._clipd = OrderedDict()\n        self._markers = {}\n        self._path_collection_id = 0\n        self._hatchd = OrderedDict()\n        self._has_gouraud = False\n        self._n_gradients = 0\n        self._fonts = OrderedDict()\n        self.mathtext_parser = MathTextParser('SVG')\n\n        RendererBase.__init__(self)\n        self._glyph_map = dict()\n        str_height = short_float_fmt(height)\n        str_width = short_float_fmt(width)\n        svgwriter.write(svgProlog)\n        self._start_id = self.writer.start(\n            'svg',\n            width='%spt' % str_width,\n            height='%spt' % str_height,\n            viewBox='0 0 %s %s' % (str_width, str_height),\n            xmlns=\"http://www.w3.org/2000/svg\",\n            version=\"1.1\",\n            attrib={'xmlns:xlink': \"http://www.w3.org/1999/xlink\"})\n        self._write_default_style()",
        "begin_line": 276,
        "end_line": 307,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.finalize#309",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.finalize(self)",
        "snippet": "    def finalize(self):\n        self._write_clips()\n        self._write_hatches()\n        self.writer.close(self._start_id)\n        self.writer.flush()",
        "begin_line": 309,
        "end_line": 313,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG._get_style_dict#408",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG._get_style_dict(self, gc, rgbFace)",
        "snippet": "    def _get_style_dict(self, gc, rgbFace):\n        \"\"\"Generate a style string from the GraphicsContext and rgbFace.\"\"\"\n        attrib = {}\n\n        forced_alpha = gc.get_forced_alpha()\n\n        if gc.get_hatch() is not None:\n            attrib['fill'] = \"url(#%s)\" % self._get_hatch(gc, rgbFace)\n            if (rgbFace is not None and len(rgbFace) == 4 and rgbFace[3] != 1.0\n                    and not forced_alpha):\n                attrib['fill-opacity'] = short_float_fmt(rgbFace[3])\n        else:\n            if rgbFace is None:\n                attrib['fill'] = 'none'\n            else:\n                if tuple(rgbFace[:3]) != (0, 0, 0):\n                    attrib['fill'] = rgb2hex(rgbFace)\n                if (len(rgbFace) == 4 and rgbFace[3] != 1.0\n                        and not forced_alpha):\n                    attrib['fill-opacity'] = short_float_fmt(rgbFace[3])\n\n        if forced_alpha and gc.get_alpha() != 1.0:\n            attrib['opacity'] = short_float_fmt(gc.get_alpha())\n\n        offset, seq = gc.get_dashes()\n        if seq is not None:\n            attrib['stroke-dasharray'] = ','.join(\n                short_float_fmt(val) for val in seq)\n            attrib['stroke-dashoffset'] = short_float_fmt(float(offset))\n\n        linewidth = gc.get_linewidth()\n        if linewidth:\n            rgb = gc.get_rgb()\n            attrib['stroke'] = rgb2hex(rgb)\n            if not forced_alpha and rgb[3] != 1.0:\n                attrib['stroke-opacity'] = short_float_fmt(rgb[3])\n            if linewidth != 1.0:\n                attrib['stroke-width'] = short_float_fmt(linewidth)\n            if gc.get_joinstyle() != 'round':\n                attrib['stroke-linejoin'] = gc.get_joinstyle()\n            if gc.get_capstyle() != 'butt':\n                attrib['stroke-linecap'] = _capstyle_d[gc.get_capstyle()]\n\n        return attrib",
        "begin_line": 408,
        "end_line": 451,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG._get_clip#456",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG._get_clip(self, gc)",
        "snippet": "    def _get_clip(self, gc):\n        cliprect = gc.get_clip_rectangle()\n        clippath, clippath_trans = gc.get_clip_path()\n        if clippath is not None:\n            clippath_trans = self._make_flip_transform(clippath_trans)\n            dictkey = (id(clippath), str(clippath_trans))\n        elif cliprect is not None:\n            x, y, w, h = cliprect.bounds\n            y = self.height-(y+h)\n            dictkey = (x, y, w, h)\n        else:\n            return None\n\n        clip = self._clipd.get(dictkey)\n        if clip is None:\n            oid = self._make_id('p', dictkey)\n            if clippath is not None:\n                self._clipd[dictkey] = ((clippath, clippath_trans), oid)\n            else:\n                self._clipd[dictkey] = (dictkey, oid)\n        else:\n            clip, oid = clip\n        return oid",
        "begin_line": 456,
        "end_line": 478,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG._write_clips#480",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG._write_clips(self)",
        "snippet": "    def _write_clips(self):\n        if not len(self._clipd):\n            return\n        writer = self.writer\n        writer.start('defs')\n        for clip, oid in self._clipd.values():\n            writer.start('clipPath', id=oid)\n            if len(clip) == 2:\n                clippath, clippath_trans = clip\n                path_data = self._convert_path(\n                    clippath, clippath_trans, simplify=False)\n                writer.element('path', d=path_data)\n            else:\n                x, y, w, h = clip\n                writer.element(\n                    'rect',\n                    x=short_float_fmt(x),\n                    y=short_float_fmt(y),\n                    width=short_float_fmt(w),\n                    height=short_float_fmt(h))\n            writer.end('clipPath')\n        writer.end('defs')",
        "begin_line": 480,
        "end_line": 501,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.open_group#503",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.open_group(self, s, gid=None)",
        "snippet": "    def open_group(self, s, gid=None):\n        # docstring inherited\n        if gid:\n            self.writer.start('g', id=gid)\n        else:\n            self._groupd[s] = self._groupd.get(s, 0) + 1\n            self.writer.start('g', id=\"%s_%d\" % (s, self._groupd[s]))",
        "begin_line": 503,
        "end_line": 509,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG._convert_path#519",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG._convert_path(self, path, transform=None, clip=None, simplify=None, sketch=None)",
        "snippet": "    def _convert_path(self, path, transform=None, clip=None, simplify=None,\n                      sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width, self.height)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, sketch, 6,\n            [b'M', b'L', b'Q', b'C', b'z'], False).decode('ascii')",
        "begin_line": 519,
        "end_line": 527,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers#551",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None)",
        "snippet": "    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        if not len(path.vertices):\n            return\n\n        writer = self.writer\n        path_data = self._convert_path(\n            marker_path,\n            marker_trans + Affine2D().scale(1.0, -1.0),\n            simplify=False)\n        style = self._get_style_dict(gc, rgbFace)\n        dictkey = (path_data, generate_css(style))\n        oid = self._markers.get(dictkey)\n        style = generate_css({k: v for k, v in style.items()\n                              if k.startswith('stroke')})\n\n        if oid is None:\n            oid = self._make_id('m', dictkey)\n            writer.start('defs')\n            writer.element('path', id=oid, d=path_data, style=style)\n            writer.end('defs')\n            self._markers[dictkey] = oid\n\n        attrib = {}\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            attrib['clip-path'] = 'url(#%s)' % clipid\n        writer.start('g', attrib=attrib)\n\n        trans_and_flip = self._make_flip_transform(trans)\n        attrib = {'xlink:href': '#%s' % oid}\n        clip = (0, 0, self.width*72, self.height*72)\n        for vertices, code in path.iter_segments(\n                trans_and_flip, clip=clip, simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                attrib['x'] = short_float_fmt(x)\n                attrib['y'] = short_float_fmt(y)\n                attrib['style'] = self._get_style(gc, rgbFace)\n                writer.element('use', attrib=attrib)\n        writer.end('g')",
        "begin_line": 551,
        "end_line": 593,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection#595",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection(self, gc, master_transform, paths, all_transforms, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls, offset_position)",
        "snippet": "    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offsetTrans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is\n        #    (len_path + 5) * uses_per_path\n        # cost of definition+use is\n        #    (len_path + 3) + 9 * uses_per_path\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + 9 * uses_per_path + 3 < (len_path + 5) * uses_per_path\n        if not should_do_optimization:\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offsetTrans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        writer = self.writer\n        path_codes = []\n        writer.start('defs')\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            transform = Affine2D(transform.get_matrix()).scale(1.0, -1.0)\n            d = self._convert_path(path, transform, simplify=False)\n            oid = 'C%x_%x_%s' % (\n                self._path_collection_id, i, self._make_id('', d))\n            writer.element('path', id=oid, d=d)\n            path_codes.append(oid)\n        writer.end('defs')\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, master_transform, all_transforms, path_codes, offsets,\n                offsetTrans, facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n            clipid = self._get_clip(gc0)\n            url = gc0.get_url()\n            if url is not None:\n                writer.start('a', attrib={'xlink:href': url})\n            if clipid is not None:\n                writer.start('g', attrib={'clip-path': 'url(#%s)' % clipid})\n            attrib = {\n                'xlink:href': '#%s' % path_id,\n                'x': short_float_fmt(xo),\n                'y': short_float_fmt(self.height - yo),\n                'style': self._get_style(gc0, rgbFace)\n                }\n            writer.element('use', attrib=attrib)\n            if clipid is not None:\n                writer.end('g')\n            if url is not None:\n                writer.end('a')\n\n        self._path_collection_id += 1",
        "begin_line": 595,
        "end_line": 651,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image#807",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image(self, gc, x, y, im, transform=None)",
        "snippet": "    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n\n        if w == 0 or h == 0:\n            return\n\n        attrib = {}\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            # Can't apply clip-path directly to the image because the\n            # image has a transformation, which would also be applied\n            # to the clip-path\n            self.writer.start('g', attrib={'clip-path': 'url(#%s)' % clipid})\n\n        oid = gc.get_gid()\n        url = gc.get_url()\n        if url is not None:\n            self.writer.start('a', attrib={'xlink:href': url})\n        if mpl.rcParams['svg.image_inline']:\n            buf = BytesIO()\n            Image.fromarray(im).save(buf, format=\"png\")\n            oid = oid or self._make_id('image', buf.getvalue())\n            attrib['xlink:href'] = (\n                \"data:image/png;base64,\\n\" +\n                base64.b64encode(buf.getvalue()).decode('ascii'))\n        else:\n            if self.basename is None:\n                raise ValueError(\"Cannot save image data to filesystem when \"\n                                 \"writing SVG to an in-memory buffer\")\n            filename = '{}.image{}.png'.format(\n                self.basename, next(self._image_counter))\n            _log.info('Writing image file for inclusion: %s', filename)\n            Image.fromarray(im).save(filename)\n            oid = oid or 'Im_' + self._make_id('image', filename)\n            attrib['xlink:href'] = filename\n\n        attrib['id'] = oid\n\n        if transform is None:\n            w = 72.0 * w / self.image_dpi\n            h = 72.0 * h / self.image_dpi\n\n            self.writer.element(\n                'image',\n                transform=generate_transform([\n                    ('scale', (1, -1)), ('translate', (0, -h))]),\n                x=short_float_fmt(x),\n                y=short_float_fmt(-(self.height - y - h)),\n                width=short_float_fmt(w), height=short_float_fmt(h),\n                attrib=attrib)\n        else:\n            alpha = gc.get_alpha()\n            if alpha != 1.0:\n                attrib['opacity'] = short_float_fmt(alpha)\n\n            flipped = (\n                Affine2D().scale(1.0 / w, 1.0 / h) +\n                transform +\n                Affine2D()\n                .translate(x, y)\n                .scale(1.0, -1.0)\n                .translate(0.0, self.height))\n\n            attrib['transform'] = generate_transform(\n                [('matrix', flipped.frozen())])\n            self.writer.element(\n                'image',\n                width=short_float_fmt(w), height=short_float_fmt(h),\n                attrib=attrib)\n\n        if url is not None:\n            self.writer.end('a')\n        if clipid is not None:\n            self.writer.end('g')",
        "begin_line": 807,
        "end_line": 882,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG._update_glyph_map_defs#884",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG._update_glyph_map_defs(self, glyph_map_new)",
        "snippet": "    def _update_glyph_map_defs(self, glyph_map_new):\n        \"\"\"\n        Emit definitions for not-yet-defined glyphs, and record them as having\n        been defined.\n        \"\"\"\n        writer = self.writer\n        if glyph_map_new:\n            writer.start('defs')\n            for char_id, (vertices, codes) in glyph_map_new.items():\n                char_id = self._adjust_char_id(char_id)\n                path_data = self._convert_path(\n                    Path(vertices, codes), simplify=False)\n                writer.element('path', id=char_id, d=path_data)\n            writer.end('defs')\n            self._glyph_map.update(glyph_map_new)",
        "begin_line": 884,
        "end_line": 898,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG._draw_text_as_path#903",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG._draw_text_as_path(self, gc, x, y, s, prop, angle, ismath, mtext=None)",
        "snippet": "    def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath, mtext=None):\n        \"\"\"\n        Draw the text by converting them to paths using the textpath module.\n\n        Parameters\n        ----------\n        s : str\n          text to be converted\n        prop : `matplotlib.font_manager.FontProperties`\n          font property\n        ismath : bool\n          If True, use mathtext parser. If \"TeX\", use *usetex* mode.\n        \"\"\"\n        writer = self.writer\n\n        writer.comment(s)\n\n        glyph_map = self._glyph_map\n\n        text2path = self._text2path\n        color = rgb2hex(gc.get_rgb())\n        fontsize = prop.get_size_in_points()\n\n        style = {}\n        if color != '#000000':\n            style['fill'] = color\n        alpha = gc.get_alpha() if gc.get_forced_alpha() else gc.get_rgb()[3]\n        if alpha != 1:\n            style['opacity'] = short_float_fmt(alpha)\n        font_scale = fontsize / text2path.FONT_SCALE\n        attrib = {\n            'style': generate_css(style),\n            'transform': generate_transform([\n                ('translate', (x, y)),\n                ('rotate', (-angle,)),\n                ('scale', (font_scale, -font_scale))]),\n        }\n        writer.start('g', attrib=attrib)\n\n        if not ismath:\n            font = text2path._get_font(prop)\n            _glyphs = text2path.get_glyphs_with_font(\n                font, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n            self._update_glyph_map_defs(glyph_map_new)\n\n            for glyph_id, xposition, yposition, scale in glyph_info:\n                attrib = {'xlink:href': '#%s' % glyph_id}\n                if xposition != 0.0:\n                    attrib['x'] = short_float_fmt(xposition)\n                if yposition != 0.0:\n                    attrib['y'] = short_float_fmt(yposition)\n                writer.element('use', attrib=attrib)\n\n        else:\n            if ismath == \"TeX\":\n                _glyphs = text2path.get_glyphs_tex(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            else:\n                _glyphs = text2path.get_glyphs_mathtext(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n            self._update_glyph_map_defs(glyph_map_new)\n\n            for char_id, xposition, yposition, scale in glyph_info:\n                char_id = self._adjust_char_id(char_id)\n                writer.element(\n                    'use',\n                    transform=generate_transform([\n                        ('translate', (xposition, yposition)),\n                        ('scale', (scale,)),\n                        ]),\n                    attrib={'xlink:href': '#%s' % char_id})\n\n            for verts, codes in rects:\n                path = Path(verts, codes)\n                path_data = self._convert_path(path, simplify=False)\n                writer.element('path', d=path_data)\n\n        writer.end('g')",
        "begin_line": 903,
        "end_line": 982,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text#1115",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None)",
        "snippet": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            # Cannot apply clip-path directly to the text, because\n            # is has a transformation\n            self.writer.start(\n                'g', attrib={'clip-path': 'url(#%s)' % clipid})\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n\n        if mpl.rcParams['svg.fonttype'] == 'path':\n            self._draw_text_as_path(gc, x, y, s, prop, angle, ismath, mtext)\n        else:\n            self._draw_text_as_text(gc, x, y, s, prop, angle, ismath, mtext)\n\n        if gc.get_url() is not None:\n            self.writer.end('a')\n\n        if clipid is not None:\n            self.writer.end('g')",
        "begin_line": 1115,
        "end_line": 1137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.flipy#1139",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.flipy(self)",
        "snippet": "    def flipy(self):\n        # docstring inherited\n        return True",
        "begin_line": 1139,
        "end_line": 1141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.get_canvas_width_height#1143",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.get_canvas_width_height(self)",
        "snippet": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height",
        "begin_line": 1143,
        "end_line": 1145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent#1147",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.RendererSVG",
        "signature": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent(self, s, prop, ismath)",
        "snippet": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n        return self._text2path.get_text_width_height_descent(s, prop, ismath)",
        "begin_line": 1147,
        "end_line": 1149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg#1158",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG",
        "signature": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg(self, filename, *args, **kwargs)",
        "snippet": "    def print_svg(self, filename, *args, **kwargs):\n        with cbook.open_file_cm(filename, \"w\", encoding=\"utf-8\") as fh:\n\n            filename = getattr(fh, 'name', '')\n            if not isinstance(filename, str):\n                filename = ''\n\n            if cbook.file_requires_unicode(fh):\n                detach = False\n            else:\n                fh = TextIOWrapper(fh, 'utf-8')\n                detach = True\n\n            self._print_svg(filename, fh, **kwargs)\n\n            # Detach underlying stream from wrapper so that it remains open in\n            # the caller.\n            if detach:\n                fh.detach()",
        "begin_line": 1158,
        "end_line": 1176,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG._print_svg#1183",
        "src_path": "lib/matplotlib/backends/backend_svg.py",
        "class_name": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG",
        "signature": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG._print_svg(self, filename, fh, *, dpi=72, bbox_inches_restore=None, **kwargs)",
        "snippet": "    def _print_svg(\n            self, filename, fh, *, dpi=72, bbox_inches_restore=None, **kwargs):\n        self.figure.set_dpi(72.0)\n        width, height = self.figure.get_size_inches()\n        w, h = width * 72, height * 72\n\n        renderer = MixedModeRenderer(\n            self.figure, width, height, dpi,\n            RendererSVG(w, h, fh, filename, dpi),\n            bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n        renderer.finalize()",
        "begin_line": 1183,
        "end_line": 1195,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.backends._backend_pdf_ps._cached_get_afm_from_fname#14",
        "src_path": "lib/matplotlib/backends/_backend_pdf_ps.py",
        "class_name": "lib.matplotlib.backends._backend_pdf_ps",
        "signature": "lib.matplotlib.backends._backend_pdf_ps._cached_get_afm_from_fname(fname)",
        "snippet": "def _cached_get_afm_from_fname(fname):\n    with open(fname, \"rb\") as fh:\n        return AFM(fh)",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends._backend_pdf_ps.CharacterTracker.track#39",
        "src_path": "lib/matplotlib/backends/_backend_pdf_ps.py",
        "class_name": "lib.matplotlib.backends._backend_pdf_ps.CharacterTracker",
        "signature": "lib.matplotlib.backends._backend_pdf_ps.CharacterTracker.track(self, font, s)",
        "snippet": "    def track(self, font, s):\n        \"\"\"Record that string *s* is being typeset using font *font*.\"\"\"\n        if isinstance(font, str):\n            # Unused, can be removed after removal of track_characters.\n            fname = font\n        else:\n            fname = font.fname\n        self.used.setdefault(fname, set()).update(map(ord, s))",
        "begin_line": 39,
        "end_line": 46,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.73591333973967e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends._backend_pdf_ps.RendererPDFPSBase.get_canvas_width_height#77",
        "src_path": "lib/matplotlib/backends/_backend_pdf_ps.py",
        "class_name": "lib.matplotlib.backends._backend_pdf_ps.RendererPDFPSBase",
        "signature": "lib.matplotlib.backends._backend_pdf_ps.RendererPDFPSBase.get_canvas_width_height(self)",
        "snippet": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width * 72.0, self.height * 72.0",
        "begin_line": 77,
        "end_line": 79,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.539709649871905e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends._backend_pdf_ps.RendererPDFPSBase.get_text_width_height_descent#81",
        "src_path": "lib/matplotlib/backends/_backend_pdf_ps.py",
        "class_name": "lib.matplotlib.backends._backend_pdf_ps.RendererPDFPSBase",
        "signature": "lib.matplotlib.backends._backend_pdf_ps.RendererPDFPSBase.get_text_width_height_descent(self, s, prop, ismath)",
        "snippet": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n        if mpl.rcParams[\"text.usetex\"]:\n            texmanager = self.get_texmanager()\n            fontsize = prop.get_size_in_points()\n            w, h, d = texmanager.get_text_width_height_descent(\n                s, fontsize, renderer=self)\n            return w, h, d\n        elif ismath:\n            parse = self.mathtext_parser.parse(s, 72, prop)\n            return parse.width, parse.height, parse.depth\n        elif mpl.rcParams[self._use_afm_rc_name]:\n            font = self._get_font_afm(prop)\n            l, b, w, h, d = font.get_str_bbox_and_descent(s)\n            scale = prop.get_size_in_points() / 1000\n            w *= scale\n            h *= scale\n            d *= scale\n            return w, h, d\n        else:\n            font = self._get_font_ttf(prop)\n            font.set_text(s, 0.0, flags=ft2font.LOAD_NO_HINTING)\n            w, h = font.get_width_height()\n            d = font.get_descent()\n            scale = 1 / 64\n            w *= scale\n            h *= scale\n            d *= scale\n            return w, h, d",
        "begin_line": 81,
        "end_line": 109,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.690362388111584e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends._backend_pdf_ps.RendererPDFPSBase._get_font_ttf#116",
        "src_path": "lib/matplotlib/backends/_backend_pdf_ps.py",
        "class_name": "lib.matplotlib.backends._backend_pdf_ps.RendererPDFPSBase",
        "signature": "lib.matplotlib.backends._backend_pdf_ps.RendererPDFPSBase._get_font_ttf(self, prop)",
        "snippet": "    def _get_font_ttf(self, prop):\n        fname = font_manager.findfont(prop)\n        font = font_manager.get_font(fname)\n        font.clear()\n        font.set_size(prop.get_size_in_points(), 72)\n        return font",
        "begin_line": 116,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.154155986818015e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot._get_required_interactive_framework#182",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot._get_required_interactive_framework(backend_mod)",
        "snippet": "def _get_required_interactive_framework(backend_mod):\n    return getattr(\n        backend_mod.FigureCanvas, \"required_interactive_framework\", None)",
        "begin_line": 182,
        "end_line": 184,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03225806451612903,
            "pseudo_dstar_susp": 0.125,
            "pseudo_tarantula_susp": 0.0004366812227074236,
            "pseudo_op2_susp": 0.09090909090909091,
            "pseudo_barinel_susp": 0.0004366812227074236
        }
    },
    {
        "name": "lib.matplotlib.pyplot.switch_backend#187",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.switch_backend(newbackend)",
        "snippet": "def switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n\n    close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in [\n                \"macosx\", \"qt5agg\", \"qt4agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]:\n            try:\n                switch_backend(candidate)\n            except ImportError:\n                continue\n            else:\n                rcParamsOrig['backend'] = candidate\n                return\n        else:\n            # Switching to Agg should always succeed; if it doesn't, let the\n            # exception propagate out.\n            switch_backend(\"agg\")\n            rcParamsOrig[\"backend\"] = \"agg\"\n            return\n\n    # Backends are implemented as modules, but \"inherit\" default method\n    # implementations from backend_bases._Backend.  This is achieved by\n    # creating a \"class\" that inherits from backend_bases._Backend and whose\n    # body is filled with the module's globals.\n\n    backend_name = cbook._backend_module_name(newbackend)\n\n    class backend_mod(matplotlib.backend_bases._Backend):\n        locals().update(vars(importlib.import_module(backend_name)))\n\n    required_framework = _get_required_interactive_framework(backend_mod)\n    if required_framework is not None:\n        current_framework = cbook._get_running_interactive_framework()\n        if (current_framework and required_framework\n                and current_framework != required_framework):\n            raise ImportError(\n                \"Cannot load backend {!r} which requires the {!r} interactive \"\n                \"framework, as {!r} is currently running\".format(\n                    newbackend, required_framework, current_framework))\n\n    _log.debug(\"Loaded backend %s version %s.\",\n               newbackend, backend_mod.backend_version)\n\n    rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n    _backend_mod = backend_mod\n    for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n        globals()[func_name].__signature__ = inspect.signature(\n            getattr(backend_mod, func_name))\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    matplotlib.backends.backend = newbackend",
        "begin_line": 187,
        "end_line": 255,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.backend_mod.switch_backend#187",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot.backend_mod",
        "signature": "lib.matplotlib.pyplot.backend_mod.switch_backend(newbackend)",
        "snippet": "def switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The argument is case-insensitive.  Switching to an interactive backend is\n    possible only if no event loop for another interactive backend has started.\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n\n    close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        # Don't try to fallback on the cairo-based backends as they each have\n        # an additional dependency (pycairo) over the agg-based backend, and\n        # are of worse quality.\n        for candidate in [\n                \"macosx\", \"qt5agg\", \"qt4agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]:\n            try:\n                switch_backend(candidate)\n            except ImportError:\n                continue\n            else:\n                rcParamsOrig['backend'] = candidate\n                return\n        else:\n            # Switching to Agg should always succeed; if it doesn't, let the\n            # exception propagate out.\n            switch_backend(\"agg\")\n            rcParamsOrig[\"backend\"] = \"agg\"\n            return\n\n    # Backends are implemented as modules, but \"inherit\" default method\n    # implementations from backend_bases._Backend.  This is achieved by\n    # creating a \"class\" that inherits from backend_bases._Backend and whose\n    # body is filled with the module's globals.\n\n    backend_name = cbook._backend_module_name(newbackend)\n\n    class backend_mod(matplotlib.backend_bases._Backend):\n        locals().update(vars(importlib.import_module(backend_name)))\n\n    required_framework = _get_required_interactive_framework(backend_mod)\n    if required_framework is not None:\n        current_framework = cbook._get_running_interactive_framework()\n        if (current_framework and required_framework\n                and current_framework != required_framework):\n            raise ImportError(\n                \"Cannot load backend {!r} which requires the {!r} interactive \"\n                \"framework, as {!r} is currently running\".format(\n                    newbackend, required_framework, current_framework))\n\n    _log.debug(\"Loaded backend %s version %s.\",\n               newbackend, backend_mod.backend_version)\n\n    rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n    _backend_mod = backend_mod\n    for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n        globals()[func_name].__signature__ = inspect.signature(\n            getattr(backend_mod, func_name))\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    matplotlib.backends.backend = newbackend",
        "begin_line": 187,
        "end_line": 255,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot._warn_if_gui_out_of_main_thread#258",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot._warn_if_gui_out_of_main_thread()",
        "snippet": "def _warn_if_gui_out_of_main_thread():\n    if (_get_required_interactive_framework(_backend_mod)\n            and threading.current_thread() is not threading.main_thread()):\n        cbook._warn_external(\n            \"Starting a Matplotlib GUI outside of the main thread will likely \"\n            \"fail.\")",
        "begin_line": 258,
        "end_line": 263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006891798759476223,
            "pseudo_dstar_susp": 0.0014005602240896359,
            "pseudo_tarantula_susp": 0.0014084507042253522,
            "pseudo_op2_susp": 0.0014005602240896359,
            "pseudo_barinel_susp": 0.0014084507042253522
        }
    },
    {
        "name": "lib.matplotlib.pyplot.new_figure_manager#267",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.new_figure_manager(*args, **kwargs)",
        "snippet": "def new_figure_manager(*args, **kwargs):\n    \"\"\"Create a new figure manager instance.\"\"\"\n    _warn_if_gui_out_of_main_thread()\n    return _backend_mod.new_figure_manager(*args, **kwargs)",
        "begin_line": 267,
        "end_line": 270,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016474464579901153,
            "pseudo_dstar_susp": 0.0027548209366391185,
            "pseudo_tarantula_susp": 0.0012610340479192938,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0012626262626262627
        }
    },
    {
        "name": "lib.matplotlib.pyplot.show#279",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.show(*args, **kwargs)",
        "snippet": "def show(*args, **kwargs):\n    \"\"\"\n    Display all figures.\n\n    When running in ipython with its pylab mode, display all\n    figures and return to the ipython prompt.\n\n    In non-interactive mode, display all figures and block until\n    the figures have been closed; in interactive mode it has no\n    effect unless figures were created prior to a change from\n    non-interactive to interactive mode (not recommended).  In\n    that case it displays the figures but does not block.\n\n    Parameters\n    ----------\n    block : bool, optional\n        This is experimental, and may be set to ``True`` or ``False`` to\n        override the blocking behavior described above.\n    \"\"\"\n    _warn_if_gui_out_of_main_thread()\n    return _backend_mod.show(*args, **kwargs)",
        "begin_line": 279,
        "end_line": 299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.rc_context#351",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.rc_context(rc=None, fname=None)",
        "snippet": "def rc_context(rc=None, fname=None):\n    return matplotlib.rc_context(rc, fname)",
        "begin_line": 351,
        "end_line": 352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.xkcd#380",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.xkcd(scale=1, length=100, randomness=2)",
        "snippet": "def xkcd(scale=1, length=100, randomness=2):\n    \"\"\"\n    Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.\n    This will only have effect on things drawn after this function is\n    called.\n\n    For best results, the \"Humor Sans\" font should be installed: it is\n    not included with matplotlib.\n\n    Parameters\n    ----------\n    scale : float, optional\n        The amplitude of the wiggle perpendicular to the source line.\n    length : float, optional\n        The length of the wiggle along the line.\n    randomness : float, optional\n        The scale factor by which the length is shrunken or expanded.\n\n    Notes\n    -----\n    This function works by a number of rcParams, so it will probably\n    override others you have set before.\n\n    If you want the effects of this function to be temporary, it can\n    be used as a context manager, for example::\n\n        with plt.xkcd():\n            # This figure will be in XKCD-style\n            fig1 = plt.figure()\n            # ...\n\n        # This figure will be in regular style\n        fig2 = plt.figure()\n    \"\"\"\n    if rcParams['text.usetex']:\n        raise RuntimeError(\n            \"xkcd mode is not compatible with text.usetex = True\")\n\n    from matplotlib import patheffects\n    return rc_context({\n        'font.family': ['xkcd', 'xkcd Script', 'Humor Sans', 'Comic Neue',\n                        'Comic Sans MS'],\n        'font.size': 14.0,\n        'path.sketch': (scale, length, randomness),\n        'path.effects': [patheffects.withStroke(linewidth=4, foreground=\"w\")],\n        'axes.linewidth': 1.5,\n        'lines.linewidth': 2.0,\n        'figure.facecolor': 'white',\n        'grid.linewidth': 0.0,\n        'axes.grid': False,\n        'axes.unicode_minus': False,\n        'axes.edgecolor': 'black',\n        'xtick.major.size': 8,\n        'xtick.major.width': 3,\n        'ytick.major.size': 8,\n        'ytick.major.width': 3,\n    })",
        "begin_line": 380,
        "end_line": 436,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.figure#441",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True, FigureClass=Figure, clear=False, **kwargs)",
        "snippet": "def figure(num=None,  # autoincrement if None, else integer from 1-N\n           figsize=None,  # defaults to rc figure.figsize\n           dpi=None,  # defaults to rc figure.dpi\n           facecolor=None,  # defaults to rc figure.facecolor\n           edgecolor=None,  # defaults to rc figure.edgecolor\n           frameon=True,\n           FigureClass=Figure,\n           clear=False,\n           **kwargs\n           ):\n    \"\"\"\n    Create a new figure, or activate an existing figure.\n\n    Parameters\n    ----------\n    num : int or str, optional\n        A unique identifier for the figure.\n\n        If a figure with that identifier already exists, this figure is made\n        active and returned. An integer refers to the ``Figure.number``\n        attribute, a string refers to the figure label.\n\n        If there is no figure with the identifier or *num* is not given, a new\n        figure is created, made active and returned.  If *num* is an int, it\n        will be used for the ``Figure.number`` attribute, otherwise, an\n        auto-generated integer value is used (starting at 1 and incremented\n        for each new figure). If *num* is a string, the figure label and the\n        window title is set to this value.\n\n    figsize : (float, float), default: :rc:`figure.figsize`\n        Width, height in inches.\n\n    dpi : float, default: :rc:`figure.dpi`\n        The resolution of the figure in dots-per-inch.\n\n    facecolor : color, default: :rc:`figure.facecolor`\n        The background color.\n\n    edgecolor : color, default: :rc:`figure.edgecolor`\n        The border color.\n\n    frameon : bool, default: True\n        If False, suppress drawing the figure frame.\n\n    FigureClass : subclass of `~matplotlib.figure.Figure`\n        Optionally use a custom `.Figure` instance.\n\n    clear : bool, default: False\n        If True and the figure already exists, then it is cleared.\n\n    Returns\n    -------\n    figure : `~matplotlib.figure.Figure`\n        The `.Figure` instance returned will also be passed to\n        new_figure_manager in the backends, which allows to hook custom\n        `.Figure` classes into the pyplot interface. Additional kwargs will be\n        passed to the `.Figure` init function.\n\n    Notes\n    -----\n    If you are creating many figures, make sure you explicitly call\n    `.pyplot.close` on the figures you are not using, because this will\n    enable pyplot to properly clean up the memory.\n\n    `~matplotlib.rcParams` defines the default values, which can be modified\n    in the matplotlibrc file.\n    \"\"\"\n\n    if figsize is None:\n        figsize = rcParams['figure.figsize']\n    if dpi is None:\n        dpi = rcParams['figure.dpi']\n    if facecolor is None:\n        facecolor = rcParams['figure.facecolor']\n    if edgecolor is None:\n        edgecolor = rcParams['figure.edgecolor']\n\n    allnums = get_fignums()\n    next_num = max(allnums) + 1 if allnums else 1\n    figLabel = ''\n    if num is None:\n        num = next_num\n    elif isinstance(num, str):\n        figLabel = num\n        allLabels = get_figlabels()\n        if figLabel not in allLabels:\n            if figLabel == 'all':\n                cbook._warn_external(\n                    \"close('all') closes all existing figures\")\n            num = next_num\n        else:\n            inum = allLabels.index(figLabel)\n            num = allnums[inum]\n    else:\n        num = int(num)  # crude validation of num argument\n\n    figManager = _pylab_helpers.Gcf.get_fig_manager(num)\n    if figManager is None:\n        max_open_warning = rcParams['figure.max_open_warning']\n\n        if len(allnums) == max_open_warning >= 1:\n            cbook._warn_external(\n                \"More than %d figures have been opened. Figures \"\n                \"created through the pyplot interface \"\n                \"(`matplotlib.pyplot.figure`) are retained until \"\n                \"explicitly closed and may consume too much memory. \"\n                \"(To control this warning, see the rcParam \"\n                \"`figure.max_open_warning`).\" %\n                max_open_warning, RuntimeWarning)\n\n        if get_backend().lower() == 'ps':\n            dpi = 72\n\n        figManager = new_figure_manager(num, figsize=figsize,\n                                        dpi=dpi,\n                                        facecolor=facecolor,\n                                        edgecolor=edgecolor,\n                                        frameon=frameon,\n                                        FigureClass=FigureClass,\n                                        **kwargs)\n\n        if figLabel:\n            figManager.set_window_title(figLabel)\n            figManager.canvas.figure.set_label(figLabel)\n\n        # make this figure current on button press event\n        def make_active(event):\n            _pylab_helpers.Gcf.set_active(figManager)\n\n        cid = figManager.canvas.mpl_connect('button_press_event', make_active)\n        figManager._cidgcf = cid\n\n        _pylab_helpers.Gcf.set_active(figManager)\n        fig = figManager.canvas.figure\n        fig.number = num\n\n        # make sure backends (inline) that we don't ship that expect this\n        # to be called in plotting commands to make the figure call show\n        # still work.  There is probably a better way to do this in the\n        # FigureManager base class.\n        if matplotlib.is_interactive():\n            draw_if_interactive()\n\n        if _INSTALL_FIG_OBSERVER:\n            fig.stale_callback = _auto_draw_if_interactive\n\n    if clear:\n        figManager.canvas.figure.clear()\n\n    return figManager.canvas.figure",
        "begin_line": 441,
        "end_line": 590,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001697792869269949,
            "pseudo_dstar_susp": 0.0028169014084507044,
            "pseudo_tarantula_susp": 0.0006887052341597796,
            "pseudo_op2_susp": 0.0028169014084507044,
            "pseudo_barinel_susp": 0.0006887052341597796
        }
    },
    {
        "name": "lib.matplotlib.pyplot.make_active#567",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.make_active(event)",
        "snippet": "        def make_active(event):\n            _pylab_helpers.Gcf.set_active(figManager)",
        "begin_line": 567,
        "end_line": 568,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006839945280437756,
            "pseudo_dstar_susp": 0.0013831258644536654,
            "pseudo_tarantula_susp": 0.0003883495145631068,
            "pseudo_op2_susp": 0.0013831258644536654,
            "pseudo_barinel_susp": 0.0003883495145631068
        }
    },
    {
        "name": "lib.matplotlib.pyplot._auto_draw_if_interactive#593",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot._auto_draw_if_interactive(fig, val)",
        "snippet": "def _auto_draw_if_interactive(fig, val):\n    \"\"\"\n    This is an internal helper function for making sure that auto-redrawing\n    works as intended in the plain python repl.\n\n    Parameters\n    ----------\n    fig : Figure\n        A figure object which is assumed to be associated with a canvas\n    \"\"\"\n    if (val and matplotlib.is_interactive()\n            and not fig.canvas.is_saving()\n            and not fig.canvas._is_idle_drawing):\n        # Some artists can mark themselves as stale in the middle of drawing\n        # (e.g. axes position & tick labels being computed at draw time), but\n        # this shouldn't trigger a redraw because the current redraw will\n        # already take them into account.\n        with fig.canvas._idle_draw_cntx():\n            fig.canvas.draw_idle()",
        "begin_line": 593,
        "end_line": 611,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006345177664974619,
            "pseudo_dstar_susp": 0.0012224938875305623,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0012224938875305623,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.pyplot.gcf#614",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.gcf()",
        "snippet": "def gcf():\n    \"\"\"\n    Get the current figure.\n\n    If no current figure exists, a new one is created using\n    `~.pyplot.figure()`.\n    \"\"\"\n    figManager = _pylab_helpers.Gcf.get_active()\n    if figManager is not None:\n        return figManager.canvas.figure\n    else:\n        return figure()",
        "begin_line": 614,
        "end_line": 625,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003252032520325203,
            "pseudo_dstar_susp": 0.0003160556257901391,
            "pseudo_tarantula_susp": 0.00041050903119868636,
            "pseudo_op2_susp": 0.0003160556257901391,
            "pseudo_barinel_susp": 0.00041050903119868636
        }
    },
    {
        "name": "lib.matplotlib.pyplot.get_fignums#633",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.get_fignums()",
        "snippet": "def get_fignums():\n    \"\"\"Return a list of existing figure numbers.\"\"\"\n    return sorted(_pylab_helpers.Gcf.figs)",
        "begin_line": 633,
        "end_line": 635,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016233766233766235,
            "pseudo_dstar_susp": 0.0027100271002710027,
            "pseudo_tarantula_susp": 0.001128668171557562,
            "pseudo_op2_susp": 0.0027100271002710027,
            "pseudo_barinel_susp": 0.001128668171557562
        }
    },
    {
        "name": "lib.matplotlib.pyplot.get_figlabels#638",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.get_figlabels()",
        "snippet": "def get_figlabels():\n    \"\"\"Return a list of existing figure labels.\"\"\"\n    figManagers = _pylab_helpers.Gcf.get_all_fig_managers()\n    figManagers.sort(key=lambda m: m.num)\n    return [m.canvas.figure.get_label() for m in figManagers]",
        "begin_line": 638,
        "end_line": 642,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.close#672",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.close(fig=None)",
        "snippet": "def close(fig=None):\n    \"\"\"\n    Close a figure window.\n\n    Parameters\n    ----------\n    fig : None or int or str or `.Figure`\n        The figure to close. There are a number of ways to specify this:\n\n        - *None*: the current figure\n        - `.Figure`: the given `.Figure` instance\n        - ``int``: a figure number\n        - ``str``: a figure name\n        - 'all': all figures\n\n    \"\"\"\n    if fig is None:\n        figManager = _pylab_helpers.Gcf.get_active()\n        if figManager is None:\n            return\n        else:\n            _pylab_helpers.Gcf.destroy(figManager.num)\n    elif fig == 'all':\n        _pylab_helpers.Gcf.destroy_all()\n    elif isinstance(fig, int):\n        _pylab_helpers.Gcf.destroy(fig)\n    elif hasattr(fig, 'int'):\n        # if we are dealing with a type UUID, we\n        # can use its integer representation\n        _pylab_helpers.Gcf.destroy(fig.int)\n    elif isinstance(fig, str):\n        allLabels = get_figlabels()\n        if fig in allLabels:\n            num = get_fignums()[allLabels.index(fig)]\n            _pylab_helpers.Gcf.destroy(num)\n    elif isinstance(fig, Figure):\n        _pylab_helpers.Gcf.destroy_fig(fig)\n    else:\n        raise TypeError(\"close() argument must be a Figure, an int, a string, \"\n                        \"or None, not '%s'\")",
        "begin_line": 672,
        "end_line": 711,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008333333333333333,
            "pseudo_dstar_susp": 0.004347826086956522,
            "pseudo_tarantula_susp": 0.00234192037470726,
            "pseudo_op2_susp": 0.004366812227074236,
            "pseudo_barinel_susp": 0.00234192037470726
        }
    },
    {
        "name": "lib.matplotlib.pyplot.draw#719",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.draw()",
        "snippet": "def draw():\n    \"\"\"\n    Redraw the current figure.\n\n    This is used to update a figure that has been altered, but not\n    automatically re-drawn.  If interactive mode is on (via `.ion()`), this\n    should be only rarely needed, but there may be ways to modify the state of\n    a figure without marking it as \"stale\".  Please report these cases as bugs.\n\n    This is equivalent to calling ``fig.canvas.draw_idle()``, where ``fig`` is\n    the current figure.\n    \"\"\"\n    gcf().canvas.draw_idle()",
        "begin_line": 719,
        "end_line": 731,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.savefig#735",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.savefig(*args, **kwargs)",
        "snippet": "def savefig(*args, **kwargs):\n    fig = gcf()\n    res = fig.savefig(*args, **kwargs)\n    fig.canvas.draw_idle()   # need this if 'transparent=True' to reset colors\n    return res",
        "begin_line": 735,
        "end_line": 739,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.axes#754",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.axes(arg=None, **kwargs)",
        "snippet": "def axes(arg=None, **kwargs):\n    \"\"\"\n    Add an axes to the current figure and make it the current axes.\n\n    Call signatures::\n\n        plt.axes()\n        plt.axes(rect, projection=None, polar=False, **kwargs)\n        plt.axes(ax)\n\n    Parameters\n    ----------\n    arg : None or 4-tuple\n        The exact behavior of this function depends on the type:\n\n        - *None*: A new full window axes is added using\n          ``subplot(111, **kwargs)``\n        - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.\n          A new axes is added with dimensions *rect* in normalized\n          (0, 1) units using `~.Figure.add_axes` on the current figure.\n\n    projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n'polar', 'rectilinear', str}, optional\n        The projection type of the `~.axes.Axes`. *str* is the name of\n        a custom projection, see `~matplotlib.projections`. The default\n        None results in a 'rectilinear' projection.\n\n    polar : bool, default: False\n        If True, equivalent to projection='polar'.\n\n    sharex, sharey : `~.axes.Axes`, optional\n        Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n        The axis will have the same limits, ticks, and scale as the axis\n        of the shared axes.\n\n    label : str\n        A label for the returned axes.\n\n    Other Parameters\n    ----------------\n    **kwargs\n        This method also takes the keyword arguments for\n        the returned axes class. The keyword arguments for the\n        rectilinear axes class `~.axes.Axes` can be found in\n        the following table but there might also be other keyword\n        arguments if another projection is used, see the actual axes\n        class.\n\n        %(Axes)s\n\n    Returns\n    -------\n    axes : `~.axes.Axes` (or a subclass of `~.axes.Axes`)\n        The returned axes class depends on the projection used. It is\n        `~.axes.Axes` if rectilinear projection are used and\n        `.projections.polar.PolarAxes` if polar projection\n        are used.\n\n    Notes\n    -----\n    If the figure already has a axes with key (*args*,\n    *kwargs*) then it will simply make that axes current and\n    return it.  This behavior is deprecated. Meanwhile, if you do\n    not want this behavior (i.e., you want to force the creation of a\n    new axes), you must use a unique set of args and kwargs.  The axes\n    *label* attribute has been exposed for this purpose: if you want\n    two axes that are otherwise identical to be added to the figure,\n    make sure you give them unique labels.\n\n    See Also\n    --------\n    .Figure.add_axes\n    .pyplot.subplot\n    .Figure.add_subplot\n    .Figure.subplots\n    .pyplot.subplots\n\n    Examples\n    --------\n    ::\n\n        # Creating a new full window axes\n        plt.axes()\n\n        # Creating a new axes with specified dimensions and some kwargs\n        plt.axes((left, bottom, width, height), facecolor='w')\n    \"\"\"\n\n    if arg is None:\n        return subplot(111, **kwargs)\n    else:\n        return gcf().add_axes(arg, **kwargs)",
        "begin_line": 754,
        "end_line": 845,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.154155986818015e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.delaxes#848",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.delaxes(ax=None)",
        "snippet": "def delaxes(ax=None):\n    \"\"\"\n    Remove an `~.axes.Axes` (defaulting to the current axes) from its figure.\n    \"\"\"\n    if ax is None:\n        ax = gca()\n    ax.remove()",
        "begin_line": 848,
        "end_line": 854,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.subplot#870",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.subplot(*args, **kwargs)",
        "snippet": "def subplot(*args, **kwargs):\n    \"\"\"\n    Add a subplot to the current figure.\n\n    Wrapper of `.Figure.add_subplot` with a difference in behavior\n    explained in the notes section.\n\n    Call signatures::\n\n       subplot(nrows, ncols, index, **kwargs)\n       subplot(pos, **kwargs)\n       subplot(**kwargs)\n       subplot(ax)\n\n    Parameters\n    ----------\n    *args, default: (1, 1, 1)\n        Either a 3-digit integer or three separate integers\n        describing the position of the subplot. If the three\n        integers are *nrows*, *ncols*, and *index* in order, the\n        subplot will take the *index* position on a grid with *nrows*\n        rows and *ncols* columns. *index* starts at 1 in the upper left\n        corner and increases to the right.\n\n        *pos* is a three digit integer, where the first digit is the\n        number of rows, the second the number of columns, and the third\n        the index of the subplot. i.e. fig.add_subplot(235) is the same as\n        fig.add_subplot(2, 3, 5). Note that all integers must be less than\n        10 for this form to work.\n\n    projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n'polar', 'rectilinear', str}, optional\n        The projection type of the subplot (`~.axes.Axes`). *str* is the name\n        of a custom projection, see `~matplotlib.projections`. The default\n        None results in a 'rectilinear' projection.\n\n    polar : bool, default: False\n        If True, equivalent to projection='polar'.\n\n    sharex, sharey : `~.axes.Axes`, optional\n        Share the x or y `~matplotlib.axis` with sharex and/or sharey. The\n        axis will have the same limits, ticks, and scale as the axis of the\n        shared axes.\n\n    label : str\n        A label for the returned axes.\n\n    Other Parameters\n    ----------------\n    **kwargs\n        This method also takes the keyword arguments for the returned axes\n        base class; except for the *figure* argument. The keyword arguments\n        for the rectilinear base class `~.axes.Axes` can be found in\n        the following table but there might also be other keyword\n        arguments if another projection is used.\n\n        %(Axes)s\n\n    Returns\n    -------\n    axes : an `.axes.SubplotBase` subclass of `~.axes.Axes` (or a subclass \\\n    of `~.axes.Axes`)\n\n        The axes of the subplot. The returned axes base class depends on\n        the projection used. It is `~.axes.Axes` if rectilinear projection\n        are used and `.projections.polar.PolarAxes` if polar projection\n        are used. The returned axes is then a subplot subclass of the\n        base class.\n\n    Notes\n    -----\n    Creating a subplot will delete any pre-existing subplot that overlaps\n    with it beyond sharing a boundary::\n\n        import matplotlib.pyplot as plt\n        # plot a line, implicitly creating a subplot(111)\n        plt.plot([1, 2, 3])\n        # now create a subplot which represents the top plot of a grid\n        # with 2 rows and 1 column. Since this subplot will overlap the\n        # first, the plot (and its axes) previously created, will be removed\n        plt.subplot(211)\n\n    If you do not want this behavior, use the `.Figure.add_subplot` method\n    or the `.pyplot.axes` function instead.\n\n    If the figure already has a subplot with key (*args*,\n    *kwargs*) then it will simply make that subplot current and\n    return it.  This behavior is deprecated. Meanwhile, if you do\n    not want this behavior (i.e., you want to force the creation of a\n    new subplot), you must use a unique set of args and kwargs.  The axes\n    *label* attribute has been exposed for this purpose: if you want\n    two subplots that are otherwise identical to be added to the figure,\n    make sure you give them unique labels.\n\n    In rare circumstances, `.add_subplot` may be called with a single\n    argument, a subplot axes instance already created in the\n    present figure but not in the figure's list of axes.\n\n    See Also\n    --------\n    .Figure.add_subplot\n    .pyplot.subplots\n    .pyplot.axes\n    .Figure.subplots\n\n    Examples\n    --------\n    ::\n\n        plt.subplot(221)\n\n        # equivalent but more general\n        ax1=plt.subplot(2, 2, 1)\n\n        # add a subplot with no frame\n        ax2=plt.subplot(222, frameon=False)\n\n        # add a polar subplot\n        plt.subplot(223, projection='polar')\n\n        # add a red subplot that shares the x-axis with ax1\n        plt.subplot(224, sharex=ax1, facecolor='red')\n\n        # delete ax2 from the figure\n        plt.delaxes(ax2)\n\n        # add ax2 to the figure again\n        plt.subplot(ax2)\n    \"\"\"\n\n    # if subplot called without arguments, create subplot(1, 1, 1)\n    if len(args) == 0:\n        args = (1, 1, 1)\n\n    # This check was added because it is very easy to type\n    # subplot(1, 2, False) when subplots(1, 2, False) was intended\n    # (sharex=False, that is). In most cases, no error will\n    # ever occur, but mysterious behavior can result because what was\n    # intended to be the sharex argument is instead treated as a\n    # subplot index for subplot()\n    if len(args) >= 3 and isinstance(args[2], bool):\n        cbook._warn_external(\"The subplot index argument to subplot() appears \"\n                             \"to be a boolean. Did you intend to use \"\n                             \"subplots()?\")\n    # Check for nrows and ncols, which are not valid subplot args:\n    if 'nrows' in kwargs or 'ncols' in kwargs:\n        raise TypeError(\"subplot() got an unexpected keyword argument 'ncols' \"\n                        \"and/or 'nrows'.  Did you intend to call subplots()?\")\n\n    fig = gcf()\n    ax = fig.add_subplot(*args, **kwargs)\n    bbox = ax.bbox\n    axes_to_delete = []\n    for other_ax in fig.axes:\n        if other_ax == ax:\n            continue\n        if bbox.fully_overlaps(other_ax.bbox):\n            axes_to_delete.append(other_ax)\n    for ax_to_del in axes_to_delete:\n        delaxes(ax_to_del)\n\n    return ax",
        "begin_line": 870,
        "end_line": 1031,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.subplots#1034",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True, subplot_kw=None, gridspec_kw=None, **fig_kw)",
        "snippet": "def subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True,\n             subplot_kw=None, gridspec_kw=None, **fig_kw):\n    \"\"\"\n    Create a figure and a set of subplots.\n\n    This utility wrapper makes it convenient to create common layouts of\n    subplots, including the enclosing figure object, in a single call.\n\n    Parameters\n    ----------\n    nrows, ncols : int, default: 1\n        Number of rows/columns of the subplot grid.\n\n    sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False\n        Controls sharing of properties among x (`sharex`) or y (`sharey`)\n        axes:\n\n        - True or 'all': x- or y-axis will be shared among all subplots.\n        - False or 'none': each subplot x- or y-axis will be independent.\n        - 'row': each subplot row will share an x- or y-axis.\n        - 'col': each subplot column will share an x- or y-axis.\n\n        When subplots have a shared x-axis along a column, only the x tick\n        labels of the bottom subplot are created. Similarly, when subplots\n        have a shared y-axis along a row, only the y tick labels of the first\n        column subplot are created. To later turn other subplots' ticklabels\n        on, use `~matplotlib.axes.Axes.tick_params`.\n\n    squeeze : bool, default: True\n        - If True, extra dimensions are squeezed out from the returned\n          array of `~matplotlib.axes.Axes`:\n\n          - if only one subplot is constructed (nrows=ncols=1), the\n            resulting single Axes object is returned as a scalar.\n          - for Nx1 or 1xM subplots, the returned object is a 1D numpy\n            object array of Axes objects.\n          - for NxM, subplots with N>1 and M>1 are returned as a 2D array.\n\n        - If False, no squeezing at all is done: the returned Axes object is\n          always a 2D array containing Axes instances, even if it ends up\n          being 1x1.\n\n    subplot_kw : dict, optional\n        Dict with keywords passed to the\n        `~matplotlib.figure.Figure.add_subplot` call used to create each\n        subplot.\n\n    gridspec_kw : dict, optional\n        Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`\n        constructor used to create the grid the subplots are placed on.\n\n    **fig_kw\n        All additional keyword arguments are passed to the\n        `.pyplot.figure` call.\n\n    Returns\n    -------\n    fig : `~.figure.Figure`\n\n    ax : `.axes.Axes` or array of Axes\n        *ax* can be either a single `~matplotlib.axes.Axes` object or an\n        array of Axes objects if more than one subplot was created.  The\n        dimensions of the resulting array can be controlled with the squeeze\n        keyword, see above.\n\n        Typical idioms for handling the return value are::\n\n            # using the variable ax for single a Axes\n            fig, ax = plt.subplots()\n\n            # using the variable axs for multiple Axes\n            fig, axs = plt.subplots(2, 2)\n\n            # using tuple unpacking for multiple Axes\n            fig, (ax1, ax2) = plt.subplot(1, 2)\n            fig, ((ax1, ax2), (ax3, ax4)) = plt.subplot(2, 2)\n\n        The names ``ax`` and pluralized ``axs`` are preferred over ``axes``\n        because for the latter it's not clear if it refers to a single\n        `~.axes.Axes` instance or a collection of these.\n\n    Examples\n    --------\n    ::\n\n        # First create some toy data:\n        x = np.linspace(0, 2*np.pi, 400)\n        y = np.sin(x**2)\n\n        # Create just a figure and only one subplot\n        fig, ax = plt.subplots()\n        ax.plot(x, y)\n        ax.set_title('Simple plot')\n\n        # Create two subplots and unpack the output array immediately\n        f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\n        ax1.plot(x, y)\n        ax1.set_title('Sharing Y axis')\n        ax2.scatter(x, y)\n\n        # Create four polar axes and access them through the returned array\n        fig, axs = plt.subplots(2, 2, subplot_kw=dict(polar=True))\n        axs[0, 0].plot(x, y)\n        axs[1, 1].scatter(x, y)\n\n        # Share a X axis with each column of subplots\n        plt.subplots(2, 2, sharex='col')\n\n        # Share a Y axis with each row of subplots\n        plt.subplots(2, 2, sharey='row')\n\n        # Share both X and Y axes with all subplots\n        plt.subplots(2, 2, sharex='all', sharey='all')\n\n        # Note that this is the same as\n        plt.subplots(2, 2, sharex=True, sharey=True)\n\n        # Create figure number 10 with a single subplot\n        # and clears it if it already exists.\n        fig, ax = plt.subplots(num=10, clear=True)\n\n    See Also\n    --------\n    .pyplot.figure\n    .pyplot.subplot\n    .pyplot.axes\n    .Figure.subplots\n    .Figure.add_subplot\n\n    \"\"\"\n    fig = figure(**fig_kw)\n    axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,\n                       squeeze=squeeze, subplot_kw=subplot_kw,\n                       gridspec_kw=gridspec_kw)\n    return fig, axs",
        "begin_line": 1034,
        "end_line": 1168,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004737091425864519,
            "pseudo_dstar_susp": 0.0006618133686300463,
            "pseudo_tarantula_susp": 0.001392757660167131,
            "pseudo_op2_susp": 0.0006618133686300463,
            "pseudo_barinel_susp": 0.001392757660167131
        }
    },
    {
        "name": "lib.matplotlib.pyplot.subplot2grid#1171",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.subplot2grid(shape, loc, rowspan=1, colspan=1, fig=None, **kwargs)",
        "snippet": "def subplot2grid(shape, loc, rowspan=1, colspan=1, fig=None, **kwargs):\n    \"\"\"\n    Create an axis at specific location inside a regular grid.\n\n    Parameters\n    ----------\n    shape : (int, int)\n        Number of rows and of columns of the grid in which to place axis.\n    loc : (int, int)\n        Row number and column number of the axis location within the grid.\n    rowspan : int\n        Number of rows for the axis to span to the right.\n    colspan : int\n        Number of columns for the axis to span downwards.\n    fig : `.Figure`, optional\n        Figure to place axis in. Defaults to current figure.\n    **kwargs\n        Additional keyword arguments are handed to `add_subplot`.\n\n    Notes\n    -----\n    The following call ::\n\n        subplot2grid(shape, loc, rowspan=1, colspan=1)\n\n    is identical to ::\n\n        gridspec = GridSpec(shape[0], shape[1])\n        subplotspec = gridspec.new_subplotspec(loc, rowspan, colspan)\n        subplot(subplotspec)\n    \"\"\"\n\n    if fig is None:\n        fig = gcf()\n\n    s1, s2 = shape\n    subplotspec = GridSpec(s1, s2).new_subplotspec(loc,\n                                                   rowspan=rowspan,\n                                                   colspan=colspan)\n    ax = fig.add_subplot(subplotspec, **kwargs)\n    bbox = ax.bbox\n    axes_to_delete = []\n    for other_ax in fig.axes:\n        if other_ax == ax:\n            continue\n        if bbox.fully_overlaps(other_ax.bbox):\n            axes_to_delete.append(other_ax)\n    for ax_to_del in axes_to_delete:\n        delaxes(ax_to_del)\n\n    return ax",
        "begin_line": 1171,
        "end_line": 1221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.twinx#1224",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.twinx(ax=None)",
        "snippet": "def twinx(ax=None):\n    \"\"\"\n    Make and return a second axes that shares the *x*-axis.  The new axes will\n    overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be\n    on the right.\n\n    Examples\n    --------\n    :doc:`/gallery/subplots_axes_and_figures/two_scales`\n    \"\"\"\n    if ax is None:\n        ax = gca()\n    ax1 = ax.twinx()\n    return ax1",
        "begin_line": 1224,
        "end_line": 1237,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.tight_layout#1297",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.tight_layout(pad=1.08, h_pad=None, w_pad=None, rect=None)",
        "snippet": "def tight_layout(pad=1.08, h_pad=None, w_pad=None, rect=None):\n    \"\"\"\n    Automatically adjust subplot parameters to give specified padding.\n\n    Parameters\n    ----------\n    pad : float\n        Padding between the figure edge and the edges of subplots,\n        as a fraction of the font size.\n    h_pad, w_pad : float, optional\n        Padding (height/width) between edges of adjacent subplots,\n        as a fraction of the font size.  Defaults to *pad*.\n    rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)\n        A rectangle (left, bottom, right, top) in the normalized\n        figure coordinate that the whole subplots area (including\n        labels) will fit into.\n    \"\"\"\n    gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)",
        "begin_line": 1297,
        "end_line": 1314,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.box#1317",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.box(on=None)",
        "snippet": "def box(on=None):\n    \"\"\"\n    Turn the axes box on or off on the current axes.\n\n    Parameters\n    ----------\n    on : bool or None\n        The new `~matplotlib.axes.Axes` box state. If ``None``, toggle\n        the state.\n\n    See Also\n    --------\n    :meth:`matplotlib.axes.Axes.set_frame_on`\n    :meth:`matplotlib.axes.Axes.get_frame_on`\n    \"\"\"\n    ax = gca()\n    if on is None:\n        on = not ax.get_frame_on()\n    ax.set_frame_on(on)",
        "begin_line": 1317,
        "end_line": 1335,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.xlim#1340",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.xlim(*args, **kwargs)",
        "snippet": "def xlim(*args, **kwargs):\n    \"\"\"\n    Get or set the x limits of the current axes.\n\n    Call signatures::\n\n        left, right = xlim()  # return the current xlim\n        xlim((left, right))   # set the xlim to left, right\n        xlim(left, right)     # set the xlim to left, right\n\n    If you do not specify args, you can pass *left* or *right* as kwargs,\n    i.e.::\n\n        xlim(right=3)  # adjust the right leaving left unchanged\n        xlim(left=1)  # adjust the left leaving right unchanged\n\n    Setting limits turns autoscaling off for the x-axis.\n\n    Returns\n    -------\n    left, right\n        A tuple of the new x-axis limits.\n\n    Notes\n    -----\n    Calling this function with no arguments (e.g. ``xlim()``) is the pyplot\n    equivalent of calling `~.Axes.get_xlim` on the current axes.\n    Calling this function with arguments is the pyplot equivalent of calling\n    `~.Axes.set_xlim` on the current axes. All arguments are passed though.\n    \"\"\"\n    ax = gca()\n    if not args and not kwargs:\n        return ax.get_xlim()\n    ret = ax.set_xlim(*args, **kwargs)\n    return ret",
        "begin_line": 1340,
        "end_line": 1374,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.xticks#1414",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.xticks(ticks=None, labels=None, **kwargs)",
        "snippet": "def xticks(ticks=None, labels=None, **kwargs):\n    \"\"\"\n    Get or set the current tick locations and labels of the x-axis.\n\n    Pass no arguments to return the current values without modifying them.\n\n    Parameters\n    ----------\n    ticks : array-like, optional\n        The list of xtick locations.  Passing an empty list removes all xticks.\n    labels : array-like, optional\n        The labels to place at the given *ticks* locations.  This argument can\n        only be passed if *ticks* is passed as well.\n    **kwargs\n        `.Text` properties can be used to control the appearance of the labels.\n\n    Returns\n    -------\n    locs\n        The list of xtick locations.\n    labels\n        The list of xlabel `.Text` objects.\n\n    Notes\n    -----\n    Calling this function with no arguments (e.g. ``xticks()``) is the pyplot\n    equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on\n    the current axes.\n    Calling this function with arguments is the pyplot equivalent of calling\n    `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.\n\n    Examples\n    --------\n    >>> locs, labels = xticks()  # Get the current locations and labels.\n    >>> xticks(np.arange(0, 1, step=0.2))  # Set label locations.\n    >>> xticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.\n    >>> xticks([0, 1, 2], ['January', 'February', 'March'],\n    ...        rotation=20)  # Set text labels and properties.\n    >>> xticks([])  # Disable xticks.\n    \"\"\"\n    ax = gca()\n\n    if ticks is None:\n        locs = ax.get_xticks()\n        if labels is not None:\n            raise TypeError(\"xticks(): Parameter 'labels' can't be set \"\n                            \"without setting 'ticks'\")\n    else:\n        locs = ax.set_xticks(ticks)\n\n    if labels is None:\n        labels = ax.get_xticklabels()\n    else:\n        labels = ax.set_xticklabels(labels, **kwargs)\n    for l in labels:\n        l.update(kwargs)\n\n    return locs, labels",
        "begin_line": 1414,
        "end_line": 1471,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.yticks#1474",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.yticks(ticks=None, labels=None, **kwargs)",
        "snippet": "def yticks(ticks=None, labels=None, **kwargs):\n    \"\"\"\n    Get or set the current tick locations and labels of the y-axis.\n\n    Pass no arguments to return the current values without modifying them.\n\n    Parameters\n    ----------\n    ticks : array-like, optional\n        The list of xtick locations.  Passing an empty list removes all xticks.\n    labels : array-like, optional\n        The labels to place at the given *ticks* locations.  This argument can\n        only be passed if *ticks* is passed as well.\n    **kwargs\n        `.Text` properties can be used to control the appearance of the labels.\n\n    Returns\n    -------\n    locs\n        The list of ytick locations.\n    labels\n        The list of ylabel `.Text` objects.\n\n    Notes\n    -----\n    Calling this function with no arguments (e.g. ``yticks()``) is the pyplot\n    equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on\n    the current axes.\n    Calling this function with arguments is the pyplot equivalent of calling\n    `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.\n\n    Examples\n    --------\n    >>> locs, labels = yticks()  # Get the current locations and labels.\n    >>> yticks(np.arange(0, 1, step=0.2))  # Set label locations.\n    >>> yticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.\n    >>> yticks([0, 1, 2], ['January', 'February', 'March'],\n    ...        rotation=45)  # Set text labels and properties.\n    >>> yticks([])  # Disable yticks.\n    \"\"\"\n    ax = gca()\n\n    if ticks is None:\n        locs = ax.get_yticks()\n        if labels is not None:\n            raise TypeError(\"yticks(): Parameter 'labels' can't be set \"\n                            \"without setting 'ticks'\")\n    else:\n        locs = ax.set_yticks(ticks)\n\n    if labels is None:\n        labels = ax.get_yticklabels()\n    else:\n        labels = ax.set_yticklabels(labels, **kwargs)\n    for l in labels:\n        l.update(kwargs)\n\n    return locs, labels",
        "begin_line": 1474,
        "end_line": 1531,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.colorbar#1981",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.colorbar(mappable=None, cax=None, ax=None, **kw)",
        "snippet": "def colorbar(mappable=None, cax=None, ax=None, **kw):\n    if mappable is None:\n        mappable = gci()\n        if mappable is None:\n            raise RuntimeError('No mappable was found to use for colorbar '\n                               'creation. First define a mappable such as '\n                               'an image (with imshow) or a contour set ('\n                               'with contourf).')\n    if ax is None:\n        ax = gca()\n    ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kw)\n    return ret",
        "begin_line": 1981,
        "end_line": 1992,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.imsave#2047",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.imsave(fname, arr, **kwargs)",
        "snippet": "def imsave(fname, arr, **kwargs):\n    return matplotlib.image.imsave(fname, arr, **kwargs)",
        "begin_line": 2047,
        "end_line": 2048,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.714396735962697e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.figimage#2148",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.figimage(X, xo=0, yo=0, alpha=None, norm=None, cmap=None, vmin=None, vmax=None, origin=None, resize=False, **kwargs)",
        "snippet": "def figimage(\n        X, xo=0, yo=0, alpha=None, norm=None, cmap=None, vmin=None,\n        vmax=None, origin=None, resize=False, **kwargs):\n    return gcf().figimage(\n        X, xo=xo, yo=yo, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,\n        vmax=vmax, origin=origin, resize=resize, **kwargs)",
        "begin_line": 2148,
        "end_line": 2153,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.gca#2164",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.gca(**kwargs)",
        "snippet": "def gca(**kwargs):\n    return gcf().gca(**kwargs)",
        "begin_line": 2164,
        "end_line": 2165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007716049382716049,
            "pseudo_dstar_susp": 0.0007002801120448179,
            "pseudo_tarantula_susp": 0.0011074197120708748,
            "pseudo_op2_susp": 0.000697350069735007,
            "pseudo_barinel_susp": 0.0011074197120708748
        }
    },
    {
        "name": "lib.matplotlib.pyplot.suptitle#2188",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.suptitle(t, **kwargs)",
        "snippet": "def suptitle(t, **kwargs):\n    return gcf().suptitle(t, **kwargs)",
        "begin_line": 2188,
        "end_line": 2189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.bar#2271",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.bar(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)",
        "snippet": "def bar(\n        x, height, width=0.8, bottom=None, *, align='center',\n        data=None, **kwargs):\n    return gca().bar(\n        x, height, width=width, bottom=bottom, align=align,\n        **({\"data\": data} if data is not None else {}), **kwargs)",
        "begin_line": 2271,
        "end_line": 2276,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.barbs#2281",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.barbs(*args, data=None, **kw)",
        "snippet": "def barbs(*args, data=None, **kw):\n    return gca().barbs(\n        *args, **({\"data\": data} if data is not None else {}), **kw)",
        "begin_line": 2281,
        "end_line": 2283,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.boxplot#2295",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.boxplot(x, notch=None, sym=None, vert=None, whis=None, positions=None, widths=None, patch_artist=None, bootstrap=None, usermedians=None, conf_intervals=None, meanline=None, showmeans=None, showcaps=None, showbox=None, showfliers=None, boxprops=None, labels=None, flierprops=None, medianprops=None, meanprops=None, capprops=None, whiskerprops=None, manage_ticks=True, autorange=False, zorder=None, *, data=None)",
        "snippet": "def boxplot(\n        x, notch=None, sym=None, vert=None, whis=None,\n        positions=None, widths=None, patch_artist=None,\n        bootstrap=None, usermedians=None, conf_intervals=None,\n        meanline=None, showmeans=None, showcaps=None, showbox=None,\n        showfliers=None, boxprops=None, labels=None, flierprops=None,\n        medianprops=None, meanprops=None, capprops=None,\n        whiskerprops=None, manage_ticks=True, autorange=False,\n        zorder=None, *, data=None):\n    return gca().boxplot(\n        x, notch=notch, sym=sym, vert=vert, whis=whis,\n        positions=positions, widths=widths, patch_artist=patch_artist,\n        bootstrap=bootstrap, usermedians=usermedians,\n        conf_intervals=conf_intervals, meanline=meanline,\n        showmeans=showmeans, showcaps=showcaps, showbox=showbox,\n        showfliers=showfliers, boxprops=boxprops, labels=labels,\n        flierprops=flierprops, medianprops=medianprops,\n        meanprops=meanprops, capprops=capprops,\n        whiskerprops=whiskerprops, manage_ticks=manage_ticks,\n        autorange=autorange, zorder=zorder,\n        **({\"data\": data} if data is not None else {}))",
        "begin_line": 2295,
        "end_line": 2315,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.clabel#2334",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.clabel(CS, levels=None, **kwargs)",
        "snippet": "def clabel(CS, levels=None, **kwargs):\n    return gca().clabel(CS, levels=levels, **kwargs)",
        "begin_line": 2334,
        "end_line": 2335,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.contour#2353",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.contour(*args, data=None, **kwargs)",
        "snippet": "def contour(*args, data=None, **kwargs):\n    __ret = gca().contour(\n        *args, **({\"data\": data} if data is not None else {}),\n        **kwargs)\n    if __ret._A is not None: sci(__ret)  # noqa\n    return __ret",
        "begin_line": 2353,
        "end_line": 2358,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.contourf#2363",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.contourf(*args, data=None, **kwargs)",
        "snippet": "def contourf(*args, data=None, **kwargs):\n    __ret = gca().contourf(\n        *args, **({\"data\": data} if data is not None else {}),\n        **kwargs)\n    if __ret._A is not None: sci(__ret)  # noqa\n    return __ret",
        "begin_line": 2363,
        "end_line": 2368,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.errorbar#2386",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.errorbar(x, y, yerr=None, xerr=None, fmt='', ecolor=None, elinewidth=None, capsize=None, barsabove=False, lolims=False, uplims=False, xlolims=False, xuplims=False, errorevery=1, capthick=None, *, data=None, **kwargs)",
        "snippet": "def errorbar(\n        x, y, yerr=None, xerr=None, fmt='', ecolor=None,\n        elinewidth=None, capsize=None, barsabove=False, lolims=False,\n        uplims=False, xlolims=False, xuplims=False, errorevery=1,\n        capthick=None, *, data=None, **kwargs):\n    return gca().errorbar(\n        x, y, yerr=yerr, xerr=xerr, fmt=fmt, ecolor=ecolor,\n        elinewidth=elinewidth, capsize=capsize, barsabove=barsabove,\n        lolims=lolims, uplims=uplims, xlolims=xlolims,\n        xuplims=xuplims, errorevery=errorevery, capthick=capthick,\n        **({\"data\": data} if data is not None else {}), **kwargs)",
        "begin_line": 2386,
        "end_line": 2396,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.eventplot#2401",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.eventplot(positions, orientation='horizontal', lineoffsets=1, linelengths=1, linewidths=None, colors=None, linestyles='solid', *, data=None, **kwargs)",
        "snippet": "def eventplot(\n        positions, orientation='horizontal', lineoffsets=1,\n        linelengths=1, linewidths=None, colors=None,\n        linestyles='solid', *, data=None, **kwargs):\n    return gca().eventplot(\n        positions, orientation=orientation, lineoffsets=lineoffsets,\n        linelengths=linelengths, linewidths=linewidths, colors=colors,\n        linestyles=linestyles,\n        **({\"data\": data} if data is not None else {}), **kwargs)",
        "begin_line": 2401,
        "end_line": 2409,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.hist#2467",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.hist(x, bins=None, range=None, density=False, weights=None, cumulative=False, bottom=None, histtype='bar', align='mid', orientation='vertical', rwidth=None, log=False, color=None, label=None, stacked=False, *, data=None, **kwargs)",
        "snippet": "def hist(\n        x, bins=None, range=None, density=False, weights=None,\n        cumulative=False, bottom=None, histtype='bar', align='mid',\n        orientation='vertical', rwidth=None, log=False, color=None,\n        label=None, stacked=False, *, data=None, **kwargs):\n    return gca().hist(\n        x, bins=bins, range=range, density=density, weights=weights,\n        cumulative=cumulative, bottom=bottom, histtype=histtype,\n        align=align, orientation=orientation, rwidth=rwidth, log=log,\n        color=color, label=label, stacked=stacked,\n        **({\"data\": data} if data is not None else {}), **kwargs)",
        "begin_line": 2467,
        "end_line": 2477,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.013333333333333334,
            "pseudo_dstar_susp": 0.0006426735218508997,
            "pseudo_tarantula_susp": 0.006493506493506494,
            "pseudo_op2_susp": 0.0006426735218508997,
            "pseudo_barinel_susp": 0.006493506493506494
        }
    },
    {
        "name": "lib.matplotlib.pyplot.imshow#2506",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.imshow(X, cmap=None, norm=None, aspect=None, interpolation=None, alpha=None, vmin=None, vmax=None, origin=None, extent=None, *, filternorm=True, filterrad=4.0, resample=None, url=None, data=None, **kwargs)",
        "snippet": "def imshow(\n        X, cmap=None, norm=None, aspect=None, interpolation=None,\n        alpha=None, vmin=None, vmax=None, origin=None, extent=None, *,\n        filternorm=True, filterrad=4.0, resample=None, url=None,\n        data=None, **kwargs):\n    __ret = gca().imshow(\n        X, cmap=cmap, norm=norm, aspect=aspect,\n        interpolation=interpolation, alpha=alpha, vmin=vmin,\n        vmax=vmax, origin=origin, extent=extent,\n        filternorm=filternorm, filterrad=filterrad, resample=resample,\n        url=url, **({\"data\": data} if data is not None else {}),\n        **kwargs)\n    sci(__ret)\n    return __ret",
        "begin_line": 2506,
        "end_line": 2519,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.legend#2524",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.legend(*args, **kwargs)",
        "snippet": "def legend(*args, **kwargs):\n    return gca().legend(*args, **kwargs)",
        "begin_line": 2524,
        "end_line": 2525,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.pcolormesh#2584",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.pcolormesh(*args, alpha=None, norm=None, cmap=None, vmin=None, vmax=None, shading=None, antialiased=False, data=None, **kwargs)",
        "snippet": "def pcolormesh(\n        *args, alpha=None, norm=None, cmap=None, vmin=None,\n        vmax=None, shading=None, antialiased=False, data=None,\n        **kwargs):\n    __ret = gca().pcolormesh(\n        *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,\n        vmax=vmax, shading=shading, antialiased=antialiased,\n        **({\"data\": data} if data is not None else {}), **kwargs)\n    sci(__ret)\n    return __ret",
        "begin_line": 2584,
        "end_line": 2593,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.plot#2626",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.plot(*args, scalex=True, scaley=True, data=None, **kwargs)",
        "snippet": "def plot(*args, scalex=True, scaley=True, data=None, **kwargs):\n    return gca().plot(\n        *args, scalex=scalex, scaley=scaley,\n        **({\"data\": data} if data is not None else {}), **kwargs)",
        "begin_line": 2626,
        "end_line": 2629,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006422607578676942,
            "pseudo_dstar_susp": 0.0005605381165919282,
            "pseudo_tarantula_susp": 0.0018726591760299626,
            "pseudo_op2_susp": 0.0005605381165919282,
            "pseudo_barinel_susp": 0.0018726591760299626
        }
    },
    {
        "name": "lib.matplotlib.pyplot.quiver#2657",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.quiver(*args, data=None, **kw)",
        "snippet": "def quiver(*args, data=None, **kw):\n    __ret = gca().quiver(\n        *args, **({\"data\": data} if data is not None else {}), **kw)\n    sci(__ret)\n    return __ret",
        "begin_line": 2657,
        "end_line": 2661,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.scatter#2672",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, verts=cbook.deprecation._deprecated_parameter, edgecolors=None, *, plotnonfinite=False, data=None, **kwargs)",
        "snippet": "def scatter(\n        x, y, s=None, c=None, marker=None, cmap=None, norm=None,\n        vmin=None, vmax=None, alpha=None, linewidths=None,\n        verts=cbook.deprecation._deprecated_parameter,\n        edgecolors=None, *, plotnonfinite=False, data=None, **kwargs):\n    __ret = gca().scatter(\n        x, y, s=s, c=c, marker=marker, cmap=cmap, norm=norm,\n        vmin=vmin, vmax=vmax, alpha=alpha, linewidths=linewidths,\n        verts=verts, edgecolors=edgecolors,\n        plotnonfinite=plotnonfinite,\n        **({\"data\": data} if data is not None else {}), **kwargs)\n    sci(__ret)\n    return __ret",
        "begin_line": 2672,
        "end_line": 2684,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.stackplot#2730",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.stackplot(x, *args, labels=(), colors=None, baseline='zero', data=None, **kwargs)",
        "snippet": "def stackplot(\n        x, *args, labels=(), colors=None, baseline='zero', data=None,\n        **kwargs):\n    return gca().stackplot(\n        x, *args, labels=labels, colors=colors, baseline=baseline,\n        **({\"data\": data} if data is not None else {}), **kwargs)",
        "begin_line": 2730,
        "end_line": 2735,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.streamplot#2760",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.streamplot(x, y, u, v, density=1, linewidth=None, color=None, cmap=None, norm=None, arrowsize=1, arrowstyle='-|>', minlength=0.1, transform=None, zorder=None, start_points=None, maxlength=4.0, integration_direction='both', *, data=None)",
        "snippet": "def streamplot(\n        x, y, u, v, density=1, linewidth=None, color=None, cmap=None,\n        norm=None, arrowsize=1, arrowstyle='-|>', minlength=0.1,\n        transform=None, zorder=None, start_points=None, maxlength=4.0,\n        integration_direction='both', *, data=None):\n    __ret = gca().streamplot(\n        x, y, u, v, density=density, linewidth=linewidth, color=color,\n        cmap=cmap, norm=norm, arrowsize=arrowsize,\n        arrowstyle=arrowstyle, minlength=minlength,\n        transform=transform, zorder=zorder, start_points=start_points,\n        maxlength=maxlength,\n        integration_direction=integration_direction,\n        **({\"data\": data} if data is not None else {}))\n    sci(__ret.lines)\n    return __ret",
        "begin_line": 2760,
        "end_line": 2774,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.table#2779",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.table(cellText=None, cellColours=None, cellLoc='right', colWidths=None, rowLabels=None, rowColours=None, rowLoc='left', colLabels=None, colColours=None, colLoc='center', loc='bottom', bbox=None, edges='closed', **kwargs)",
        "snippet": "def table(\n        cellText=None, cellColours=None, cellLoc='right',\n        colWidths=None, rowLabels=None, rowColours=None,\n        rowLoc='left', colLabels=None, colColours=None,\n        colLoc='center', loc='bottom', bbox=None, edges='closed',\n        **kwargs):\n    return gca().table(\n        cellText=cellText, cellColours=cellColours, cellLoc=cellLoc,\n        colWidths=colWidths, rowLabels=rowLabels,\n        rowColours=rowColours, rowLoc=rowLoc, colLabels=colLabels,\n        colColours=colColours, colLoc=colLoc, loc=loc, bbox=bbox,\n        edges=edges, **kwargs)",
        "begin_line": 2779,
        "end_line": 2790,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.tricontour#2818",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.tricontour(*args, **kwargs)",
        "snippet": "def tricontour(*args, **kwargs):\n    __ret = gca().tricontour(*args, **kwargs)\n    if __ret._A is not None: sci(__ret)  # noqa\n    return __ret",
        "begin_line": 2818,
        "end_line": 2821,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.tricontourf#2826",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.tricontourf(*args, **kwargs)",
        "snippet": "def tricontourf(*args, **kwargs):\n    __ret = gca().tricontourf(*args, **kwargs)\n    if __ret._A is not None: sci(__ret)  # noqa\n    return __ret",
        "begin_line": 2826,
        "end_line": 2829,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.tripcolor#2834",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.tripcolor(*args, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None, shading='flat', facecolors=None, **kwargs)",
        "snippet": "def tripcolor(\n        *args, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None,\n        shading='flat', facecolors=None, **kwargs):\n    __ret = gca().tripcolor(\n        *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,\n        vmax=vmax, shading=shading, facecolors=facecolors, **kwargs)\n    sci(__ret)\n    return __ret",
        "begin_line": 2834,
        "end_line": 2841,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.violinplot#2852",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.violinplot(dataset, positions=None, vert=True, widths=0.5, showmeans=False, showextrema=True, showmedians=False, quantiles=None, points=100, bw_method=None, *, data=None)",
        "snippet": "def violinplot(\n        dataset, positions=None, vert=True, widths=0.5,\n        showmeans=False, showextrema=True, showmedians=False,\n        quantiles=None, points=100, bw_method=None, *, data=None):\n    return gca().violinplot(\n        dataset, positions=positions, vert=vert, widths=widths,\n        showmeans=showmeans, showextrema=showextrema,\n        showmedians=showmedians, quantiles=quantiles, points=points,\n        bw_method=bw_method,\n        **({\"data\": data} if data is not None else {}))",
        "begin_line": 2852,
        "end_line": 2861,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.sci#2888",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.sci(im)",
        "snippet": "def sci(im):\n    return gca()._sci(im)",
        "begin_line": 2888,
        "end_line": 2889,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.406893652795292e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.title#2894",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.title(label, fontdict=None, loc=None, pad=None, **kwargs)",
        "snippet": "def title(label, fontdict=None, loc=None, pad=None, **kwargs):\n    return gca().set_title(\n        label, fontdict=fontdict, loc=loc, pad=pad, **kwargs)",
        "begin_line": 2894,
        "end_line": 2896,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.xlabel#2901",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.xlabel(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
        "snippet": "def xlabel(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs):\n    return gca().set_xlabel(\n        xlabel, fontdict=fontdict, labelpad=labelpad, loc=loc,\n        **kwargs)",
        "begin_line": 2901,
        "end_line": 2904,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.xscale#2917",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.xscale(value, **kwargs)",
        "snippet": "def xscale(value, **kwargs):\n    return gca().set_xscale(value, **kwargs)",
        "begin_line": 2917,
        "end_line": 2918,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.pyplot.yscale#2923",
        "src_path": "lib/matplotlib/pyplot.py",
        "class_name": "lib.matplotlib.pyplot",
        "signature": "lib.matplotlib.pyplot.yscale(value, **kwargs)",
        "snippet": "def yscale(value, **kwargs):\n    return gca().set_yscale(value, **kwargs)",
        "begin_line": 2923,
        "end_line": 2924,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.jpl_units.Duration.Duration.__init__#13",
        "src_path": "lib/matplotlib/testing/jpl_units/Duration.py",
        "class_name": "lib.matplotlib.testing.jpl_units.Duration.Duration",
        "signature": "lib.matplotlib.testing.jpl_units.Duration.Duration.__init__(self, frame, seconds)",
        "snippet": "    def __init__(self, frame, seconds):\n        \"\"\"Create a new Duration object.\n\n        = ERROR CONDITIONS\n        - If the input frame is not in the allowed list, an error is thrown.\n\n        = INPUT VARIABLES\n        - frame     The frame of the duration.  Must be 'ET' or 'UTC'\n        - seconds  The number of seconds in the Duration.\n        \"\"\"\n        cbook._check_in_list(self.allowed, frame=frame)\n        self._frame = frame\n        self._seconds = seconds",
        "begin_line": 13,
        "end_line": 25,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._text_layout.layout#8",
        "src_path": "lib/matplotlib/_text_layout.py",
        "class_name": "lib.matplotlib._text_layout",
        "signature": "lib.matplotlib._text_layout.layout(string, font, *, kern_mode=KERNING_DEFAULT)",
        "snippet": "def layout(string, font, *, kern_mode=KERNING_DEFAULT):\n    \"\"\"\n    Render *string* with *font*.  For each character in *string*, yield a\n    (glyph-index, x-position) pair.  When such a pair is yielded, the font's\n    glyph is set to the corresponding character.\n\n    Parameters\n    ----------\n    string : str\n        The string to be rendered.\n    font : FT2Font\n        The font.\n    kern_mode : int\n        A FreeType kerning mode.\n\n    Yields\n    ------\n    glyph_index : int\n    x_position : float\n    \"\"\"\n    x = 0\n    last_glyph_idx = None\n    for char in string:\n        glyph_idx = font.get_char_index(ord(char))\n        kern = (font.get_kerning(last_glyph_idx, glyph_idx, kern_mode)\n                if last_glyph_idx is not None else 0) / 64\n        x += kern\n        glyph = font.load_glyph(glyph_idx, flags=LOAD_NO_HINTING)\n        yield glyph_idx, x\n        x += glyph.linearHoriAdvance / 65536\n        last_glyph_idx = glyph_idx",
        "begin_line": 8,
        "end_line": 38,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001584786053882726,
            "pseudo_dstar_susp": 0.0006666666666666666,
            "pseudo_tarantula_susp": 0.001937984496124031,
            "pseudo_op2_susp": 0.0006666666666666666,
            "pseudo_barinel_susp": 0.001937984496124031
        }
    },
    {
        "name": "lib.matplotlib.animation.AbstractMovieWriter.saving#241",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.AbstractMovieWriter",
        "signature": "lib.matplotlib.animation.AbstractMovieWriter.saving(self, fig, outfile, dpi, *args, **kwargs)",
        "snippet": "    def saving(self, fig, outfile, dpi, *args, **kwargs):\n        \"\"\"\n        Context manager to facilitate writing the movie file.\n\n        ``*args, **kw`` are any parameters that should be passed to `setup`.\n        \"\"\"\n        # This particular sequence is what contextlib.contextmanager wants\n        self.setup(fig, outfile, dpi, *args, **kwargs)\n        try:\n            yield self\n        finally:\n            self.finish()",
        "begin_line": 241,
        "end_line": 252,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.790436005625879e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.animation.FileMovieWriter.setup#426",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.FileMovieWriter",
        "signature": "lib.matplotlib.animation.FileMovieWriter.setup(self, fig, outfile, dpi=None, frame_prefix=None, clear_temp=True)",
        "snippet": "    def setup(self, fig, outfile, dpi=None, frame_prefix=None,\n              clear_temp=True):\n        \"\"\"\n        Perform setup for writing the movie file.\n\n        Parameters\n        ----------\n        fig : `~matplotlib.figure.Figure`\n            The figure to grab the rendered frames from.\n        outfile : str\n            The filename of the resulting movie file.\n        dpi : float, optional\n            The dpi of the output file. This, with the figure size,\n            controls the size in pixels of the resulting movie file.\n            Default is ``fig.dpi``.\n        frame_prefix : str, optional\n            The filename prefix to use for temporary files.  If None (the\n            default), files are written to a temporary directory which is\n            deleted by `cleanup` (regardless of the value of *clear_temp*).\n        clear_temp : bool, optional\n            If the temporary files should be deleted after stitching\n            the final result.  Setting this to ``False`` can be useful for\n            debugging.  Defaults to ``True``.\n        \"\"\"\n        self.fig = fig\n        self.outfile = outfile\n        if dpi is None:\n            dpi = self.fig.dpi\n        self.dpi = dpi\n        self._adjust_frame_size()\n\n        if frame_prefix is None:\n            self._tmpdir = TemporaryDirectory()\n            self.temp_prefix = str(Path(self._tmpdir.name, 'tmp'))\n        else:\n            self._tmpdir = None\n            self.temp_prefix = frame_prefix\n        self._clear_temp = clear_temp\n        self._frame_counter = 0  # used for generating sequential file names\n        self._temp_paths = list()\n        self.fname_format_str = '%s%%07d.%s'",
        "begin_line": 426,
        "end_line": 466,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.animation.PillowWriter.finish#560",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.PillowWriter",
        "signature": "lib.matplotlib.animation.PillowWriter.finish(self)",
        "snippet": "    def finish(self):\n        self._frames[0].save(\n            self.outfile, save_all=True, append_images=self._frames[1:],\n            duration=int(1000 / self.fps), loop=0)",
        "begin_line": 560,
        "end_line": 563,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.animation.HTMLWriter.setup#815",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.HTMLWriter",
        "signature": "lib.matplotlib.animation.HTMLWriter.setup(self, fig, outfile, dpi, frame_dir=None)",
        "snippet": "    def setup(self, fig, outfile, dpi, frame_dir=None):\n        outfile = Path(outfile)\n        cbook._check_in_list(['.html', '.htm'],\n                             outfile_extension=outfile.suffix)\n\n        self._saved_frames = []\n        self._total_bytes = 0\n        self._hit_limit = False\n\n        if not self.embed_frames:\n            if frame_dir is None:\n                frame_dir = outfile.with_name(outfile.stem + '_frames')\n            frame_dir.mkdir(parents=True, exist_ok=True)\n            frame_prefix = frame_dir / 'frame'\n        else:\n            frame_prefix = None\n\n        super().setup(fig, outfile, dpi, frame_prefix)\n        self._clear_temp = False",
        "begin_line": 815,
        "end_line": 833,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.animation.HTMLWriter.finish#858",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.HTMLWriter",
        "signature": "lib.matplotlib.animation.HTMLWriter.finish(self)",
        "snippet": "    def finish(self):\n        # save the frames to an html file\n        if self.embed_frames:\n            fill_frames = _embedded_frames(self._saved_frames,\n                                           self.frame_format)\n            Nframes = len(self._saved_frames)\n        else:\n            # temp names is filled by FileMovieWriter\n            fill_frames = _included_frames(self._temp_paths, self.frame_format)\n            Nframes = len(self._temp_paths)\n        mode_dict = dict(once_checked='',\n                         loop_checked='',\n                         reflect_checked='')\n        mode_dict[self.default_mode + '_checked'] = 'checked'\n\n        interval = 1000 // self.fps\n\n        with open(self.outfile, 'w') as of:\n            of.write(JS_INCLUDE + STYLE_INCLUDE)\n            of.write(DISPLAY_TEMPLATE.format(id=uuid.uuid4().hex,\n                                             Nframes=Nframes,\n                                             fill_frames=fill_frames,\n                                             interval=interval,\n                                             **mode_dict))",
        "begin_line": 858,
        "end_line": 881,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.animation.Animation.__init__#913",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.Animation",
        "signature": "lib.matplotlib.animation.Animation.__init__(self, fig, event_source=None, blit=False)",
        "snippet": "    def __init__(self, fig, event_source=None, blit=False):\n        self._fig = fig\n        # Disables blitting for backends that don't support it.  This\n        # allows users to request it if available, but still have a\n        # fallback that works if it is not.\n        self._blit = blit and fig.canvas.supports_blit\n\n        # These are the basics of the animation.  The frame sequence represents\n        # information for each frame of the animation and depends on how the\n        # drawing is handled by the subclasses. The event source fires events\n        # that cause the frame sequence to be iterated.\n        self.frame_seq = self.new_frame_seq()\n        self.event_source = event_source\n\n        # Instead of starting the event source now, we connect to the figure's\n        # draw_event, so that we only start once the figure has been drawn.\n        self._first_draw_id = fig.canvas.mpl_connect('draw_event', self._start)\n\n        # Connect to the figure's close_event so that we don't continue to\n        # fire events and try to draw to a deleted figure.\n        self._close_id = self._fig.canvas.mpl_connect('close_event',\n                                                      self._stop)\n        if self._blit:\n            self._setup_blit()",
        "begin_line": 913,
        "end_line": 936,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.animation.Animation.save#965",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.Animation",
        "signature": "lib.matplotlib.animation.Animation.save(self, filename, writer=None, fps=None, dpi=None, codec=None, bitrate=None, extra_args=None, metadata=None, extra_anim=None, savefig_kwargs=None, *, progress_callback=None)",
        "snippet": "    def save(self, filename, writer=None, fps=None, dpi=None, codec=None,\n             bitrate=None, extra_args=None, metadata=None, extra_anim=None,\n             savefig_kwargs=None, *, progress_callback=None):\n        \"\"\"\n        Save the animation as a movie file by drawing every frame.\n\n        Parameters\n        ----------\n        filename : str\n            The output filename, e.g., :file:`mymovie.mp4`.\n\n        writer : `MovieWriter` or str, default: :rc:`animation.writer`\n            A `MovieWriter` instance to use or a key that identifies a\n            class to use, such as 'ffmpeg'.\n\n        fps : int, optional\n            Movie frame rate (per second).  If not set, the frame rate from the\n            animation's frame interval.\n\n        dpi : float, default: :rc:`savefig.dpi`\n            Controls the dots per inch for the movie frames.  Together with\n            the figure's size in inches, this controls the size of the movie.\n\n        codec : str, optional, default: :rc:`animation.codec`.\n            The video codec to use.  Not all codecs are supported by a given\n            `MovieWriter`.\n\n        bitrate : int, default: :rc:`animation.bitrate`\n            The bitrate of the movie, in kilobits per second.  Higher values\n            means higher quality movies, but increase the file size.  A value\n            of -1 lets the underlying movie encoder select the bitrate.\n\n        extra_args : list of str or None, optional\n            Extra command-line arguments passed to the underlying movie\n            encoder.  The default, None, means to use\n            :rc:`animation.[name-of-encoder]_args` for the builtin writers.\n\n        metadata : Dict[str, str], default {}\n            Dictionary of keys and values for metadata to include in\n            the output file. Some keys that may be of use include:\n            title, artist, genre, subject, copyright, srcform, comment.\n\n        extra_anim : list, default: []\n            Additional `Animation` objects that should be included\n            in the saved movie file. These need to be from the same\n            `matplotlib.figure.Figure` instance. Also, animation frames will\n            just be simply combined, so there should be a 1:1 correspondence\n            between the frames from the different animations.\n\n        savefig_kwargs : dict, default: {}\n            Keyword arguments passed to each `~.Figure.savefig` call used to\n            save the individual frames.\n\n        progress_callback : function, optional\n            A callback function that will be called for every frame to notify\n            the saving progress. It must have the signature ::\n\n                def func(current_frame: int, total_frames: int) -> Any\n\n            where *current_frame* is the current frame number and\n            *total_frames* is the total number of frames to be saved.\n            *total_frames* is set to None, if the total number of frames can\n            not be determined. Return values may exist but are ignored.\n\n            Example code to write the progress to stdout::\n\n                progress_callback =\\\n                    lambda i, n: print(f'Saving frame {i} of {n}')\n\n        Notes\n        -----\n        *fps*, *codec*, *bitrate*, *extra_args* and *metadata* are used to\n        construct a `.MovieWriter` instance and can only be passed if\n        *writer* is a string.  If they are passed as non-*None* and *writer*\n        is a `.MovieWriter`, a `RuntimeError` will be raised.\n        \"\"\"\n\n        if writer is None:\n            writer = mpl.rcParams['animation.writer']\n        elif (not isinstance(writer, str) and\n              any(arg is not None\n                  for arg in (fps, codec, bitrate, extra_args, metadata))):\n            raise RuntimeError('Passing in values for arguments '\n                               'fps, codec, bitrate, extra_args, or metadata '\n                               'is not supported when writer is an existing '\n                               'MovieWriter instance. These should instead be '\n                               'passed as arguments when creating the '\n                               'MovieWriter instance.')\n\n        if savefig_kwargs is None:\n            savefig_kwargs = {}\n\n        if fps is None and hasattr(self, '_interval'):\n            # Convert interval in ms to frames per second\n            fps = 1000. / self._interval\n\n        # Re-use the savefig DPI for ours if none is given\n        if dpi is None:\n            dpi = mpl.rcParams['savefig.dpi']\n        if dpi == 'figure':\n            dpi = self._fig.dpi\n\n        writer_kwargs = {}\n        if codec is not None:\n            writer_kwargs['codec'] = codec\n        if bitrate is not None:\n            writer_kwargs['bitrate'] = bitrate\n        if extra_args is not None:\n            writer_kwargs['extra_args'] = extra_args\n        if metadata is not None:\n            writer_kwargs['metadata'] = metadata\n\n        all_anim = [self]\n        if extra_anim is not None:\n            all_anim.extend(anim\n                            for anim\n                            in extra_anim if anim._fig is self._fig)\n\n        # If we have the name of a writer, instantiate an instance of the\n        # registered class.\n        if isinstance(writer, str):\n            if writers.is_available(writer):\n                writer = writers[writer](fps, **writer_kwargs)\n            else:\n                alt_writer = next(writers, None)\n                if alt_writer is None:\n                    raise ValueError(\"Cannot save animation: no writers are \"\n                                     \"available. Please install ffmpeg to \"\n                                     \"save animations.\")\n                _log.warning(\"MovieWriter %s unavailable; trying to use %s \"\n                             \"instead.\", writer, alt_writer)\n                writer = alt_writer(fps, **writer_kwargs)\n        _log.info('Animation.save using %s', type(writer))\n\n        if 'bbox_inches' in savefig_kwargs:\n            _log.warning(\"Warning: discarding the 'bbox_inches' argument in \"\n                         \"'savefig_kwargs' as it may cause frame size \"\n                         \"to vary, which is inappropriate for animation.\")\n            savefig_kwargs.pop('bbox_inches')\n\n        # Create a new sequence of frames for saved data. This is different\n        # from new_frame_seq() to give the ability to save 'live' generated\n        # frame information to be saved later.\n        # TODO: Right now, after closing the figure, saving a movie won't work\n        # since GUI widgets are gone. Either need to remove extra code to\n        # allow for this non-existent use case or find a way to make it work.\n        if mpl.rcParams['savefig.bbox'] == 'tight':\n            _log.info(\"Disabling savefig.bbox = 'tight', as it may cause \"\n                      \"frame size to vary, which is inappropriate for \"\n                      \"animation.\")\n        # canvas._is_saving = True makes the draw_event animation-starting\n        # callback a no-op.\n        with mpl.rc_context({'savefig.bbox': None}), \\\n             writer.saving(self._fig, filename, dpi), \\\n             cbook._setattr_cm(self._fig.canvas, _is_saving=True):\n            for anim in all_anim:\n                anim._init_draw()  # Clear the initial frame\n            frame_number = 0\n            # TODO: Currently only FuncAnimation has a save_count\n            #       attribute. Can we generalize this to all Animations?\n            save_count_list = [getattr(a, 'save_count', None)\n                               for a in all_anim]\n            if None in save_count_list:\n                total_frames = None\n            else:\n                total_frames = sum(save_count_list)\n            for data in zip(*[a.new_saved_frame_seq() for a in all_anim]):\n                for anim, d in zip(all_anim, data):\n                    # TODO: See if turning off blit is really necessary\n                    anim._draw_next_frame(d, blit=False)\n                    if progress_callback is not None:\n                        progress_callback(frame_number, total_frames)\n                        frame_number += 1\n                writer.grab_frame(**savefig_kwargs)",
        "begin_line": 965,
        "end_line": 1138,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.animation.Animation._post_draw#1188",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.Animation",
        "signature": "lib.matplotlib.animation.Animation._post_draw(self, framedata, blit)",
        "snippet": "    def _post_draw(self, framedata, blit):\n        # After the frame is rendered, this handles the actual flushing of\n        # the draw, which can be a direct draw_idle() or make use of the\n        # blitting.\n        if blit and self._drawn_artists:\n            self._blit_draw(self._drawn_artists)\n        else:\n            self._fig.canvas.draw_idle()",
        "begin_line": 1188,
        "end_line": 1195,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.714396735962697e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.animation.Animation.to_jshtml#1344",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.Animation",
        "signature": "lib.matplotlib.animation.Animation.to_jshtml(self, fps=None, embed_frames=True, default_mode=None)",
        "snippet": "    def to_jshtml(self, fps=None, embed_frames=True, default_mode=None):\n        \"\"\"Generate HTML representation of the animation\"\"\"\n        if fps is None and hasattr(self, '_interval'):\n            # Convert interval in ms to frames per second\n            fps = 1000 / self._interval\n\n        # If we're not given a default mode, choose one base on the value of\n        # the repeat attribute\n        if default_mode is None:\n            default_mode = 'loop' if self.repeat else 'once'\n\n        if not hasattr(self, \"_html_representation\"):\n            # Can't open a NamedTemporaryFile twice on Windows, so use a\n            # TemporaryDirectory instead.\n            with TemporaryDirectory() as tmpdir:\n                path = Path(tmpdir, \"temp.html\")\n                writer = HTMLWriter(fps=fps,\n                                    embed_frames=embed_frames,\n                                    default_mode=default_mode)\n                self.save(str(path), writer=writer)\n                self._html_representation = path.read_text()\n\n        return self._html_representation",
        "begin_line": 1344,
        "end_line": 1366,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.animation.TimedAnimation.__init__#1398",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.TimedAnimation",
        "signature": "lib.matplotlib.animation.TimedAnimation.__init__(self, fig, interval=200, repeat_delay=0, repeat=True, event_source=None, *args, **kwargs)",
        "snippet": "    def __init__(self, fig, interval=200, repeat_delay=0, repeat=True,\n                 event_source=None, *args, **kwargs):\n        self._interval = interval\n        # Undocumented support for repeat_delay = None as backcompat.\n        self._repeat_delay = repeat_delay if repeat_delay is not None else 0\n        self.repeat = repeat\n        # If we're not given an event source, create a new timer. This permits\n        # sharing timers between animation objects for syncing animations.\n        if event_source is None:\n            event_source = fig.canvas.new_timer(interval=self._interval)\n        Animation.__init__(self, fig, event_source=event_source,\n                           *args, **kwargs)",
        "begin_line": 1398,
        "end_line": 1409,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.animation.FuncAnimation.__init__#1598",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.FuncAnimation",
        "signature": "lib.matplotlib.animation.FuncAnimation.__init__(self, fig, func, frames=None, init_func=None, fargs=None, save_count=None, *, cache_frame_data=True, **kwargs)",
        "snippet": "    def __init__(self, fig, func, frames=None, init_func=None, fargs=None,\n                 save_count=None, *, cache_frame_data=True, **kwargs):\n        if fargs:\n            self._args = fargs\n        else:\n            self._args = ()\n        self._func = func\n        self._init_func = init_func\n\n        # Amount of framedata to keep around for saving movies. This is only\n        # used if we don't know how many frames there will be: in the case\n        # of no generator or in the case of a callable.\n        self.save_count = save_count\n        # Set up a function that creates a new iterable when needed. If nothing\n        # is passed in for frames, just use itertools.count, which will just\n        # keep counting from 0. A callable passed in for frames is assumed to\n        # be a generator. An iterable will be used as is, and anything else\n        # will be treated as a number of frames.\n        if frames is None:\n            self._iter_gen = itertools.count\n        elif callable(frames):\n            self._iter_gen = frames\n        elif np.iterable(frames):\n            if kwargs.get('repeat', True):\n                def iter_frames(frames=frames):\n                    while True:\n                        this, frames = itertools.tee(frames, 2)\n                        yield from this\n                self._iter_gen = iter_frames\n            else:\n                self._iter_gen = lambda: iter(frames)\n            if hasattr(frames, '__len__'):\n                self.save_count = len(frames)\n        else:\n            self._iter_gen = lambda: iter(range(frames))\n            self.save_count = frames\n\n        if self.save_count is None:\n            # If we're passed in and using the default, set save_count to 100.\n            self.save_count = 100\n        else:\n            # itertools.islice returns an error when passed a numpy int instead\n            # of a native python int (http://bugs.python.org/issue30537).\n            # As a workaround, convert save_count to a native python int.\n            self.save_count = int(self.save_count)\n\n        self._cache_frame_data = cache_frame_data\n\n        # Needs to be initialized so the draw functions work without checking\n        self._save_seq = []\n\n        TimedAnimation.__init__(self, fig, **kwargs)\n\n        # Need to reset the saved seq, since right now it will contain data\n        # for a single frame from init, which is not what we want.\n        self._save_seq = []",
        "begin_line": 1598,
        "end_line": 1653,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.animation.FuncAnimation.iter_frames#1622",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.FuncAnimation",
        "signature": "lib.matplotlib.animation.FuncAnimation.iter_frames(frames=frames)",
        "snippet": "                def iter_frames(frames=frames):\n                    while True:\n                        this, frames = itertools.tee(frames, 2)\n                        yield from this",
        "begin_line": 1622,
        "end_line": 1625,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.animation.FuncAnimation.new_frame_seq#1655",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.FuncAnimation",
        "signature": "lib.matplotlib.animation.FuncAnimation.new_frame_seq(self)",
        "snippet": "    def new_frame_seq(self):\n        # Use the generating function to generate a new frame sequence\n        return self._iter_gen()",
        "begin_line": 1655,
        "end_line": 1657,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.714396735962697e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.animation.FuncAnimation.new_saved_frame_seq#1659",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.FuncAnimation",
        "signature": "lib.matplotlib.animation.FuncAnimation.new_saved_frame_seq(self)",
        "snippet": "    def new_saved_frame_seq(self):\n        # Generate an iterator for the sequence of saved data. If there are\n        # no saved frames, generate a new frame sequence and take the first\n        # save_count entries in it.\n        if self._save_seq:\n            # While iterating we are going to update _save_seq\n            # so make a copy to safely iterate over\n            self._old_saved_seq = list(self._save_seq)\n            return iter(self._old_saved_seq)\n        else:\n            if self.save_count is not None:\n                return itertools.islice(self.new_frame_seq(), self.save_count)\n\n            else:\n                frame_seq = self.new_frame_seq()\n\n                def gen():\n                    try:\n                        for _ in range(100):\n                            yield next(frame_seq)\n                    except StopIteration:\n                        pass\n                    else:\n                        cbook.warn_deprecated(\n                            \"2.2\", message=\"FuncAnimation.save has truncated \"\n                            \"your animation to 100 frames.  In the future, no \"\n                            \"such truncation will occur; please pass \"\n                            \"'save_count' accordingly.\")\n\n                return gen()",
        "begin_line": 1659,
        "end_line": 1688,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.animation.FuncAnimation._init_draw#1690",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.FuncAnimation",
        "signature": "lib.matplotlib.animation.FuncAnimation._init_draw(self)",
        "snippet": "    def _init_draw(self):\n        # Initialize the drawing either using the given init_func or by\n        # calling the draw function with the first item of the frame sequence.\n        # For blitting, the init_func should return a sequence of modified\n        # artists.\n        if self._init_func is None:\n            self._draw_frame(next(self.new_frame_seq()))\n\n        else:\n            self._drawn_artists = self._init_func()\n            if self._blit:\n                if self._drawn_artists is None:\n                    raise RuntimeError('The init_func must return a '\n                                       'sequence of Artist objects.')\n                for a in self._drawn_artists:\n                    a.set_animated(self._blit)\n        self._save_seq = []",
        "begin_line": 1690,
        "end_line": 1706,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.animation.FuncAnimation._draw_frame#1708",
        "src_path": "lib/matplotlib/animation.py",
        "class_name": "lib.matplotlib.animation.FuncAnimation",
        "signature": "lib.matplotlib.animation.FuncAnimation._draw_frame(self, framedata)",
        "snippet": "    def _draw_frame(self, framedata):\n        if self._cache_frame_data:\n            # Save the data for potential saving of movies.\n            self._save_seq.append(framedata)\n\n        # Make sure to respect save_count (keep only the last save_count\n        # around)\n        self._save_seq = self._save_seq[-self.save_count:]\n\n        # Call the func with framedata and args. If blitting is desired,\n        # func needs to return a sequence of any artists that were modified.\n        self._drawn_artists = self._func(framedata, *self._args)\n        if self._blit:\n            if self._drawn_artists is None:\n                raise RuntimeError('The animation function must return a '\n                                   'sequence of Artist objects.')\n            self._drawn_artists = sorted(self._drawn_artists,\n                                         key=lambda x: x.get_zorder())\n\n            for a in self._drawn_artists:\n                a.set_animated(self._blit)",
        "begin_line": 1708,
        "end_line": 1728,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.86679822397632e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.__init__#73",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.__init__(self)",
        "snippet": "    def __init__(self):\n        self._stale = True\n        self.stale_callback = None\n        self._axes = None\n        self.figure = None\n\n        self._transform = None\n        self._transformSet = False\n        self._visible = True\n        self._animated = False\n        self._alpha = None\n        self.clipbox = None\n        self._clippath = None\n        self._clipon = True\n        self._label = ''\n        self._picker = None\n        self._contains = None\n        self._rasterized = None\n        self._agg_filter = None\n        self._mouseover = False\n        self.eventson = False  # fire events only if eventson\n        self._oid = 0  # an observer id\n        self._propobservers = {}  # a dict from oids to funcs\n        try:\n            self.axes = None\n        except AttributeError:\n            # Handle self.axes as a read-only property, as in Figure.\n            pass\n        self._remove_method = None\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = mpl.rcParams['path.sketch']\n        self._path_effects = mpl.rcParams['path.effects']\n        self._sticky_edges = _XYPair([], [])\n        self._in_layout = True",
        "begin_line": 73,
        "end_line": 108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035587188612099642,
            "pseudo_dstar_susp": 0.0051813471502590676,
            "pseudo_tarantula_susp": 0.000576036866359447,
            "pseudo_op2_susp": 0.005319148936170213,
            "pseudo_barinel_susp": 0.000576036866359447
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.remove#117",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.remove(self)",
        "snippet": "    def remove(self):\n        \"\"\"\n        Remove the artist from the figure if possible.\n\n        The effect will not be visible until the figure is redrawn, e.g.,\n        with `.FigureCanvasBase.draw_idle`.  Call `~.axes.Axes.relim` to\n        update the axes limits if desired.\n\n        Note: `~.axes.Axes.relim` will not see collections even if the\n        collection was added to the axes with *autolim* = True.\n\n        Note: there is no support for removing the artist's legend entry.\n        \"\"\"\n\n        # There is no method to set the callback.  Instead the parent should\n        # set the _remove_method attribute directly.  This would be a\n        # protected attribute if Python supported that sort of thing.  The\n        # callback has one parameter, which is the child to be removed.\n        if self._remove_method is not None:\n            self._remove_method(self)\n            # clear stale callback\n            self.stale_callback = None\n            _ax_flag = False\n            if hasattr(self, 'axes') and self.axes:\n                # remove from the mouse hit list\n                self.axes._mouseover_set.discard(self)\n                # mark the axes as stale\n                self.axes.stale = True\n                # decouple the artist from the axes\n                self.axes = None\n                _ax_flag = True\n\n            if self.figure:\n                self.figure = None\n                if not _ax_flag:\n                    self.figure = True\n\n        else:\n            raise NotImplementedError('cannot remove artist')",
        "begin_line": 117,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.041170794467674e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.convert_yunits#179",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.convert_yunits(self, y)",
        "snippet": "    def convert_yunits(self, y):\n        \"\"\"\n        Convert *y* using the unit type of the yaxis.\n\n        If the artist is not in contained in an Axes or if the yaxis does not\n        have units, *y* itself is returned.\n        \"\"\"\n        ax = getattr(self, 'axes', None)\n        if ax is None or ax.yaxis is None:\n            return y\n        return ax.yaxis.convert_units(y)",
        "begin_line": 179,
        "end_line": 189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.649770781074301e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.axes#197",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.axes(self, new_axes)",
        "snippet": "    def axes(self, new_axes):\n        if (new_axes is not None and self._axes is not None\n                and new_axes != self._axes):\n            raise ValueError(\"Can not reset the axes.  You are probably \"\n                             \"trying to re-use an artist in more than one \"\n                             \"Axes which is not supported\")\n        self._axes = new_axes\n        if new_axes is not None and new_axes is not self:\n            self.stale_callback = _stale_axes_callback",
        "begin_line": 197,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.056719303899453e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.stale#216",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.stale(self, val)",
        "snippet": "    def stale(self, val):\n        self._stale = val\n\n        # if the artist is animated it does not take normal part in the\n        # draw stack and is not expected to be drawn as part of the normal\n        # draw loop (when not saving) so do not propagate this change\n        if self.get_animated():\n            return\n\n        if val and self.stale_callback is not None:\n            self.stale_callback(self, val)",
        "begin_line": 216,
        "end_line": 226,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.265829062654984e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.pchanged#334",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.pchanged(self)",
        "snippet": "    def pchanged(self):\n        \"\"\"\n        Call all of the registered callbacks.\n\n        This function is triggered internally when a property is changed.\n\n        See Also\n        --------\n        add_callback\n        remove_callback\n        \"\"\"\n        for oid, func in self._propobservers.items():\n            func(self)",
        "begin_line": 334,
        "end_line": 346,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006779661016949153,
            "pseudo_dstar_susp": 0.000819672131147541,
            "pseudo_tarantula_susp": 0.00039824771007566706,
            "pseudo_op2_susp": 0.000819672131147541,
            "pseudo_barinel_susp": 0.00039824771007566706
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_transform#356",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_transform(self, t)",
        "snippet": "    def set_transform(self, t):\n        \"\"\"\n        Set the artist transform.\n\n        Parameters\n        ----------\n        t : `.Transform`\n        \"\"\"\n        self._transform = t\n        self._transformSet = True\n        self.pchanged()\n        self.stale = True",
        "begin_line": 356,
        "end_line": 367,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.3905531035778e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_transform#369",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_transform(self)",
        "snippet": "    def get_transform(self):\n        \"\"\"Return the `.Transform` instance used by this artist.\"\"\"\n        if self._transform is None:\n            self._transform = IdentityTransform()\n        elif (not isinstance(self._transform, Transform)\n              and hasattr(self._transform, '_as_mpl_transform')):\n            self._transform = self._transform._as_mpl_transform(self.axes)\n        return self._transform",
        "begin_line": 369,
        "end_line": 376,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist._default_contains#382",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist._default_contains(self, mouseevent, figure=None)",
        "snippet": "    def _default_contains(self, mouseevent, figure=None):\n        \"\"\"\n        Base impl. for checking whether a mouseevent happened in an artist.\n\n        1. If the artist defines a custom checker, use it (deprecated).\n        2. If the artist figure is known and the event did not occur in that\n           figure (by checking its ``canvas`` attribute), reject it.\n        3. Otherwise, return `None, {}`, indicating that the subclass'\n           implementation should be used.\n\n        Subclasses should start their definition of `contains` as follows:\n\n            inside, info = self._default_contains(mouseevent)\n            if inside is not None:\n                return inside, info\n            # subclass-specific implementation follows\n\n        The *figure* kwarg is provided for the implementation of\n        `Figure.contains`.\n        \"\"\"\n        if callable(self._contains):\n            return self._contains(self, mouseevent)\n        if figure is not None and mouseevent.canvas is not figure.canvas:\n            return False, {}\n        return None, {}",
        "begin_line": 382,
        "end_line": 406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_gid#573",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_gid(self)",
        "snippet": "    def get_gid(self):\n        \"\"\"Return the group id.\"\"\"\n        return self._gid",
        "begin_line": 573,
        "end_line": 575,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_snap#587",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_snap(self)",
        "snippet": "    def get_snap(self):\n        \"\"\"\n        Returns the snap setting.\n\n        See `.set_snap` for details.\n        \"\"\"\n        if mpl.rcParams['path.snap']:\n            return self._snap\n        else:\n            return False",
        "begin_line": 587,
        "end_line": 596,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_snap#598",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_snap(self, snap)",
        "snippet": "    def set_snap(self, snap):\n        \"\"\"\n        Set the snapping behavior.\n\n        Snapping aligns positions with the pixel grid, which results in\n        clearer images. For example, if a black line of 1px width was\n        defined at a position in between two pixels, the resulting image\n        would contain the interpolated value of that line in the pixel grid,\n        which would be a grey value on both adjacent pixel positions. In\n        contrast, snapping will move the line to the nearest integer pixel\n        value, so that the resulting image will really contain a 1px wide\n        black line.\n\n        Snapping is currently only supported by the Agg and MacOSX backends.\n\n        Parameters\n        ----------\n        snap : bool or None\n            Possible values:\n\n            - *True*: Snap vertices to the nearest pixel center.\n            - *False*: Do not modify vertex positions.\n            - *None*: (auto) If the path contains only rectilinear line\n              segments, round to the nearest pixel center.\n        \"\"\"\n        self._snap = snap\n        self.stale = True",
        "begin_line": 598,
        "end_line": 624,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_path_effects#681",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_path_effects(self)",
        "snippet": "    def get_path_effects(self):\n        return self._path_effects",
        "begin_line": 681,
        "end_line": 682,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_figure#688",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_figure(self, fig)",
        "snippet": "    def set_figure(self, fig):\n        \"\"\"\n        Set the `.Figure` instance the artist belongs to.\n\n        Parameters\n        ----------\n        fig : `.Figure`\n        \"\"\"\n        # if this is a no-op just return\n        if self.figure is fig:\n            return\n        # if we currently have a figure (the case of both `self.figure`\n        # and *fig* being none is taken care of above) we then user is\n        # trying to change the figure an artist is associated with which\n        # is not allowed for the same reason as adding the same instance\n        # to more than one Axes\n        if self.figure is not None:\n            raise RuntimeError(\"Can not put single artist in \"\n                               \"more than one figure\")\n        self.figure = fig\n        if self.figure and self.figure is not self:\n            self.pchanged()\n        self.stale = True",
        "begin_line": 688,
        "end_line": 710,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001841620626151013,
            "pseudo_dstar_susp": 0.0010111223458038423,
            "pseudo_tarantula_susp": 0.000725689404934688,
            "pseudo_op2_susp": 0.0010111223458038423,
            "pseudo_barinel_susp": 0.000725689404934688
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_clip_path#724",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_clip_path(self, path, transform=None)",
        "snippet": "    def set_clip_path(self, path, transform=None):\n        \"\"\"\n        Set the artist's clip path.\n\n        Parameters\n        ----------\n        path : `.Patch` or `.Path` or `.TransformedPath` or None\n            The clip path. If given a `.Path`, *transform* must be provided as\n            well. If *None*, a previously set clip path is removed.\n        transform : `~matplotlib.transforms.Transform`, optional\n            Only used if *path* is a `.Path`, in which case the given `.Path`\n            is converted to a `.TransformedPath` using *transform*.\n\n        Notes\n        -----\n        For efficiency, if *path* is a `.Rectangle` this method will set the\n        clipping box to the corresponding rectangle and set the clipping path\n        to ``None``.\n\n        For technical reasons (support of `~.Artist.set`), a tuple\n        (*path*, *transform*) is also accepted as a single positional\n        parameter.\n\n        .. ACCEPTS: Patch or (Path, Transform) or None\n        \"\"\"\n        from matplotlib.patches import Patch, Rectangle\n\n        success = False\n        if transform is None:\n            if isinstance(path, Rectangle):\n                self.clipbox = TransformedBbox(Bbox.unit(),\n                                               path.get_transform())\n                self._clippath = None\n                success = True\n            elif isinstance(path, Patch):\n                self._clippath = TransformedPatchPath(path)\n                success = True\n            elif isinstance(path, tuple):\n                path, transform = path\n\n        if path is None:\n            self._clippath = None\n            success = True\n        elif isinstance(path, Path):\n            self._clippath = TransformedPath(path, transform)\n            success = True\n        elif isinstance(path, TransformedPatchPath):\n            self._clippath = path\n            success = True\n        elif isinstance(path, TransformedPath):\n            self._clippath = path\n            success = True\n\n        if not success:\n            raise TypeError(\n                \"Invalid arguments to set_clip_path, of type {} and {}\"\n                .format(type(path).__name__, type(transform).__name__))\n        # This may result in the callbacks being hit twice, but guarantees they\n        # will be hit at least once.\n        self.pchanged()\n        self.stale = True",
        "begin_line": 724,
        "end_line": 784,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0025380710659898475,
            "pseudo_dstar_susp": 0.0011074197120708748,
            "pseudo_tarantula_susp": 0.0008424599831508003,
            "pseudo_op2_susp": 0.0011074197120708748,
            "pseudo_barinel_susp": 0.0008424599831508003
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_visible#793",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_visible(self)",
        "snippet": "    def get_visible(self):\n        \"\"\"Return the visibility.\"\"\"\n        return self._visible",
        "begin_line": 793,
        "end_line": 795,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006079027355623101,
            "pseudo_dstar_susp": 0.0007968127490039841,
            "pseudo_tarantula_susp": 0.0003700962250185048,
            "pseudo_op2_susp": 0.0007968127490039841,
            "pseudo_barinel_susp": 0.0003700962250185048
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_animated#797",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_animated(self)",
        "snippet": "    def get_animated(self):\n        \"\"\"Return whether the artist is animated.\"\"\"\n        return self._animated",
        "begin_line": 797,
        "end_line": 799,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019083969465648854,
            "pseudo_dstar_susp": 0.0010245901639344263,
            "pseudo_tarantula_susp": 0.001455604075691412,
            "pseudo_op2_susp": 0.0010245901639344263,
            "pseudo_barinel_susp": 0.001455604075691412
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_in_layout#801",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_in_layout(self)",
        "snippet": "    def get_in_layout(self):\n        \"\"\"\n        Return boolean flag, ``True`` if artist is included in layout\n        calculations.\n\n        E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n        `.Figure.tight_layout()`, and\n        ``fig.savefig(fname, bbox_inches='tight')``.\n        \"\"\"\n        return self._in_layout",
        "begin_line": 801,
        "end_line": 810,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_clip_box#816",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_clip_box(self)",
        "snippet": "    def get_clip_box(self):\n        \"\"\"Return the clipbox.\"\"\"\n        return self.clipbox",
        "begin_line": 816,
        "end_line": 818,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031928480204342275,
            "pseudo_dstar_susp": 0.00031240237425804435,
            "pseudo_tarantula_susp": 0.00038476337052712584,
            "pseudo_op2_susp": 0.00031240237425804435,
            "pseudo_barinel_susp": 0.00038476337052712584
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_transformed_clip_path_and_affine#824",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_transformed_clip_path_and_affine(self)",
        "snippet": "    def get_transformed_clip_path_and_affine(self):\n        \"\"\"\n        Return the clip path with the non-affine part of its\n        transformation applied, and the remaining affine part of its\n        transformation.\n        \"\"\"\n        if self._clippath is not None:\n            return self._clippath.get_transformed_path_and_affine()\n        return None, None",
        "begin_line": 824,
        "end_line": 832,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_clip_on#834",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_clip_on(self, b)",
        "snippet": "    def set_clip_on(self, b):\n        \"\"\"\n        Set whether the artist uses clipping.\n\n        When False artists will be visible out side of the axes which\n        can lead to unexpected results.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._clipon = b\n        # This may result in the callbacks being hit twice, but ensures they\n        # are hit at least once\n        self.pchanged()\n        self.stale = True",
        "begin_line": 834,
        "end_line": 849,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist._set_gc_clip#851",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist._set_gc_clip(self, gc)",
        "snippet": "    def _set_gc_clip(self, gc):\n        \"\"\"Set the clip properly for the gc.\"\"\"\n        if self._clipon:\n            if self.clipbox is not None:\n                gc.set_clip_rectangle(self.clipbox)\n            gc.set_clip_path(self._clippath)\n        else:\n            gc.set_clip_rectangle(None)\n            gc.set_clip_path(None)",
        "begin_line": 851,
        "end_line": 859,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_rasterized#861",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_rasterized(self)",
        "snippet": "    def get_rasterized(self):\n        \"\"\"Return whether the artist is to be rasterized.\"\"\"\n        return self._rasterized",
        "begin_line": 861,
        "end_line": 863,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_rasterized#865",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_rasterized(self, rasterized)",
        "snippet": "    def set_rasterized(self, rasterized):\n        \"\"\"\n        Force rasterized (bitmap) drawing in vector backend output.\n\n        Defaults to None, which implies the backend's default behavior.\n\n        Parameters\n        ----------\n        rasterized : bool or None\n        \"\"\"\n        if rasterized and not hasattr(self.draw, \"_supports_rasterization\"):\n            cbook._warn_external(\n                \"Rasterization of '%s' will be ignored\" % self)\n\n        self._rasterized = rasterized",
        "begin_line": 865,
        "end_line": 879,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_agg_filter#881",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_agg_filter(self)",
        "snippet": "    def get_agg_filter(self):\n        \"\"\"Return filter function to be used for agg filter.\"\"\"\n        return self._agg_filter",
        "begin_line": 881,
        "end_line": 883,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_alpha#921",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_alpha(self, alpha)",
        "snippet": "    def set_alpha(self, alpha):\n        \"\"\"\n        Set the alpha value used for blending - not supported on all backends.\n\n        Parameters\n        ----------\n        alpha : float or None\n        \"\"\"\n        if alpha is not None and not isinstance(alpha, Number):\n            raise TypeError('alpha must be a float or None')\n        self._alpha = alpha\n        self.pchanged()\n        self.stale = True",
        "begin_line": 921,
        "end_line": 933,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018726591760299626,
            "pseudo_dstar_susp": 0.0010162601626016261,
            "pseudo_tarantula_susp": 0.0015337423312883436,
            "pseudo_op2_susp": 0.0010162601626016261,
            "pseudo_barinel_susp": 0.0015337423312883436
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_visible#935",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_visible(self, b)",
        "snippet": "    def set_visible(self, b):\n        \"\"\"\n        Set the artist's visibility.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._visible = b\n        self.pchanged()\n        self.stale = True",
        "begin_line": 935,
        "end_line": 945,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028735632183908046,
            "pseudo_dstar_susp": 0.001148105625717566,
            "pseudo_tarantula_susp": 0.0009025270758122744,
            "pseudo_op2_susp": 0.001148105625717566,
            "pseudo_barinel_susp": 0.0009025270758122744
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_in_layout#959",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_in_layout(self, in_layout)",
        "snippet": "    def set_in_layout(self, in_layout):\n        \"\"\"\n        Set if artist is to be included in layout calculations,\n        E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n        `.Figure.tight_layout()`, and\n        ``fig.savefig(fname, bbox_inches='tight')``.\n\n        Parameters\n        ----------\n        in_layout : bool\n        \"\"\"\n        self._in_layout = in_layout",
        "begin_line": 959,
        "end_line": 970,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00036483035388544326,
            "pseudo_dstar_susp": 0.00033852403520649965,
            "pseudo_tarantula_susp": 0.0006385696040868455,
            "pseudo_op2_susp": 0.00033852403520649965,
            "pseudo_barinel_susp": 0.0006385696040868455
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.update#972",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.update(self, props)",
        "snippet": "    def update(self, props):\n        \"\"\"\n        Update this artist's properties from the dict *props*.\n\n        Parameters\n        ----------\n        props : dict\n        \"\"\"\n        ret = []\n        with cbook._setattr_cm(self, eventson=False):\n            for k, v in props.items():\n                k = k.lower()\n                # White list attributes we want to be able to update through\n                # art.update, art.set, setp.\n                if k == \"axes\":\n                    ret.append(setattr(self, k, v))\n                else:\n                    func = getattr(self, f\"set_{k}\", None)\n                    if not callable(func):\n                        raise AttributeError(f\"{type(self).__name__!r} object \"\n                                             f\"has no property {k!r}\")\n                    ret.append(func(v))\n        if ret:\n            self.pchanged()\n            self.stale = True\n        return ret",
        "begin_line": 972,
        "end_line": 997,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019011406844106464,
            "pseudo_dstar_susp": 0.0010224948875255625,
            "pseudo_tarantula_susp": 0.0007468259895444362,
            "pseudo_op2_susp": 0.0010224948875255625,
            "pseudo_barinel_susp": 0.0007468259895444362
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.get_label#999",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.get_label(self)",
        "snippet": "    def get_label(self):\n        \"\"\"Return the label used for this artist in the legend.\"\"\"\n        return self._label",
        "begin_line": 999,
        "end_line": 1001,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004008016032064128,
            "pseudo_dstar_susp": 0.0004952947003467063,
            "pseudo_tarantula_susp": 0.0009267840593141798,
            "pseudo_op2_susp": 0.0004952947003467063,
            "pseudo_barinel_susp": 0.0009267840593141798
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.set_label#1003",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.set_label(self, s)",
        "snippet": "    def set_label(self, s):\n        \"\"\"\n        Set a label that will be displayed in the legend.\n\n        Parameters\n        ----------\n        s : object\n            *s* will be converted to a string by calling `str`.\n        \"\"\"\n        if s is not None:\n            self._label = str(s)\n        else:\n            self._label = None\n        self.pchanged()\n        self.stale = True",
        "begin_line": 1003,
        "end_line": 1017,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.update_from#1060",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.update_from(self, other)",
        "snippet": "    def update_from(self, other):\n        \"\"\"Copy properties from *other* to *self*.\"\"\"\n        self._transform = other._transform\n        self._transformSet = other._transformSet\n        self._visible = other._visible\n        self._alpha = other._alpha\n        self.clipbox = other.clipbox\n        self._clipon = other._clipon\n        self._clippath = other._clippath\n        self._label = other._label\n        self._sketch = other._sketch\n        self._path_effects = other._path_effects\n        self.sticky_edges.x[:] = other.sticky_edges.x.copy()\n        self.sticky_edges.y[:] = other.sticky_edges.y.copy()\n        self.pchanged()\n        self.stale = True",
        "begin_line": 1060,
        "end_line": 1075,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.513148009015778e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.matchfunc#1116",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.matchfunc(x)",
        "snippet": "            def matchfunc(x):\n                return True",
        "begin_line": 1116,
        "end_line": 1117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.format_cursor_data#1163",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.format_cursor_data(self, data)",
        "snippet": "    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        try:\n            data[0]\n        except (TypeError, IndexError):\n            data = [data]\n        data_str = ', '.join('{:0.3g}'.format(item) for item in data\n                             if isinstance(item, Number))\n        return \"[\" + data_str + \"]\"",
        "begin_line": 1163,
        "end_line": 1185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.Artist.mouseover#1188",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.Artist",
        "signature": "lib.matplotlib.artist.Artist.mouseover(self)",
        "snippet": "    def mouseover(self):\n        \"\"\"\n        If this property is set to *True*, the artist will be queried for\n        custom context information when the mouse cursor moves over it.\n\n        See also :meth:`get_cursor_data`, :class:`.ToolCursorPosition` and\n        :class:`.NavigationToolbar2`.\n        \"\"\"\n        return self._mouseover",
        "begin_line": 1188,
        "end_line": 1196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018315018315018315,
            "pseudo_dstar_susp": 0.0010090817356205853,
            "pseudo_tarantula_susp": 0.0007246376811594203,
            "pseudo_op2_susp": 0.0010090817356205853,
            "pseudo_barinel_susp": 0.0007246376811594203
        }
    },
    {
        "name": "lib.matplotlib.artist.ArtistInspector.get_aliases#1236",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.ArtistInspector",
        "signature": "lib.matplotlib.artist.ArtistInspector.get_aliases(self)",
        "snippet": "    def get_aliases(self):\n        \"\"\"\n        Get a dict mapping property fullnames to sets of aliases for each alias\n        in the :class:`~matplotlib.artist.ArtistInspector`.\n\n        e.g., for lines::\n\n          {'markerfacecolor': {'mfc'},\n           'linewidth'      : {'lw'},\n          }\n        \"\"\"\n        names = [name for name in dir(self.o)\n                 if name.startswith(('set_', 'get_'))\n                    and callable(getattr(self.o, name))]\n        aliases = {}\n        for name in names:\n            func = getattr(self.o, name)\n            if not self.is_alias(func):\n                continue\n            propname = re.search(\"`({}.*)`\".format(name[:4]),  # get_.*/set_.*\n                                 inspect.getdoc(func)).group(1)\n            aliases.setdefault(propname[4:], set()).add(name[4:])\n        return aliases",
        "begin_line": 1236,
        "end_line": 1258,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.ArtistInspector.get_valid_values#1264",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.ArtistInspector",
        "signature": "lib.matplotlib.artist.ArtistInspector.get_valid_values(self, attr)",
        "snippet": "    def get_valid_values(self, attr):\n        \"\"\"\n        Get the legal arguments for the setter associated with *attr*.\n\n        This is done by querying the docstring of the setter for a line that\n        begins with \"ACCEPTS:\" or \".. ACCEPTS:\", and then by looking for a\n        numpydoc-style documentation for the setter's first argument.\n        \"\"\"\n\n        name = 'set_%s' % attr\n        if not hasattr(self.o, name):\n            raise AttributeError('%s has no function %s' % (self.o, name))\n        func = getattr(self.o, name)\n\n        docstring = inspect.getdoc(func)\n        if docstring is None:\n            return 'unknown'\n\n        if docstring.startswith('Alias for '):\n            return None\n\n        match = self._get_valid_values_regex.search(docstring)\n        if match is not None:\n            return re.sub(\"\\n *\", \" \", match.group(1))\n\n        # Much faster than list(inspect.signature(func).parameters)[1],\n        # although barely relevant wrt. matplotlib's total import time.\n        param_name = func.__code__.co_varnames[1]\n        # We could set the presence * based on whether the parameter is a\n        # varargs (it can't be a varkwargs) but it's not really worth the it.\n        match = re.search(r\"(?m)^ *\\*?{} : (.+)\".format(param_name), docstring)\n        if match:\n            return match.group(1)\n\n        return 'unknown'",
        "begin_line": 1264,
        "end_line": 1298,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.ArtistInspector._get_setters_and_targets#1300",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.ArtistInspector",
        "signature": "lib.matplotlib.artist.ArtistInspector._get_setters_and_targets(self)",
        "snippet": "    def _get_setters_and_targets(self):\n        \"\"\"\n        Get the attribute strings and a full path to where the setter\n        is defined for all setters in an object.\n        \"\"\"\n        setters = []\n        for name in dir(self.o):\n            if not name.startswith('set_'):\n                continue\n            func = getattr(self.o, name)\n            if (not callable(func)\n                    or len(inspect.signature(func).parameters) < 2\n                    or self.is_alias(func)):\n                continue\n            setters.append(\n                (name[4:], f\"{func.__module__}.{func.__qualname__}\"))\n        return setters",
        "begin_line": 1300,
        "end_line": 1316,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.ArtistInspector.is_alias#1336",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.ArtistInspector",
        "signature": "lib.matplotlib.artist.ArtistInspector.is_alias(self, o)",
        "snippet": "    def is_alias(self, o):\n        \"\"\"Return whether method object *o* is an alias for another method.\"\"\"\n        ds = inspect.getdoc(o)\n        if ds is None:\n            return False\n        return ds.startswith('Alias for ')",
        "begin_line": 1336,
        "end_line": 1341,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.ArtistInspector.aliased_name#1343",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.ArtistInspector",
        "signature": "lib.matplotlib.artist.ArtistInspector.aliased_name(self, s)",
        "snippet": "    def aliased_name(self, s):\n        \"\"\"\n        Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME'.\n\n        e.g., for the line markerfacecolor property, which has an\n        alias, return 'markerfacecolor or mfc' and for the transform\n        property, which does not, return 'transform'.\n        \"\"\"\n        aliases = ''.join(' or %s' % x for x in sorted(self.aliasd.get(s, [])))\n        return s + aliases",
        "begin_line": 1343,
        "end_line": 1352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.ArtistInspector.pprint_setters#1366",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.ArtistInspector",
        "signature": "lib.matplotlib.artist.ArtistInspector.pprint_setters(self, prop=None, leadingspace=2)",
        "snippet": "    def pprint_setters(self, prop=None, leadingspace=2):\n        \"\"\"\n        If *prop* is *None*, return a list of strings of all settable\n        properties and their valid values.\n\n        If *prop* is not *None*, it is a valid property name and that\n        property will be returned as a string of property : valid\n        values.\n        \"\"\"\n        if leadingspace:\n            pad = ' ' * leadingspace\n        else:\n            pad = ''\n        if prop is not None:\n            accepts = self.get_valid_values(prop)\n            return '%s%s: %s' % (pad, prop, accepts)\n\n        attrs = self._get_setters_and_targets()\n        attrs.sort()\n        lines = []\n\n        for prop, path in attrs:\n            accepts = self.get_valid_values(prop)\n            name = self.aliased_name(prop)\n\n            lines.append('%s%s: %s' % (pad, name, accepts))\n        return lines",
        "begin_line": 1366,
        "end_line": 1392,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.ArtistInspector.properties#1438",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist.ArtistInspector",
        "signature": "lib.matplotlib.artist.ArtistInspector.properties(self)",
        "snippet": "    def properties(self):\n        \"\"\"Return a dictionary mapping property name -> value.\"\"\"\n        o = self.oorig\n        getters = [name for name in dir(o)\n                   if name.startswith('get_') and callable(getattr(o, name))]\n        getters.sort()\n        d = {}\n        for name in getters:\n            func = getattr(o, name)\n            if self.is_alias(func):\n                continue\n            try:\n                with warnings.catch_warnings():\n                    warnings.simplefilter('ignore')\n                    val = func()\n            except Exception:\n                continue\n            else:\n                d[name[4:]] = val\n        return d",
        "begin_line": 1438,
        "end_line": 1457,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.getp#1475",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist",
        "signature": "lib.matplotlib.artist.getp(obj, property=None)",
        "snippet": "def getp(obj, property=None):\n    \"\"\"\n    Return the value of an object's *property*, or print all of them.\n\n    Parameters\n    ----------\n    obj : `.Artist`\n        The queried artist; e.g., a `.Line2D`, a `.Text`, or an `~.axes.Axes`.\n\n    property : str or None, default: None\n        If *property* is 'somename', this function returns\n        ``obj.get_somename()``.\n\n        If is is None (or unset), it *prints* all gettable properties from\n        *obj*.  Many properties have aliases for shorter typing, e.g. 'lw' is\n        an alias for 'linewidth'.  In the output, aliases and full property\n        names will be listed as:\n\n          property or alias = value\n\n        e.g.:\n\n          linewidth or lw = 2\n    \"\"\"\n    if property is None:\n        insp = ArtistInspector(obj)\n        ret = insp.pprint_getters()\n        print('\\n'.join(ret))\n        return\n    return getattr(obj, 'get_' + property)()",
        "begin_line": 1475,
        "end_line": 1504,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.artist.setp#1510",
        "src_path": "lib/matplotlib/artist.py",
        "class_name": "lib.matplotlib.artist",
        "signature": "lib.matplotlib.artist.setp(obj, *args, **kwargs)",
        "snippet": "def setp(obj, *args, **kwargs):\n    \"\"\"\n    Set a property on an artist object.\n\n    matplotlib supports the use of :func:`setp` (\"set property\") and\n    :func:`getp` to set and get object properties, as well as to do\n    introspection on the object.  For example, to set the linestyle of a\n    line to be dashed, you can do::\n\n      >>> line, = plot([1, 2, 3])\n      >>> setp(line, linestyle='--')\n\n    If you want to know the valid types of arguments, you can provide\n    the name of the property you want to set without a value::\n\n      >>> setp(line, 'linestyle')\n          linestyle: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n\n    If you want to see all the properties that can be set, and their\n    possible values, you can do::\n\n      >>> setp(line)\n          ... long output listing omitted\n\n    You may specify another output file to `setp` if `sys.stdout` is not\n    acceptable for some reason using the *file* keyword-only argument::\n\n      >>> with fopen('output.log') as f:\n      >>>     setp(line, file=f)\n\n    :func:`setp` operates on a single instance or a iterable of\n    instances. If you are in query mode introspecting the possible\n    values, only the first instance in the sequence is used. When\n    actually setting values, all the instances will be set.  e.g.,\n    suppose you have a list of two lines, the following will make both\n    lines thicker and red::\n\n      >>> x = arange(0, 1, 0.01)\n      >>> y1 = sin(2*pi*x)\n      >>> y2 = sin(4*pi*x)\n      >>> lines = plot(x, y1, x, y2)\n      >>> setp(lines, linewidth=2, color='r')\n\n    :func:`setp` works with the MATLAB style string/value pairs or\n    with python kwargs.  For example, the following are equivalent::\n\n      >>> setp(lines, 'linewidth', 2, 'color', 'r')  # MATLAB style\n      >>> setp(lines, linewidth=2, color='r')        # python style\n    \"\"\"\n\n    if isinstance(obj, Artist):\n        objs = [obj]\n    else:\n        objs = list(cbook.flatten(obj))\n\n    if not objs:\n        return\n\n    insp = ArtistInspector(objs[0])\n\n    # file has to be popped before checking if kwargs is empty\n    printArgs = {}\n    if 'file' in kwargs:\n        printArgs['file'] = kwargs.pop('file')\n\n    if not kwargs and len(args) < 2:\n        if args:\n            print(insp.pprint_setters(prop=args[0]), **printArgs)\n        else:\n            print('\\n'.join(insp.pprint_setters()), **printArgs)\n        return\n\n    if len(args) % 2:\n        raise ValueError('The set args must be string, value pairs')\n\n    # put args into ordereddict to maintain order\n    funcvals = OrderedDict((k, v) for k, v in zip(args[::2], args[1::2]))\n    ret = [o.update(funcvals) for o in objs] + [o.set(**kwargs) for o in objs]\n    return list(cbook.flatten(ret))",
        "begin_line": 1510,
        "end_line": 1588,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text.__init__#128",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.__init__(self, x=0, y=0, text='', color=None, verticalalignment='baseline', horizontalalignment='left', multialignment=None, fontproperties=None, rotation=None, linespacing=None, rotation_mode=None, usetex=None, wrap=False, **kwargs)",
        "snippet": "    def __init__(self,\n                 x=0, y=0, text='',\n                 color=None,           # defaults to rc params\n                 verticalalignment='baseline',\n                 horizontalalignment='left',\n                 multialignment=None,\n                 fontproperties=None,  # defaults to FontProperties()\n                 rotation=None,\n                 linespacing=None,\n                 rotation_mode=None,\n                 usetex=None,          # defaults to rcParams['text.usetex']\n                 wrap=False,\n                 **kwargs\n                 ):\n        \"\"\"\n        Create a `.Text` instance at *x*, *y* with string *text*.\n\n        Valid keyword arguments are:\n\n        %(Text)s\n        \"\"\"\n        Artist.__init__(self)\n        self._x, self._y = x, y\n\n        if color is None:\n            color = rcParams['text.color']\n        if fontproperties is None:\n            fontproperties = FontProperties()\n\n        self._text = ''\n        self.set_text(text)\n        self.set_color(color)\n        self.set_fontproperties(fontproperties)\n        self.set_usetex(usetex)\n        self.set_wrap(wrap)\n        self.set_verticalalignment(verticalalignment)\n        self.set_horizontalalignment(horizontalalignment)\n        self._multialignment = multialignment\n        self._rotation = rotation\n        self._bbox_patch = None  # a FancyBboxPatch instance\n        self._renderer = None\n        if linespacing is None:\n            linespacing = 1.2   # Maybe use rcParam later.\n        self._linespacing = linespacing\n        self.set_rotation_mode(rotation_mode)\n        self.update(kwargs)",
        "begin_line": 128,
        "end_line": 173,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007042253521126761,
            "pseudo_dstar_susp": 0.007142857142857143,
            "pseudo_tarantula_susp": 0.000591715976331361,
            "pseudo_op2_susp": 0.007042253521126761,
            "pseudo_barinel_susp": 0.000591715976331361
        }
    },
    {
        "name": "lib.matplotlib.text.Text._get_xy_display#225",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text._get_xy_display(self)",
        "snippet": "    def _get_xy_display(self):\n        \"\"\"\n        Get the (possibly unit converted) transformed x, y in display coords.\n        \"\"\"\n        x, y = self.get_unitless_position()\n        return self.get_transform().transform((x, y))",
        "begin_line": 225,
        "end_line": 230,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.420599584446424e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text._get_multialignment#232",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text._get_multialignment(self)",
        "snippet": "    def _get_multialignment(self):\n        if self._multialignment is not None:\n            return self._multialignment\n        else:\n            return self._horizontalalignment",
        "begin_line": 232,
        "end_line": 236,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.247952453431905e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_rotation#238",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_rotation(self)",
        "snippet": "    def get_rotation(self):\n        \"\"\"Return the text angle in degrees between 0 and 360.\"\"\"\n        return get_rotation(self._rotation)  # string_or_number -> number",
        "begin_line": 238,
        "end_line": 240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.24427702115329e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_rotation_mode#242",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_rotation_mode(self, m)",
        "snippet": "    def set_rotation_mode(self, m):\n        \"\"\"\n        Set text rotation mode.\n\n        Parameters\n        ----------\n        m : {None, 'default', 'anchor'}\n            If ``None`` or ``\"default\"``, the text will be first rotated, then\n            aligned according to their horizontal and vertical alignments.  If\n            ``\"anchor\"``, then alignment occurs before rotation.\n        \"\"\"\n        cbook._check_in_list([\"anchor\", \"default\", None], rotation_mode=m)\n        self._rotation_mode = m\n        self.stale = True",
        "begin_line": 242,
        "end_line": 255,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006711409395973154,
            "pseudo_dstar_susp": 0.0045871559633027525,
            "pseudo_tarantula_susp": 0.0003401360544217687,
            "pseudo_op2_susp": 0.004608294930875576,
            "pseudo_barinel_susp": 0.0003401360544217687
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_rotation_mode#257",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_rotation_mode(self)",
        "snippet": "    def get_rotation_mode(self):\n        \"\"\"Return the text rotation mode.\"\"\"\n        return self._rotation_mode",
        "begin_line": 257,
        "end_line": 259,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.3905531035778e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text.update_from#261",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.update_from(self, other)",
        "snippet": "    def update_from(self, other):\n        # docstring inherited\n        Artist.update_from(self, other)\n        self._color = other._color\n        self._multialignment = other._multialignment\n        self._verticalalignment = other._verticalalignment\n        self._horizontalalignment = other._horizontalalignment\n        self._fontproperties = other._fontproperties.copy()\n        self._usetex = other._usetex\n        self._rotation = other._rotation\n        self._picker = other._picker\n        self._linespacing = other._linespacing\n        self.stale = True",
        "begin_line": 261,
        "end_line": 273,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.714396735962697e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text._get_layout#275",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text._get_layout(self, renderer)",
        "snippet": "    def _get_layout(self, renderer):\n        \"\"\"\n        Return the extent (bbox) of the text together with\n        multiple-alignment information. Note that it returns an extent\n        of a rotated text when necessary.\n        \"\"\"\n        key = self.get_prop_tup(renderer=renderer)\n        if key in self._cached:\n            return self._cached[key]\n\n        thisx, thisy = 0.0, 0.0\n        lines = self.get_text().split(\"\\n\")  # Ensures lines is not empty.\n\n        ws = []\n        hs = []\n        xs = []\n        ys = []\n\n        # Full vertical extent of font, including ascenders and descenders:\n        _, lp_h, lp_d = renderer.get_text_width_height_descent(\n            \"lp\", self._fontproperties,\n            ismath=\"TeX\" if self.get_usetex() else False)\n        min_dy = (lp_h - lp_d) * self._linespacing\n\n        for i, line in enumerate(lines):\n            clean_line, ismath = self._preprocess_math(line)\n            if clean_line:\n                w, h, d = renderer.get_text_width_height_descent(\n                    clean_line, self._fontproperties, ismath=ismath)\n            else:\n                w = h = d = 0\n\n            # For multiline text, increase the line spacing when the text\n            # net-height (excluding baseline) is larger than that of a \"l\"\n            # (e.g., use of superscripts), which seems what TeX does.\n            h = max(h, lp_h)\n            d = max(d, lp_d)\n\n            ws.append(w)\n            hs.append(h)\n\n            # Metrics of the last line that are needed later:\n            baseline = (h - d) - thisy\n\n            if i == 0:\n                # position at baseline\n                thisy = -(h - d)\n            else:\n                # put baseline a good distance from bottom of previous line\n                thisy -= max(min_dy, (h - d) * self._linespacing)\n\n            xs.append(thisx)  # == 0.\n            ys.append(thisy)\n\n            thisy -= d\n\n        # Metrics of the last line that are needed later:\n        descent = d\n\n        # Bounding box definition:\n        width = max(ws)\n        xmin = 0\n        xmax = width\n        ymax = 0\n        ymin = ys[-1] - descent  # baseline of last line minus its descent\n        height = ymax - ymin\n\n        # get the rotation matrix\n        M = Affine2D().rotate_deg(self.get_rotation())\n\n        # now offset the individual text lines within the box\n        malign = self._get_multialignment()\n        if malign == 'left':\n            offset_layout = [(x, y) for x, y in zip(xs, ys)]\n        elif malign == 'center':\n            offset_layout = [(x + width / 2 - w / 2, y)\n                             for x, y, w in zip(xs, ys, ws)]\n        elif malign == 'right':\n            offset_layout = [(x + width - w, y)\n                             for x, y, w in zip(xs, ys, ws)]\n\n        # the corners of the unrotated bounding box\n        corners_horiz = np.array(\n            [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)])\n\n        # now rotate the bbox\n        corners_rotated = M.transform(corners_horiz)\n        # compute the bounds of the rotated box\n        xmin = corners_rotated[:, 0].min()\n        xmax = corners_rotated[:, 0].max()\n        ymin = corners_rotated[:, 1].min()\n        ymax = corners_rotated[:, 1].max()\n        width = xmax - xmin\n        height = ymax - ymin\n\n        # Now move the box to the target position offset the display\n        # bbox by alignment\n        halign = self._horizontalalignment\n        valign = self._verticalalignment\n\n        rotation_mode = self.get_rotation_mode()\n        if rotation_mode != \"anchor\":\n            # compute the text location in display coords and the offsets\n            # necessary to align the bbox with that location\n            if halign == 'center':\n                offsetx = (xmin + xmax) / 2\n            elif halign == 'right':\n                offsetx = xmax\n            else:\n                offsetx = xmin\n\n            if valign == 'center':\n                offsety = (ymin + ymax) / 2\n            elif valign == 'top':\n                offsety = ymax\n            elif valign == 'baseline':\n                offsety = ymin + descent\n            elif valign == 'center_baseline':\n                offsety = ymin + height - baseline / 2.0\n            else:\n                offsety = ymin\n        else:\n            xmin1, ymin1 = corners_horiz[0]\n            xmax1, ymax1 = corners_horiz[2]\n\n            if halign == 'center':\n                offsetx = (xmin1 + xmax1) / 2.0\n            elif halign == 'right':\n                offsetx = xmax1\n            else:\n                offsetx = xmin1\n\n            if valign == 'center':\n                offsety = (ymin1 + ymax1) / 2.0\n            elif valign == 'top':\n                offsety = ymax1\n            elif valign == 'baseline':\n                offsety = ymax1 - baseline\n            elif valign == 'center_baseline':\n                offsety = ymax1 - baseline / 2.0\n            else:\n                offsety = ymin1\n\n            offsetx, offsety = M.transform((offsetx, offsety))\n\n        xmin -= offsetx\n        ymin -= offsety\n\n        bbox = Bbox.from_bounds(xmin, ymin, width, height)\n\n        # now rotate the positions around the first (x, y) position\n        xys = M.transform(offset_layout) - (offsetx, offsety)\n\n        ret = bbox, list(zip(lines, zip(ws, hs), *xys.T)), descent\n        self._cached[key] = ret\n        return ret",
        "begin_line": 275,
        "end_line": 430,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002775464890369137,
            "pseudo_dstar_susp": 0.0002775464890369137,
            "pseudo_tarantula_susp": 0.0002777777777777778,
            "pseudo_op2_susp": 0.0002775464890369137,
            "pseudo_barinel_susp": 0.0002777777777777778
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_bbox#432",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_bbox(self, rectprops)",
        "snippet": "    def set_bbox(self, rectprops):\n        \"\"\"\n        Draw a bounding box around self.\n\n        Parameters\n        ----------\n        rectprops : dict with properties for `.patches.FancyBboxPatch`\n             The default boxstyle is 'square'. The mutation\n             scale of the `.patches.FancyBboxPatch` is set to the fontsize.\n\n        Examples\n        --------\n        ::\n\n            t.set_bbox(dict(facecolor='red', alpha=0.5))\n        \"\"\"\n\n        if rectprops is not None:\n            props = rectprops.copy()\n            boxstyle = props.pop(\"boxstyle\", None)\n            pad = props.pop(\"pad\", None)\n            if boxstyle is None:\n                boxstyle = \"square\"\n                if pad is None:\n                    pad = 4  # points\n                pad /= self.get_size()  # to fraction of font size\n            else:\n                if pad is None:\n                    pad = 0.3\n\n            # boxstyle could be a callable or a string\n            if isinstance(boxstyle, str) and \"pad\" not in boxstyle:\n                boxstyle += \",pad=%0.2f\" % pad\n\n            bbox_transmuter = props.pop(\"bbox_transmuter\", None)\n\n            self._bbox_patch = FancyBboxPatch(\n                                    (0., 0.),\n                                    1., 1.,\n                                    boxstyle=boxstyle,\n                                    bbox_transmuter=bbox_transmuter,\n                                    transform=IdentityTransform(),\n                                    **props)\n        else:\n            self._bbox_patch = None\n\n        self._update_clip_properties()",
        "begin_line": 432,
        "end_line": 478,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text.update_bbox_position_size#487",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.update_bbox_position_size(self, renderer)",
        "snippet": "    def update_bbox_position_size(self, renderer):\n        \"\"\"\n        Update the location and the size of the bbox.\n\n        This method should be used when the position and size of the bbox needs\n        to be updated before actually drawing the bbox.\n        \"\"\"\n\n        if self._bbox_patch:\n\n            trans = self.get_transform()\n\n            # don't use self.get_unitless_position here, which refers to text\n            # position in Text:\n            posx = float(self.convert_xunits(self._x))\n            posy = float(self.convert_yunits(self._y))\n\n            posx, posy = trans.transform((posx, posy))\n\n            x_box, y_box, w_box, h_box = _get_textbox(self, renderer)\n            self._bbox_patch.set_bounds(0., 0., w_box, h_box)\n            theta = np.deg2rad(self.get_rotation())\n            tr = Affine2D().rotate(theta)\n            tr = tr.translate(posx + x_box, posy + y_box)\n            self._bbox_patch.set_transform(tr)\n            fontsize_in_pixel = renderer.points_to_pixels(self.get_size())\n            self._bbox_patch.set_mutation_scale(fontsize_in_pixel)",
        "begin_line": 487,
        "end_line": 513,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text._update_clip_properties#531",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text._update_clip_properties(self)",
        "snippet": "    def _update_clip_properties(self):\n        clipprops = dict(clip_box=self.clipbox,\n                         clip_path=self._clippath,\n                         clip_on=self._clipon)\n        if self._bbox_patch:\n            self._bbox_patch.update(clipprops)",
        "begin_line": 531,
        "end_line": 536,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0026041666666666665,
            "pseudo_dstar_susp": 0.0011160714285714285,
            "pseudo_tarantula_susp": 0.0008688097306689834,
            "pseudo_op2_susp": 0.0011160714285714285,
            "pseudo_barinel_susp": 0.0008688097306689834
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_clip_box#538",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_clip_box(self, clipbox)",
        "snippet": "    def set_clip_box(self, clipbox):\n        # docstring inherited.\n        super().set_clip_box(clipbox)\n        self._update_clip_properties()",
        "begin_line": 538,
        "end_line": 541,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0027100271002710027,
            "pseudo_dstar_susp": 0.0011312217194570137,
            "pseudo_tarantula_susp": 0.000877963125548727,
            "pseudo_op2_susp": 0.0011312217194570137,
            "pseudo_barinel_susp": 0.000877963125548727
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_clip_path#543",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_clip_path(self, path, transform=None)",
        "snippet": "    def set_clip_path(self, path, transform=None):\n        # docstring inherited.\n        super().set_clip_path(path, transform)\n        self._update_clip_properties()",
        "begin_line": 543,
        "end_line": 546,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_clip_on#548",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_clip_on(self, b)",
        "snippet": "    def set_clip_on(self, b):\n        # docstring inherited.\n        super().set_clip_on(b)\n        self._update_clip_properties()",
        "begin_line": 548,
        "end_line": 551,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_wrap#553",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_wrap(self)",
        "snippet": "    def get_wrap(self):\n        \"\"\"Return whether the text can be wrapped.\"\"\"\n        return self._wrap",
        "begin_line": 553,
        "end_line": 555,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.46880030300161e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_wrap#557",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_wrap(self, wrap)",
        "snippet": "    def set_wrap(self, wrap):\n        \"\"\"\n        Set whether the text can be wrapped.\n\n        Parameters\n        ----------\n        wrap : bool\n        \"\"\"\n        self._wrap = wrap",
        "begin_line": 557,
        "end_line": 565,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010298661174047373,
            "pseudo_dstar_susp": 0.0008865248226950354,
            "pseudo_tarantula_susp": 0.000550357732526142,
            "pseudo_op2_susp": 0.0008865248226950354,
            "pseudo_barinel_susp": 0.000550357732526142
        }
    },
    {
        "name": "lib.matplotlib.text.Text.draw#675",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        # docstring inherited\n\n        if renderer is not None:\n            self._renderer = renderer\n        if not self.get_visible():\n            return\n        if self.get_text() == '':\n            return\n\n        renderer.open_group('text', self.get_gid())\n\n        with _wrap_text(self) as textobj:\n            bbox, info, descent = textobj._get_layout(renderer)\n            trans = textobj.get_transform()\n\n            # don't use textobj.get_position here, which refers to text\n            # position in Text:\n            posx = float(textobj.convert_xunits(textobj._x))\n            posy = float(textobj.convert_yunits(textobj._y))\n            posx, posy = trans.transform((posx, posy))\n            if not np.isfinite(posx) or not np.isfinite(posy):\n                _log.warning(\"posx and posy should be finite values\")\n                return\n            canvasw, canvash = renderer.get_canvas_width_height()\n\n            # draw the FancyBboxPatch\n            if textobj._bbox_patch:\n                textobj._draw_bbox(renderer, posx, posy)\n\n            gc = renderer.new_gc()\n            gc.set_foreground(textobj.get_color())\n            gc.set_alpha(textobj.get_alpha())\n            gc.set_url(textobj._url)\n            textobj._set_gc_clip(gc)\n\n            angle = textobj.get_rotation()\n\n            for line, wh, x, y in info:\n\n                mtext = textobj if len(info) == 1 else None\n                x = x + posx\n                y = y + posy\n                if renderer.flipy():\n                    y = canvash - y\n                clean_line, ismath = textobj._preprocess_math(line)\n\n                if textobj.get_path_effects():\n                    from matplotlib.patheffects import PathEffectRenderer\n                    textrenderer = PathEffectRenderer(\n                                        textobj.get_path_effects(), renderer)\n                else:\n                    textrenderer = renderer\n\n                if textobj.get_usetex():\n                    textrenderer.draw_tex(gc, x, y, clean_line,\n                                          textobj._fontproperties, angle,\n                                          mtext=mtext)\n                else:\n                    textrenderer.draw_text(gc, x, y, clean_line,\n                                           textobj._fontproperties, angle,\n                                           ismath=ismath, mtext=mtext)\n\n        gc.restore()\n        renderer.close_group('text')\n        self.stale = False",
        "begin_line": 675,
        "end_line": 740,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000277623542476402,
            "pseudo_dstar_susp": 0.000277623542476402,
            "pseudo_tarantula_susp": 0.0002778549597110308,
            "pseudo_op2_susp": 0.000277623542476402,
            "pseudo_barinel_susp": 0.0002778549597110308
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_fontsize#780",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_fontsize(self)",
        "snippet": "    def get_fontsize(self):\n        \"\"\"\n        Return the font size as an integer.\n\n        See Also\n        --------\n        .font_manager.FontProperties.get_size_in_points\n        \"\"\"\n        return self._fontproperties.get_size_in_points()",
        "begin_line": 780,
        "end_line": 788,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_unitless_position#827",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_unitless_position(self)",
        "snippet": "    def get_unitless_position(self):\n        \"\"\"Return the (x, y) unitless position of the text.\"\"\"\n        # This will get the position with all unit information stripped away.\n        # This is here for convenience since it is done in several locations.\n        x = float(self.convert_xunits(self._x))\n        y = float(self.convert_yunits(self._y))\n        return x, y",
        "begin_line": 827,
        "end_line": 833,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_position#835",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_position(self)",
        "snippet": "    def get_position(self):\n        \"\"\"Return the (x, y) position of the text.\"\"\"\n        # This should return the same data (possible unitized) as was\n        # specified with 'set_x' and 'set_y'.\n        return self._x, self._y",
        "begin_line": 835,
        "end_line": 839,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.539709649871905e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_prop_tup#841",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_prop_tup(self, renderer=None)",
        "snippet": "    def get_prop_tup(self, renderer=None):\n        \"\"\"\n        Return a hashable tuple of properties.\n\n        Not intended to be human readable, but useful for backends who\n        want to cache derived information about text (e.g., layouts) and\n        need to know if the text has changed.\n        \"\"\"\n        x, y = self.get_unitless_position()\n        renderer = renderer or self._renderer\n        return (x, y, self.get_text(), self._color,\n                self._verticalalignment, self._horizontalalignment,\n                hash(self._fontproperties),\n                self._rotation, self._rotation_mode,\n                self.figure.dpi, weakref.ref(renderer),\n                self._linespacing\n                )",
        "begin_line": 841,
        "end_line": 857,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.298737318443909e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_window_extent#870",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_window_extent(self, renderer=None, dpi=None)",
        "snippet": "    def get_window_extent(self, renderer=None, dpi=None):\n        \"\"\"\n        Return the `.Bbox` bounding the text, in display units.\n\n        In addition to being used internally, this is useful for specifying\n        clickable regions in a png file on a web page.\n\n        Parameters\n        ----------\n        renderer : Renderer, optional\n            A renderer is needed to compute the bounding box.  If the artist\n            has already been drawn, the renderer is cached; thus, it is only\n            necessary to pass this argument when calling `get_window_extent`\n            before the first `draw`.  In practice, it is usually easier to\n            trigger a draw first (e.g. by saving the figure).\n\n        dpi : float, optional\n            The dpi value for computing the bbox, defaults to\n            ``self.figure.dpi`` (*not* the renderer dpi); should be set e.g. if\n            to match regions with a figure saved with a custom dpi value.\n        \"\"\"\n        #return _unit_box\n        if not self.get_visible():\n            return Bbox.unit()\n        if dpi is not None:\n            dpi_orig = self.figure.dpi\n            self.figure.dpi = dpi\n        if self.get_text() == '':\n            tx, ty = self._get_xy_display()\n            return Bbox.from_bounds(tx, ty, 0, 0)\n\n        if renderer is not None:\n            self._renderer = renderer\n        if self._renderer is None:\n            self._renderer = self.figure._cachedRenderer\n        if self._renderer is None:\n            raise RuntimeError('Cannot get window extent w/o renderer')\n\n        bbox, info, descent = self._get_layout(self._renderer)\n        x, y = self.get_unitless_position()\n        x, y = self.get_transform().transform((x, y))\n        bbox = bbox.translated(x, y)\n        if dpi is not None:\n            self.figure.dpi = dpi_orig\n        return bbox",
        "begin_line": 870,
        "end_line": 914,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003071253071253071,
            "pseudo_dstar_susp": 0.00030395136778115504,
            "pseudo_tarantula_susp": 0.00033444816053511704,
            "pseudo_op2_susp": 0.00030395136778115504,
            "pseudo_barinel_susp": 0.00033456005352960856
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_color#936",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_color(self, color)",
        "snippet": "    def set_color(self, color):\n        \"\"\"\n        Set the foreground color of the text\n\n        Parameters\n        ----------\n        color : color\n        \"\"\"\n        # Make sure it is hashable, or get_prop_tup will fail.\n        try:\n            hash(color)\n        except TypeError:\n            color = tuple(color)\n        self._color = color\n        self.stale = True",
        "begin_line": 936,
        "end_line": 950,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022988505747126436,
            "pseudo_dstar_susp": 0.0010672358591248667,
            "pseudo_tarantula_susp": 0.0007930214115781126,
            "pseudo_op2_susp": 0.0010672358591248667,
            "pseudo_barinel_susp": 0.0007930214115781126
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_horizontalalignment#952",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_horizontalalignment(self, align)",
        "snippet": "    def set_horizontalalignment(self, align):\n        \"\"\"\n        Set the horizontal alignment to one of\n\n        Parameters\n        ----------\n        align : {'center', 'right', 'left'}\n        \"\"\"\n        cbook._check_in_list(['center', 'right', 'left'], align=align)\n        self._horizontalalignment = align\n        self.stale = True",
        "begin_line": 952,
        "end_line": 962,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022624434389140274,
            "pseudo_dstar_susp": 0.0013966480446927375,
            "pseudo_tarantula_susp": 0.0007898894154818325,
            "pseudo_op2_susp": 0.0013966480446927375,
            "pseudo_barinel_susp": 0.0007898894154818325
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_fontsize#1047",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_fontsize(self, fontsize)",
        "snippet": "    def set_fontsize(self, fontsize):\n        \"\"\"\n        Set the font size.\n\n        Parameters\n        ----------\n        fontsize : float or {'xx-small', 'x-small', 'small', 'medium', \\\n'large', 'x-large', 'xx-large'}\n            If float, the fontsize in points. The string values denote sizes\n            relative to the default font size.\n\n        See Also\n        --------\n        .font_manager.FontProperties.set_size\n        \"\"\"\n        self._fontproperties.set_size(fontsize)\n        self.stale = True",
        "begin_line": 1047,
        "end_line": 1063,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_fontweight#1065",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_fontweight(self, weight)",
        "snippet": "    def set_fontweight(self, weight):\n        \"\"\"\n        Set the font weight.\n\n        Parameters\n        ----------\n        weight : {a numeric value in range 0-1000, 'ultralight', 'light', \\\n'normal', 'regular', 'book', 'medium', 'roman', 'semibold', 'demibold', \\\n'demi', 'bold', 'heavy', 'extra bold', 'black'}\n\n        See Also\n        --------\n        .font_manager.FontProperties.set_weight\n        \"\"\"\n        self._fontproperties.set_weight(weight)\n        self.stale = True",
        "begin_line": 1065,
        "end_line": 1080,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009940357852882703,
            "pseudo_dstar_susp": 0.0008818342151675485,
            "pseudo_tarantula_susp": 0.0005470459518599562,
            "pseudo_op2_susp": 0.0008818342151675485,
            "pseudo_barinel_susp": 0.0005470459518599562
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_position#1099",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_position(self, xy)",
        "snippet": "    def set_position(self, xy):\n        \"\"\"\n        Set the (*x*, *y*) position of the text.\n\n        Parameters\n        ----------\n        xy : (float, float)\n        \"\"\"\n        self.set_x(xy[0])\n        self.set_y(xy[1])",
        "begin_line": 1099,
        "end_line": 1108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.430992327796982e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_x#1110",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_x(self, x)",
        "snippet": "    def set_x(self, x):\n        \"\"\"\n        Set the *x* position of the text.\n\n        Parameters\n        ----------\n        x : float\n        \"\"\"\n        self._x = x\n        self.stale = True",
        "begin_line": 1110,
        "end_line": 1119,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013175230566534915,
            "pseudo_dstar_susp": 0.0009099181073703367,
            "pseudo_tarantula_susp": 0.0005924170616113745,
            "pseudo_op2_susp": 0.0009099181073703367,
            "pseudo_barinel_susp": 0.0005924170616113745
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_y#1121",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_y(self, y)",
        "snippet": "    def set_y(self, y):\n        \"\"\"\n        Set the *y* position of the text.\n\n        Parameters\n        ----------\n        y : float\n        \"\"\"\n        self._y = y\n        self.stale = True",
        "begin_line": 1121,
        "end_line": 1130,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001336898395721925,
            "pseudo_dstar_susp": 0.0024330900243309003,
            "pseudo_tarantula_susp": 0.0008561643835616438,
            "pseudo_op2_susp": 0.0024330900243309003,
            "pseudo_barinel_susp": 0.0008561643835616438
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_rotation#1132",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_rotation(self, s)",
        "snippet": "    def set_rotation(self, s):\n        \"\"\"\n        Set the rotation of the text.\n\n        Parameters\n        ----------\n        s : float or {'vertical', 'horizontal'}\n            The rotation angle in degrees in mathematically positive direction\n            (counterclockwise). 'horizontal' equals 0, 'vertical' equals 90.\n        \"\"\"\n        self._rotation = s\n        self.stale = True",
        "begin_line": 1132,
        "end_line": 1143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013966480446927375,
            "pseudo_dstar_susp": 0.002570694087403599,
            "pseudo_tarantula_susp": 0.0012987012987012987,
            "pseudo_op2_susp": 0.002570694087403599,
            "pseudo_barinel_susp": 0.0012987012987012987
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_verticalalignment#1145",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_verticalalignment(self, align)",
        "snippet": "    def set_verticalalignment(self, align):\n        \"\"\"\n        Set the vertical alignment.\n\n        Parameters\n        ----------\n        align : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n        \"\"\"\n        cbook._check_in_list(\n            ['top', 'bottom', 'center', 'baseline', 'center_baseline'],\n            align=align)\n        self._verticalalignment = align\n        self.stale = True",
        "begin_line": 1145,
        "end_line": 1157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000697350069735007,
            "pseudo_dstar_susp": 0.00141643059490085,
            "pseudo_tarantula_susp": 0.0007178750897343862,
            "pseudo_op2_susp": 0.00141643059490085,
            "pseudo_barinel_susp": 0.0007178750897343862
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_text#1159",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_text(self, s)",
        "snippet": "    def set_text(self, s):\n        r\"\"\"\n        Set the text string *s*.\n\n        It may contain newlines (``\\n``) or math in LaTeX syntax.\n\n        Parameters\n        ----------\n        s : object\n            Any object gets converted to its `str` representation, except for\n            ``None`` which is converted to an empty string.\n        \"\"\"\n        if s is None:\n            s = ''\n        if s != self._text:\n            self._text = str(s)\n            self.stale = True",
        "begin_line": 1159,
        "end_line": 1175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006958942240779402,
            "pseudo_dstar_susp": 0.0014144271570014145,
            "pseudo_tarantula_susp": 0.0016666666666666668,
            "pseudo_op2_susp": 0.0014144271570014145,
            "pseudo_barinel_susp": 0.0016666666666666668
        }
    },
    {
        "name": "lib.matplotlib.text.Text._preprocess_math#1201",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text._preprocess_math(self, s)",
        "snippet": "    def _preprocess_math(self, s):\n        \"\"\"\n        Return the string *s* after mathtext preprocessing, and the kind of\n        mathtext support needed.\n\n        - If *self* is configured to use TeX, return *s* unchanged except that\n          a single space gets escaped, and the flag \"TeX\".\n        - Otherwise, if *s* is mathtext (has an even number of unescaped dollar\n          signs), return *s* and the flag True.\n        - Otherwise, return *s* with dollar signs unescaped, and the flag\n          False.\n        \"\"\"\n        if self.get_usetex():\n            if s == \" \":\n                s = r\"\\ \"\n            return s, \"TeX\"\n        elif cbook.is_math_text(s):\n            return s, True\n        else:\n            return s.replace(r\"\\$\", \"$\"), False",
        "begin_line": 1201,
        "end_line": 1220,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.468817686160281e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_fontproperties#1222",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_fontproperties(self, fp)",
        "snippet": "    def set_fontproperties(self, fp):\n        \"\"\"\n        Set the font properties that control the text.\n\n        Parameters\n        ----------\n        fp : `.font_manager.FontProperties` or `str` or `pathlib.Path`\n            If a `str`, it is interpreted as a fontconfig pattern parsed by\n            `.FontProperties`.  If a `pathlib.Path`, it is interpreted as the\n            absolute path to a font file.\n        \"\"\"\n        self._fontproperties = FontProperties._from_any(fp).copy()\n        self.stale = True",
        "begin_line": 1222,
        "end_line": 1234,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006906077348066298,
            "pseudo_dstar_susp": 0.0014064697609001407,
            "pseudo_tarantula_susp": 0.001455604075691412,
            "pseudo_op2_susp": 0.0014064697609001407,
            "pseudo_barinel_susp": 0.001455604075691412
        }
    },
    {
        "name": "lib.matplotlib.text.Text.set_usetex#1236",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.set_usetex(self, usetex)",
        "snippet": "    def set_usetex(self, usetex):\n        \"\"\"\n        Parameters\n        ----------\n        usetex : bool or None\n            Whether to render using TeX, ``None`` means to use\n            :rc:`text.usetex`.\n        \"\"\"\n        if usetex is None:\n            self._usetex = rcParams['text.usetex']\n        else:\n            self._usetex = bool(usetex)\n        self.stale = True",
        "begin_line": 1236,
        "end_line": 1248,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005047955577990914,
            "pseudo_dstar_susp": 0.0005518763796909492,
            "pseudo_tarantula_susp": 0.0013157894736842105,
            "pseudo_op2_susp": 0.0005518763796909492,
            "pseudo_barinel_susp": 0.0013157894736842105
        }
    },
    {
        "name": "lib.matplotlib.text.Text.get_usetex#1250",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Text",
        "signature": "lib.matplotlib.text.Text.get_usetex(self)",
        "snippet": "    def get_usetex(self):\n        \"\"\"Return whether this `Text` object uses TeX for rendering.\"\"\"\n        return self._usetex",
        "begin_line": 1250,
        "end_line": 1252,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041186161449752884,
            "pseudo_dstar_susp": 0.00037537537537537537,
            "pseudo_tarantula_susp": 0.0010204081632653062,
            "pseudo_op2_susp": 0.00037537537537537537,
            "pseudo_barinel_susp": 0.0010204081632653062
        }
    },
    {
        "name": "lib.matplotlib.text._AnnotationBase.__init__#1360",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text._AnnotationBase",
        "signature": "lib.matplotlib.text._AnnotationBase.__init__(self, xy, xycoords='data', annotation_clip=None)",
        "snippet": "    def __init__(self,\n                 xy,\n                 xycoords='data',\n                 annotation_clip=None):\n\n        self.xy = xy\n        self.xycoords = xycoords\n        self.set_annotation_clip(annotation_clip)\n\n        self._draggable = None",
        "begin_line": 1360,
        "end_line": 1369,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text._AnnotationBase._get_xy#1371",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text._AnnotationBase",
        "signature": "lib.matplotlib.text._AnnotationBase._get_xy(self, renderer, x, y, s)",
        "snippet": "    def _get_xy(self, renderer, x, y, s):\n        if isinstance(s, tuple):\n            s1, s2 = s\n        else:\n            s1, s2 = s, s\n        if s1 == 'data':\n            x = float(self.convert_xunits(x))\n        if s2 == 'data':\n            y = float(self.convert_yunits(y))\n        return self._get_xy_transform(renderer, s).transform((x, y))",
        "begin_line": 1371,
        "end_line": 1380,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text._AnnotationBase._get_xy_transform#1382",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text._AnnotationBase",
        "signature": "lib.matplotlib.text._AnnotationBase._get_xy_transform(self, renderer, s)",
        "snippet": "    def _get_xy_transform(self, renderer, s):\n\n        if isinstance(s, tuple):\n            s1, s2 = s\n            from matplotlib.transforms import blended_transform_factory\n            tr1 = self._get_xy_transform(renderer, s1)\n            tr2 = self._get_xy_transform(renderer, s2)\n            tr = blended_transform_factory(tr1, tr2)\n            return tr\n        elif callable(s):\n            tr = s(renderer)\n            if isinstance(tr, BboxBase):\n                return BboxTransformTo(tr)\n            elif isinstance(tr, Transform):\n                return tr\n            else:\n                raise RuntimeError(\"unknown return type ...\")\n        elif isinstance(s, Artist):\n            bbox = s.get_window_extent(renderer)\n            return BboxTransformTo(bbox)\n        elif isinstance(s, BboxBase):\n            return BboxTransformTo(s)\n        elif isinstance(s, Transform):\n            return s\n        elif not isinstance(s, str):\n            raise RuntimeError(\"unknown coordinate type : %s\" % s)\n\n        if s == 'data':\n            return self.axes.transData\n        elif s == 'polar':\n            from matplotlib.projections import PolarAxes\n            tr = PolarAxes.PolarTransform()\n            trans = tr + self.axes.transData\n            return trans\n\n        s_ = s.split()\n        if len(s_) != 2:\n            raise ValueError(\"%s is not a recognized coordinate\" % s)\n\n        bbox0, xy0 = None, None\n\n        bbox_name, unit = s_\n        # if unit is offset-like\n        if bbox_name == \"figure\":\n            bbox0 = self.figure.bbox\n        elif bbox_name == \"axes\":\n            bbox0 = self.axes.bbox\n        # elif bbox_name == \"bbox\":\n        #     if bbox is None:\n        #         raise RuntimeError(\"bbox is specified as a coordinate but \"\n        #                            \"never set\")\n        #     bbox0 = self._get_bbox(renderer, bbox)\n\n        if bbox0 is not None:\n            xy0 = bbox0.bounds[:2]\n        elif bbox_name == \"offset\":\n            xy0 = self._get_ref_xy(renderer)\n\n        if xy0 is not None:\n            # reference x, y in display coordinate\n            ref_x, ref_y = xy0\n            from matplotlib.transforms import Affine2D\n            if unit == \"points\":\n                # dots per points\n                dpp = self.figure.get_dpi() / 72.\n                tr = Affine2D().scale(dpp)\n            elif unit == \"pixels\":\n                tr = Affine2D()\n            elif unit == \"fontsize\":\n                fontsize = self.get_size()\n                dpp = fontsize * self.figure.get_dpi() / 72.\n                tr = Affine2D().scale(dpp)\n            elif unit == \"fraction\":\n                w, h = bbox0.bounds[2:]\n                tr = Affine2D().scale(w, h)\n            else:\n                raise ValueError(\"%s is not a recognized coordinate\" % s)\n\n            return tr.translate(ref_x, ref_y)\n\n        else:\n            raise ValueError(\"%s is not a recognized coordinate\" % s)",
        "begin_line": 1382,
        "end_line": 1463,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text._AnnotationBase.set_annotation_clip#1482",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text._AnnotationBase",
        "signature": "lib.matplotlib.text._AnnotationBase.set_annotation_clip(self, b)",
        "snippet": "    def set_annotation_clip(self, b):\n        \"\"\"\n        Set the annotation's clipping behavior.\n\n        Parameters\n        ----------\n        b : bool or None\n            - True: the annotation will only be drawn when ``self.xy`` is\n              inside the axes.\n            - False: the annotation will always be drawn regardless of its\n              position.\n            - None: the ``self.xy`` will be checked only if *xycoords* is\n              \"data\".\n        \"\"\"\n        self._annotation_clip = b",
        "begin_line": 1482,
        "end_line": 1496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text._AnnotationBase.get_annotation_clip#1498",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text._AnnotationBase",
        "signature": "lib.matplotlib.text._AnnotationBase.get_annotation_clip(self)",
        "snippet": "    def get_annotation_clip(self):\n        \"\"\"\n        Return the annotation's clipping behavior.\n\n        See `set_annotation_clip` for the meaning of return values.\n        \"\"\"\n        return self._annotation_clip",
        "begin_line": 1498,
        "end_line": 1504,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text._AnnotationBase._get_position_xy#1506",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text._AnnotationBase",
        "signature": "lib.matplotlib.text._AnnotationBase._get_position_xy(self, renderer)",
        "snippet": "    def _get_position_xy(self, renderer):\n        \"\"\"Return the pixel position of the annotated point.\"\"\"\n        x, y = self.xy\n        return self._get_xy(renderer, x, y, self.xycoords)",
        "begin_line": 1506,
        "end_line": 1509,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text._AnnotationBase._check_xy#1511",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text._AnnotationBase",
        "signature": "lib.matplotlib.text._AnnotationBase._check_xy(self, renderer, xy_pixel)",
        "snippet": "    def _check_xy(self, renderer, xy_pixel):\n        \"\"\"Check whether the annotation at *xy_pixel* should be drawn.\"\"\"\n        b = self.get_annotation_clip()\n        if b or (b is None and self.xycoords == \"data\"):\n            # check if self.xy is inside the axes.\n            return self.axes.contains_point(xy_pixel)\n        return True",
        "begin_line": 1511,
        "end_line": 1517,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Annotation.__init__#1571",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Annotation",
        "signature": "lib.matplotlib.text.Annotation.__init__(self, text, xy, xytext=None, xycoords='data', textcoords=None, arrowprops=None, annotation_clip=None, **kwargs)",
        "snippet": "    def __init__(self, text, xy,\n                 xytext=None,\n                 xycoords='data',\n                 textcoords=None,\n                 arrowprops=None,\n                 annotation_clip=None,\n                 **kwargs):\n        \"\"\"\n        Annotate the point *xy* with text *text*.\n\n        In the simplest form, the text is placed at *xy*.\n\n        Optionally, the text can be displayed in another position *xytext*.\n        An arrow pointing from the text to the annotated point *xy* can then\n        be added by defining *arrowprops*.\n\n        Parameters\n        ----------\n        text : str\n            The text of the annotation.  *s* is a deprecated synonym for this\n            parameter.\n\n        xy : (float, float)\n            The point *(x, y)* to annotate. The coordinate system is determined\n            by *xycoords*.\n\n        xytext : (float, float), default: *xy*\n            The position *(x, y)* to place the text at. The coordinate system\n            is determined by *textcoords*.\n\n        xycoords : str or `.Artist` or `.Transform` or callable or \\\n(float, float), default: 'data'\n\n            The coordinate system that *xy* is given in. The following types\n            of values are supported:\n\n            - One of the following strings:\n\n              =================   =============================================\n              Value               Description\n              =================   =============================================\n              'figure points'     Points from the lower left of the figure\n              'figure pixels'     Pixels from the lower left of the figure\n              'figure fraction'   Fraction of figure from lower left\n              'axes points'       Points from lower left corner of axes\n              'axes pixels'       Pixels from lower left corner of axes\n              'axes fraction'     Fraction of axes from lower left\n              'data'              Use the coordinate system of the object being\n                                  annotated (default)\n              'polar'             *(theta, r)* if not native 'data' coordinates\n              =================   =============================================\n\n            - An `.Artist`: *xy* is interpreted as a fraction of the artists\n              `~matplotlib.transforms.Bbox`. E.g. *(0, 0)* would be the lower\n              left corner of the bounding box and *(0.5, 1)* would be the\n              center top of the bounding box.\n\n            - A `.Transform` to transform *xy* to screen coordinates.\n\n            - A function with one of the following signatures::\n\n                def transform(renderer) -> Bbox\n                def transform(renderer) -> Transform\n\n              where *renderer* is a `.RendererBase` subclass.\n\n              The result of the function is interpreted like the `.Artist` and\n              `.Transform` cases above.\n\n            - A tuple *(xcoords, ycoords)* specifying separate coordinate\n              systems for *x* and *y*. *xcoords* and *ycoords* must each be\n              of one of the above described types.\n\n            See :ref:`plotting-guide-annotation` for more details.\n\n        textcoords : str or `.Artist` or `.Transform` or callable or \\\n(float, float), default: value of *xycoords*\n            The coordinate system that *xytext* is given in.\n\n            All *xycoords* values are valid as well as the following\n            strings:\n\n            =================   =========================================\n            Value               Description\n            =================   =========================================\n            'offset points'     Offset (in points) from the *xy* value\n            'offset pixels'     Offset (in pixels) from the *xy* value\n            =================   =========================================\n\n        arrowprops : dict, optional\n            The properties used to draw a `.FancyArrowPatch` arrow between the\n            positions *xy* and *xytext*.\n\n            If *arrowprops* does not contain the key 'arrowstyle' the\n            allowed keys are:\n\n            ==========   ======================================================\n            Key          Description\n            ==========   ======================================================\n            width        The width of the arrow in points\n            headwidth    The width of the base of the arrow head in points\n            headlength   The length of the arrow head in points\n            shrink       Fraction of total length to shrink from both ends\n            ?            Any key to :class:`matplotlib.patches.FancyArrowPatch`\n            ==========   ======================================================\n\n            If *arrowprops* contains the key 'arrowstyle' the\n            above keys are forbidden.  The allowed values of\n            ``'arrowstyle'`` are:\n\n            ============   =============================================\n            Name           Attrs\n            ============   =============================================\n            ``'-'``        None\n            ``'->'``       head_length=0.4,head_width=0.2\n            ``'-['``       widthB=1.0,lengthB=0.2,angleB=None\n            ``'|-|'``      widthA=1.0,widthB=1.0\n            ``'-|>'``      head_length=0.4,head_width=0.2\n            ``'<-'``       head_length=0.4,head_width=0.2\n            ``'<->'``      head_length=0.4,head_width=0.2\n            ``'<|-'``      head_length=0.4,head_width=0.2\n            ``'<|-|>'``    head_length=0.4,head_width=0.2\n            ``'fancy'``    head_length=0.4,head_width=0.4,tail_width=0.4\n            ``'simple'``   head_length=0.5,head_width=0.5,tail_width=0.2\n            ``'wedge'``    tail_width=0.3,shrink_factor=0.5\n            ============   =============================================\n\n            Valid keys for `~matplotlib.patches.FancyArrowPatch` are:\n\n            ===============  ==================================================\n            Key              Description\n            ===============  ==================================================\n            arrowstyle       the arrow style\n            connectionstyle  the connection style\n            relpos           default is (0.5, 0.5)\n            patchA           default is bounding box of the text\n            patchB           default is None\n            shrinkA          default is 2 points\n            shrinkB          default is 2 points\n            mutation_scale   default is text size (in points)\n            mutation_aspect  default is 1.\n            ?                any key for :class:`matplotlib.patches.PathPatch`\n            ===============  ==================================================\n\n            Defaults to None, i.e. no arrow is drawn.\n\n        annotation_clip : bool or None, default: None\n            Whether to draw the annotation when the annotation point *xy* is\n            outside the axes area.\n\n            - If *True*, the annotation will only be drawn when *xy* is\n              within the axes.\n            - If *False*, the annotation will always be drawn.\n            - If *None*, the annotation will only be drawn when *xy* is\n              within the axes and *xycoords* is 'data'.\n\n        **kwargs\n            Additional kwargs are passed to `~matplotlib.text.Text`.\n\n        Returns\n        -------\n        annotation : `.Annotation`\n\n        See Also\n        --------\n        :ref:`plotting-guide-annotation`\n\n        \"\"\"\n        _AnnotationBase.__init__(self,\n                                 xy,\n                                 xycoords=xycoords,\n                                 annotation_clip=annotation_clip)\n        # warn about wonky input data\n        if (xytext is None and\n                textcoords is not None and\n                textcoords != xycoords):\n            cbook._warn_external(\"You have used the `textcoords` kwarg, but \"\n                                 \"not the `xytext` kwarg.  This can lead to \"\n                                 \"surprising results.\")\n\n        # clean up textcoords and assign default\n        if textcoords is None:\n            textcoords = self.xycoords\n        self._textcoords = textcoords\n\n        # cleanup xytext defaults\n        if xytext is None:\n            xytext = self.xy\n        x, y = xytext\n\n        Text.__init__(self, x, y, text, **kwargs)\n\n        self.arrowprops = arrowprops\n\n        if arrowprops is not None:\n            if \"arrowstyle\" in arrowprops:\n                arrowprops = self.arrowprops.copy()\n                self._arrow_relpos = arrowprops.pop(\"relpos\", (0.5, 0.5))\n            else:\n                # modified YAArrow API to be used with FancyArrowPatch\n                shapekeys = ('width', 'headwidth', 'headlength',\n                             'shrink', 'frac')\n                arrowprops = dict()\n                for key, val in self.arrowprops.items():\n                    if key not in shapekeys:\n                        arrowprops[key] = val  # basic Patch properties\n            self.arrow_patch = FancyArrowPatch((0, 0), (1, 1),\n                                               **arrowprops)\n        else:\n            self.arrow_patch = None",
        "begin_line": 1571,
        "end_line": 1780,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Annotation.contains#1782",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Annotation",
        "signature": "lib.matplotlib.text.Annotation.contains(self, event)",
        "snippet": "    def contains(self, event):\n        inside, info = self._default_contains(event)\n        if inside is not None:\n            return inside, info\n        contains, tinfo = Text.contains(self, event)\n        if self.arrow_patch is not None:\n            in_patch, _ = self.arrow_patch.contains(event)\n            contains = contains or in_patch\n        return contains, tinfo",
        "begin_line": 1782,
        "end_line": 1790,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Annotation.xycoords#1793",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Annotation",
        "signature": "lib.matplotlib.text.Annotation.xycoords(self)",
        "snippet": "    def xycoords(self):\n        return self._xycoords",
        "begin_line": 1793,
        "end_line": 1794,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Annotation.is_offset#1798",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Annotation",
        "signature": "lib.matplotlib.text.Annotation.is_offset(s)",
        "snippet": "        def is_offset(s):\n            return isinstance(s, str) and s.startswith(\"offset\")",
        "begin_line": 1798,
        "end_line": 1799,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Annotation.xycoords#1797",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Annotation",
        "signature": "lib.matplotlib.text.Annotation.xycoords(self, xycoords)",
        "snippet": "    def xycoords(self, xycoords):\n        def is_offset(s):\n            return isinstance(s, str) and s.startswith(\"offset\")\n\n        if (isinstance(xycoords, tuple) and any(map(is_offset, xycoords))\n                or is_offset(xycoords)):\n            raise ValueError(\"xycoords cannot be an offset coordinate\")\n        self._xycoords = xycoords",
        "begin_line": 1797,
        "end_line": 1804,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Annotation.get_anncoords#1819",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Annotation",
        "signature": "lib.matplotlib.text.Annotation.get_anncoords(self)",
        "snippet": "    def get_anncoords(self):\n        \"\"\"\n        Return the coordinate system to use for `.Annotation.xyann`.\n\n        See also *xycoords* in `.Annotation`.\n        \"\"\"\n        return self._textcoords",
        "begin_line": 1819,
        "end_line": 1825,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Annotation.set_figure#1838",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Annotation",
        "signature": "lib.matplotlib.text.Annotation.set_figure(self, fig)",
        "snippet": "    def set_figure(self, fig):\n        # docstring inherited\n        if self.arrow_patch is not None:\n            self.arrow_patch.set_figure(fig)\n        Artist.set_figure(self, fig)",
        "begin_line": 1838,
        "end_line": 1842,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Annotation._update_position_xytext#1849",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Annotation",
        "signature": "lib.matplotlib.text.Annotation._update_position_xytext(self, renderer, xy_pixel)",
        "snippet": "    def _update_position_xytext(self, renderer, xy_pixel):\n        \"\"\"\n        Update the pixel positions of the annotation text and the arrow patch.\n        \"\"\"\n        # generate transformation,\n        self.set_transform(self._get_xy_transform(renderer, self.anncoords))\n\n        ox0, oy0 = self._get_xy_display()\n        ox1, oy1 = xy_pixel\n\n        if self.arrowprops is not None:\n            x0, y0 = xy_pixel\n            l, b, w, h = Text.get_window_extent(self, renderer).bounds\n            r = l + w\n            t = b + h\n            xc = 0.5 * (l + r)\n            yc = 0.5 * (b + t)\n\n            d = self.arrowprops.copy()\n            ms = d.pop(\"mutation_scale\", self.get_size())\n            self.arrow_patch.set_mutation_scale(ms)\n\n            if \"arrowstyle\" not in d:\n                # Approximately simulate the YAArrow.\n                # Pop its kwargs:\n                shrink = d.pop('shrink', 0.0)\n                width = d.pop('width', 4)\n                headwidth = d.pop('headwidth', 12)\n                # Ignore frac--it is useless.\n                frac = d.pop('frac', None)\n                if frac is not None:\n                    cbook._warn_external(\n                        \"'frac' option in 'arrowprops' is no longer supported;\"\n                        \" use 'headlength' to set the head length in points.\")\n                headlength = d.pop('headlength', 12)\n\n                # NB: ms is in pts\n                stylekw = dict(head_length=headlength / ms,\n                               head_width=headwidth / ms,\n                               tail_width=width / ms)\n\n                self.arrow_patch.set_arrowstyle('simple', **stylekw)\n\n                # using YAArrow style:\n                # pick the (x, y) corner of the text bbox closest to point\n                # annotated\n                xpos = ((l, 0), (xc, 0.5), (r, 1))\n                ypos = ((b, 0), (yc, 0.5), (t, 1))\n\n                _, (x, relposx) = min((abs(val[0] - x0), val) for val in xpos)\n                _, (y, relposy) = min((abs(val[0] - y0), val) for val in ypos)\n\n                self._arrow_relpos = (relposx, relposy)\n\n                r = np.hypot((y - y0), (x - x0))\n                shrink_pts = shrink * r / renderer.points_to_pixels(1)\n                self.arrow_patch.shrinkA = shrink_pts\n                self.arrow_patch.shrinkB = shrink_pts\n\n            # adjust the starting point of the arrow relative to\n            # the textbox.\n            # TODO : Rotation needs to be accounted.\n            relpos = self._arrow_relpos\n            bbox = Text.get_window_extent(self, renderer)\n            ox0 = bbox.x0 + bbox.width * relpos[0]\n            oy0 = bbox.y0 + bbox.height * relpos[1]\n\n            # The arrow will be drawn from (ox0, oy0) to (ox1,\n            # oy1). It will be first clipped by patchA and patchB.\n            # Then it will be shrunk by shrinkA and shrinkB\n            # (in points). If patch A is not set, self.bbox_patch\n            # is used.\n\n            self.arrow_patch.set_positions((ox0, oy0), (ox1, oy1))\n\n            if \"patchA\" in d:\n                self.arrow_patch.set_patchA(d.pop(\"patchA\"))\n            else:\n                if self._bbox_patch:\n                    self.arrow_patch.set_patchA(self._bbox_patch)\n                else:\n                    pad = renderer.points_to_pixels(4)\n                    if self.get_text() == \"\":\n                        self.arrow_patch.set_patchA(None)\n                        return\n\n                    bbox = Text.get_window_extent(self, renderer)\n                    l, b, w, h = bbox.bounds\n                    l -= pad / 2.\n                    b -= pad / 2.\n                    w += pad\n                    h += pad\n                    r = Rectangle(xy=(l, b),\n                                  width=w,\n                                  height=h,\n                                  )\n                    r.set_transform(IdentityTransform())\n                    r.set_clip_on(False)\n\n                    self.arrow_patch.set_patchA(r)",
        "begin_line": 1849,
        "end_line": 1948,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Annotation.draw#1951",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Annotation",
        "signature": "lib.matplotlib.text.Annotation.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        # docstring inherited\n\n        if renderer is not None:\n            self._renderer = renderer\n        if not self.get_visible():\n            return\n\n        xy_pixel = self._get_position_xy(renderer)\n        if not self._check_xy(renderer, xy_pixel):\n            return\n\n        self._update_position_xytext(renderer, xy_pixel)\n        self.update_bbox_position_size(renderer)\n\n        if self.arrow_patch is not None:   # FancyArrowPatch\n            if self.arrow_patch.figure is None and self.figure is not None:\n                self.arrow_patch.figure = self.figure\n            self.arrow_patch.draw(renderer)\n\n        # Draw text, including FancyBboxPatch, after FancyArrowPatch.\n        # Otherwise, a wedge arrowstyle can land partly on top of the Bbox.\n        Text.draw(self, renderer)",
        "begin_line": 1951,
        "end_line": 1973,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.text.Annotation.get_window_extent#1975",
        "src_path": "lib/matplotlib/text.py",
        "class_name": "lib.matplotlib.text.Annotation",
        "signature": "lib.matplotlib.text.Annotation.get_window_extent(self, renderer=None)",
        "snippet": "    def get_window_extent(self, renderer=None):\n        \"\"\"\n        Return the `.Bbox` bounding the text and arrow, in display units.\n\n        Parameters\n        ----------\n        renderer : Renderer, optional\n            A renderer is needed to compute the bounding box.  If the artist\n            has already been drawn, the renderer is cached; thus, it is only\n            necessary to pass this argument when calling `get_window_extent`\n            before the first `draw`.  In practice, it is usually easier to\n            trigger a draw first (e.g. by saving the figure).\n        \"\"\"\n        # This block is the same as in Text.get_window_extent, but we need to\n        # set the renderer before calling update_positions().\n        if not self.get_visible():\n            return Bbox.unit()\n        if renderer is not None:\n            self._renderer = renderer\n        if self._renderer is None:\n            self._renderer = self.figure._cachedRenderer\n        if self._renderer is None:\n            raise RuntimeError('Cannot get window extent w/o renderer')\n\n        self.update_positions(self._renderer)\n\n        text_bbox = Text.get_window_extent(self)\n        bboxes = [text_bbox]\n\n        if self.arrow_patch is not None:\n            bboxes.append(self.arrow_patch.get_window_extent())\n\n        return Bbox.union(bboxes)",
        "begin_line": 1975,
        "end_line": 2007,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.Stream.end#400",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.Stream",
        "signature": "lib.matplotlib.backends.backend_pdf.Stream.end(self)",
        "snippet": "    def end(self):\n        \"\"\"Finalize stream.\"\"\"\n\n        self._flush()\n        if self.len is None:\n            contents = self.file.getvalue()\n            self.len = len(contents)\n            self.file = self.pdfFile.fh\n            self._writeHeader()\n            self.file.write(contents)\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n        else:\n            length = self.file.tell() - self.pos\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n            self.pdfFile.writeObject(self.len, length)",
        "begin_line": 400,
        "end_line": 414,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.Stream.write#416",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.Stream",
        "signature": "lib.matplotlib.backends.backend_pdf.Stream.write(self, data)",
        "snippet": "    def write(self, data):\n        \"\"\"Write some data on the stream.\"\"\"\n\n        if self.compressobj is None:\n            self.file.write(data)\n        else:\n            compressed = self.compressobj.compress(data)\n            self.file.write(compressed)",
        "begin_line": 416,
        "end_line": 423,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__#437",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__(self, filename, metadata=None)",
        "snippet": "    def __init__(self, filename, metadata=None):\n        \"\"\"\n        Parameters\n        ----------\n\n        filename : str or path-like or file-like\n            Output target; if a string, a file will be opened for writing.\n        metadata : dict from strings to strings and dates\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n        \"\"\"\n        super().__init__()\n\n        self._object_seq = itertools.count(1)  # consumed by reserveObject\n        self.xrefTable = [[0, 65535, 'the zero object']]\n        self.passed_in_file_object = False\n        self.original_file_like = None\n        self.tell_base = 0\n        fh, opened = cbook.to_filehandle(filename, \"wb\", return_opened=True)\n        if not opened:\n            try:\n                self.tell_base = filename.tell()\n            except IOError:\n                fh = BytesIO()\n                self.original_file_like = filename\n            else:\n                fh = filename\n                self.passed_in_file_object = True\n\n        self.fh = fh\n        self.currentstream = None  # stream object to write to, if any\n        fh.write(b\"%PDF-1.4\\n\")    # 1.4 is the first version to have alpha\n        # Output some eight-bit chars as a comment so various utilities\n        # recognize the file as binary by looking at the first few\n        # lines (see note in section 3.4.1 of the PDF reference).\n        fh.write(b\"%\\254\\334 \\253\\272\\n\")\n\n        self.rootObject = self.reserveObject('root')\n        self.pagesObject = self.reserveObject('pages')\n        self.pageList = []\n        self.fontObject = self.reserveObject('fonts')\n        self._extGStateObject = self.reserveObject('extended graphics states')\n        self.hatchObject = self.reserveObject('tiling patterns')\n        self.gouraudObject = self.reserveObject('Gouraud triangles')\n        self.XObjectObject = self.reserveObject('external objects')\n        self.resourceObject = self.reserveObject('resources')\n\n        root = {'Type': Name('Catalog'),\n                'Pages': self.pagesObject}\n        self.writeObject(self.rootObject, root)\n\n        # get source date from SOURCE_DATE_EPOCH, if set\n        # See https://reproducible-builds.org/specs/source-date-epoch/\n        source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n        if source_date_epoch:\n            source_date = datetime.utcfromtimestamp(int(source_date_epoch))\n            source_date = source_date.replace(tzinfo=UTC)\n        else:\n            source_date = datetime.today()\n\n        self.infoDict = {\n            'Creator': f'matplotlib {mpl.__version__}, http://matplotlib.org',\n            'Producer': f'matplotlib pdf backend {mpl.__version__}',\n            'CreationDate': source_date\n        }\n        if metadata is not None:\n            self.infoDict.update(metadata)\n        self.infoDict = {k: v for (k, v) in self.infoDict.items()\n                         if v is not None}\n\n        self.fontNames = {}     # maps filenames to internal font names\n        self._internal_font_seq = (Name(f'F{i}') for i in itertools.count(1))\n        self.dviFontInfo = {}   # maps dvi font names to embedding information\n        # differently encoded Type-1 fonts may share the same descriptor\n        self.type1Descriptors = {}\n        self._character_tracker = _backend_pdf_ps.CharacterTracker()\n\n        self.alphaStates = {}   # maps alpha values to graphics state objects\n        self._alpha_state_seq = (Name(f'A{i}') for i in itertools.count(1))\n        self._soft_mask_states = {}\n        self._soft_mask_seq = (Name(f'SM{i}') for i in itertools.count(1))\n        self._soft_mask_groups = []\n        # reproducible writeHatches needs an ordered dict:\n        self.hatchPatterns = collections.OrderedDict()\n        self._hatch_pattern_seq = (Name(f'H{i}') for i in itertools.count(1))\n        self.gouraudTriangles = []\n\n        self._images = collections.OrderedDict()   # reproducible writeImages\n        self._image_seq = (Name(f'I{i}') for i in itertools.count(1))\n\n        self.markers = collections.OrderedDict()   # reproducible writeMarkers\n        self.multi_byte_charprocs = {}\n\n        self.paths = []\n\n        self.pageAnnotations = []  # A list of annotations for the current page\n\n        # The PDF spec recommends to include every procset\n        procsets = [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]\n\n        # Write resource dictionary.\n        # Possibly TODO: more general ExtGState (graphics state dictionaries)\n        #                ColorSpace Pattern Shading Properties\n        resources = {'Font': self.fontObject,\n                     'XObject': self.XObjectObject,\n                     'ExtGState': self._extGStateObject,\n                     'Pattern': self.hatchObject,\n                     'Shading': self.gouraudObject,\n                     'ProcSet': procsets}\n        self.writeObject(self.resourceObject, resources)",
        "begin_line": 437,
        "end_line": 552,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage#559",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage(self, width, height)",
        "snippet": "    def newPage(self, width, height):\n        self.endStream()\n\n        self.width, self.height = width, height\n        contentObject = self.reserveObject('page contents')\n        thePage = {'Type': Name('Page'),\n                   'Parent': self.pagesObject,\n                   'Resources': self.resourceObject,\n                   'MediaBox': [0, 0, 72 * width, 72 * height],\n                   'Contents': contentObject,\n                   'Group': {'Type': Name('Group'),\n                             'S': Name('Transparency'),\n                             'CS': Name('DeviceRGB')},\n                   'Annots': self.pageAnnotations,\n                   }\n        pageObject = self.reserveObject('page')\n        self.writeObject(pageObject, thePage)\n        self.pageList.append(pageObject)\n\n        self.beginStream(contentObject.id,\n                         self.reserveObject('length of content stream'))\n        # Initialize the pdf graphics state to match the default mpl\n        # graphics context: currently only the join style needs to be set\n        self.output(GraphicsContextPdf.joinstyles['round'], Op.setlinejoin)\n\n        # Clear the list of annotations for the next page\n        self.pageAnnotations = []",
        "begin_line": 559,
        "end_line": 585,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.finalize#598",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.finalize(self)",
        "snippet": "    def finalize(self):\n        \"\"\"Write out the various deferred objects and the pdf end matter.\"\"\"\n\n        self.endStream()\n        self.writeFonts()\n        self.writeExtGSTates()\n        self._write_soft_mask_groups()\n        self.writeHatches()\n        self.writeGouraudTriangles()\n        xobjects = {\n            name: ob for image, name, ob in self._images.values()}\n        for tup in self.markers.values():\n            xobjects[tup[0]] = tup[1]\n        for name, value in self.multi_byte_charprocs.items():\n            xobjects[name] = value\n        for name, path, trans, ob, join, cap, padding, filled, stroked \\\n                in self.paths:\n            xobjects[name] = ob\n        self.writeObject(self.XObjectObject, xobjects)\n        self.writeImages()\n        self.writeMarkers()\n        self.writePathCollectionTemplates()\n        self.writeObject(self.pagesObject,\n                         {'Type': Name('Pages'),\n                          'Kids': self.pageList,\n                          'Count': len(self.pageList)})\n        self.writeInfoDict()\n\n        # Finalize the file\n        self.writeXref()\n        self.writeTrailer()",
        "begin_line": 598,
        "end_line": 628,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.cvt#904",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.cvt(length, upe=font.units_per_EM, nearest=True)",
        "snippet": "        def cvt(length, upe=font.units_per_EM, nearest=True):\n            \"\"\"Convert font coordinates to PDF glyph coordinates.\"\"\"\n            value = length / upe * 1000\n            if nearest:\n                return round(value)\n            # Best(?) to round away from zero for bounding boxes and the like.\n            if value < 0:\n                return math.floor(value)\n            else:\n                return math.ceil(value)",
        "begin_line": 904,
        "end_line": 913,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTFType3#915",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTFType3(font, characters, descriptor)",
        "snippet": "        def embedTTFType3(font, characters, descriptor):\n            \"\"\"The Type 3-specific part of embedding a Truetype font\"\"\"\n            widthsObject = self.reserveObject('font widths')\n            fontdescObject = self.reserveObject('font descriptor')\n            fontdictObject = self.reserveObject('font dictionary')\n            charprocsObject = self.reserveObject('character procs')\n            differencesArray = []\n            firstchar, lastchar = 0, 255\n            bbox = [cvt(x, nearest=False) for x in font.bbox]\n\n            fontdict = {\n                'Type': Name('Font'),\n                'BaseFont': ps_name,\n                'FirstChar': firstchar,\n                'LastChar': lastchar,\n                'FontDescriptor': fontdescObject,\n                'Subtype': Name('Type3'),\n                'Name': descriptor['FontName'],\n                'FontBBox': bbox,\n                'FontMatrix': [.001, 0, 0, .001, 0, 0],\n                'CharProcs': charprocsObject,\n                'Encoding': {\n                    'Type': Name('Encoding'),\n                    'Differences': differencesArray},\n                'Widths': widthsObject\n                }\n\n            from encodings import cp1252\n\n            # Make the \"Widths\" array\n            def get_char_width(charcode):\n                s = ord(cp1252.decoding_table[charcode])\n                width = font.load_char(\n                    s, flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance\n                return cvt(width)\n\n            with warnings.catch_warnings():\n                # Ignore 'Required glyph missing from current font' warning\n                # from ft2font: here we're just building the widths table, but\n                # the missing glyphs may not even be used in the actual string.\n                warnings.filterwarnings(\"ignore\")\n                widths = [get_char_width(charcode)\n                          for charcode in range(firstchar, lastchar+1)]\n            descriptor['MaxWidth'] = max(widths)\n\n            # Make the \"Differences\" array, sort the ccodes < 255 from\n            # the multi-byte ccodes, and build the whole set of glyph ids\n            # that we need from this font.\n            glyph_ids = []\n            differences = []\n            multi_byte_chars = set()\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph_ids.append(gind)\n                glyph_name = font.get_glyph_name(gind)\n                if ccode <= 255:\n                    differences.append((ccode, glyph_name))\n                else:\n                    multi_byte_chars.add(glyph_name)\n            differences.sort()\n\n            last_c = -2\n            for c, name in differences:\n                if c != last_c + 1:\n                    differencesArray.append(c)\n                differencesArray.append(Name(name))\n                last_c = c\n\n            # Make the charprocs array (using ttconv to generate the\n            # actual outlines)\n            try:\n                rawcharprocs = ttconv.get_pdf_charprocs(\n                    os.fsencode(filename), glyph_ids)\n            except RuntimeError:\n                _log.warning(\"The PDF backend does not currently support the \"\n                             \"selected font.\")\n                raise\n            charprocs = {}\n            for charname in sorted(rawcharprocs):\n                stream = rawcharprocs[charname]\n                charprocDict = {'Length': len(stream)}\n                # The 2-byte characters are used as XObjects, so they\n                # need extra info in their dictionary\n                if charname in multi_byte_chars:\n                    charprocDict['Type'] = Name('XObject')\n                    charprocDict['Subtype'] = Name('Form')\n                    charprocDict['BBox'] = bbox\n                    # Each glyph includes bounding box information,\n                    # but xpdf and ghostscript can't handle it in a\n                    # Form XObject (they segfault!!!), so we remove it\n                    # from the stream here.  It's not needed anyway,\n                    # since the Form XObject includes it in its BBox\n                    # value.\n                    stream = stream[stream.find(b\"d1\") + 2:]\n                charprocObject = self.reserveObject('charProc')\n                self.beginStream(charprocObject.id, None, charprocDict)\n                self.currentstream.write(stream)\n                self.endStream()\n\n                # Send the glyphs with ccode > 255 to the XObject dictionary,\n                # and the others to the font itself\n                if charname in multi_byte_chars:\n                    name = self._get_xobject_symbol_name(filename, charname)\n                    self.multi_byte_charprocs[name] = charprocObject\n                else:\n                    charprocs[charname] = charprocObject\n\n            # Write everything out\n            self.writeObject(fontdictObject, fontdict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(widthsObject, widths)\n            self.writeObject(charprocsObject, charprocs)\n\n            return fontdictObject",
        "begin_line": 915,
        "end_line": 1029,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.get_char_width#945",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.get_char_width(charcode)",
        "snippet": "            def get_char_width(charcode):\n                s = ord(cp1252.decoding_table[charcode])\n                width = font.load_char(\n                    s, flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance\n                return cvt(width)",
        "begin_line": 945,
        "end_line": 949,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF#898",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF(self, filename, characters)",
        "snippet": "    def embedTTF(self, filename, characters):\n        \"\"\"Embed the TTF font from the named file into the document.\"\"\"\n\n        font = get_font(filename)\n        fonttype = mpl.rcParams['pdf.fonttype']\n\n        def cvt(length, upe=font.units_per_EM, nearest=True):\n            \"\"\"Convert font coordinates to PDF glyph coordinates.\"\"\"\n            value = length / upe * 1000\n            if nearest:\n                return round(value)\n            # Best(?) to round away from zero for bounding boxes and the like.\n            if value < 0:\n                return math.floor(value)\n            else:\n                return math.ceil(value)\n\n        def embedTTFType3(font, characters, descriptor):\n            \"\"\"The Type 3-specific part of embedding a Truetype font\"\"\"\n            widthsObject = self.reserveObject('font widths')\n            fontdescObject = self.reserveObject('font descriptor')\n            fontdictObject = self.reserveObject('font dictionary')\n            charprocsObject = self.reserveObject('character procs')\n            differencesArray = []\n            firstchar, lastchar = 0, 255\n            bbox = [cvt(x, nearest=False) for x in font.bbox]\n\n            fontdict = {\n                'Type': Name('Font'),\n                'BaseFont': ps_name,\n                'FirstChar': firstchar,\n                'LastChar': lastchar,\n                'FontDescriptor': fontdescObject,\n                'Subtype': Name('Type3'),\n                'Name': descriptor['FontName'],\n                'FontBBox': bbox,\n                'FontMatrix': [.001, 0, 0, .001, 0, 0],\n                'CharProcs': charprocsObject,\n                'Encoding': {\n                    'Type': Name('Encoding'),\n                    'Differences': differencesArray},\n                'Widths': widthsObject\n                }\n\n            from encodings import cp1252\n\n            # Make the \"Widths\" array\n            def get_char_width(charcode):\n                s = ord(cp1252.decoding_table[charcode])\n                width = font.load_char(\n                    s, flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance\n                return cvt(width)\n\n            with warnings.catch_warnings():\n                # Ignore 'Required glyph missing from current font' warning\n                # from ft2font: here we're just building the widths table, but\n                # the missing glyphs may not even be used in the actual string.\n                warnings.filterwarnings(\"ignore\")\n                widths = [get_char_width(charcode)\n                          for charcode in range(firstchar, lastchar+1)]\n            descriptor['MaxWidth'] = max(widths)\n\n            # Make the \"Differences\" array, sort the ccodes < 255 from\n            # the multi-byte ccodes, and build the whole set of glyph ids\n            # that we need from this font.\n            glyph_ids = []\n            differences = []\n            multi_byte_chars = set()\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph_ids.append(gind)\n                glyph_name = font.get_glyph_name(gind)\n                if ccode <= 255:\n                    differences.append((ccode, glyph_name))\n                else:\n                    multi_byte_chars.add(glyph_name)\n            differences.sort()\n\n            last_c = -2\n            for c, name in differences:\n                if c != last_c + 1:\n                    differencesArray.append(c)\n                differencesArray.append(Name(name))\n                last_c = c\n\n            # Make the charprocs array (using ttconv to generate the\n            # actual outlines)\n            try:\n                rawcharprocs = ttconv.get_pdf_charprocs(\n                    os.fsencode(filename), glyph_ids)\n            except RuntimeError:\n                _log.warning(\"The PDF backend does not currently support the \"\n                             \"selected font.\")\n                raise\n            charprocs = {}\n            for charname in sorted(rawcharprocs):\n                stream = rawcharprocs[charname]\n                charprocDict = {'Length': len(stream)}\n                # The 2-byte characters are used as XObjects, so they\n                # need extra info in their dictionary\n                if charname in multi_byte_chars:\n                    charprocDict['Type'] = Name('XObject')\n                    charprocDict['Subtype'] = Name('Form')\n                    charprocDict['BBox'] = bbox\n                    # Each glyph includes bounding box information,\n                    # but xpdf and ghostscript can't handle it in a\n                    # Form XObject (they segfault!!!), so we remove it\n                    # from the stream here.  It's not needed anyway,\n                    # since the Form XObject includes it in its BBox\n                    # value.\n                    stream = stream[stream.find(b\"d1\") + 2:]\n                charprocObject = self.reserveObject('charProc')\n                self.beginStream(charprocObject.id, None, charprocDict)\n                self.currentstream.write(stream)\n                self.endStream()\n\n                # Send the glyphs with ccode > 255 to the XObject dictionary,\n                # and the others to the font itself\n                if charname in multi_byte_chars:\n                    name = self._get_xobject_symbol_name(filename, charname)\n                    self.multi_byte_charprocs[name] = charprocObject\n                else:\n                    charprocs[charname] = charprocObject\n\n            # Write everything out\n            self.writeObject(fontdictObject, fontdict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(widthsObject, widths)\n            self.writeObject(charprocsObject, charprocs)\n\n            return fontdictObject\n\n        def embedTTFType42(font, characters, descriptor):\n            \"\"\"The Type 42-specific part of embedding a Truetype font\"\"\"\n            fontdescObject = self.reserveObject('font descriptor')\n            cidFontDictObject = self.reserveObject('CID font dictionary')\n            type0FontDictObject = self.reserveObject('Type 0 font dictionary')\n            cidToGidMapObject = self.reserveObject('CIDToGIDMap stream')\n            fontfileObject = self.reserveObject('font file stream')\n            wObject = self.reserveObject('Type 0 widths')\n            toUnicodeMapObject = self.reserveObject('ToUnicode map')\n\n            cidFontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('CIDFontType2'),\n                'BaseFont': ps_name,\n                'CIDSystemInfo': {\n                    'Registry': 'Adobe',\n                    'Ordering': 'Identity',\n                    'Supplement': 0},\n                'FontDescriptor': fontdescObject,\n                'W': wObject,\n                'CIDToGIDMap': cidToGidMapObject\n                }\n\n            type0FontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('Type0'),\n                'BaseFont': ps_name,\n                'Encoding': Name('Identity-H'),\n                'DescendantFonts': [cidFontDictObject],\n                'ToUnicode': toUnicodeMapObject\n                }\n\n            # Make fontfile stream\n            descriptor['FontFile2'] = fontfileObject\n            length1Object = self.reserveObject('decoded length of a font')\n            self.beginStream(\n                fontfileObject.id,\n                self.reserveObject('length of font stream'),\n                {'Length1': length1Object})\n            with open(filename, 'rb') as fontfile:\n                length1 = 0\n                while True:\n                    data = fontfile.read(4096)\n                    if not data:\n                        break\n                    length1 += len(data)\n                    self.currentstream.write(data)\n            self.endStream()\n            self.writeObject(length1Object, length1)\n\n            # Make the 'W' (Widths) array, CidToGidMap and ToUnicode CMap\n            # at the same time\n            cid_to_gid_map = ['\\0'] * 65536\n            widths = []\n            max_ccode = 0\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph = font.load_char(ccode,\n                                       flags=LOAD_NO_SCALE | LOAD_NO_HINTING)\n                widths.append((ccode, cvt(glyph.horiAdvance)))\n                if ccode < 65536:\n                    cid_to_gid_map[ccode] = chr(gind)\n                max_ccode = max(ccode, max_ccode)\n            widths.sort()\n            cid_to_gid_map = cid_to_gid_map[:max_ccode + 1]\n\n            last_ccode = -2\n            w = []\n            max_width = 0\n            unicode_groups = []\n            for ccode, width in widths:\n                if ccode != last_ccode + 1:\n                    w.append(ccode)\n                    w.append([width])\n                    unicode_groups.append([ccode, ccode])\n                else:\n                    w[-1].append(width)\n                    unicode_groups[-1][1] = ccode\n                max_width = max(max_width, width)\n                last_ccode = ccode\n\n            unicode_bfrange = []\n            for start, end in unicode_groups:\n                unicode_bfrange.append(\n                    b\"<%04x> <%04x> [%s]\" %\n                    (start, end,\n                     b\" \".join(b\"<%04x>\" % x for x in range(start, end+1))))\n            unicode_cmap = (self._identityToUnicodeCMap %\n                            (len(unicode_groups), b\"\\n\".join(unicode_bfrange)))\n\n            # CIDToGIDMap stream\n            cid_to_gid_map = \"\".join(cid_to_gid_map).encode(\"utf-16be\")\n            self.beginStream(cidToGidMapObject.id,\n                             None,\n                             {'Length': len(cid_to_gid_map)})\n            self.currentstream.write(cid_to_gid_map)\n            self.endStream()\n\n            # ToUnicode CMap\n            self.beginStream(toUnicodeMapObject.id,\n                             None,\n                             {'Length': unicode_cmap})\n            self.currentstream.write(unicode_cmap)\n            self.endStream()\n\n            descriptor['MaxWidth'] = max_width\n\n            # Write everything out\n            self.writeObject(cidFontDictObject, cidFontDict)\n            self.writeObject(type0FontDictObject, type0FontDict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(wObject, w)\n\n            return type0FontDictObject\n\n        # Beginning of main embedTTF function...\n\n        ps_name = font.postscript_name.encode('ascii', 'replace')\n        ps_name = Name(ps_name)\n        pclt = font.get_sfnt_table('pclt') or {'capHeight': 0, 'xHeight': 0}\n        post = font.get_sfnt_table('post') or {'italicAngle': (0, 0)}\n        ff = font.face_flags\n        sf = font.style_flags\n\n        flags = 0\n        symbolic = False  # ps_name.name in ('Cmsy10', 'Cmmi10', 'Cmex10')\n        if ff & FIXED_WIDTH:\n            flags |= 1 << 0\n        if 0:  # TODO: serif\n            flags |= 1 << 1\n        if symbolic:\n            flags |= 1 << 2\n        else:\n            flags |= 1 << 5\n        if sf & ITALIC:\n            flags |= 1 << 6\n        if 0:  # TODO: all caps\n            flags |= 1 << 16\n        if 0:  # TODO: small caps\n            flags |= 1 << 17\n        if 0:  # TODO: force bold\n            flags |= 1 << 18\n\n        descriptor = {\n            'Type': Name('FontDescriptor'),\n            'FontName': ps_name,\n            'Flags': flags,\n            'FontBBox': [cvt(x, nearest=False) for x in font.bbox],\n            'Ascent': cvt(font.ascender, nearest=False),\n            'Descent': cvt(font.descender, nearest=False),\n            'CapHeight': cvt(pclt['capHeight'], nearest=False),\n            'XHeight': cvt(pclt['xHeight']),\n            'ItalicAngle': post['italicAngle'][1],  # ???\n            'StemV': 0  # ???\n            }\n\n        # The font subsetting to a Type 3 font does not work for\n        # OpenType (.otf) that embed a Postscript CFF font, so avoid that --\n        # save as a (non-subsetted) Type 42 font instead.\n        if is_opentype_cff_font(filename):\n            fonttype = 42\n            _log.warning(\"%r can not be subsetted into a Type 3 font. The \"\n                         \"entire font will be embedded in the output.\",\n                         os.path.basename(filename))\n\n        if fonttype == 3:\n            return embedTTFType3(font, characters, descriptor)\n        elif fonttype == 42:\n            return embedTTFType42(font, characters, descriptor)",
        "begin_line": 898,
        "end_line": 1200,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.alphaState#1202",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.alphaState(self, alpha)",
        "snippet": "    def alphaState(self, alpha):\n        \"\"\"Return name of an ExtGState that sets alpha to the given value.\"\"\"\n\n        state = self.alphaStates.get(alpha, None)\n        if state is not None:\n            return state[0]\n\n        name = next(self._alpha_state_seq)\n        self.alphaStates[alpha] = \\\n            (name, {'Type': Name('ExtGState'),\n                    'CA': alpha[0], 'ca': alpha[1]})\n        return name",
        "begin_line": 1202,
        "end_line": 1213,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeExtGSTates#1266",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeExtGSTates(self)",
        "snippet": "    def writeExtGSTates(self):\n        self.writeObject(\n            self._extGStateObject,\n            dict([\n                *self.alphaStates.values(),\n                *self._soft_mask_states.values()\n            ])\n        )",
        "begin_line": 1266,
        "end_line": 1273,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeHatches#1299",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeHatches(self)",
        "snippet": "    def writeHatches(self):\n        hatchDict = dict()\n        sidelen = 72.0\n        for hatch_style, name in self.hatchPatterns.items():\n            ob = self.reserveObject('hatch pattern')\n            hatchDict[name] = ob\n            res = {'Procsets':\n                   [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]}\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('Pattern'),\n                 'PatternType': 1, 'PaintType': 1, 'TilingType': 1,\n                 'BBox': [0, 0, sidelen, sidelen],\n                 'XStep': sidelen, 'YStep': sidelen,\n                 'Resources': res,\n                 # Change origin to match Agg at top-left.\n                 'Matrix': [1, 0, 0, 1, 0, self.height * 72]})\n\n            stroke_rgb, fill_rgb, path = hatch_style\n            self.output(stroke_rgb[0], stroke_rgb[1], stroke_rgb[2],\n                        Op.setrgb_stroke)\n            if fill_rgb is not None:\n                self.output(fill_rgb[0], fill_rgb[1], fill_rgb[2],\n                            Op.setrgb_nonstroke,\n                            0, 0, sidelen, sidelen, Op.rectangle,\n                            Op.fill)\n\n            self.output(mpl.rcParams['hatch.linewidth'], Op.setlinewidth)\n\n            self.output(*self.pathOperations(\n                Path.hatch(path),\n                Affine2D().scale(sidelen),\n                simplify=False))\n            self.output(Op.fill_stroke)\n\n            self.endStream()\n        self.writeObject(self.hatchObject, hatchDict)",
        "begin_line": 1299,
        "end_line": 1335,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.imageObject#1403",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.imageObject(self, image)",
        "snippet": "    def imageObject(self, image):\n        \"\"\"Return name of an image XObject representing the given image.\"\"\"\n\n        entry = self._images.get(id(image), None)\n        if entry is not None:\n            return entry[1]\n\n        name = next(self._image_seq)\n        ob = self.reserveObject(f'image {name}')\n        self._images[id(image)] = (image, name, ob)\n        return name",
        "begin_line": 1403,
        "end_line": 1413,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile._unpack#1415",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile._unpack(self, im)",
        "snippet": "    def _unpack(self, im):\n        \"\"\"\n        Unpack image array *im* into ``(data, alpha)``, which have shape\n        ``(height, width, 3)`` (RGB) or ``(height, width, 1)`` (grayscale or\n        alpha), except that alpha is None if the image is fully opaque.\n        \"\"\"\n        im = im[::-1]\n        if im.ndim == 2:\n            return im, None\n        else:\n            rgb = im[:, :, :3]\n            rgb = np.array(rgb, order='C')\n            # PDF needs a separate alpha image\n            if im.shape[2] == 4:\n                alpha = im[:, :, 3][..., None]\n                if np.all(alpha == 255):\n                    alpha = None\n                else:\n                    alpha = np.array(alpha, order='C')\n            else:\n                alpha = None\n            return rgb, alpha",
        "begin_line": 1415,
        "end_line": 1436,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile._writePng#1438",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile._writePng(self, data)",
        "snippet": "    def _writePng(self, data):\n        \"\"\"\n        Write the image *data* into the pdf file using png\n        predictors with Flate compression.\n        \"\"\"\n        buffer = BytesIO()\n        if data.shape[-1] == 1:\n            data = data.squeeze(axis=-1)\n        Image.fromarray(data).save(buffer, format=\"png\")\n        buffer.seek(8)\n        while True:\n            length, type = struct.unpack(b'!L4s', buffer.read(8))\n            if type == b'IDAT':\n                data = buffer.read(length)\n                if len(data) != length:\n                    raise RuntimeError(\"truncated data\")\n                self.currentstream.write(data)\n            elif type == b'IEND':\n                break\n            else:\n                buffer.seek(length, 1)\n            buffer.seek(4, 1)   # skip CRC",
        "begin_line": 1438,
        "end_line": 1459,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile._writeImg#1461",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile._writeImg(self, data, id, smask=None)",
        "snippet": "    def _writeImg(self, data, id, smask=None):\n        \"\"\"\n        Write the image *data*, of shape ``(height, width, 1)`` (grayscale) or\n        ``(height, width, 3)`` (RGB), as pdf object *id* and with the soft mask\n        (alpha channel) *smask*, which should be either None or a ``(height,\n        width, 1)`` array.\n        \"\"\"\n        height, width, colors = data.shape\n        obj = {'Type': Name('XObject'),\n               'Subtype': Name('Image'),\n               'Width': width,\n               'Height': height,\n               'ColorSpace': Name({1: 'DeviceGray', 3: 'DeviceRGB'}[colors]),\n               'BitsPerComponent': 8}\n        if smask:\n            obj['SMask'] = smask\n        if mpl.rcParams['pdf.compression']:\n            png = {'Predictor': 10, 'Colors': colors, 'Columns': width}\n        else:\n            png = None\n        self.beginStream(\n            id,\n            self.reserveObject('length of image stream'),\n            obj,\n            png=png\n            )\n        if png:\n            self._writePng(data)\n        else:\n            self.currentstream.write(data.tostring())\n        self.endStream()",
        "begin_line": 1461,
        "end_line": 1491,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeImages#1493",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeImages(self)",
        "snippet": "    def writeImages(self):\n        for img, name, ob in self._images.values():\n            data, adata = self._unpack(img)\n            if adata is not None:\n                smaskObject = self.reserveObject(\"smask\")\n                self._writeImg(adata, smaskObject.id)\n            else:\n                smaskObject = None\n            self._writeImg(data, ob.id, smaskObject)",
        "begin_line": 1493,
        "end_line": 1501,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject#1503",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject(self, path, trans, fill, stroke, lw, joinstyle, capstyle)",
        "snippet": "    def markerObject(self, path, trans, fill, stroke, lw, joinstyle,\n                     capstyle):\n        \"\"\"Return name of a marker XObject representing the given path.\"\"\"\n        # self.markers used by markerObject, writeMarkers, close:\n        # mapping from (path operations, fill?, stroke?) to\n        #   [name, object reference, bounding box, linewidth]\n        # This enables different draw_markers calls to share the XObject\n        # if the gc is sufficiently similar: colors etc can vary, but\n        # the choices of whether to fill and whether to stroke cannot.\n        # We need a bounding box enclosing all of the XObject path,\n        # but since line width may vary, we store the maximum of all\n        # occurring line widths in self.markers.\n        # close() is somewhat tightly coupled in that it expects the\n        # first two components of each value in self.markers to be the\n        # name and object reference.\n        pathops = self.pathOperations(path, trans, simplify=False)\n        key = (tuple(pathops), bool(fill), bool(stroke), joinstyle, capstyle)\n        result = self.markers.get(key)\n        if result is None:\n            name = Name('M%d' % len(self.markers))\n            ob = self.reserveObject('marker %d' % len(self.markers))\n            bbox = path.get_extents(trans)\n            self.markers[key] = [name, ob, bbox, lw]\n        else:\n            if result[-1] < lw:\n                result[-1] = lw\n            name = result[0]\n        return name",
        "begin_line": 1503,
        "end_line": 1530,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeMarkers#1532",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeMarkers(self)",
        "snippet": "    def writeMarkers(self):\n        for ((pathops, fill, stroke, joinstyle, capstyle),\n             (name, ob, bbox, lw)) in self.markers.items():\n            bbox = bbox.padded(lw * 0.5)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': list(bbox.extents)})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(fill, stroke))\n            self.endStream()",
        "begin_line": 1532,
        "end_line": 1545,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writePathCollectionTemplates#1555",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writePathCollectionTemplates(self)",
        "snippet": "    def writePathCollectionTemplates(self):\n        for (name, path, trans, ob, joinstyle, capstyle, padding, filled,\n             stroked) in self.paths:\n            pathops = self.pathOperations(path, trans, simplify=False)\n            bbox = path.get_extents(trans)\n            if not np.all(np.isfinite(bbox.extents)):\n                extents = [0, 0, 0, 0]\n            else:\n                bbox = bbox.padded(padding)\n                extents = list(bbox.extents)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': extents})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(filled, stroked))\n            self.endStream()",
        "begin_line": 1555,
        "end_line": 1574,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath#1584",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath(self, path, transform, clip=False, sketch=None)",
        "snippet": "    def writePath(self, path, transform, clip=False, sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72, self.height * 72)\n            simplify = path.should_simplify\n        else:\n            clip = None\n            simplify = False\n        cmds = self.pathOperations(path, transform, clip, simplify=simplify,\n                                   sketch=sketch)\n        self.output(*cmds)",
        "begin_line": 1584,
        "end_line": 1593,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.reserveObject#1595",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.reserveObject(self, name='')",
        "snippet": "    def reserveObject(self, name=''):\n        \"\"\"Reserve an ID for an indirect object.\n        The name is used for debugging in case we forget to print out\n        the object with writeObject.\n        \"\"\"\n\n        id = next(self._object_seq)\n        self.xrefTable.append([None, 0, name])\n        return Reference(id)",
        "begin_line": 1595,
        "end_line": 1603,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.recordXref#1605",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.recordXref(self, id)",
        "snippet": "    def recordXref(self, id):\n        self.xrefTable[id][0] = self.fh.tell() - self.tell_base",
        "begin_line": 1605,
        "end_line": 1606,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject#1608",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject(self, object, contents)",
        "snippet": "    def writeObject(self, object, contents):\n        self.recordXref(object.id)\n        object.write(contents, self)",
        "begin_line": 1608,
        "end_line": 1610,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeXref#1612",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeXref(self)",
        "snippet": "    def writeXref(self):\n        \"\"\"Write out the xref table.\"\"\"\n        self.startxref = self.fh.tell() - self.tell_base\n        self.write(b\"xref\\n0 %d\\n\" % len(self.xrefTable))\n        for i, (offset, generation, name) in enumerate(self.xrefTable):\n            if offset is None:\n                raise AssertionError(\n                    'No offset for object %d (%s)' % (i, name))\n            else:\n                key = b\"f\" if name == 'the zero object' else b\"n\"\n                text = b\"%010d %05d %b \\n\" % (offset, generation, key)\n                self.write(text)",
        "begin_line": 1612,
        "end_line": 1623,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeInfoDict#1625",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeInfoDict(self)",
        "snippet": "    def writeInfoDict(self):\n        \"\"\"Write out the info dictionary, checking it for good form\"\"\"\n\n        def is_string_like(x):\n            return isinstance(x, str)\n\n        def is_date(x):\n            return isinstance(x, datetime)\n\n        check_trapped = (lambda x: isinstance(x, Name) and\n                         x.name in ('True', 'False', 'Unknown'))\n\n        keywords = {'Title': is_string_like,\n                    'Author': is_string_like,\n                    'Subject': is_string_like,\n                    'Keywords': is_string_like,\n                    'Creator': is_string_like,\n                    'Producer': is_string_like,\n                    'CreationDate': is_date,\n                    'ModDate': is_date,\n                    'Trapped': check_trapped}\n        for k in self.infoDict:\n            if k not in keywords:\n                cbook._warn_external('Unknown infodict keyword: %s' % k)\n            else:\n                if not keywords[k](self.infoDict[k]):\n                    cbook._warn_external(\n                        'Bad value for infodict keyword %s' % k)\n\n        self.infoObject = self.reserveObject('info')\n        self.writeObject(self.infoObject, self.infoDict)",
        "begin_line": 1625,
        "end_line": 1655,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfFile.writeTrailer#1657",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfFile",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfFile.writeTrailer(self)",
        "snippet": "    def writeTrailer(self):\n        \"\"\"Write out the PDF trailer.\"\"\"\n\n        self.write(b\"trailer\\n\")\n        self.write(pdfRepr(\n            {'Size': len(self.xrefTable),\n             'Root': self.rootObject,\n             'Info': self.infoObject}))\n        # Could add 'ID'\n        self.write(b\"\\nstartxref\\n%d\\n%%%%EOF\\n\" % self.startxref)",
        "begin_line": 1657,
        "end_line": 1666,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__#1674",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__(self, file, image_dpi, height, width)",
        "snippet": "    def __init__(self, file, image_dpi, height, width):\n        super().__init__(width, height)\n        self.file = file\n        self.gc = self.new_gc()\n        self.mathtext_parser = MathTextParser(\"Pdf\")\n        self.image_dpi = image_dpi",
        "begin_line": 1674,
        "end_line": 1679,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.finalize#1681",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.finalize(self)",
        "snippet": "    def finalize(self):\n        self.file.output(*self.gc.finalize())",
        "begin_line": 1681,
        "end_line": 1682,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc#1684",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc(self, gc, fillcolor=None)",
        "snippet": "    def check_gc(self, gc, fillcolor=None):\n        orig_fill = getattr(gc, '_fillcolor', (0., 0., 0.))\n        gc._fillcolor = fillcolor\n\n        orig_alphas = getattr(gc, '_effective_alphas', (1.0, 1.0))\n\n        if gc.get_rgb() is None:\n            # It should not matter what color here since linewidth should be\n            # 0 unless affected by global settings in rcParams, hence setting\n            # zero alpha just in case.\n            gc.set_foreground((0, 0, 0, 0), isRGBA=True)\n\n        if gc._forced_alpha:\n            gc._effective_alphas = (gc._alpha, gc._alpha)\n        elif fillcolor is None or len(fillcolor) < 4:\n            gc._effective_alphas = (gc._rgb[3], 1.0)\n        else:\n            gc._effective_alphas = (gc._rgb[3], fillcolor[3])\n\n        delta = self.gc.delta(gc)\n        if delta:\n            self.file.output(*delta)\n\n        # Restore gc to avoid unwanted side effects\n        gc._fillcolor = orig_fill\n        gc._effective_alphas = orig_alphas",
        "begin_line": 1684,
        "end_line": 1709,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.get_image_magnification#1720",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.get_image_magnification(self)",
        "snippet": "    def get_image_magnification(self):\n        return self.image_dpi/72.0",
        "begin_line": 1720,
        "end_line": 1721,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image#1723",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image(self, gc, x, y, im, transform=None)",
        "snippet": "    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        if w == 0 or h == 0:\n            return\n\n        if transform is None:\n            # If there's no transform, alpha has already been applied\n            gc.set_alpha(1.0)\n\n        self.check_gc(gc)\n\n        w = 72.0 * w / self.image_dpi\n        h = 72.0 * h / self.image_dpi\n\n        imob = self.file.imageObject(im)\n\n        if transform is None:\n            self.file.output(Op.gsave,\n                             w, 0, 0, h, x, y, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)\n        else:\n            tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()\n\n            self.file.output(Op.gsave,\n                             1, 0, 0, 1, x, y, Op.concat_matrix,\n                             tr1, tr2, tr3, tr4, tr5, tr6, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)",
        "begin_line": 1723,
        "end_line": 1751,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path#1753",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path(self, gc, path, transform, rgbFace=None)",
        "snippet": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        self.check_gc(gc, rgbFace)\n        self.file.writePath(\n            path, transform,\n            rgbFace is None and gc.get_hatch_path() is None,\n            gc.get_sketch_params())\n        self.file.output(self.gc.paint())",
        "begin_line": 1753,
        "end_line": 1760,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers#1832",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None)",
        "snippet": "    def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n                     rgbFace=None):\n        # docstring inherited\n\n        # Same logic as in draw_path_collection\n        len_marker_path = len(marker_path)\n        uses = len(path)\n        if len_marker_path * uses < len_marker_path + uses + 5:\n            RendererBase.draw_markers(self, gc, marker_path, marker_trans,\n                                      path, trans, rgbFace)\n            return\n\n        self.check_gc(gc, rgbFace)\n        fill = gc.fill(rgbFace)\n        stroke = gc.stroke()\n\n        output = self.file.output\n        marker = self.file.markerObject(\n            marker_path, marker_trans, fill, stroke, self.gc._linewidth,\n            gc.get_joinstyle(), gc.get_capstyle())\n\n        output(Op.gsave)\n        lastx, lasty = 0, 0\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.file.width*72, self.file.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                if not (0 <= x <= self.file.width * 72\n                        and 0 <= y <= self.file.height * 72):\n                    continue\n                dx, dy = x - lastx, y - lasty\n                output(1, 0, 0, 1, dx, dy, Op.concat_matrix,\n                       marker, Op.use_xobject)\n                lastx, lasty = x, y\n        output(Op.grestore)",
        "begin_line": 1832,
        "end_line": 1868,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf._setup_textpos#1914",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf._setup_textpos(self, x, y, angle, oldx=0, oldy=0, oldangle=0)",
        "snippet": "    def _setup_textpos(self, x, y, angle, oldx=0, oldy=0, oldangle=0):\n        if angle == oldangle == 0:\n            self.file.output(x - oldx, y - oldy, Op.textpos)\n        else:\n            angle = math.radians(angle)\n            self.file.output(math.cos(angle), math.sin(angle),\n                             -math.sin(angle), math.cos(angle),\n                             x, y, Op.textmatrix)\n            self.file.output(0, 0, Op.textpos)",
        "begin_line": 1914,
        "end_line": 1922,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text#2075",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None)",
        "snippet": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # TODO: combine consecutive texts into one BT/ET delimited section\n\n        self.check_gc(gc, gc._rgb)\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        fontsize = prop.get_size_in_points()\n\n        if mpl.rcParams['pdf.use14corefonts']:\n            font = self._get_font_afm(prop)\n            fonttype = 1\n        else:\n            font = self._get_font_ttf(prop)\n            self.file._character_tracker.track(font, s)\n            fonttype = mpl.rcParams['pdf.fonttype']\n            # We can't subset all OpenType fonts, so switch to Type 42\n            # in that case.\n            if is_opentype_cff_font(font.fname):\n                fonttype = 42\n\n        # If fonttype != 3 or there are no multibyte characters, emit the whole\n        # string at once.\n        if fonttype != 3 or all(ord(char) <= 255 for char in s):\n            self.file.output(Op.begin_text,\n                             self.file.fontName(prop), fontsize, Op.selectfont)\n            self._setup_textpos(x, y, angle)\n            self.file.output(self.encode_string(s, fonttype), Op.show,\n                             Op.end_text)\n\n        # There is no way to access multibyte characters of Type 3 fonts, as\n        # they cannot have a CIDMap.  Therefore, in this case we break the\n        # string into chunks, where each chunk contains either a string of\n        # consecutive 1-byte characters or a single multibyte character.  Each\n        # chunk is emitted with a separate command: 1-byte characters use the\n        # regular text show command (Tj), whereas multibyte characters use\n        # the XObject command (Do).  (If using Type 42 fonts, all of this\n        # complication is avoided, but of course, those fonts can not be\n        # subsetted.)\n        else:\n            singlebyte_chunks = []  # List of (start_x, list-of-1-byte-chars).\n            multibyte_glyphs = []  # List of (start_x, glyph_index).\n            prev_was_singlebyte = False\n            for char, (glyph_idx, glyph_x) in zip(\n                    s,\n                    _text_layout.layout(s, font, kern_mode=KERNING_UNFITTED)):\n                if ord(char) <= 255:\n                    if prev_was_singlebyte:\n                        singlebyte_chunks[-1][1].append(char)\n                    else:\n                        singlebyte_chunks.append((glyph_x, [char]))\n                    prev_was_singlebyte = True\n                else:\n                    multibyte_glyphs.append((glyph_x, glyph_idx))\n                    prev_was_singlebyte = False\n            # Do the rotation and global translation as a single matrix\n            # concatenation up front\n            self.file.output(Op.gsave)\n            a = math.radians(angle)\n            self.file.output(math.cos(a), math.sin(a),\n                             -math.sin(a), math.cos(a),\n                             x, y, Op.concat_matrix)\n            # Emit all the 1-byte characters in a BT/ET group.\n            self.file.output(Op.begin_text,\n                             self.file.fontName(prop), fontsize, Op.selectfont)\n            prev_start_x = 0\n            for start_x, chars in singlebyte_chunks:\n                self._setup_textpos(start_x, 0, 0, prev_start_x, 0, 0)\n                self.file.output(self.encode_string(''.join(chars), fonttype),\n                                 Op.show)\n                prev_start_x = start_x\n            self.file.output(Op.end_text)\n            # Then emit all the multibyte characters, one at a time.\n            for start_x, glyph_idx in multibyte_glyphs:\n                glyph_name = font.get_glyph_name(glyph_idx)\n                self.file.output(Op.gsave)\n                self.file.output(0.001 * fontsize, 0,\n                                 0, 0.001 * fontsize,\n                                 start_x, 0, Op.concat_matrix)\n                name = self.file._get_xobject_symbol_name(\n                    font.fname, glyph_name)\n                self.file.output(Name(name), Op.use_xobject)\n                self.file.output(Op.grestore)\n            self.file.output(Op.grestore)",
        "begin_line": 2075,
        "end_line": 2160,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.RendererPdf.new_gc#2162",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.RendererPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.RendererPdf.new_gc(self)",
        "snippet": "    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextPdf(self.file)",
        "begin_line": 2162,
        "end_line": 2164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__init__#2169",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__init__(self, file)",
        "snippet": "    def __init__(self, file):\n        GraphicsContextBase.__init__(self)\n        self._fillcolor = (0.0, 0.0, 0.0)\n        self._effective_alphas = (1.0, 1.0)\n        self.file = file\n        self.parent = None",
        "begin_line": 2169,
        "end_line": 2174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.stroke#2182",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.stroke(self)",
        "snippet": "    def stroke(self):\n        \"\"\"\n        Predicate: does the path need to be stroked (its outline drawn)?\n        This tests for the various conditions that disable stroking\n        the path, in which case it would presumably be filled.\n        \"\"\"\n        # _linewidth > 0: in pdf a line of width 0 is drawn at minimum\n        #   possible device width, but e.g., agg doesn't draw at all\n        return (self._linewidth > 0 and self._alpha > 0 and\n                (len(self._rgb) <= 3 or self._rgb[3] != 0.0))",
        "begin_line": 2182,
        "end_line": 2191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fill#2193",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fill(self, *args)",
        "snippet": "    def fill(self, *args):\n        \"\"\"\n        Predicate: does the path need to be filled?\n\n        An optional argument can be used to specify an alternative\n        _fillcolor, as needed by RendererPdf.draw_markers.\n        \"\"\"\n        if len(args):\n            _fillcolor = args[0]\n        else:\n            _fillcolor = self._fillcolor\n        return (self._hatch or\n                (_fillcolor is not None and\n                 (len(_fillcolor) <= 3 or _fillcolor[3] != 0.0)))",
        "begin_line": 2193,
        "end_line": 2206,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.paint#2208",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.paint(self)",
        "snippet": "    def paint(self):\n        \"\"\"\n        Return the appropriate pdf operator to cause the path to be\n        stroked, filled, or both.\n        \"\"\"\n        return Op.paint_path(self.fill(), self.stroke())",
        "begin_line": 2208,
        "end_line": 2213,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.capstyle_cmd#2218",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.capstyle_cmd(self, style)",
        "snippet": "    def capstyle_cmd(self, style):\n        return [self.capstyles[style], Op.setlinecap]",
        "begin_line": 2218,
        "end_line": 2219,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.joinstyle_cmd#2221",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.joinstyle_cmd(self, style)",
        "snippet": "    def joinstyle_cmd(self, style):\n        return [self.joinstyles[style], Op.setlinejoin]",
        "begin_line": 2221,
        "end_line": 2222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd#2238",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd(self, hatch, hatch_color)",
        "snippet": "    def hatch_cmd(self, hatch, hatch_color):\n        if not hatch:\n            if self._fillcolor is not None:\n                return self.fillcolor_cmd(self._fillcolor)\n            else:\n                return [Name('DeviceRGB'), Op.setcolorspace_nonstroke]\n        else:\n            hatch_style = (hatch_color, self._fillcolor, hatch)\n            name = self.file.hatchPattern(hatch_style)\n            return [Name('Pattern'), Op.setcolorspace_nonstroke,\n                    name, Op.setcolor_nonstroke]",
        "begin_line": 2238,
        "end_line": 2248,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.rgb_cmd#2250",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.rgb_cmd(self, rgb)",
        "snippet": "    def rgb_cmd(self, rgb):\n        if mpl.rcParams['pdf.inheritcolor']:\n            return []\n        if rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_stroke]\n        else:\n            return [*rgb[:3], Op.setrgb_stroke]",
        "begin_line": 2250,
        "end_line": 2256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fillcolor_cmd#2258",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fillcolor_cmd(self, rgb)",
        "snippet": "    def fillcolor_cmd(self, rgb):\n        if rgb is None or mpl.rcParams['pdf.inheritcolor']:\n            return []\n        elif rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_nonstroke]\n        else:\n            return [*rgb[:3], Op.setrgb_nonstroke]",
        "begin_line": 2258,
        "end_line": 2264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.push#2266",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.push(self)",
        "snippet": "    def push(self):\n        parent = GraphicsContextPdf(self.file)\n        parent.copy_properties(self)\n        parent.parent = self.parent\n        self.parent = parent\n        return [Op.gsave]",
        "begin_line": 2266,
        "end_line": 2271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.pop#2273",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.pop(self)",
        "snippet": "    def pop(self):\n        assert self.parent is not None\n        self.copy_properties(self.parent)\n        self.parent = self.parent.parent\n        return [Op.grestore]",
        "begin_line": 2273,
        "end_line": 2277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd#2279",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd(self, cliprect, clippath)",
        "snippet": "    def clip_cmd(self, cliprect, clippath):\n        \"\"\"Set clip rectangle. Calls `.pop()` and `.push()`.\"\"\"\n        cmds = []\n        # Pop graphics state until we hit the right one or the stack is empty\n        while ((self._cliprect, self._clippath) != (cliprect, clippath)\n                and self.parent is not None):\n            cmds.extend(self.pop())\n        # Unless we hit the right one, set the clip polygon\n        if ((self._cliprect, self._clippath) != (cliprect, clippath) or\n                self.parent is None):\n            cmds.extend(self.push())\n            if self._cliprect != cliprect:\n                cmds.extend([cliprect, Op.rectangle, Op.clip, Op.endpath])\n            if self._clippath != clippath:\n                path, affine = clippath.get_transformed_path_and_affine()\n                cmds.extend(\n                    PdfFile.pathOperations(path, affine, simplify=False) +\n                    [Op.clip, Op.endpath])\n        return cmds",
        "begin_line": 2279,
        "end_line": 2297,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.delta#2313",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.delta(self, other)",
        "snippet": "    def delta(self, other):\n        \"\"\"\n        Copy properties of other into self and return PDF commands\n        needed to transform self into other.\n        \"\"\"\n        cmds = []\n        fill_performed = False\n        for params, cmd in self.commands:\n            different = False\n            for p in params:\n                ours = getattr(self, p)\n                theirs = getattr(other, p)\n                try:\n                    if ours is None or theirs is None:\n                        different = ours is not theirs\n                    else:\n                        different = bool(ours != theirs)\n                except ValueError:\n                    ours = np.asarray(ours)\n                    theirs = np.asarray(theirs)\n                    different = (ours.shape != theirs.shape or\n                                 np.any(ours != theirs))\n                if different:\n                    break\n\n            # Need to update hatching if we also updated fillcolor\n            if params == ('_hatch', '_hatch_color') and fill_performed:\n                different = True\n\n            if different:\n                if params == ('_fillcolor',):\n                    fill_performed = True\n                theirs = [getattr(other, p) for p in params]\n                cmds.extend(cmd(self, *theirs))\n                for p in params:\n                    setattr(self, p, getattr(other, p))\n        return cmds",
        "begin_line": 2313,
        "end_line": 2349,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.copy_properties#2351",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.copy_properties(self, other)",
        "snippet": "    def copy_properties(self, other):\n        \"\"\"\n        Copy properties of other into self.\n        \"\"\"\n        GraphicsContextBase.copy_properties(self, other)\n        fillcolor = getattr(other, '_fillcolor', self._fillcolor)\n        effective_alphas = getattr(other, '_effective_alphas',\n                                   self._effective_alphas)\n        self._fillcolor = fillcolor\n        self._effective_alphas = effective_alphas",
        "begin_line": 2351,
        "end_line": 2360,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.finalize#2362",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.finalize(self)",
        "snippet": "    def finalize(self):\n        \"\"\"\n        Make sure every pushed graphics state is popped.\n        \"\"\"\n        cmds = []\n        while self.parent is not None:\n            cmds.extend(self.pop())\n        return cmds",
        "begin_line": 2362,
        "end_line": 2369,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfPages.__enter__#2420",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfPages",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfPages.__enter__(self)",
        "snippet": "    def __enter__(self):\n        return self",
        "begin_line": 2420,
        "end_line": 2421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__#2423",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfPages",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()",
        "begin_line": 2423,
        "end_line": 2424,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfPages.close#2426",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfPages",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfPages.close(self)",
        "snippet": "    def close(self):\n        \"\"\"\n        Finalize this object, making the underlying file a complete\n        PDF file.\n        \"\"\"\n        self._file.finalize()\n        self._file.close()\n        if (self.get_pagecount() == 0 and not self.keep_empty and\n                not self._file.passed_in_file_object):\n            os.remove(self._file.fh.name)\n        self._file = None",
        "begin_line": 2426,
        "end_line": 2436,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig#2446",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfPages",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig(self, figure=None, **kwargs)",
        "snippet": "    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Saves a `.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to `~.Figure.savefig`.\n\n        Parameters\n        ----------\n        figure : `.Figure` or int, optional\n            Specifies what figure is saved to file. If not specified, the\n            active figure is saved. If a `.Figure` instance is provided, this\n            figure is saved. If an int is specified, the figure instance to\n            save is looked up by number.\n        \"\"\"\n        if not isinstance(figure, Figure):\n            if figure is None:\n                manager = Gcf.get_active()\n            else:\n                manager = Gcf.get_fig_manager(figure)\n            if manager is None:\n                raise ValueError(\"No figure {}\".format(figure))\n            figure = manager.canvas.figure\n        # Force use of pdf backend, as PdfPages is tightly coupled with it.\n        try:\n            orig_canvas = figure.canvas\n            figure.canvas = FigureCanvasPdf(figure)\n            figure.savefig(self, format=\"pdf\", **kwargs)\n        finally:\n            figure.canvas = orig_canvas",
        "begin_line": 2446,
        "end_line": 2474,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.PdfPages.get_pagecount#2476",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.PdfPages",
        "signature": "lib.matplotlib.backends.backend_pdf.PdfPages.get_pagecount(self)",
        "snippet": "    def get_pagecount(self):\n        \"\"\"\n        Returns the current number of pages in the multipage pdf file.\n        \"\"\"\n        return len(self._file.pageList)",
        "begin_line": 2476,
        "end_line": 2480,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf#2509",
        "src_path": "lib/matplotlib/backends/backend_pdf.py",
        "class_name": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf",
        "signature": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf(self, filename, *, dpi=72, bbox_inches_restore=None, metadata=None, **kwargs)",
        "snippet": "    def print_pdf(self, filename, *,\n                  dpi=72,  # dpi to use for images\n                  bbox_inches_restore=None, metadata=None,\n                  **kwargs):\n        self.figure.set_dpi(72)            # there are 72 pdf points to an inch\n        width, height = self.figure.get_size_inches()\n        if isinstance(filename, PdfPages):\n            file = filename._file\n        else:\n            file = PdfFile(filename, metadata=metadata)\n        try:\n            file.newPage(width, height)\n            renderer = MixedModeRenderer(\n                self.figure, width, height, dpi,\n                RendererPdf(file, dpi, height, width),\n                bbox_inches_restore=bbox_inches_restore)\n            self.figure.draw(renderer)\n            renderer.finalize()\n            if not isinstance(filename, PdfPages):\n                file.finalize()\n        finally:\n            if isinstance(filename, PdfPages):  # finish off this page\n                file.endStream()\n            else:            # we opened the file above; now finish it off\n                file.close()",
        "begin_line": 2509,
        "end_line": 2533,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image._draw_list_compositing_images#114",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image",
        "signature": "lib.matplotlib.image._draw_list_compositing_images(renderer, parent, artists, suppress_composite=None)",
        "snippet": "def _draw_list_compositing_images(\n        renderer, parent, artists, suppress_composite=None):\n    \"\"\"\n    Draw a sorted list of artists, compositing images into a single\n    image where possible.\n\n    For internal Matplotlib use only: It is here to reduce duplication\n    between `Figure.draw` and `Axes.draw`, but otherwise should not be\n    generally useful.\n    \"\"\"\n    has_images = any(isinstance(x, _ImageBase) for x in artists)\n\n    # override the renderer default if suppressComposite is not None\n    not_composite = (suppress_composite if suppress_composite is not None\n                     else renderer.option_image_nocomposite())\n\n    if not_composite or not has_images:\n        for a in artists:\n            a.draw(renderer)\n    else:\n        # Composite any adjacent images together\n        image_group = []\n        mag = renderer.get_image_magnification()\n\n        def flush_images():\n            if len(image_group) == 1:\n                image_group[0].draw(renderer)\n            elif len(image_group) > 1:\n                data, l, b = composite_images(image_group, renderer, mag)\n                if data.size != 0:\n                    gc = renderer.new_gc()\n                    gc.set_clip_rectangle(parent.bbox)\n                    gc.set_clip_path(parent.get_clip_path())\n                    renderer.draw_image(gc, round(l), round(b), data)\n                    gc.restore()\n            del image_group[:]\n\n        for a in artists:\n            if isinstance(a, _ImageBase) and a.can_composite():\n                image_group.append(a)\n            else:\n                flush_images()\n                a.draw(renderer)\n        flush_images()",
        "begin_line": 114,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.872327211427557e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image._ImageBase.__init__#232",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image._ImageBase",
        "signature": "lib.matplotlib.image._ImageBase.__init__(self, ax, cmap=None, norm=None, interpolation=None, origin=None, filternorm=True, filterrad=4.0, resample=False, **kwargs)",
        "snippet": "    def __init__(self, ax,\n                 cmap=None,\n                 norm=None,\n                 interpolation=None,\n                 origin=None,\n                 filternorm=True,\n                 filterrad=4.0,\n                 resample=False,\n                 **kwargs\n                 ):\n        martist.Artist.__init__(self)\n        cm.ScalarMappable.__init__(self, norm, cmap)\n        self._mouseover = True\n        if origin is None:\n            origin = mpl.rcParams['image.origin']\n        cbook._check_in_list([\"upper\", \"lower\"], origin=origin)\n        self.origin = origin\n        self.set_filternorm(filternorm)\n        self.set_filterrad(filterrad)\n        self.set_interpolation(interpolation)\n        self.set_resample(resample)\n        self.axes = ax\n\n        self._imcache = None\n\n        self.update(kwargs)",
        "begin_line": 232,
        "end_line": 257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.864726700747149e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image._ImageBase.changed#303",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image._ImageBase",
        "signature": "lib.matplotlib.image._ImageBase.changed(self)",
        "snippet": "    def changed(self):\n        \"\"\"\n        Call this whenever the mappable is changed so observers can update.\n        \"\"\"\n        self._imcache = None\n        self._rgbacache = None\n        cm.ScalarMappable.changed(self)",
        "begin_line": 303,
        "end_line": 309,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.027614995584812e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image._ImageBase._make_image#311",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image._ImageBase",
        "signature": "lib.matplotlib.image._ImageBase._make_image(self, A, in_bbox, out_bbox, clip_bbox, magnification=1.0, unsampled=False, round_to_pixel_border=True)",
        "snippet": "    def _make_image(self, A, in_bbox, out_bbox, clip_bbox, magnification=1.0,\n                    unsampled=False, round_to_pixel_border=True):\n        \"\"\"\n        Normalize, rescale, and colormap the image *A* from the given *in_bbox*\n        (in data space), to the given *out_bbox* (in pixel space) clipped to\n        the given *clip_bbox* (also in pixel space), and magnified by the\n        *magnification* factor.\n\n        *A* may be a greyscale image (M, N) with a dtype of float32, float64,\n        float128, uint16 or uint8, or an (M, N, 4) RGBA image with a dtype of\n        float32, float64, float128, or uint8.\n\n        If *unsampled* is True, the image will not be scaled, but an\n        appropriate affine transformation will be returned instead.\n\n        If *round_to_pixel_border* is True, the output image size will be\n        rounded to the nearest pixel boundary.  This makes the images align\n        correctly with the axes.  It should not be used if exact scaling is\n        needed, such as for `FigureImage`.\n\n        Returns\n        -------\n        image : (M, N, 4) uint8 array\n            The RGBA image, resampled unless *unsampled* is True.\n        x, y : float\n            The upper left corner where the image should be drawn, in pixel\n            space.\n        trans : Affine2D\n            The affine transformation from image to pixel space.\n        \"\"\"\n        if A is None:\n            raise RuntimeError('You must first set the image '\n                               'array or the image attribute')\n        if A.size == 0:\n            raise RuntimeError(\"_make_image must get a non-empty image. \"\n                               \"Your Artist's draw method must filter before \"\n                               \"this method is called.\")\n\n        clipped_bbox = Bbox.intersection(out_bbox, clip_bbox)\n\n        if clipped_bbox is None:\n            return None, 0, 0, None\n\n        out_width_base = clipped_bbox.width * magnification\n        out_height_base = clipped_bbox.height * magnification\n\n        if out_width_base == 0 or out_height_base == 0:\n            return None, 0, 0, None\n\n        if self.origin == 'upper':\n            # Flip the input image using a transform.  This avoids the\n            # problem with flipping the array, which results in a copy\n            # when it is converted to contiguous in the C wrapper\n            t0 = Affine2D().translate(0, -A.shape[0]).scale(1, -1)\n        else:\n            t0 = IdentityTransform()\n\n        t0 += (\n            Affine2D()\n            .scale(\n                in_bbox.width / A.shape[1],\n                in_bbox.height / A.shape[0])\n            .translate(in_bbox.x0, in_bbox.y0)\n            + self.get_transform())\n\n        t = (t0\n             + (Affine2D()\n                .translate(-clipped_bbox.x0, -clipped_bbox.y0)\n                .scale(magnification)))\n\n        # So that the image is aligned with the edge of the axes, we want to\n        # round up the output width to the next integer.  This also means\n        # scaling the transform slightly to account for the extra subpixel.\n        if (t.is_affine and round_to_pixel_border and\n                (out_width_base % 1.0 != 0.0 or out_height_base % 1.0 != 0.0)):\n            out_width = math.ceil(out_width_base)\n            out_height = math.ceil(out_height_base)\n            extra_width = (out_width - out_width_base) / out_width_base\n            extra_height = (out_height - out_height_base) / out_height_base\n            t += Affine2D().scale(1.0 + extra_width, 1.0 + extra_height)\n        else:\n            out_width = int(out_width_base)\n            out_height = int(out_height_base)\n        out_shape = (out_height, out_width)\n\n        if not unsampled:\n            if not (A.ndim == 2 or A.ndim == 3 and A.shape[-1] in (3, 4)):\n                raise ValueError(f\"Invalid shape {A.shape} for image data\")\n\n            if A.ndim == 2:\n                # if we are a 2D array, then we are running through the\n                # norm + colormap transformation.  However, in general the\n                # input data is not going to match the size on the screen so we\n                # have to resample to the correct number of pixels\n\n                # TODO slice input array first\n                inp_dtype = A.dtype\n                a_min = A.min()\n                a_max = A.max()\n                # figure out the type we should scale to.  For floats,\n                # leave as is.  For integers cast to an appropriate-sized\n                # float.  Small integers get smaller floats in an attempt\n                # to keep the memory footprint reasonable.\n                if a_min is np.ma.masked:\n                    # all masked, so values don't matter\n                    a_min, a_max = np.int32(0), np.int32(1)\n                if inp_dtype.kind == 'f':\n                    scaled_dtype = A.dtype\n                    # Cast to float64\n                    if A.dtype not in (np.float32, np.float16):\n                        if A.dtype != np.float64:\n                            cbook._warn_external(\n                                f\"Casting input data from '{A.dtype}' to \"\n                                f\"'float64' for imshow\")\n                        scaled_dtype = np.float64\n                else:\n                    # probably an integer of some type.\n                    da = a_max.astype(np.float64) - a_min.astype(np.float64)\n                    # give more breathing room if a big dynamic range\n                    scaled_dtype = np.float64 if da > 1e8 else np.float32\n\n                # scale the input data to [.1, .9].  The Agg\n                # interpolators clip to [0, 1] internally, use a\n                # smaller input scale to identify which of the\n                # interpolated points need to be should be flagged as\n                # over / under.\n                # This may introduce numeric instabilities in very broadly\n                # scaled data\n                # Always copy, and don't allow array subtypes.\n                A_scaled = np.array(A, dtype=scaled_dtype)\n                # clip scaled data around norm if necessary.\n                # This is necessary for big numbers at the edge of\n                # float64's ability to represent changes.  Applying\n                # a norm first would be good, but ruins the interpolation\n                # of over numbers.\n                self.norm.autoscale_None(A)\n                dv = np.float64(self.norm.vmax) - np.float64(self.norm.vmin)\n                vmid = self.norm.vmin + dv / 2\n                fact = 1e7 if scaled_dtype == np.float64 else 1e4\n                newmin = vmid - dv * fact\n                if newmin < a_min:\n                    newmin = None\n                else:\n                    a_min = np.float64(newmin)\n                newmax = vmid + dv * fact\n                if newmax > a_max:\n                    newmax = None\n                else:\n                    a_max = np.float64(newmax)\n                if newmax is not None or newmin is not None:\n                    np.clip(A_scaled, newmin, newmax, out=A_scaled)\n\n                A_scaled -= a_min\n                # a_min and a_max might be ndarray subclasses so use\n                # item to avoid errors\n                a_min = a_min.astype(scaled_dtype).item()\n                a_max = a_max.astype(scaled_dtype).item()\n\n                if a_min != a_max:\n                    A_scaled /= ((a_max - a_min) / 0.8)\n                A_scaled += 0.1\n                # resample the input data to the correct resolution and shape\n                A_resampled = _resample(self, A_scaled, out_shape, t)\n                # done with A_scaled now, remove from namespace to be sure!\n                del A_scaled\n                # un-scale the resampled data to approximately the\n                # original range things that interpolated to above /\n                # below the original min/max will still be above /\n                # below, but possibly clipped in the case of higher order\n                # interpolation + drastically changing data.\n                A_resampled -= 0.1\n                if a_min != a_max:\n                    A_resampled *= ((a_max - a_min) / 0.8)\n                A_resampled += a_min\n                # if using NoNorm, cast back to the original datatype\n                if isinstance(self.norm, mcolors.NoNorm):\n                    A_resampled = A_resampled.astype(A.dtype)\n\n                mask = (np.where(A.mask, np.float32(np.nan), np.float32(1))\n                        if A.mask.shape == A.shape  # nontrivial mask\n                        else np.ones_like(A, np.float32))\n                # we always have to interpolate the mask to account for\n                # non-affine transformations\n                out_alpha = _resample(self, mask, out_shape, t, resample=True)\n                # done with the mask now, delete from namespace to be sure!\n                del mask\n                # Agg updates out_alpha in place.  If the pixel has no image\n                # data it will not be updated (and still be 0 as we initialized\n                # it), if input data that would go into that output pixel than\n                # it will be `nan`, if all the input data for a pixel is good\n                # it will be 1, and if there is _some_ good data in that output\n                # pixel it will be between [0, 1] (such as a rotated image).\n                out_mask = np.isnan(out_alpha)\n                out_alpha[out_mask] = 1\n                # Apply the pixel-by-pixel alpha values if present\n                alpha = self.get_alpha()\n                if alpha is not None and np.ndim(alpha) > 0:\n                    out_alpha *= _resample(self, alpha, out_shape,\n                                           t, resample=True)\n                # mask and run through the norm\n                output = self.norm(np.ma.masked_array(A_resampled, out_mask))\n            else:\n                if A.shape[2] == 3:\n                    A = _rgb_to_rgba(A)\n                alpha = self._get_scalar_alpha()\n                output_alpha = _resample(  # resample alpha channel\n                    self, A[..., 3], out_shape, t, alpha=alpha)\n                output = _resample(  # resample rgb channels\n                    self, _rgb_to_rgba(A[..., :3]), out_shape, t, alpha=alpha)\n                output[..., 3] = output_alpha  # recombine rgb and alpha\n\n            # at this point output is either a 2D array of normed data\n            # (of int or float)\n            # or an RGBA array of re-sampled input\n            output = self.to_rgba(output, bytes=True, norm=False)\n            # output is now a correctly sized RGBA array of uint8\n\n            # Apply alpha *after* if the input was greyscale without a mask\n            if A.ndim == 2:\n                alpha = self._get_scalar_alpha()\n                alpha_channel = output[:, :, 3]\n                alpha_channel[:] = np.asarray(\n                    np.asarray(alpha_channel, np.float32) * out_alpha * alpha,\n                    np.uint8)\n\n        else:\n            if self._imcache is None:\n                self._imcache = self.to_rgba(A, bytes=True, norm=(A.ndim == 2))\n            output = self._imcache\n\n            # Subset the input image to only the part that will be\n            # displayed\n            subset = TransformedBbox(clip_bbox, t0.inverted()).frozen()\n            output = output[\n                int(max(subset.ymin, 0)):\n                int(min(subset.ymax + 1, output.shape[0])),\n                int(max(subset.xmin, 0)):\n                int(min(subset.xmax + 1, output.shape[1]))]\n\n            t = Affine2D().translate(\n                int(max(subset.xmin, 0)), int(max(subset.ymin, 0))) + t\n\n        return output, clipped_bbox.x0, clipped_bbox.y0, t",
        "begin_line": 311,
        "end_line": 553,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003728560775540641,
            "pseudo_dstar_susp": 0.0003450655624568668,
            "pseudo_tarantula_susp": 0.0007027406886858749,
            "pseudo_op2_susp": 0.0003450655624568668,
            "pseudo_barinel_susp": 0.0007027406886858749
        }
    },
    {
        "name": "lib.matplotlib.image._ImageBase.draw#598",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image._ImageBase",
        "signature": "lib.matplotlib.image._ImageBase.draw(self, renderer, *args, **kwargs)",
        "snippet": "    def draw(self, renderer, *args, **kwargs):\n        # if not visible, declare victory and return\n        if not self.get_visible():\n            self.stale = False\n            return\n\n        # for empty images, there is nothing to draw!\n        if self.get_array().size == 0:\n            self.stale = False\n            return\n\n        # actually render the image.\n        gc = renderer.new_gc()\n        self._set_gc_clip(gc)\n        gc.set_alpha(self._get_scalar_alpha())\n        gc.set_url(self.get_url())\n        gc.set_gid(self.get_gid())\n\n        if (self._check_unsampled_image(renderer) and\n                self.get_transform().is_affine):\n            self._draw_unsampled_image(renderer, gc)\n        else:\n            im, l, b, trans = self.make_image(\n                renderer, renderer.get_image_magnification())\n            if im is not None:\n                renderer.draw_image(gc, l, b, im)\n        gc.restore()\n        self.stale = False",
        "begin_line": 598,
        "end_line": 625,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00036656891495601173,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0006565988181221273,
            "pseudo_op2_susp": 0.0003399048266485384,
            "pseudo_barinel_susp": 0.0006565988181221273
        }
    },
    {
        "name": "lib.matplotlib.image._ImageBase.set_data#663",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image._ImageBase",
        "signature": "lib.matplotlib.image._ImageBase.set_data(self, A)",
        "snippet": "    def set_data(self, A):\n        \"\"\"\n        Set the image array.\n\n        Note that this function does *not* update the normalization used.\n\n        Parameters\n        ----------\n        A : array-like or `PIL.Image.Image`\n        \"\"\"\n        if isinstance(A, PIL.Image.Image):\n            A = pil_to_array(A)  # Needed e.g. to apply png palette.\n        self._A = cbook.safe_masked_invalid(A, copy=True)\n\n        if (self._A.dtype != np.uint8 and\n                not np.can_cast(self._A.dtype, float, \"same_kind\")):\n            raise TypeError(\"Image data of dtype {} cannot be converted to \"\n                            \"float\".format(self._A.dtype))\n\n        if self._A.ndim == 3 and self._A.shape[-1] == 1:\n            # If just one dimension assume scalar and apply colormap\n            self._A = self._A[:, :, 0]\n\n        if not (self._A.ndim == 2\n                or self._A.ndim == 3 and self._A.shape[-1] in [3, 4]):\n            raise TypeError(\"Invalid shape {} for image data\"\n                            .format(self._A.shape))\n\n        if self._A.ndim == 3:\n            # If the input data has values outside the valid range (after\n            # normalisation), we issue a warning and then clip X to the bounds\n            # - otherwise casting wraps extreme values, hiding outliers and\n            # making reliable interpretation impossible.\n            high = 255 if np.issubdtype(self._A.dtype, np.integer) else 1\n            if self._A.min() < 0 or high < self._A.max():\n                _log.warning(\n                    'Clipping input data to the valid range for imshow with '\n                    'RGB data ([0..1] for floats or [0..255] for integers).'\n                )\n                self._A = np.clip(self._A, 0, high)\n            # Cast unsupported integer types to uint8\n            if self._A.dtype != np.uint8 and np.issubdtype(self._A.dtype,\n                                                           np.integer):\n                self._A = self._A.astype(np.uint8)\n\n        self._imcache = None\n        self._rgbacache = None\n        self.stale = True",
        "begin_line": 663,
        "end_line": 710,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image._ImageBase.get_resample#779",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image._ImageBase",
        "signature": "lib.matplotlib.image._ImageBase.get_resample(self)",
        "snippet": "    def get_resample(self):\n        \"\"\"Return whether image resampling is used.\"\"\"\n        return self._resample",
        "begin_line": 779,
        "end_line": 781,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image._ImageBase.get_filterrad#815",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image._ImageBase",
        "signature": "lib.matplotlib.image._ImageBase.get_filterrad(self)",
        "snippet": "    def get_filterrad(self):\n        \"\"\"Return the filterrad setting.\"\"\"\n        return self._filterrad",
        "begin_line": 815,
        "end_line": 817,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.133387555917039e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image.AxesImage.__init__#863",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.AxesImage",
        "signature": "lib.matplotlib.image.AxesImage.__init__(self, ax, cmap=None, norm=None, interpolation=None, origin=None, extent=None, filternorm=True, filterrad=4.0, resample=False, **kwargs)",
        "snippet": "    def __init__(self, ax,\n                 cmap=None,\n                 norm=None,\n                 interpolation=None,\n                 origin=None,\n                 extent=None,\n                 filternorm=True,\n                 filterrad=4.0,\n                 resample=False,\n                 **kwargs\n                 ):\n\n        self._extent = extent\n\n        super().__init__(\n            ax,\n            cmap=cmap,\n            norm=norm,\n            interpolation=interpolation,\n            origin=origin,\n            filternorm=filternorm,\n            filterrad=filterrad,\n            resample=resample,\n            **kwargs\n        )",
        "begin_line": 863,
        "end_line": 887,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image.AxesImage.make_image#894",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.AxesImage",
        "signature": "lib.matplotlib.image.AxesImage.make_image(self, renderer, magnification=1.0, unsampled=False)",
        "snippet": "    def make_image(self, renderer, magnification=1.0, unsampled=False):\n        # docstring inherited\n        trans = self.get_transform()\n        # image is created in the canvas coordinate.\n        x1, x2, y1, y2 = self.get_extent()\n        bbox = Bbox(np.array([[x1, y1], [x2, y2]]))\n        transformed_bbox = TransformedBbox(bbox, trans)\n        return self._make_image(\n            self._A, bbox, transformed_bbox,\n            self.get_clip_box() or self.axes.bbox,\n            magnification, unsampled=unsampled)",
        "begin_line": 894,
        "end_line": 904,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.204791598293403e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image.AxesImage.set_extent#911",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.AxesImage",
        "signature": "lib.matplotlib.image.AxesImage.set_extent(self, extent)",
        "snippet": "    def set_extent(self, extent):\n        \"\"\"\n        Set the image extent.\n\n        Parameters\n        ----------\n        extent : 4-tuple of float\n            The position and size of the image as tuple\n            ``(left, right, bottom, top)`` in data coordinates.\n\n        Notes\n        -----\n        This updates ``ax.dataLim``, and, if autoscaling, sets ``ax.viewLim``\n        to tightly fit the image, regardless of ``dataLim``.  Autoscaling\n        state is not changed, so following this with ``ax.autoscale_view()``\n        will redo the autoscaling in accord with ``dataLim``.\n        \"\"\"\n        self._extent = xmin, xmax, ymin, ymax = extent\n        corners = (xmin, ymin), (xmax, ymax)\n        self.axes.update_datalim(corners)\n        self.sticky_edges.x[:] = [xmin, xmax]\n        self.sticky_edges.y[:] = [ymin, ymax]\n        if self.axes._autoscaleXon:\n            self.axes.set_xlim((xmin, xmax), auto=None)\n        if self.axes._autoscaleYon:\n            self.axes.set_ylim((ymin, ymax), auto=None)\n        self.stale = True",
        "begin_line": 911,
        "end_line": 937,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.940289026520565e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image.AxesImage.format_cursor_data#977",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.AxesImage",
        "signature": "lib.matplotlib.image.AxesImage.format_cursor_data(self, data)",
        "snippet": "    def format_cursor_data(self, data):\n        if np.ndim(data) == 0 and self.colorbar:\n            return (\n                \"[\"\n                + cbook.strip_math(\n                    self.colorbar.formatter.format_data_short(data)).strip()\n                + \"]\")\n        else:\n            return super().format_cursor_data(data)",
        "begin_line": 977,
        "end_line": 985,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image.NonUniformImage.set_cmap#1109",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.NonUniformImage",
        "signature": "lib.matplotlib.image.NonUniformImage.set_cmap(self, cmap)",
        "snippet": "    def set_cmap(self, cmap):\n        if self._A is not None:\n            raise RuntimeError('Cannot change colors after loading data')\n        super().set_cmap(cmap)",
        "begin_line": 1109,
        "end_line": 1112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image.PcolorImage.set_data#1196",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.PcolorImage",
        "signature": "lib.matplotlib.image.PcolorImage.set_data(self, x, y, A)",
        "snippet": "    def set_data(self, x, y, A):\n        \"\"\"\n        Set the grid for the rectangle boundaries, and the data values.\n\n        Parameters\n        ----------\n        x, y : 1D array-like, optional\n            Monotonic arrays of length N+1 and M+1, respectively, specifying\n            rectangle boundaries.  If not given, will default to\n            ``range(N + 1)`` and ``range(M + 1)``, respectively.\n        A : array-like\n            The data to be color-coded. The interpretation depends on the\n            shape:\n\n            - (M, N) ndarray or masked array: values to be colormapped\n            - (M, N, 3): RGB array\n            - (M, N, 4): RGBA array\n        \"\"\"\n        A = cbook.safe_masked_invalid(A, copy=True)\n        if x is None:\n            x = np.arange(0, A.shape[1]+1, dtype=np.float64)\n        else:\n            x = np.array(x, np.float64).ravel()\n        if y is None:\n            y = np.arange(0, A.shape[0]+1, dtype=np.float64)\n        else:\n            y = np.array(y, np.float64).ravel()\n\n        if A.shape[:2] != (y.size-1, x.size-1):\n            raise ValueError(\n                \"Axes don't match array shape. Got %s, expected %s.\" %\n                (A.shape[:2], (y.size - 1, x.size - 1)))\n        if A.ndim not in [2, 3]:\n            raise ValueError(\"A must be 2D or 3D\")\n        if A.ndim == 3 and A.shape[2] == 1:\n            A.shape = A.shape[:2]\n        self._is_grayscale = False\n        if A.ndim == 3:\n            if A.shape[2] in [3, 4]:\n                if ((A[:, :, 0] == A[:, :, 1]).all() and\n                        (A[:, :, 0] == A[:, :, 2]).all()):\n                    self._is_grayscale = True\n            else:\n                raise ValueError(\"3D arrays must have RGB or RGBA as last dim\")\n\n        # For efficient cursor readout, ensure x and y are increasing.\n        if x[-1] < x[0]:\n            x = x[::-1]\n            A = A[:, ::-1]\n        if y[-1] < y[0]:\n            y = y[::-1]\n            A = A[::-1]\n\n        self._A = A\n        self._Ax = x\n        self._Ay = y\n        self._rgbacache = None\n        self.stale = True",
        "begin_line": 1196,
        "end_line": 1253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image.FigureImage.__init__#1277",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.FigureImage",
        "signature": "lib.matplotlib.image.FigureImage.__init__(self, fig, cmap=None, norm=None, offsetx=0, offsety=0, origin=None, **kwargs)",
        "snippet": "    def __init__(self, fig,\n                 cmap=None,\n                 norm=None,\n                 offsetx=0,\n                 offsety=0,\n                 origin=None,\n                 **kwargs\n                 ):\n        \"\"\"\n        cmap is a colors.Colormap instance\n        norm is a colors.Normalize instance to map luminance to 0-1\n\n        kwargs are an optional list of Artist keyword args\n        \"\"\"\n        super().__init__(\n            None,\n            norm=norm,\n            cmap=cmap,\n            origin=origin\n        )\n        self.figure = fig\n        self.ox = offsetx\n        self.oy = offsety\n        self.update(kwargs)\n        self.magnification = 1.0",
        "begin_line": 1277,
        "end_line": 1301,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image.FigureImage.make_image#1309",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.FigureImage",
        "signature": "lib.matplotlib.image.FigureImage.make_image(self, renderer, magnification=1.0, unsampled=False)",
        "snippet": "    def make_image(self, renderer, magnification=1.0, unsampled=False):\n        # docstring inherited\n        fac = renderer.dpi/self.figure.dpi\n        # fac here is to account for pdf, eps, svg backends where\n        # figure.dpi is set to 72.  This means we need to scale the\n        # image (using magnification) and offset it appropriately.\n        bbox = Bbox([[self.ox/fac, self.oy/fac],\n                     [(self.ox/fac + self._A.shape[1]),\n                     (self.oy/fac + self._A.shape[0])]])\n        width, height = self.figure.get_size_inches()\n        width *= renderer.dpi\n        height *= renderer.dpi\n        clip = Bbox([[0, 0], [width, height]])\n        return self._make_image(\n            self._A, bbox, bbox, clip, magnification=magnification / fac,\n            unsampled=unsampled, round_to_pixel_border=False)",
        "begin_line": 1309,
        "end_line": 1324,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image.BboxImage.__init__#1336",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.BboxImage",
        "signature": "lib.matplotlib.image.BboxImage.__init__(self, bbox, cmap=None, norm=None, interpolation=None, origin=None, filternorm=True, filterrad=4.0, resample=False, **kwargs)",
        "snippet": "    def __init__(self, bbox,\n                 cmap=None,\n                 norm=None,\n                 interpolation=None,\n                 origin=None,\n                 filternorm=True,\n                 filterrad=4.0,\n                 resample=False,\n                 **kwargs\n                 ):\n        \"\"\"\n        cmap is a colors.Colormap instance\n        norm is a colors.Normalize instance to map luminance to 0-1\n\n        kwargs are an optional list of Artist keyword args\n        \"\"\"\n        super().__init__(\n            None,\n            cmap=cmap,\n            norm=norm,\n            interpolation=interpolation,\n            origin=origin,\n            filternorm=filternorm,\n            filterrad=filterrad,\n            resample=resample,\n            **kwargs\n        )\n\n        self.bbox = bbox\n        self._transform = IdentityTransform()",
        "begin_line": 1336,
        "end_line": 1365,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image.BboxImage.get_transform#1367",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.BboxImage",
        "signature": "lib.matplotlib.image.BboxImage.get_transform(self)",
        "snippet": "    def get_transform(self):\n        return self._transform",
        "begin_line": 1367,
        "end_line": 1368,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image.BboxImage.get_window_extent#1370",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image.BboxImage",
        "signature": "lib.matplotlib.image.BboxImage.get_window_extent(self, renderer=None)",
        "snippet": "    def get_window_extent(self, renderer=None):\n        if renderer is None:\n            renderer = self.get_figure()._cachedRenderer\n\n        if isinstance(self.bbox, BboxBase):\n            return self.bbox\n        elif callable(self.bbox):\n            return self.bbox(renderer)\n        else:\n            raise ValueError(\"Unknown type of bbox\")",
        "begin_line": 1370,
        "end_line": 1379,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image.imread#1408",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image",
        "signature": "lib.matplotlib.image.imread(fname, format=None)",
        "snippet": "def imread(fname, format=None):\n    \"\"\"\n    Read an image from a file into an array.\n\n    Parameters\n    ----------\n    fname : str or file-like\n        The image file to read: a filename, a URL or a file-like object opened\n        in read-binary mode.\n    format : str, optional\n        The image file format assumed for reading the data. If not\n        given, the format is deduced from the filename.  If nothing can\n        be deduced, PNG is tried.\n\n    Returns\n    -------\n    imagedata : :class:`numpy.array`\n        The image data. The returned array has shape\n\n        - (M, N) for grayscale images.\n        - (M, N, 3) for RGB images.\n        - (M, N, 4) for RGBA images.\n    \"\"\"\n    if format is None:\n        if isinstance(fname, str):\n            parsed = urllib.parse.urlparse(fname)\n            # If the string is a URL (Windows paths appear as if they have a\n            # length-1 scheme), assume png.\n            if len(parsed.scheme) > 1:\n                ext = 'png'\n            else:\n                ext = Path(fname).suffix.lower()[1:]\n        elif hasattr(fname, 'geturl'):  # Returned by urlopen().\n            # We could try to parse the url's path and use the extension, but\n            # returning png is consistent with the block above.  Note that this\n            # if clause has to come before checking for fname.name as\n            # urlopen(\"file:///...\") also has a name attribute (with the fixed\n            # value \"<urllib response>\").\n            ext = 'png'\n        elif hasattr(fname, 'name'):\n            ext = Path(fname.name).suffix.lower()[1:]\n        else:\n            ext = 'png'\n    else:\n        ext = format\n    img_open = (\n        PIL.PngImagePlugin.PngImageFile if ext == 'png' else PIL.Image.open)\n    if isinstance(fname, str):\n        parsed = urllib.parse.urlparse(fname)\n        if len(parsed.scheme) > 1:  # Pillow doesn't handle URLs directly.\n            from urllib import request\n            with urllib.request.urlopen(fname) as response:\n                return imread(response, format=ext)\n    with img_open(fname) as image:\n        return (_pil_png_to_float_array(image)\n                if isinstance(image, PIL.PngImagePlugin.PngImageFile) else\n                pil_to_array(image))",
        "begin_line": 1408,
        "end_line": 1464,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image.imsave#1467",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image",
        "signature": "lib.matplotlib.image.imsave(fname, arr, vmin=None, vmax=None, cmap=None, format=None, origin=None, dpi=100, *, metadata=None, pil_kwargs=None)",
        "snippet": "def imsave(fname, arr, vmin=None, vmax=None, cmap=None, format=None,\n           origin=None, dpi=100, *, metadata=None, pil_kwargs=None):\n    \"\"\"\n    Save an array as an image file.\n\n    Parameters\n    ----------\n    fname : str or PathLike or file-like\n        A path or a file-like object to store the image in.\n        If *format* is not set, then the output format is inferred from the\n        extension of *fname*, if any, and from :rc:`savefig.format` otherwise.\n        If *format* is set, it determines the output format.\n    arr : array-like\n        The image data. The shape can be one of\n        MxN (luminance), MxNx3 (RGB) or MxNx4 (RGBA).\n    vmin, vmax : scalar, optional\n        *vmin* and *vmax* set the color scaling for the image by fixing the\n        values that map to the colormap color limits. If either *vmin*\n        or *vmax* is None, that limit is determined from the *arr*\n        min/max value.\n    cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n        A Colormap instance or registered colormap name. The colormap\n        maps scalar data to colors. It is ignored for RGB(A) data.\n    format : str, optional\n        The file format, e.g. 'png', 'pdf', 'svg', ...  The behavior when this\n        is unset is documented under *fname*.\n    origin : {'upper', 'lower'}, default: :rc:`image.origin`\n        Indicates whether the ``(0, 0)`` index of the array is in the upper\n        left or lower left corner of the axes.\n    dpi : float\n        The DPI to store in the metadata of the file.  This does not affect the\n        resolution of the output image.  Depending on file format, this may be\n        rounded to the nearest integer.\n    metadata : dict, optional\n        Metadata in the image file.  The supported keys depend on the output\n        format, see the documentation of the respective backends for more\n        information.\n    pil_kwargs : dict, optional\n        Keyword arguments passed to `PIL.Image.Image.save`.  If the 'pnginfo'\n        key is present, it completely overrides *metadata*, including the\n        default 'Software' key.\n    \"\"\"\n    from matplotlib.figure import Figure\n    if isinstance(fname, os.PathLike):\n        fname = os.fspath(fname)\n    if format is None:\n        format = (Path(fname).suffix[1:] if isinstance(fname, str)\n                  else mpl.rcParams[\"savefig.format\"]).lower()\n    if format in [\"pdf\", \"ps\", \"eps\", \"svg\"]:\n        # Vector formats that are not handled by PIL.\n        if pil_kwargs is not None:\n            raise ValueError(\n                f\"Cannot use 'pil_kwargs' when saving to {format}\")\n        fig = Figure(dpi=dpi, frameon=False)\n        fig.figimage(arr, cmap=cmap, vmin=vmin, vmax=vmax, origin=origin,\n                     resize=True)\n        fig.savefig(fname, dpi=dpi, format=format, transparent=True,\n                    metadata=metadata)\n    else:\n        # Don't bother creating an image; this avoids rounding errors on the\n        # size when dividing and then multiplying by dpi.\n        sm = cm.ScalarMappable(cmap=cmap)\n        sm.set_clim(vmin, vmax)\n        if origin is None:\n            origin = mpl.rcParams[\"image.origin\"]\n        if origin == \"lower\":\n            arr = arr[::-1]\n        rgba = sm.to_rgba(arr, bytes=True)\n        if pil_kwargs is None:\n            pil_kwargs = {}\n        pil_shape = (rgba.shape[1], rgba.shape[0])\n        image = PIL.Image.frombuffer(\n            \"RGBA\", pil_shape, rgba, \"raw\", \"RGBA\", 0, 1)\n        if format == \"png\" and metadata is not None:\n            # cf. backend_agg's print_png.\n            pnginfo = PIL.PngImagePlugin.PngInfo()\n            for k, v in metadata.items():\n                pnginfo.add_text(k, v)\n            pil_kwargs[\"pnginfo\"] = pnginfo\n        if format in [\"jpg\", \"jpeg\"]:\n            format = \"jpeg\"  # Pillow doesn't recognize \"jpg\".\n            color = tuple(\n                int(x * 255)\n                for x in mcolors.to_rgb(mpl.rcParams[\"savefig.facecolor\"]))\n            background = PIL.Image.new(\"RGB\", pil_shape, color)\n            background.paste(image, image)\n            image = background\n        pil_kwargs.setdefault(\"format\", format)\n        pil_kwargs.setdefault(\"dpi\", (dpi, dpi))\n        image.save(fname, **pil_kwargs)",
        "begin_line": 1467,
        "end_line": 1556,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.image._pil_png_to_float_array#1594",
        "src_path": "lib/matplotlib/image.py",
        "class_name": "lib.matplotlib.image",
        "signature": "lib.matplotlib.image._pil_png_to_float_array(pil_png)",
        "snippet": "def _pil_png_to_float_array(pil_png):\n    \"\"\"Convert a PIL `PNGImageFile` to a 0-1 float array.\"\"\"\n    # Unlike pil_to_array this converts to 0-1 float32s for backcompat with the\n    # old libpng-based loader.\n    # The supported rawmodes are from PIL.PngImagePlugin._MODES.  When\n    # mode == \"RGB(A)\", the 16-bit raw data has already been coarsened to 8-bit\n    # by Pillow.\n    mode = pil_png.mode\n    rawmode = pil_png.png.im_rawmode\n    if rawmode == \"1\":  # Grayscale.\n        return np.asarray(pil_png, np.float32)\n    if rawmode == \"L;2\":  # Grayscale.\n        return np.divide(pil_png, 2**2 - 1, dtype=np.float32)\n    if rawmode == \"L;4\":  # Grayscale.\n        return np.divide(pil_png, 2**4 - 1, dtype=np.float32)\n    if rawmode == \"L\":  # Grayscale.\n        return np.divide(pil_png, 2**8 - 1, dtype=np.float32)\n    if rawmode == \"I;16B\":  # Grayscale.\n        return np.divide(pil_png, 2**16 - 1, dtype=np.float32)\n    if mode == \"RGB\":  # RGB.\n        return np.divide(pil_png, 2**8 - 1, dtype=np.float32)\n    if mode == \"P\":  # Palette.\n        return np.divide(pil_png.convert(\"RGBA\"), 2**8 - 1, dtype=np.float32)\n    if mode == \"LA\":  # Grayscale + alpha.\n        return np.divide(pil_png.convert(\"RGBA\"), 2**8 - 1, dtype=np.float32)\n    if mode == \"RGBA\":  # RGBA.\n        return np.divide(pil_png, 2**8 - 1, dtype=np.float32)\n    raise ValueError(f\"Unknown PIL rawmode: {rawmode}\")",
        "begin_line": 1594,
        "end_line": 1621,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators._cleanup_cm#27",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators",
        "signature": "lib.matplotlib.testing.decorators._cleanup_cm()",
        "snippet": "def _cleanup_cm():\n    orig_units_registry = matplotlib.units.registry.copy()\n    try:\n        with warnings.catch_warnings(), matplotlib.rc_context():\n            yield\n    finally:\n        matplotlib.units.registry.clear()\n        matplotlib.units.registry.update(orig_units_registry)\n        plt.close(\"all\")",
        "begin_line": 27,
        "end_line": 35,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002688172043010753,
            "pseudo_dstar_susp": 0.0196078431372549,
            "pseudo_tarantula_susp": 0.00034164673727365904,
            "pseudo_op2_susp": 0.02702702702702703,
            "pseudo_barinel_susp": 0.00034164673727365904
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators.remove_ticks_and_titles#112",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators",
        "signature": "lib.matplotlib.testing.decorators.remove_ticks_and_titles(figure)",
        "snippet": "def remove_ticks_and_titles(figure):\n    figure.suptitle(\"\")\n    null_formatter = ticker.NullFormatter()\n    for ax in figure.get_axes():\n        ax.set_title(\"\")\n        ax.xaxis.set_major_formatter(null_formatter)\n        ax.xaxis.set_minor_formatter(null_formatter)\n        ax.yaxis.set_major_formatter(null_formatter)\n        ax.yaxis.set_minor_formatter(null_formatter)\n        try:\n            ax.zaxis.set_major_formatter(null_formatter)\n            ax.zaxis.set_minor_formatter(null_formatter)\n        except AttributeError:\n            pass",
        "begin_line": 112,
        "end_line": 125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.72141147401745e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators._raise_on_image_difference#128",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators",
        "signature": "lib.matplotlib.testing.decorators._raise_on_image_difference(expected, actual, tol)",
        "snippet": "def _raise_on_image_difference(expected, actual, tol):\n    __tracebackhide__ = True\n\n    err = compare_images(expected, actual, tol, in_decorator=True)\n    if err:\n        for key in [\"actual\", \"expected\"]:\n            err[key] = os.path.relpath(err[key])\n        raise ImageComparisonFailure(\n            'images not close (RMS %(rms).3f):\\n\\t%(actual)s\\n\\t%(expected)s '\n             % err)",
        "begin_line": 128,
        "end_line": 137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.243752263672582e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators._ImageComparisonBase.__init__#174",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators._ImageComparisonBase",
        "signature": "lib.matplotlib.testing.decorators._ImageComparisonBase.__init__(self, func, tol, remove_text, savefig_kwargs)",
        "snippet": "    def __init__(self, func, tol, remove_text, savefig_kwargs):\n        self.func = func\n        self.baseline_dir, self.result_dir = _image_directories(func)\n        self.tol = tol\n        self.remove_text = remove_text\n        self.savefig_kwargs = savefig_kwargs",
        "begin_line": 174,
        "end_line": 179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.440476190476191e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators._ImageComparisonBase.copy_baseline#181",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators._ImageComparisonBase",
        "signature": "lib.matplotlib.testing.decorators._ImageComparisonBase.copy_baseline(self, baseline, extension)",
        "snippet": "    def copy_baseline(self, baseline, extension):\n        baseline_path = self.baseline_dir / baseline\n        orig_expected_path = baseline_path.with_suffix(f'.{extension}')\n        if extension == 'eps' and not orig_expected_path.exists():\n            orig_expected_path = orig_expected_path.with_suffix('.pdf')\n        expected_fname = make_test_filename(\n            self.result_dir / orig_expected_path.name, 'expected')\n        try:\n            # os.symlink errors if the target already exists.\n            with contextlib.suppress(OSError):\n                os.remove(expected_fname)\n            try:\n                os.symlink(orig_expected_path, expected_fname)\n            except OSError:  # On Windows, symlink *may* be unavailable.\n                shutil.copyfile(orig_expected_path, expected_fname)\n        except OSError as err:\n            raise ImageComparisonFailure(\n                f\"Missing baseline image {expected_fname} because the \"\n                f\"following file cannot be accessed: \"\n                f\"{orig_expected_path}\") from err\n        return expected_fname",
        "begin_line": 181,
        "end_line": 201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.4360499702558e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators._ImageComparisonBase.compare#203",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators._ImageComparisonBase",
        "signature": "lib.matplotlib.testing.decorators._ImageComparisonBase.compare(self, idx, baseline, extension)",
        "snippet": "    def compare(self, idx, baseline, extension):\n        __tracebackhide__ = True\n        fignum = plt.get_fignums()[idx]\n        fig = plt.figure(fignum)\n\n        if self.remove_text:\n            remove_ticks_and_titles(fig)\n\n        actual_path = (self.result_dir / baseline).with_suffix(f'.{extension}')\n        kwargs = self.savefig_kwargs.copy()\n        if extension == 'pdf':\n            kwargs.setdefault('metadata',\n                              {'Creator': None, 'Producer': None,\n                               'CreationDate': None})\n        fig.savefig(actual_path, **kwargs)\n\n        expected_path = self.copy_baseline(baseline, extension)\n        _raise_on_image_difference(expected_path, actual_path, self.tol)",
        "begin_line": 203,
        "end_line": 220,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.500750075007501e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators.decorator#238",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators",
        "signature": "lib.matplotlib.testing.decorators.decorator(func)",
        "snippet": "    def decorator(func):\n        @functools.wraps(func)\n        # Parameter indirection; see docstring above and comment below.\n        @pytest.mark.usefixtures('mpl_image_comparison_parameters')\n        @pytest.mark.parametrize('extension', extensions)\n        @pytest.mark.baseline_images(baseline_images)\n        # END Parameter indirection.\n        @pytest.mark.style(style)\n        @_checked_on_freetype_version(freetype_version)\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            __tracebackhide__ = True\n            img = _ImageComparisonBase(func, tol=tol, remove_text=remove_text,\n                                       savefig_kwargs=savefig_kwargs)\n            matplotlib.testing.set_font_settings_for_testing()\n            func(*args, **kwargs)\n\n            # Parameter indirection:\n            # This is hacked on via the mpl_image_comparison_parameters fixture\n            # so that we don't need to modify the function's real signature for\n            # any parametrization. Modifying the signature is very very tricky\n            # and likely to confuse pytest.\n            baseline_images, extension = func.parameters\n\n            assert len(plt.get_fignums()) == len(baseline_images), (\n                \"Test generated {} images but there are {} baseline images\"\n                .format(len(plt.get_fignums()), len(baseline_images)))\n            for idx, baseline in enumerate(baseline_images):\n                img.compare(idx, baseline, extension)\n\n        return wrapper",
        "begin_line": 238,
        "end_line": 268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators.wrapper#248",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators",
        "signature": "lib.matplotlib.testing.decorators.wrapper(*args, **kwargs)",
        "snippet": "        def wrapper(*args, **kwargs):\n            __tracebackhide__ = True\n            img = _ImageComparisonBase(func, tol=tol, remove_text=remove_text,\n                                       savefig_kwargs=savefig_kwargs)\n            matplotlib.testing.set_font_settings_for_testing()\n            func(*args, **kwargs)\n\n            # Parameter indirection:\n            # This is hacked on via the mpl_image_comparison_parameters fixture\n            # so that we don't need to modify the function's real signature for\n            # any parametrization. Modifying the signature is very very tricky\n            # and likely to confuse pytest.\n            baseline_images, extension = func.parameters\n\n            assert len(plt.get_fignums()) == len(baseline_images), (\n                \"Test generated {} images but there are {} baseline images\"\n                .format(len(plt.get_fignums()), len(baseline_images)))\n            for idx, baseline in enumerate(baseline_images):\n                img.compare(idx, baseline, extension)",
        "begin_line": 248,
        "end_line": 266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators.decorator#388",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators",
        "signature": "lib.matplotlib.testing.decorators.decorator(func)",
        "snippet": "    def decorator(func):\n        import pytest\n\n        _, result_dir = _image_directories(func)\n        old_sig = inspect.signature(func)\n\n        @pytest.mark.parametrize(\"ext\", extensions)\n        def wrapper(*args, **kwargs):\n            ext = kwargs['ext']\n            if 'ext' not in old_sig.parameters:\n                kwargs.pop('ext')\n            request = kwargs['request']\n            if 'request' not in old_sig.parameters:\n                kwargs.pop('request')\n\n            file_name = \"\".join(c for c in request.node.name\n                                if c in ALLOWED_CHARS)\n            try:\n                fig_test = plt.figure(\"test\")\n                fig_ref = plt.figure(\"reference\")\n                func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)\n                test_image_path = result_dir / (file_name + \".\" + ext)\n                ref_image_path = result_dir / (file_name + \"-expected.\" + ext)\n                fig_test.savefig(test_image_path)\n                fig_ref.savefig(ref_image_path)\n                _raise_on_image_difference(\n                    ref_image_path, test_image_path, tol=tol\n                )\n            finally:\n                plt.close(fig_test)\n                plt.close(fig_ref)\n\n        parameters = [\n            param\n            for param in old_sig.parameters.values()\n            if param.name not in {\"fig_test\", \"fig_ref\"}\n        ]\n        if 'ext' not in old_sig.parameters:\n            parameters += [inspect.Parameter(\"ext\", KEYWORD_ONLY)]\n        if 'request' not in old_sig.parameters:\n            parameters += [inspect.Parameter(\"request\", KEYWORD_ONLY)]\n        new_sig = old_sig.replace(parameters=parameters)\n        wrapper.__signature__ = new_sig\n\n        # reach a bit into pytest internals to hoist the marks from\n        # our wrapped function\n        new_marks = getattr(func, \"pytestmark\", []) + wrapper.pytestmark\n        wrapper.pytestmark = new_marks\n\n        return wrapper",
        "begin_line": 388,
        "end_line": 437,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators.wrapper#395",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators",
        "signature": "lib.matplotlib.testing.decorators.wrapper(*args, **kwargs)",
        "snippet": "        def wrapper(*args, **kwargs):\n            ext = kwargs['ext']\n            if 'ext' not in old_sig.parameters:\n                kwargs.pop('ext')\n            request = kwargs['request']\n            if 'request' not in old_sig.parameters:\n                kwargs.pop('request')\n\n            file_name = \"\".join(c for c in request.node.name\n                                if c in ALLOWED_CHARS)\n            try:\n                fig_test = plt.figure(\"test\")\n                fig_ref = plt.figure(\"reference\")\n                func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)\n                test_image_path = result_dir / (file_name + \".\" + ext)\n                ref_image_path = result_dir / (file_name + \"-expected.\" + ext)\n                fig_test.savefig(test_image_path)\n                fig_ref.savefig(ref_image_path)\n                _raise_on_image_difference(\n                    ref_image_path, test_image_path, tol=tol\n                )\n            finally:\n                plt.close(fig_test)\n                plt.close(fig_ref)",
        "begin_line": 395,
        "end_line": 418,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.decorators._image_directories#442",
        "src_path": "lib/matplotlib/testing/decorators.py",
        "class_name": "lib.matplotlib.testing.decorators",
        "signature": "lib.matplotlib.testing.decorators._image_directories(func)",
        "snippet": "def _image_directories(func):\n    \"\"\"\n    Compute the baseline and result image directories for testing *func*.\n\n    For test module ``foo.bar.test_baz``, the baseline directory is at\n    ``foo/bar/baseline_images/test_baz`` and the result directory at\n    ``$(pwd)/result_images/test_baz``.  The result directory is created if it\n    doesn't exist.\n    \"\"\"\n    module_path = Path(sys.modules[func.__module__].__file__)\n    baseline_dir = module_path.parent / \"baseline_images\" / module_path.stem\n    result_dir = Path().resolve() / \"result_images\" / module_path.stem\n    result_dir.mkdir(parents=True, exist_ok=True)\n    return baseline_dir, result_dir",
        "begin_line": 442,
        "end_line": 455,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.86679822397632e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.bbox_artist#43",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox",
        "signature": "lib.matplotlib.offsetbox.bbox_artist(*args, **kwargs)",
        "snippet": "def bbox_artist(*args, **kwargs):\n    if DEBUG:\n        mbbox_artist(*args, **kwargs)",
        "begin_line": 43,
        "end_line": 45,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003134796238244514,
            "pseudo_dstar_susp": 0.0006680026720106881,
            "pseudo_tarantula_susp": 0.00202020202020202,
            "pseudo_op2_susp": 0.0006680026720106881,
            "pseudo_barinel_susp": 0.002
        }
    },
    {
        "name": "lib.matplotlib.offsetbox._get_packed_offsets#52",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox",
        "signature": "lib.matplotlib.offsetbox._get_packed_offsets(wd_list, total, sep, mode='fixed')",
        "snippet": "def _get_packed_offsets(wd_list, total, sep, mode=\"fixed\"):\n    \"\"\"\n    Given a list of (width, xdescent) of each boxes, calculate the\n    total width and the x-offset positions of each items according to\n    *mode*. xdescent is analogous to the usual descent, but along the\n    x-direction. xdescent values are currently ignored.\n\n    For simplicity of the description, the terminology used here assumes a\n    horizontal layout, but the function works equally for a vertical layout.\n\n    There are three packing modes:\n\n    - 'fixed': The elements are packed tight to the left with a spacing of\n      *sep* in between. If *total* is *None* the returned total will be the\n      right edge of the last box. A non-*None* total will be passed unchecked\n      to the output. In particular this means that right edge of the last\n      box may be further to the right than the returned total.\n\n    - 'expand': Distribute the boxes with equal spacing so that the left edge\n      of the first box is at 0, and the right edge of the last box is at\n      *total*. The parameter *sep* is ignored in this mode. A total of *None*\n      is accepted and considered equal to 1. The total is returned unchanged\n      (except for the conversion *None* to 1). If the total is smaller than\n      the sum of the widths, the laid out boxes will overlap.\n\n    - 'equal': If *total* is given, the total space is divided in N equal\n      ranges and each box is left-aligned within its subspace.\n      Otherwise (*total* is *None*), *sep* must be provided and each box is\n      left-aligned in its subspace of width ``(max(widths) + sep)``. The\n      total width is then calculated to be ``N * (max(widths) + sep)``.\n\n    Parameters\n    ----------\n    wd_list : list of (float, float)\n        (width, xdescent) of boxes to be packed.\n    total : float or None\n        Intended total length. *None* if not used.\n    sep : float\n        Spacing between boxes.\n    mode : {'fixed', 'expand', 'equal'}\n        The packing mode.\n\n    Returns\n    -------\n    total : float\n        The total width needed to accommodate the laid out boxes.\n    offsets : array of float\n        The left offsets of the boxes.\n    \"\"\"\n    w_list, d_list = zip(*wd_list)  # d_list is currently not used.\n    cbook._check_in_list([\"fixed\", \"expand\", \"equal\"], mode=mode)\n\n    if mode == \"fixed\":\n        offsets_ = np.cumsum([0] + [w + sep for w in w_list])\n        offsets = offsets_[:-1]\n        if total is None:\n            total = offsets_[-1] - sep\n        return total, offsets\n\n    elif mode == \"expand\":\n        # This is a bit of a hack to avoid a TypeError when *total*\n        # is None and used in conjugation with tight layout.\n        if total is None:\n            total = 1\n        if len(w_list) > 1:\n            sep = (total - sum(w_list)) / (len(w_list) - 1)\n        else:\n            sep = 0\n        offsets_ = np.cumsum([0] + [w + sep for w in w_list])\n        offsets = offsets_[:-1]\n        return total, offsets\n\n    elif mode == \"equal\":\n        maxh = max(w_list)\n        if total is None:\n            if sep is None:\n                raise ValueError(\"total and sep cannot both be None when \"\n                                 \"using layout mode 'equal'\")\n            total = (maxh + sep) * len(w_list)\n        else:\n            sep = total / len(w_list) - maxh\n        offsets = (maxh + sep) * np.arange(len(w_list))\n        return total, offsets",
        "begin_line": 52,
        "end_line": 134,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.016666666666666666,
            "pseudo_dstar_susp": 0.0006825938566552901,
            "pseudo_tarantula_susp": 0.0036496350364963502,
            "pseudo_op2_susp": 0.0006825938566552901,
            "pseudo_barinel_susp": 0.0036496350364963502
        }
    },
    {
        "name": "lib.matplotlib.offsetbox._get_aligned_offsets#137",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox",
        "signature": "lib.matplotlib.offsetbox._get_aligned_offsets(hd_list, height, align='baseline')",
        "snippet": "def _get_aligned_offsets(hd_list, height, align=\"baseline\"):\n    \"\"\"\n    Given a list of (height, descent) of each boxes, align the boxes\n    with *align* and calculate the y-offsets of each boxes.\n    total width and the offset positions of each items according to\n    *mode*. xdescent is analogous to the usual descent, but along the\n    x-direction. xdescent values are currently ignored.\n\n    *hd_list* : list of (width, xdescent) of boxes to be aligned.\n    *sep* : spacing between boxes\n    *height* : Intended total length. None if not used.\n    *align* : align mode. 'baseline', 'top', 'bottom', or 'center'.\n    \"\"\"\n\n    if height is None:\n        height = max(h for h, d in hd_list)\n    cbook._check_in_list(\n        [\"baseline\", \"left\", \"top\", \"right\", \"bottom\", \"center\"], align=align)\n\n    if align == \"baseline\":\n        height_descent = max(h - d for h, d in hd_list)\n        descent = max(d for h, d in hd_list)\n        height = height_descent + descent\n        offsets = [0. for h, d in hd_list]\n    elif align in [\"left\", \"top\"]:\n        descent = 0.\n        offsets = [d for h, d in hd_list]\n    elif align in [\"right\", \"bottom\"]:\n        descent = 0.\n        offsets = [height - h + d for h, d in hd_list]\n    elif align == \"center\":\n        descent = 0.\n        offsets = [(height - h) * .5 + d for h, d in hd_list]\n\n    return height, descent, offsets",
        "begin_line": 137,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.047619047619047616,
            "pseudo_dstar_susp": 0.000757002271006813,
            "pseudo_tarantula_susp": 0.006666666666666667,
            "pseudo_op2_susp": 0.0007564296520423601,
            "pseudo_barinel_susp": 0.006666666666666667
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.OffsetBox.set_figure#195",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.OffsetBox",
        "signature": "lib.matplotlib.offsetbox.OffsetBox.set_figure(self, fig)",
        "snippet": "    def set_figure(self, fig):\n        \"\"\"\n        Set the `.Figure` for the `.OffsetBox` and all its children.\n\n        Parameters\n        ----------\n        fig : `~matplotlib.figure.Figure`\n        \"\"\"\n        martist.Artist.set_figure(self, fig)\n        for c in self.get_children():\n            c.set_figure(fig)",
        "begin_line": 195,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.870916961826053e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.OffsetBox.set_offset#248",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.OffsetBox",
        "signature": "lib.matplotlib.offsetbox.OffsetBox.set_offset(self, xy)",
        "snippet": "    def set_offset(self, xy):\n        \"\"\"\n        Set the offset.\n\n        Parameters\n        ----------\n        xy : (float, float) or callable\n            The (x, y) coordinates of the offset in display units. These can\n            either be given explicitly as a tuple (x, y), or by providing a\n            function that converts the extent into the offset. This function\n            must have the signature::\n\n                def offset(width, height, xdescent, ydescent, renderer) \\\n-> (float, float)\n        \"\"\"\n        self._offset = xy\n        self.stale = True",
        "begin_line": 248,
        "end_line": 264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00044483985765124553,
            "pseudo_dstar_susp": 0.0006578947368421052,
            "pseudo_tarantula_susp": 0.00040225261464199515,
            "pseudo_op2_susp": 0.0006578947368421052,
            "pseudo_barinel_susp": 0.00040225261464199515
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.OffsetBox.get_offset#266",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.OffsetBox",
        "signature": "lib.matplotlib.offsetbox.OffsetBox.get_offset(self, width, height, xdescent, ydescent, renderer)",
        "snippet": "    def get_offset(self, width, height, xdescent, ydescent, renderer):\n        \"\"\"\n        Return the offset as a tuple (x, y).\n\n        The extent parameters have to be provided to handle the case where the\n        offset is dynamically determined by a callable (see\n        `~.OffsetBox.set_offset`).\n\n        Parameters\n        ----------\n        width, height, xdescent, ydescent\n            Extent parameters.\n        renderer : `.RendererBase` subclass\n\n        \"\"\"\n        return (self._offset(width, height, xdescent, ydescent, renderer)\n                if callable(self._offset)\n                else self._offset)",
        "begin_line": 266,
        "end_line": 283,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.OffsetBox.get_children#311",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.OffsetBox",
        "signature": "lib.matplotlib.offsetbox.OffsetBox.get_children(self)",
        "snippet": "    def get_children(self):\n        r\"\"\"Return a list of the child `.Artist`\\s.\"\"\"\n        return self._children",
        "begin_line": 311,
        "end_line": 313,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000708215297450425,
            "pseudo_dstar_susp": 0.0004268032437046522,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0004268032437046522,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.OffsetBox.get_window_extent#339",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.OffsetBox",
        "signature": "lib.matplotlib.offsetbox.OffsetBox.get_window_extent(self, renderer)",
        "snippet": "    def get_window_extent(self, renderer):\n        \"\"\"Return the bounding box (`.Bbox`) in display space.\"\"\"\n        w, h, xd, yd, offsets = self.get_extent_offsets(renderer)\n        px, py = self.get_offset(w, h, xd, yd, renderer)\n        return mtransforms.Bbox.from_bounds(px - xd, py - yd, w, h)",
        "begin_line": 339,
        "end_line": 343,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.OffsetBox.draw#345",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.OffsetBox",
        "signature": "lib.matplotlib.offsetbox.OffsetBox.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        \"\"\"\n        Update the location of children if necessary and draw them\n        to the given *renderer*.\n        \"\"\"\n        width, height, xdescent, ydescent, offsets = self.get_extent_offsets(\n                                                        renderer)\n\n        px, py = self.get_offset(width, height, xdescent, ydescent, renderer)\n\n        for c, (ox, oy) in zip(self.get_visible_children(), offsets):\n            c.set_offset((px + ox, py + oy))\n            c.draw(renderer)\n\n        bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False",
        "begin_line": 345,
        "end_line": 360,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.PackerBase.__init__#364",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.PackerBase",
        "signature": "lib.matplotlib.offsetbox.PackerBase.__init__(self, pad=None, sep=None, width=None, height=None, align=None, mode=None, children=None)",
        "snippet": "    def __init__(self, pad=None, sep=None, width=None, height=None,\n                 align=None, mode=None,\n                 children=None):\n        \"\"\"\n        Parameters\n        ----------\n        pad : float, optional\n            The boundary padding in points.\n\n        sep : float, optional\n            The spacing between items in points.\n\n        width, height : float, optional\n            Width and height of the container box in pixels, calculated if\n            *None*.\n\n        align : {'top', 'bottom', 'left', 'right', 'center', 'baseline'}\n            Alignment of boxes.\n\n        mode : {'fixed', 'expand', 'equal'}\n            The packing mode.\n\n            - 'fixed' packs the given `.Artists` tight with *sep* spacing.\n            - 'expand' uses the maximal available space to distribute the\n              artists with equal spacing in between.\n            - 'equal': Each artist an equal fraction of the available space\n              and is left-aligned (or top-aligned) therein.\n\n        children : list of `.Artist`\n            The artists to pack.\n\n        Notes\n        -----\n        *pad* and *sep* are in points and will be scaled with the renderer\n        dpi, while *width* and *height* are in in pixels.\n        \"\"\"\n        super().__init__()\n\n        self.height = height\n        self.width = width\n        self.sep = sep\n        self.pad = pad\n        self.mode = mode\n        self.align = align\n\n        self._children = children",
        "begin_line": 364,
        "end_line": 409,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.406893652795292e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.VPacker.__init__#417",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.VPacker",
        "signature": "lib.matplotlib.offsetbox.VPacker.__init__(self, pad=None, sep=None, width=None, height=None, align='baseline', mode='fixed', children=None)",
        "snippet": "    def __init__(self, pad=None, sep=None, width=None, height=None,\n                 align=\"baseline\", mode=\"fixed\",\n                 children=None):\n        \"\"\"\n        Parameters\n        ----------\n        pad : float, optional\n            The boundary padding in points.\n\n        sep : float, optional\n            The spacing between items in points.\n\n        width, height : float, optional\n            Width and height of the container box in pixels, calculated if\n            *None*.\n\n        align : {'top', 'bottom', 'left', 'right', 'center', 'baseline'}\n            Alignment of boxes.\n\n        mode : {'fixed', 'expand', 'equal'}\n            The packing mode.\n\n            - 'fixed' packs the given `.Artists` tight with *sep* spacing.\n            - 'expand' uses the maximal available space to distribute the\n              artists with equal spacing in between.\n            - 'equal': Each artist an equal fraction of the available space\n              and is left-aligned (or top-aligned) therein.\n\n        children : list of `.Artist`\n            The artists to pack.\n\n        Notes\n        -----\n        *pad* and *sep* are in points and will be scaled with the renderer\n        dpi, while *width* and *height* are in in pixels.\n        \"\"\"\n        super().__init__(pad, sep, width, height, align, mode, children)",
        "begin_line": 417,
        "end_line": 453,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.252867871585376e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.VPacker.get_extent_offsets#455",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.VPacker",
        "signature": "lib.matplotlib.offsetbox.VPacker.get_extent_offsets(self, renderer)",
        "snippet": "    def get_extent_offsets(self, renderer):\n        # docstring inherited\n        dpicor = renderer.points_to_pixels(1.)\n        pad = self.pad * dpicor\n        sep = self.sep * dpicor\n\n        if self.width is not None:\n            for c in self.get_visible_children():\n                if isinstance(c, PackerBase) and c.mode == \"expand\":\n                    c.set_width(self.width)\n\n        whd_list = [c.get_extent(renderer)\n                    for c in self.get_visible_children()]\n        whd_list = [(w, h, xd, (h - yd)) for w, h, xd, yd in whd_list]\n\n        wd_list = [(w, xd) for w, h, xd, yd in whd_list]\n        width, xdescent, xoffsets = _get_aligned_offsets(wd_list,\n                                                         self.width,\n                                                         self.align)\n\n        pack_list = [(h, yd) for w, h, xd, yd in whd_list]\n        height, yoffsets_ = _get_packed_offsets(pack_list, self.height,\n                                                sep, self.mode)\n\n        yoffsets = yoffsets_ + [yd for w, h, xd, yd in whd_list]\n        ydescent = height - yoffsets[0]\n        yoffsets = height - yoffsets\n\n        yoffsets = yoffsets - ydescent\n\n        return (width + 2 * pad, height + 2 * pad,\n                xdescent + pad, ydescent + pad,\n                list(zip(xoffsets, yoffsets)))",
        "begin_line": 455,
        "end_line": 487,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.HPacker.get_extent_offsets#533",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.HPacker",
        "signature": "lib.matplotlib.offsetbox.HPacker.get_extent_offsets(self, renderer)",
        "snippet": "    def get_extent_offsets(self, renderer):\n        # docstring inherited\n        dpicor = renderer.points_to_pixels(1.)\n        pad = self.pad * dpicor\n        sep = self.sep * dpicor\n\n        whd_list = [c.get_extent(renderer)\n                    for c in self.get_visible_children()]\n\n        if not whd_list:\n            return 2 * pad, 2 * pad, pad, pad, []\n\n        if self.height is None:\n            height_descent = max(h - yd for w, h, xd, yd in whd_list)\n            ydescent = max(yd for w, h, xd, yd in whd_list)\n            height = height_descent + ydescent\n        else:\n            height = self.height - 2 * pad  # width w/o pad\n\n        hd_list = [(h, yd) for w, h, xd, yd in whd_list]\n        height, ydescent, yoffsets = _get_aligned_offsets(hd_list,\n                                                          self.height,\n                                                          self.align)\n\n        pack_list = [(w, xd) for w, h, xd, yd in whd_list]\n\n        width, xoffsets_ = _get_packed_offsets(pack_list, self.width,\n                                               sep, self.mode)\n\n        xoffsets = xoffsets_ + [xd for w, h, xd, yd in whd_list]\n\n        xdescent = whd_list[0][2]\n        xoffsets = xoffsets - xdescent\n\n        return (width + 2 * pad, height + 2 * pad,\n                xdescent + pad, ydescent + pad,\n                list(zip(xoffsets, yoffsets)))",
        "begin_line": 533,
        "end_line": 569,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.DrawingArea.__init__#663",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.DrawingArea",
        "signature": "lib.matplotlib.offsetbox.DrawingArea.__init__(self, width, height, xdescent=0.0, ydescent=0.0, clip=False)",
        "snippet": "    def __init__(self, width, height, xdescent=0.,\n                 ydescent=0., clip=False):\n        \"\"\"\n        Parameters\n        ----------\n        width, height : float\n            Width and height of the container box.\n        xdescent, ydescent : float\n            Descent of the box in x- and y-direction.\n        clip : bool\n            Whether to clip the children to the box.\n        \"\"\"\n        super().__init__()\n        self.width = width\n        self.height = height\n        self.xdescent = xdescent\n        self.ydescent = ydescent\n        self._clip_children = clip\n        self.offset_transform = mtransforms.Affine2D()\n        self.dpi_transform = mtransforms.Affine2D()",
        "begin_line": 663,
        "end_line": 682,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00036656891495601173,
            "pseudo_dstar_susp": 0.0003399048266485384,
            "pseudo_tarantula_susp": 0.0006565988181221273,
            "pseudo_op2_susp": 0.0003399048266485384,
            "pseudo_barinel_susp": 0.0006565988181221273
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.DrawingArea.get_transform#697",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.DrawingArea",
        "signature": "lib.matplotlib.offsetbox.DrawingArea.get_transform(self)",
        "snippet": "    def get_transform(self):\n        \"\"\"\n        Return the `~matplotlib.transforms.Transform` applied to the children.\n        \"\"\"\n        return self.dpi_transform + self.offset_transform",
        "begin_line": 697,
        "end_line": 701,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.DrawingArea.get_extent#733",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.DrawingArea",
        "signature": "lib.matplotlib.offsetbox.DrawingArea.get_extent(self, renderer)",
        "snippet": "    def get_extent(self, renderer):\n        \"\"\"Return width, height, xdescent, ydescent of box.\"\"\"\n        dpi_cor = renderer.points_to_pixels(1.)\n        return (self.width * dpi_cor, self.height * dpi_cor,\n                self.xdescent * dpi_cor, self.ydescent * dpi_cor)",
        "begin_line": 733,
        "end_line": 737,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.DrawingArea.add_artist#739",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.DrawingArea",
        "signature": "lib.matplotlib.offsetbox.DrawingArea.add_artist(self, a)",
        "snippet": "    def add_artist(self, a):\n        \"\"\"Add an `.Artist` to the container box.\"\"\"\n        self._children.append(a)\n        if not a.is_transform_set():\n            a.set_transform(self.get_transform())\n        if self.axes is not None:\n            a.axes = self.axes\n        fig = self.figure\n        if fig is not None:\n            a.set_figure(fig)",
        "begin_line": 739,
        "end_line": 748,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.DrawingArea.draw#750",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.DrawingArea",
        "signature": "lib.matplotlib.offsetbox.DrawingArea.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        # docstring inherited\n\n        dpi_cor = renderer.points_to_pixels(1.)\n        self.dpi_transform.clear()\n        self.dpi_transform.scale(dpi_cor)\n\n        # At this point the DrawingArea has a transform\n        # to the display space so the path created is\n        # good for clipping children\n        tpath = mtransforms.TransformedPath(\n            mpath.Path([[0, 0], [0, self.height],\n                        [self.width, self.height],\n                        [self.width, 0]]),\n            self.get_transform())\n        for c in self._children:\n            if self._clip_children and not (c.clipbox or c._clippath):\n                c.set_clip_path(tpath)\n            c.draw(renderer)\n\n        bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False",
        "begin_line": 750,
        "end_line": 771,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005988023952095808,
            "pseudo_dstar_susp": 0.0004233700254022015,
            "pseudo_tarantula_susp": 0.0024813895781637717,
            "pseudo_op2_susp": 0.0004233700254022015,
            "pseudo_barinel_susp": 0.0024813895781637717
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.TextArea.__init__#781",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.TextArea",
        "signature": "lib.matplotlib.offsetbox.TextArea.__init__(self, s, textprops=None, multilinebaseline=None, minimumdescent=True)",
        "snippet": "    def __init__(self, s,\n                 textprops=None,\n                 multilinebaseline=None,\n                 minimumdescent=True,\n                 ):\n        \"\"\"\n        Parameters\n        ----------\n        s : str\n            The text to be displayed.\n\n        textprops : dict, optional\n            Dictionary of keyword parameters to be passed to the\n            `~matplotlib.text.Text` instance contained inside TextArea.\n\n        multilinebaseline : bool, optional\n            If `True`, baseline for multiline text is adjusted so that it is\n            (approximately) center-aligned with singleline text.\n\n        minimumdescent : bool, optional\n            If `True`, the box has a minimum descent of \"p\".\n        \"\"\"\n        if textprops is None:\n            textprops = {}\n        textprops.setdefault(\"va\", \"baseline\")\n        self._text = mtext.Text(0, 0, s, **textprops)\n        OffsetBox.__init__(self)\n        self._children = [self._text]\n        self.offset_transform = mtransforms.Affine2D()\n        self._baseline_transform = mtransforms.Affine2D()\n        self._text.set_transform(self.offset_transform +\n                                 self._baseline_transform)\n        self._multilinebaseline = multilinebaseline\n        self._minimumdescent = minimumdescent",
        "begin_line": 781,
        "end_line": 814,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.TextArea.set_minimumdescent#841",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.TextArea",
        "signature": "lib.matplotlib.offsetbox.TextArea.set_minimumdescent(self, t)",
        "snippet": "    def set_minimumdescent(self, t):\n        \"\"\"\n        Set minimumdescent.\n\n        If True, extent of the single line text is adjusted so that\n        it has minimum descent of \"p\"\n        \"\"\"\n        self._minimumdescent = t\n        self.stale = True",
        "begin_line": 841,
        "end_line": 849,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.TextArea.set_offset#862",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.TextArea",
        "signature": "lib.matplotlib.offsetbox.TextArea.set_offset(self, xy)",
        "snippet": "    def set_offset(self, xy):\n        \"\"\"\n        Set the offset of the container.\n\n        Parameters\n        ----------\n        xy : (float, float)\n            The (x, y) coordinates of the offset in display units.\n        \"\"\"\n        self._offset = xy\n        self.offset_transform.clear()\n        self.offset_transform.translate(xy[0], xy[1])\n        self.stale = True",
        "begin_line": 862,
        "end_line": 874,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.TextArea.get_extent#886",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.TextArea",
        "signature": "lib.matplotlib.offsetbox.TextArea.get_extent(self, renderer)",
        "snippet": "    def get_extent(self, renderer):\n        _, h_, d_ = renderer.get_text_width_height_descent(\n            \"lp\", self._text._fontproperties, ismath=False)\n\n        bbox, info, d = self._text._get_layout(renderer)\n        w, h = bbox.width, bbox.height\n\n        self._baseline_transform.clear()\n\n        if len(info) > 1 and self._multilinebaseline:\n            d_new = 0.5 * h - 0.5 * (h_ - d_)\n            self._baseline_transform.translate(0, d - d_new)\n            d = d_new\n\n        else:  # single line\n\n            h_d = max(h_ - d_, h - d)\n\n            if self.get_minimumdescent():\n                ## to have a minimum descent, #i.e., \"l\" and \"p\" have same\n                ## descents.\n                d = max(d, d_)\n            #else:\n            #    d = d\n\n            h = h_d + d\n\n        return w, h, 0., d",
        "begin_line": 886,
        "end_line": 913,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.TextArea.draw#915",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.TextArea",
        "signature": "lib.matplotlib.offsetbox.TextArea.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        # docstring inherited\n        self._text.draw(renderer)\n        bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n        self.stale = False",
        "begin_line": 915,
        "end_line": 919,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.__init__#1035",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.__init__(self, loc, pad=0.4, borderpad=0.5, child=None, prop=None, frameon=True, bbox_to_anchor=None, bbox_transform=None, **kwargs)",
        "snippet": "    def __init__(self, loc,\n                 pad=0.4, borderpad=0.5,\n                 child=None, prop=None, frameon=True,\n                 bbox_to_anchor=None,\n                 bbox_transform=None,\n                 **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        loc : str\n            The box location. Supported values:\n\n            - 'upper right'\n            - 'upper left'\n            - 'lower left'\n            - 'lower right'\n            - 'center left'\n            - 'center right'\n            - 'lower center'\n            - 'upper center'\n            - 'center'\n\n            For backward compatibility, numeric values are accepted as well.\n            See the parameter *loc* of `.Legend` for details.\n\n        pad : float, default: 0.4\n            Padding around the child as fraction of the fontsize.\n\n        borderpad : float, default: 0.5\n            Padding between the offsetbox frame and the *bbox_to_anchor*.\n\n        child : `.OffsetBox`\n            The box that will be anchored.\n\n        prop : `.FontProperties`\n            This is only used as a reference for paddings. If not given,\n            :rc:`legend.fontsize` is used.\n\n        frameon : bool\n            Whether to draw a frame around the box.\n\n        bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\n            Box that is used to position the legend in conjunction with *loc*.\n\n        bbox_transform : None or :class:`matplotlib.transforms.Transform`\n            The transform for the bounding box (*bbox_to_anchor*).\n\n        **kwargs\n            All other parameters are passed on to `.OffsetBox`.\n\n        Notes\n        -----\n        See `.Legend` for a detailed description of the anchoring mechanism.\n        \"\"\"\n        super().__init__(**kwargs)\n\n        self.set_bbox_to_anchor(bbox_to_anchor, bbox_transform)\n        self.set_child(child)\n\n        if isinstance(loc, str):\n            loc = cbook._check_getitem(self.codes, loc=loc)\n\n        self.loc = loc\n        self.borderpad = borderpad\n        self.pad = pad\n\n        if prop is None:\n            self.prop = FontProperties(size=rcParams[\"legend.fontsize\"])\n        else:\n            self.prop = FontProperties._from_any(prop)\n            if isinstance(prop, dict) and \"size\" not in prop:\n                self.prop.set_size(rcParams[\"legend.fontsize\"])\n\n        self.patch = FancyBboxPatch(\n            xy=(0.0, 0.0), width=1., height=1.,\n            facecolor='w', edgecolor='k',\n            mutation_scale=self.prop.get_size_in_points(),\n            snap=True\n            )\n        self.patch.set_boxstyle(\"square\", pad=0)\n        self._drawFrame = frameon",
        "begin_line": 1035,
        "end_line": 1115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.set_child#1117",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.set_child(self, child)",
        "snippet": "    def set_child(self, child):\n        \"\"\"Set the child to be anchored.\"\"\"\n        self._child = child\n        if child is not None:\n            child.axes = self.axes\n        self.stale = True",
        "begin_line": 1117,
        "end_line": 1122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_child#1124",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_child(self)",
        "snippet": "    def get_child(self):\n        \"\"\"Return the child.\"\"\"\n        return self._child",
        "begin_line": 1124,
        "end_line": 1126,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_children#1128",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_children(self)",
        "snippet": "    def get_children(self):\n        \"\"\"Return the list of children.\"\"\"\n        return [self._child]",
        "begin_line": 1128,
        "end_line": 1130,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_extent#1132",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_extent(self, renderer)",
        "snippet": "    def get_extent(self, renderer):\n        \"\"\"\n        Return the extent of the box as (width, height, x, y).\n\n        This is the extent of the child plus the padding.\n        \"\"\"\n        w, h, xd, yd = self.get_child().get_extent(renderer)\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        pad = self.pad * fontsize\n\n        return w + 2 * pad, h + 2 * pad, xd + pad, yd + pad",
        "begin_line": 1132,
        "end_line": 1142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_bbox_to_anchor#1144",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_bbox_to_anchor(self)",
        "snippet": "    def get_bbox_to_anchor(self):\n        \"\"\"Return the bbox that the box is anchored to.\"\"\"\n        if self._bbox_to_anchor is None:\n            return self.axes.bbox\n        else:\n            transform = self._bbox_to_anchor_transform\n            if transform is None:\n                return self._bbox_to_anchor\n            else:\n                return TransformedBbox(self._bbox_to_anchor,\n                                       transform)",
        "begin_line": 1144,
        "end_line": 1154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.set_bbox_to_anchor#1156",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.set_bbox_to_anchor(self, bbox, transform=None)",
        "snippet": "    def set_bbox_to_anchor(self, bbox, transform=None):\n        \"\"\"\n        Set the bbox that the box is anchored to.\n\n        *bbox* can be a Bbox instance, a list of [left, bottom, width,\n        height], or a list of [left, bottom] where the width and\n        height will be assumed to be zero. The bbox will be\n        transformed to display coordinate by the given transform.\n        \"\"\"\n        if bbox is None or isinstance(bbox, BboxBase):\n            self._bbox_to_anchor = bbox\n        else:\n            try:\n                l = len(bbox)\n            except TypeError as err:\n                raise ValueError(\"Invalid argument for bbox : %s\" %\n                                 str(bbox)) from err\n\n            if l == 2:\n                bbox = [bbox[0], bbox[1], 0, 0]\n\n            self._bbox_to_anchor = Bbox.from_bounds(*bbox)\n\n        self._bbox_to_anchor_transform = transform\n        self.stale = True",
        "begin_line": 1156,
        "end_line": 1180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_window_extent#1182",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.get_window_extent(self, renderer)",
        "snippet": "    def get_window_extent(self, renderer):\n        \"\"\"Return the bounding box in display space.\"\"\"\n        self._update_offset_func(renderer)\n        w, h, xd, yd = self.get_extent(renderer)\n        ox, oy = self.get_offset(w, h, xd, yd, renderer)\n        return Bbox.from_bounds(ox - xd, oy - yd, w, h)",
        "begin_line": 1182,
        "end_line": 1187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox._update_offset_func#1189",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox._update_offset_func(self, renderer, fontsize=None)",
        "snippet": "    def _update_offset_func(self, renderer, fontsize=None):\n        \"\"\"\n        Update the offset func which depends on the dpi of the\n        renderer (because of the padding).\n        \"\"\"\n        if fontsize is None:\n            fontsize = renderer.points_to_pixels(\n                            self.prop.get_size_in_points())\n\n        def _offset(w, h, xd, yd, renderer, fontsize=fontsize, self=self):\n            bbox = Bbox.from_bounds(0, 0, w, h)\n            borderpad = self.borderpad * fontsize\n            bbox_to_anchor = self.get_bbox_to_anchor()\n\n            x0, y0 = self._get_anchored_bbox(self.loc,\n                                             bbox,\n                                             bbox_to_anchor,\n                                             borderpad)\n            return x0 + xd, y0 + yd\n\n        self.set_offset(_offset)",
        "begin_line": 1189,
        "end_line": 1209,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox._offset#1198",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox._offset(w, h, xd, yd, renderer, fontsize=fontsize, self=self)",
        "snippet": "        def _offset(w, h, xd, yd, renderer, fontsize=fontsize, self=self):\n            bbox = Bbox.from_bounds(0, 0, w, h)\n            borderpad = self.borderpad * fontsize\n            bbox_to_anchor = self.get_bbox_to_anchor()\n\n            x0, y0 = self._get_anchored_bbox(self.loc,\n                                             bbox,\n                                             bbox_to_anchor,\n                                             borderpad)\n            return x0 + xd, y0 + yd",
        "begin_line": 1198,
        "end_line": 1207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.update_frame#1211",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.update_frame(self, bbox, fontsize=None)",
        "snippet": "    def update_frame(self, bbox, fontsize=None):\n        self.patch.set_bounds(bbox.x0, bbox.y0,\n                              bbox.width, bbox.height)\n\n        if fontsize:\n            self.patch.set_mutation_scale(fontsize)",
        "begin_line": 1211,
        "end_line": 1216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox.draw#1218",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        # docstring inherited\n\n        if not self.get_visible():\n            return\n\n        fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())\n        self._update_offset_func(renderer, fontsize)\n\n        if self._drawFrame:\n            # update the location and size of the legend\n            bbox = self.get_window_extent(renderer)\n            self.update_frame(bbox, fontsize)\n            self.patch.draw(renderer)\n\n        width, height, xdescent, ydescent = self.get_extent(renderer)\n\n        px, py = self.get_offset(width, height, xdescent, ydescent, renderer)\n\n        self.get_child().set_offset((px, py))\n        self.get_child().draw(renderer)\n        self.stale = False",
        "begin_line": 1218,
        "end_line": 1239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.AnchoredOffsetbox._get_anchored_bbox#1241",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.AnchoredOffsetbox",
        "signature": "lib.matplotlib.offsetbox.AnchoredOffsetbox._get_anchored_bbox(self, loc, bbox, parentbbox, borderpad)",
        "snippet": "    def _get_anchored_bbox(self, loc, bbox, parentbbox, borderpad):\n        \"\"\"\n        Return the position of the bbox anchored at the parentbbox\n        with the loc code, with the borderpad.\n        \"\"\"\n        assert loc in range(1, 11)  # called only internally\n\n        BEST, UR, UL, LL, LR, R, CL, CR, LC, UC, C = range(11)\n\n        anchor_coefs = {UR: \"NE\",\n                        UL: \"NW\",\n                        LL: \"SW\",\n                        LR: \"SE\",\n                        R: \"E\",\n                        CL: \"W\",\n                        CR: \"E\",\n                        LC: \"S\",\n                        UC: \"N\",\n                        C: \"C\"}\n\n        c = anchor_coefs[loc]\n\n        container = parentbbox.padded(-borderpad)\n        anchored_box = bbox.anchored(c, container=container)\n        return anchored_box.x0, anchored_box.y0",
        "begin_line": 1241,
        "end_line": 1265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.DraggableBase.__init__#1708",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.DraggableBase",
        "signature": "lib.matplotlib.offsetbox.DraggableBase.__init__(self, ref_artist, use_blit=False)",
        "snippet": "    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        self.got_artist = False\n\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n\n        c2 = self.canvas.mpl_connect('pick_event', self.on_pick)\n        c3 = self.canvas.mpl_connect('button_release_event', self.on_release)\n\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        with cbook._suppress_matplotlib_deprecation_warning():\n            if self.artist_picker != DraggableBase.artist_picker.__get__(self):\n                overridden_picker = self.artist_picker\n            else:\n                overridden_picker = None\n        if overridden_picker is not None:\n            cbook.warn_deprecated(\n                \"3.3\", name=\"artist_picker\", obj_type=\"method\",\n                addendum=\"Directly set the artist's picker if desired.\")\n            ref_artist.set_picker(overridden_picker)\n        self.cids = [c2, c3]",
        "begin_line": 1708,
        "end_line": 1730,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.DraggableBase.disconnect#1786",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.DraggableBase",
        "signature": "lib.matplotlib.offsetbox.DraggableBase.disconnect(self)",
        "snippet": "    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)",
        "begin_line": 1786,
        "end_line": 1795,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.offsetbox.DraggableOffsetBox.__init__#1812",
        "src_path": "lib/matplotlib/offsetbox.py",
        "class_name": "lib.matplotlib.offsetbox.DraggableOffsetBox",
        "signature": "lib.matplotlib.offsetbox.DraggableOffsetBox.__init__(self, ref_artist, offsetbox, use_blit=False)",
        "snippet": "    def __init__(self, ref_artist, offsetbox, use_blit=False):\n        DraggableBase.__init__(self, ref_artist, use_blit=use_blit)\n        self.offsetbox = offsetbox",
        "begin_line": 1812,
        "end_line": 1814,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.get_named_colors_mapping#109",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors.get_named_colors_mapping()",
        "snippet": "def get_named_colors_mapping():\n    \"\"\"Return the global mapping of names to named colors.\"\"\"\n    return _colors_full_map",
        "begin_line": 109,
        "end_line": 111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.46880030300161e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors._sanitize_extrema#114",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors._sanitize_extrema(ex)",
        "snippet": "def _sanitize_extrema(ex):\n    if ex is None:\n        return ex\n    try:\n        ret = ex.item()\n    except AttributeError:\n        ret = float(ex)\n    return ret",
        "begin_line": 114,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00046425255338904364,
            "pseudo_dstar_susp": 0.0007604562737642585,
            "pseudo_tarantula_susp": 0.0008077544426494346,
            "pseudo_op2_susp": 0.0007604562737642585,
            "pseudo_barinel_susp": 0.0008077544426494346
        }
    },
    {
        "name": "lib.matplotlib.colors._is_nth_color#124",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors._is_nth_color(c)",
        "snippet": "def _is_nth_color(c):\n    \"\"\"Return whether *c* can be interpreted as an item in the color cycle.\"\"\"\n    return isinstance(c, str) and re.match(r\"\\AC[0-9]+\\Z\", c)",
        "begin_line": 124,
        "end_line": 126,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017271157167530224,
            "pseudo_dstar_susp": 0.00909090909090909,
            "pseudo_tarantula_susp": 0.0003448275862068965,
            "pseudo_op2_susp": 0.009345794392523364,
            "pseudo_barinel_susp": 0.0003448275862068965
        }
    },
    {
        "name": "lib.matplotlib.colors.is_color_like#129",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors.is_color_like(c)",
        "snippet": "def is_color_like(c):\n    \"\"\"Return whether *c* can be interpreted as an RGB(A) color.\"\"\"\n    # Special-case nth color syntax because it cannot be parsed during setup.\n    if _is_nth_color(c):\n        return True\n    try:\n        to_rgba(c)\n    except ValueError:\n        return False\n    else:\n        return True",
        "begin_line": 129,
        "end_line": 139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0040650406504065045,
            "pseudo_dstar_susp": 0.058823529411764705,
            "pseudo_tarantula_susp": 0.00035075412136092597,
            "pseudo_op2_susp": 0.1,
            "pseudo_barinel_susp": 0.00035075412136092597
        }
    },
    {
        "name": "lib.matplotlib.colors.to_rgba#147",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors.to_rgba(c, alpha=None)",
        "snippet": "def to_rgba(c, alpha=None):\n    \"\"\"\n    Convert *c* to an RGBA color.\n\n    Parameters\n    ----------\n    c : Matplotlib color or ``np.ma.masked``\n\n    alpha : float, optional\n        If *alpha* is not ``None``, it forces the alpha value, except if *c* is\n        ``\"none\"`` (case-insensitive), which always maps to ``(0, 0, 0, 0)``.\n\n    Returns\n    -------\n    tuple\n        Tuple of ``(r, g, b, a)`` scalars.\n    \"\"\"\n    # Special-case nth color syntax because it should not be cached.\n    if _is_nth_color(c):\n        from matplotlib import rcParams\n        prop_cycler = rcParams['axes.prop_cycle']\n        colors = prop_cycler.by_key().get('color', ['k'])\n        c = colors[int(c[1:]) % len(colors)]\n    try:\n        rgba = _colors_full_map.cache[c, alpha]\n    except (KeyError, TypeError):  # Not in cache, or unhashable.\n        rgba = None\n    if rgba is None:  # Suppress exception chaining of cache lookup failure.\n        rgba = _to_rgba_no_colorcycle(c, alpha)\n        try:\n            _colors_full_map.cache[c, alpha] = rgba\n        except TypeError:\n            pass\n    return rgba",
        "begin_line": 147,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.06666666666666667,
            "pseudo_dstar_susp": 0.045454545454545456,
            "pseudo_tarantula_susp": 0.0009689922480620155,
            "pseudo_op2_susp": 0.037037037037037035,
            "pseudo_barinel_susp": 0.0009689922480620155
        }
    },
    {
        "name": "lib.matplotlib.colors._to_rgba_no_colorcycle#183",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors._to_rgba_no_colorcycle(c, alpha=None)",
        "snippet": "def _to_rgba_no_colorcycle(c, alpha=None):\n    \"\"\"\n    Convert *c* to an RGBA color, with no support for color-cycle syntax.\n\n    If *alpha* is not ``None``, it forces the alpha value, except if *c* is\n    ``\"none\"`` (case-insensitive), which always maps to ``(0, 0, 0, 0)``.\n    \"\"\"\n    orig_c = c\n    if c is np.ma.masked:\n        return (0., 0., 0., 0.)\n    if isinstance(c, str):\n        if c.lower() == \"none\":\n            return (0., 0., 0., 0.)\n        # Named color.\n        try:\n            # This may turn c into a non-string, so we check again below.\n            c = _colors_full_map[c]\n        except KeyError:\n            try:\n                c = _colors_full_map[c.lower()]\n            except KeyError:\n                pass\n            else:\n                if len(orig_c) == 1:\n                    cbook.warn_deprecated(\n                        \"3.1\", message=\"Support for uppercase \"\n                        \"single-letter colors is deprecated since Matplotlib \"\n                        \"%(since)s and will be removed %(removal)s; please \"\n                        \"use lowercase instead.\")\n    if isinstance(c, str):\n        # hex color in #rrggbb format.\n        match = re.match(r\"\\A#[a-fA-F0-9]{6}\\Z\", c)\n        if match:\n            return (tuple(int(n, 16) / 255\n                          for n in [c[1:3], c[3:5], c[5:7]])\n                    + (alpha if alpha is not None else 1.,))\n        # hex color in #rgb format, shorthand for #rrggbb.\n        match = re.match(r\"\\A#[a-fA-F0-9]{3}\\Z\", c)\n        if match:\n            return (tuple(int(n, 16) / 255\n                          for n in [c[1]*2, c[2]*2, c[3]*2])\n                    + (alpha if alpha is not None else 1.,))\n        # hex color with alpha in #rrggbbaa format.\n        match = re.match(r\"\\A#[a-fA-F0-9]{8}\\Z\", c)\n        if match:\n            color = [int(n, 16) / 255\n                     for n in [c[1:3], c[3:5], c[5:7], c[7:9]]]\n            if alpha is not None:\n                color[-1] = alpha\n            return tuple(color)\n        # hex color with alpha in #rgba format, shorthand for #rrggbbaa.\n        match = re.match(r\"\\A#[a-fA-F0-9]{4}\\Z\", c)\n        if match:\n            color = [int(n, 16) / 255\n                     for n in [c[1]*2, c[2]*2, c[3]*2, c[4]*2]]\n            if alpha is not None:\n                color[-1] = alpha\n            return tuple(color)\n        # string gray.\n        try:\n            c = float(c)\n        except ValueError:\n            pass\n        else:\n            if not (0 <= c <= 1):\n                raise ValueError(\n                    f\"Invalid string grayscale value {orig_c!r}. \"\n                    f\"Value must be within 0-1 range\")\n            return c, c, c, alpha if alpha is not None else 1.\n        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n    # tuple color.\n    if not np.iterable(c):\n        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n    if len(c) not in [3, 4]:\n        raise ValueError(\"RGBA sequence should have length 3 or 4\")\n    if not all(isinstance(x, Number) for x in c):\n        # Checks that don't work: `map(float, ...)`, `np.array(..., float)` and\n        # `np.array(...).astype(float)` would all convert \"0.5\" to 0.5.\n        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n    # Return a tuple to prevent the cached value from being modified.\n    c = tuple(map(float, c))\n    if len(c) == 3 and alpha is None:\n        alpha = 1\n    if alpha is not None:\n        c = c[:3] + (alpha,)\n    if any(elem < 0 or elem > 1 for elem in c):\n        raise ValueError(\"RGBA values should be within 0-1 range\")\n    return c",
        "begin_line": 183,
        "end_line": 270,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003215434083601286,
            "pseudo_dstar_susp": 0.004672897196261682,
            "pseudo_tarantula_susp": 0.0027397260273972603,
            "pseudo_op2_susp": 0.004629629629629629,
            "pseudo_barinel_susp": 0.0027397260273972603
        }
    },
    {
        "name": "lib.matplotlib.colors.to_rgba_array#273",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors.to_rgba_array(c, alpha=None)",
        "snippet": "def to_rgba_array(c, alpha=None):\n    \"\"\"\n    Convert *c* to a (n, 4) array of RGBA colors.\n\n    If *alpha* is not ``None``, it forces the alpha value.  If *c* is\n    ``\"none\"`` (case-insensitive) or an empty list, an empty array is returned.\n    If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)\n    row for each masked value or row in *c*.\n    \"\"\"\n    # Special-case inputs that are already arrays, for performance.  (If the\n    # array has the wrong kind or shape, raise the error during one-at-a-time\n    # conversion.)\n    if (isinstance(c, np.ndarray) and c.dtype.kind in \"if\"\n            and c.ndim == 2 and c.shape[1] in [3, 4]):\n        mask = c.mask.any(axis=1) if np.ma.is_masked(c) else None\n        c = np.ma.getdata(c)\n        if c.shape[1] == 3:\n            result = np.column_stack([c, np.zeros(len(c))])\n            result[:, -1] = alpha if alpha is not None else 1.\n        elif c.shape[1] == 4:\n            result = c.copy()\n            if alpha is not None:\n                result[:, -1] = alpha\n        if mask is not None:\n            result[mask] = 0\n        if np.any((result < 0) | (result > 1)):\n            raise ValueError(\"RGBA values should be within 0-1 range\")\n        return result\n    # Handle single values.\n    # Note that this occurs *after* handling inputs that are already arrays, as\n    # `to_rgba(c, alpha)` (below) is expensive for such inputs, due to the need\n    # to format the array in the ValueError message(!).\n    if cbook._str_lower_equal(c, \"none\"):\n        return np.zeros((0, 4), float)\n    try:\n        return np.array([to_rgba(c, alpha)], float)\n    except (ValueError, TypeError):\n        pass\n\n    # Convert one at a time.\n    if isinstance(c, str):\n        # Single string as color sequence.\n        # This is deprecated and will be removed in the future.\n        try:\n            result = np.array([to_rgba(cc, alpha) for cc in c])\n        except ValueError as err:\n            raise ValueError(\n                \"'%s' is neither a valid single color nor a color sequence \"\n                \"consisting of single character color specifiers such as \"\n                \"'rgb'. Note also that the latter is deprecated.\" % c) from err\n        else:\n            cbook.warn_deprecated(\"3.2\", message=\"Using a string of single \"\n                                  \"character colors as a color sequence is \"\n                                  \"deprecated. Use an explicit list instead.\")\n            return result\n\n    if len(c) == 0:\n        return np.zeros((0, 4), float)\n    else:\n        return np.array([to_rgba(cc, alpha) for cc in c])",
        "begin_line": 273,
        "end_line": 332,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005431830526887561,
            "pseudo_dstar_susp": 0.0006246096189881324,
            "pseudo_tarantula_susp": 0.0021645021645021645,
            "pseudo_op2_susp": 0.0006246096189881324,
            "pseudo_barinel_susp": 0.0021645021645021645
        }
    },
    {
        "name": "lib.matplotlib.colors.to_hex#340",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors.to_hex(c, keep_alpha=False)",
        "snippet": "def to_hex(c, keep_alpha=False):\n    \"\"\"\n    Convert *c* to a hex color.\n\n    Uses the ``#rrggbb`` format if *keep_alpha* is False (the default),\n    ``#rrggbbaa`` otherwise.\n    \"\"\"\n    c = to_rgba(c)\n    if not keep_alpha:\n        c = c[:3]\n    return \"#\" + \"\".join(format(int(round(val * 255)), \"02x\") for val in c)",
        "begin_line": 340,
        "end_line": 350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.colors._create_lookup_table#381",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors._create_lookup_table(N, data, gamma=1.0)",
        "snippet": "def _create_lookup_table(N, data, gamma=1.0):\n    r\"\"\"\n    Create an *N* -element 1-d lookup table.\n\n    This assumes a mapping :math:`f : [0, 1] \\rightarrow [0, 1]`. The returned\n    data is an array of N values :math:`y = f(x)` where x is sampled from\n    [0, 1].\n\n    By default (*gamma* = 1) x is equidistantly sampled from [0, 1]. The\n    *gamma* correction factor :math:`\\gamma` distorts this equidistant\n    sampling by :math:`x \\rightarrow x^\\gamma`.\n\n    Parameters\n    ----------\n    N : int\n        The number of elements of the created lookup table.\n        This must be N >= 1.\n    data : Mx3 array-like or callable\n        Defines the mapping :math:`f`.\n\n        If a Mx3 array-like, the rows define values (x, y0, y1). The x values\n        must start with x=0, end with x=1, and all x values be in increasing\n        order.\n\n        A value between :math:`x_i` and :math:`x_{i+1}` is mapped to the range\n        :math:`y^1_{i-1} \\ldots y^0_i` by linear interpolation.\n\n        For the simple case of a y-continuous mapping, y0 and y1 are identical.\n\n        The two values of y are to allow for discontinuous mapping functions.\n        E.g. a sawtooth with a period of 0.2 and an amplitude of 1 would be::\n\n            [(0, 1, 0), (0.2, 1, 0), (0.4, 1, 0), ..., [(1, 1, 0)]\n\n        In the special case of ``N == 1``, by convention the returned value\n        is y0 for x == 1.\n\n        If *data* is a callable, it must accept and return numpy arrays::\n\n           data(x : ndarray) -> ndarray\n\n        and map values between 0 - 1 to 0 - 1.\n    gamma : float\n        Gamma correction factor for input distribution x of the mapping.\n\n        See also https://en.wikipedia.org/wiki/Gamma_correction.\n\n    Returns\n    -------\n    lut : array\n        The lookup table where ``lut[x * (N-1)]`` gives the closest value\n        for values of x between 0 and 1.\n\n    Notes\n    -----\n    This function is internally used for `.LinearSegmentedColormap`.\n    \"\"\"\n\n    if callable(data):\n        xind = np.linspace(0, 1, N) ** gamma\n        lut = np.clip(np.array(data(xind), dtype=float), 0, 1)\n        return lut\n\n    try:\n        adata = np.array(data)\n    except Exception as err:\n        raise TypeError(\"data must be convertible to an array\") from err\n    shape = adata.shape\n    if len(shape) != 2 or shape[1] != 3:\n        raise ValueError(\"data must be nx3 format\")\n\n    x = adata[:, 0]\n    y0 = adata[:, 1]\n    y1 = adata[:, 2]\n\n    if x[0] != 0. or x[-1] != 1.0:\n        raise ValueError(\n            \"data mapping points must start with x=0 and end with x=1\")\n    if (np.diff(x) < 0).any():\n        raise ValueError(\"data mapping points must have x in increasing order\")\n    # begin generation of lookup table\n    if N == 1:\n        # convention: use the y = f(x=1) value for a 1-element lookup table\n        lut = np.array(y0[-1])\n    else:\n        x = x * (N - 1)\n        xind = (N - 1) * np.linspace(0, 1, N) ** gamma\n        ind = np.searchsorted(x, xind)[1:-1]\n\n        distance = (xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])\n        lut = np.concatenate([\n            [y1[0]],\n            distance * (y0[ind] - y1[ind - 1]) + y1[ind - 1],\n            [y0[-1]],\n        ])\n    # ensure that the lut is confined to values between 0 and 1 by clipping it\n    return np.clip(lut, 0.0, 1.0)",
        "begin_line": 381,
        "end_line": 477,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.Colormap.__init__#499",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Colormap",
        "signature": "lib.matplotlib.colors.Colormap.__init__(self, name, N=256)",
        "snippet": "    def __init__(self, name, N=256):\n        \"\"\"\n        Parameters\n        ----------\n        name : str\n            The name of the colormap.\n        N : int\n            The number of rgb quantization levels.\n\n        \"\"\"\n        self.name = name\n        self.N = int(N)  # ensure that N is always int\n        self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n        self._rgba_under = None\n        self._rgba_over = None\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n        self._isinit = False\n\n        #: When this colormap exists on a scalar mappable and colorbar_extend\n        #: is not False, colorbar creation will pick up ``colorbar_extend`` as\n        #: the default value for the ``extend`` keyword in the\n        #: :class:`matplotlib.colorbar.Colorbar` constructor.\n        self.colorbar_extend = False",
        "begin_line": 499,
        "end_line": 523,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.Colormap.__call__#525",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Colormap",
        "signature": "lib.matplotlib.colors.Colormap.__call__(self, X, alpha=None, bytes=False)",
        "snippet": "    def __call__(self, X, alpha=None, bytes=False):\n        \"\"\"\n        Parameters\n        ----------\n        X : float, ndarray\n            The data value(s) to convert to RGBA.\n            For floats, X should be in the interval ``[0.0, 1.0]`` to\n            return the RGBA values ``X*100`` percent along the Colormap line.\n            For integers, X should be in the interval ``[0, Colormap.N)`` to\n            return RGBA values *indexed* from the Colormap with index ``X``.\n        alpha : float, None\n            Alpha must be a scalar between 0 and 1, or None.\n        bytes : bool\n            If False (default), the returned RGBA values will be floats in the\n            interval ``[0, 1]`` otherwise they will be uint8s in the interval\n            ``[0, 255]``.\n\n        Returns\n        -------\n        Tuple of RGBA values if X is scalar, otherwise an array of\n        RGBA values with a shape of ``X.shape + (4, )``.\n        \"\"\"\n        if not self._isinit:\n            self._init()\n\n        mask_bad = X.mask if np.ma.is_masked(X) else np.isnan(X)  # Mask nan's.\n        xa = np.array(X, copy=True)\n        if not xa.dtype.isnative:\n            xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n\n        if bytes:\n            lut = (self._lut * 255).astype(np.uint8)\n        else:\n            lut = self._lut.copy()  # Don't let alpha modify original _lut.\n\n        if alpha is not None:\n            alpha = np.clip(alpha, 0, 1)\n            if bytes:\n                alpha = int(alpha * 255)\n            if (lut[-1] == 0).all():\n                lut[:-1, -1] = alpha\n                # All zeros is taken as a flag for the default bad\n                # color, which is no color--fully transparent.  We\n                # don't want to override this.\n            else:\n                lut[:, -1] = alpha\n                # If the bad value is set to have a color, then we\n                # override its alpha just as for any other value.\n\n        rgba = lut[xa]\n        if not np.iterable(X):\n            # Return a tuple if the input was a scalar\n            rgba = tuple(rgba)\n        return rgba",
        "begin_line": 525,
        "end_line": 594,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005431830526887561,
            "pseudo_dstar_susp": 0.0004170141784820684,
            "pseudo_tarantula_susp": 0.0021645021645021645,
            "pseudo_op2_susp": 0.0004170141784820684,
            "pseudo_barinel_susp": 0.0021645021645021645
        }
    },
    {
        "name": "lib.matplotlib.colors.Colormap.__copy__#596",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Colormap",
        "signature": "lib.matplotlib.colors.Colormap.__copy__(self)",
        "snippet": "    def __copy__(self):\n        cls = self.__class__\n        cmapobject = cls.__new__(cls)\n        cmapobject.__dict__.update(self.__dict__)\n        if self._isinit:\n            cmapobject._lut = np.copy(self._lut)\n        return cmapobject",
        "begin_line": 596,
        "end_line": 602,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.Colormap.set_bad#604",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Colormap",
        "signature": "lib.matplotlib.colors.Colormap.set_bad(self, color='k', alpha=None)",
        "snippet": "    def set_bad(self, color='k', alpha=None):\n        \"\"\"Set the color for masked values.\"\"\"\n        self._rgba_bad = to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()",
        "begin_line": 604,
        "end_line": 608,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.Colormap._set_extremes#626",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Colormap",
        "signature": "lib.matplotlib.colors.Colormap._set_extremes(self)",
        "snippet": "    def _set_extremes(self):\n        if self._rgba_under:\n            self._lut[self._i_under] = self._rgba_under\n        else:\n            self._lut[self._i_under] = self._lut[0]\n        if self._rgba_over:\n            self._lut[self._i_over] = self._rgba_over\n        else:\n            self._lut[self._i_over] = self._lut[self.N - 1]\n        self._lut[self._i_bad] = self._rgba_bad",
        "begin_line": 626,
        "end_line": 635,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LinearSegmentedColormap.__init__#680",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LinearSegmentedColormap",
        "signature": "lib.matplotlib.colors.LinearSegmentedColormap.__init__(self, name, segmentdata, N=256, gamma=1.0)",
        "snippet": "    def __init__(self, name, segmentdata, N=256, gamma=1.0):\n        \"\"\"\n        Create color map from linear mapping segments\n\n        segmentdata argument is a dictionary with a red, green and blue\n        entries. Each entry should be a list of *x*, *y0*, *y1* tuples,\n        forming rows in a table. Entries for alpha are optional.\n\n        Example: suppose you want red to increase from 0 to 1 over\n        the bottom half, green to do the same over the middle half,\n        and blue over the top half.  Then you would use::\n\n            cdict = {'red':   [(0.0,  0.0, 0.0),\n                               (0.5,  1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'green': [(0.0,  0.0, 0.0),\n                               (0.25, 0.0, 0.0),\n                               (0.75, 1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     'blue':  [(0.0,  0.0, 0.0),\n                               (0.5,  0.0, 0.0),\n                               (1.0,  1.0, 1.0)]}\n\n        Each row in the table for a given color is a sequence of\n        *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase\n        monotonically from 0 to 1.  For any input value *z* falling\n        between *x[i]* and *x[i+1]*, the output value of a given color\n        will be linearly interpolated between *y1[i]* and *y0[i+1]*::\n\n            row i:   x  y0  y1\n                           /\n                          /\n            row i+1: x  y0  y1\n\n        Hence y0 in the first row and y1 in the last row are never used.\n\n        See Also\n        --------\n        LinearSegmentedColormap.from_list\n            Static method; factory function for generating a smoothly-varying\n            LinearSegmentedColormap.\n\n        makeMappingArray\n            For information about making a mapping array.\n        \"\"\"\n        # True only if all colors in map are identical; needed for contouring.\n        self.monochrome = False\n        Colormap.__init__(self, name, N)\n        self._segmentdata = segmentdata\n        self._gamma = gamma",
        "begin_line": 680,
        "end_line": 731,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.748334108166744e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LinearSegmentedColormap._init#733",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LinearSegmentedColormap",
        "signature": "lib.matplotlib.colors.LinearSegmentedColormap._init(self)",
        "snippet": "    def _init(self):\n        self._lut = np.ones((self.N + 3, 4), float)\n        self._lut[:-3, 0] = _create_lookup_table(\n            self.N, self._segmentdata['red'], self._gamma)\n        self._lut[:-3, 1] = _create_lookup_table(\n            self.N, self._segmentdata['green'], self._gamma)\n        self._lut[:-3, 2] = _create_lookup_table(\n            self.N, self._segmentdata['blue'], self._gamma)\n        if 'alpha' in self._segmentdata:\n            self._lut[:-3, 3] = _create_lookup_table(\n                self.N, self._segmentdata['alpha'], 1)\n        self._isinit = True\n        self._set_extremes()",
        "begin_line": 733,
        "end_line": 745,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LinearSegmentedColormap.from_list#753",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LinearSegmentedColormap",
        "signature": "lib.matplotlib.colors.LinearSegmentedColormap.from_list(name, colors, N=256, gamma=1.0)",
        "snippet": "    def from_list(name, colors, N=256, gamma=1.0):\n        \"\"\"\n        Create a `LinearSegmentedColormap` from a list of colors.\n\n        Parameters\n        ----------\n        name : str\n            The name of the colormap.\n        colors : array-like of colors or array-like of (value, color)\n            If only colors are given, they are equidistantly mapped from the\n            range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to\n            ``colors[-1]``.\n            If (value, color) pairs are given, the mapping is from *value*\n            to *color*. This can be used to divide the range unevenly.\n        N : int\n            The number of rgb quantization levels.\n        gamma : float\n        \"\"\"\n        if not np.iterable(colors):\n            raise ValueError('colors must be iterable')\n\n        if (isinstance(colors[0], Sized) and len(colors[0]) == 2\n                and not isinstance(colors[0], str)):\n            # List of value, color pairs\n            vals, colors = zip(*colors)\n        else:\n            vals = np.linspace(0, 1, len(colors))\n\n        cdict = dict(red=[], green=[], blue=[], alpha=[])\n        for val, color in zip(vals, colors):\n            r, g, b, a = to_rgba(color)\n            cdict['red'].append((val, r, r))\n            cdict['green'].append((val, g, g))\n            cdict['blue'].append((val, b, b))\n            cdict['alpha'].append((val, a, a))\n\n        return LinearSegmentedColormap(name, cdict, N, gamma)",
        "begin_line": 753,
        "end_line": 789,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LinearSegmentedColormap._resample#791",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LinearSegmentedColormap",
        "signature": "lib.matplotlib.colors.LinearSegmentedColormap._resample(self, lutsize)",
        "snippet": "    def _resample(self, lutsize):\n        \"\"\"Return a new color map with *lutsize* entries.\"\"\"\n        return LinearSegmentedColormap(self.name, self._segmentdata, lutsize)",
        "begin_line": 791,
        "end_line": 793,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.ListedColormap.__init__#855",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.ListedColormap",
        "signature": "lib.matplotlib.colors.ListedColormap.__init__(self, colors, name='from_list', N=None)",
        "snippet": "    def __init__(self, colors, name='from_list', N=None):\n        self.monochrome = False  # Are all colors identical? (for contour.py)\n        if N is None:\n            self.colors = colors\n            N = len(colors)\n        else:\n            if isinstance(colors, str):\n                self.colors = [colors] * N\n                self.monochrome = True\n            elif np.iterable(colors):\n                if len(colors) == 1:\n                    self.monochrome = True\n                self.colors = list(\n                    itertools.islice(itertools.cycle(colors), N))\n            else:\n                try:\n                    gray = float(colors)\n                except TypeError:\n                    pass\n                else:\n                    self.colors = [gray] * N\n                self.monochrome = True\n        Colormap.__init__(self, name, N)",
        "begin_line": 855,
        "end_line": 877,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.ListedColormap._init#879",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.ListedColormap",
        "signature": "lib.matplotlib.colors.ListedColormap._init(self)",
        "snippet": "    def _init(self):\n        self._lut = np.zeros((self.N + 3, 4), float)\n        self._lut[:-3] = to_rgba_array(self.colors)\n        self._isinit = True\n        self._set_extremes()",
        "begin_line": 879,
        "end_line": 883,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.ListedColormap._resample#885",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.ListedColormap",
        "signature": "lib.matplotlib.colors.ListedColormap._resample(self, lutsize)",
        "snippet": "    def _resample(self, lutsize):\n        \"\"\"Return a new color map with *lutsize* entries.\"\"\"\n        colors = self(np.linspace(0, 1, lutsize))\n        return ListedColormap(colors, name=self.name)",
        "begin_line": 885,
        "end_line": 888,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.Normalize.__init__#918",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Normalize",
        "signature": "lib.matplotlib.colors.Normalize.__init__(self, vmin=None, vmax=None, clip=False)",
        "snippet": "    def __init__(self, vmin=None, vmax=None, clip=False):\n        \"\"\"\n        Parameters\n        ----------\n        vmin, vmax : float or None\n            If *vmin* and/or *vmax* is not given, they are initialized from the\n            minimum and maximum value, respectively, of the first input\n            processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.\n\n        clip : bool, default: False\n            If ``True`` values falling outside the range ``[vmin, vmax]``,\n            are mapped to 0 or 1, whichever is closer, and masked values are\n            set to 1.  If ``False`` masked values remain masked.\n\n            Clipping silently defeats the purpose of setting the over, under,\n            and masked colors in a colormap, so it is likely to lead to\n            surprises; therefore the default is ``clip=False``.\n\n        Notes\n        -----\n        Returns 0 if ``vmin == vmax``.\n        \"\"\"\n        self.vmin = _sanitize_extrema(vmin)\n        self.vmax = _sanitize_extrema(vmax)\n        self.clip = clip",
        "begin_line": 918,
        "end_line": 942,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.0005621135469364812,
            "pseudo_tarantula_susp": 0.0021645021645021645,
            "pseudo_op2_susp": 0.0005621135469364812,
            "pseudo_barinel_susp": 0.0021645021645021645
        }
    },
    {
        "name": "lib.matplotlib.colors.Normalize.process_value#945",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Normalize",
        "signature": "lib.matplotlib.colors.Normalize.process_value(value)",
        "snippet": "    def process_value(value):\n        \"\"\"\n        Homogenize the input *value* for easy and efficient normalization.\n\n        *value* can be a scalar or sequence.\n\n        Returns\n        -------\n        result : masked array\n            Masked array with the same shape as *value*.\n        is_scalar : bool\n            Whether *value* is a scalar.\n\n        Notes\n        -----\n        Float dtypes are preserved; integer types with two bytes or smaller are\n        converted to np.float32, and larger types are converted to np.float64.\n        Preserving float32 when possible, and using in-place operations,\n        greatly improves speed for large arrays.\n        \"\"\"\n        is_scalar = not np.iterable(value)\n        if is_scalar:\n            value = [value]\n        dtype = np.min_scalar_type(value)\n        if np.issubdtype(dtype, np.integer) or dtype.type is np.bool_:\n            # bool_/int8/int16 -> float32; int32/int64 -> float64\n            dtype = np.promote_types(dtype, np.float32)\n        # ensure data passed in as an ndarray subclass are interpreted as\n        # an ndarray. See issue #6622.\n        mask = np.ma.getmask(value)\n        data = np.asarray(value)\n        result = np.ma.array(data, mask=mask, dtype=dtype, copy=True)\n        return result, is_scalar",
        "begin_line": 945,
        "end_line": 977,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004464285714285714,
            "pseudo_dstar_susp": 0.0005035246727089627,
            "pseudo_tarantula_susp": 0.0014858841010401188,
            "pseudo_op2_susp": 0.0005035246727089627,
            "pseudo_barinel_susp": 0.001483679525222552
        }
    },
    {
        "name": "lib.matplotlib.colors.Normalize.__call__#979",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Normalize",
        "signature": "lib.matplotlib.colors.Normalize.__call__(self, value, clip=None)",
        "snippet": "    def __call__(self, value, clip=None):\n        \"\"\"\n        Normalize *value* data in the ``[vmin, vmax]`` interval into the\n        ``[0.0, 1.0]`` interval and return it.\n\n        Parameters\n        ----------\n        value\n            Data to normalize.\n        clip : bool\n            If ``None``, defaults to ``self.clip`` (which defaults to\n            ``False``).\n\n        Notes\n        -----\n        If not already initialized, ``self.vmin`` and ``self.vmax`` are\n        initialized using ``self.autoscale_None(value)``.\n        \"\"\"\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        # Convert at least to float, without losing precision.\n        (vmin,), _ = self.process_value(self.vmin)\n        (vmax,), _ = self.process_value(self.vmax)\n        if vmin == vmax:\n            result.fill(0)   # Or should it be all masked?  Or 0.5?\n        elif vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        else:\n            if clip:\n                mask = np.ma.getmask(result)\n                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                     mask=mask)\n            # ma division is very slow; we can take a shortcut\n            resdat = result.data\n            resdat -= vmin\n            resdat /= (vmax - vmin)\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result",
        "begin_line": 979,
        "end_line": 1022,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0005117707267144319,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0005117707267144319,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.colors.Normalize.inverse#1024",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Normalize",
        "signature": "lib.matplotlib.colors.Normalize.inverse(self, value)",
        "snippet": "    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until both vmin and vmax are set\")\n        (vmin,), _ = self.process_value(self.vmin)\n        (vmax,), _ = self.process_value(self.vmax)\n\n        if np.iterable(value):\n            val = np.ma.asarray(value)\n            return vmin + val * (vmax - vmin)\n        else:\n            return vmin + value * (vmax - vmin)",
        "begin_line": 1024,
        "end_line": 1034,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.colors.Normalize.autoscale#1036",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Normalize",
        "signature": "lib.matplotlib.colors.Normalize.autoscale(self, A)",
        "snippet": "    def autoscale(self, A):\n        \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n        A = np.asanyarray(A)\n        self.vmin = A.min()\n        self.vmax = A.max()",
        "begin_line": 1036,
        "end_line": 1040,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.Normalize.autoscale_None#1042",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Normalize",
        "signature": "lib.matplotlib.colors.Normalize.autoscale_None(self, A)",
        "snippet": "    def autoscale_None(self, A):\n        \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n        A = np.asanyarray(A)\n        if self.vmin is None and A.size:\n            self.vmin = A.min()\n        if self.vmax is None and A.size:\n            self.vmax = A.max()",
        "begin_line": 1042,
        "end_line": 1048,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016129032258064516,
            "pseudo_dstar_susp": 0.0005633802816901409,
            "pseudo_tarantula_susp": 0.0027397260273972603,
            "pseudo_op2_susp": 0.0005633802816901409,
            "pseudo_barinel_susp": 0.0027397260273972603
        }
    },
    {
        "name": "lib.matplotlib.colors.Normalize.scaled#1050",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.Normalize",
        "signature": "lib.matplotlib.colors.Normalize.scaled(self)",
        "snippet": "    def scaled(self):\n        \"\"\"Return whether vmin and vmax are set.\"\"\"\n        return self.vmin is not None and self.vmax is not None",
        "begin_line": 1050,
        "end_line": 1052,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.colors.TwoSlopeNorm.__init__#1056",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.TwoSlopeNorm",
        "signature": "lib.matplotlib.colors.TwoSlopeNorm.__init__(self, vcenter, vmin=None, vmax=None)",
        "snippet": "    def __init__(self, vcenter, vmin=None, vmax=None):\n        \"\"\"\n        Normalize data with a set center.\n\n        Useful when mapping data with an unequal rates of change around a\n        conceptual center, e.g., data that range from -2 to 4, with 0 as\n        the midpoint.\n\n        Parameters\n        ----------\n        vcenter : float\n            The data value that defines ``0.5`` in the normalization.\n        vmin : float, optional\n            The data value that defines ``0.0`` in the normalization.\n            Defaults to the min value of the dataset.\n        vmax : float, optional\n            The data value that defines ``1.0`` in the normalization.\n            Defaults to the the max value of the dataset.\n\n        Examples\n        --------\n        This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data\n        between is linearly interpolated::\n\n            >>> import matplotlib.colors as mcolors\n            >>> offset = mcolors.TwoSlopeNorm(vmin=-4000.,\n                                              vcenter=0., vmax=10000)\n            >>> data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.]\n            >>> offset(data)\n            array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])\n        \"\"\"\n\n        self.vcenter = vcenter\n        self.vmin = vmin\n        self.vmax = vmax\n        if vcenter is not None and vmax is not None and vcenter >= vmax:\n            raise ValueError('vmin, vcenter, and vmax must be in '\n                             'ascending order')\n        if vcenter is not None and vmin is not None and vcenter <= vmin:\n            raise ValueError('vmin, vcenter, and vmax must be in '\n                             'ascending order')",
        "begin_line": 1056,
        "end_line": 1096,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.TwoSlopeNorm.autoscale_None#1098",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.TwoSlopeNorm",
        "signature": "lib.matplotlib.colors.TwoSlopeNorm.autoscale_None(self, A)",
        "snippet": "    def autoscale_None(self, A):\n        \"\"\"\n        Get vmin and vmax, and then clip at vcenter\n        \"\"\"\n        super().autoscale_None(A)\n        if self.vmin > self.vcenter:\n            self.vmin = self.vcenter\n        if self.vmax < self.vcenter:\n            self.vmax = self.vcenter",
        "begin_line": 1098,
        "end_line": 1106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.TwoSlopeNorm.__call__#1108",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.TwoSlopeNorm",
        "signature": "lib.matplotlib.colors.TwoSlopeNorm.__call__(self, value, clip=None)",
        "snippet": "    def __call__(self, value, clip=None):\n        \"\"\"\n        Map value to the interval [0, 1]. The clip argument is unused.\n        \"\"\"\n        result, is_scalar = self.process_value(value)\n        self.autoscale_None(result)  # sets self.vmin, self.vmax if None\n\n        if not self.vmin <= self.vcenter <= self.vmax:\n            raise ValueError(\"vmin, vcenter, vmax must increase monotonically\")\n        result = np.ma.masked_array(\n            np.interp(result, [self.vmin, self.vcenter, self.vmax],\n                      [0, 0.5, 1.]), mask=np.ma.getmask(result))\n        if is_scalar:\n            result = np.atleast_1d(result)[0]\n        return result",
        "begin_line": 1108,
        "end_line": 1122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LogNorm._check_vmin_vmax#1133",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LogNorm",
        "signature": "lib.matplotlib.colors.LogNorm._check_vmin_vmax(self)",
        "snippet": "    def _check_vmin_vmax(self):\n        if self.vmin > self.vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif self.vmin <= 0:\n            raise ValueError(\"minvalue must be positive\")",
        "begin_line": 1133,
        "end_line": 1137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LogNorm.__call__#1139",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LogNorm",
        "signature": "lib.matplotlib.colors.LogNorm.__call__(self, value, clip=None)",
        "snippet": "    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        result = np.ma.masked_less_equal(result, 0, copy=False)\n\n        self.autoscale_None(result)\n        self._check_vmin_vmax()\n        vmin, vmax = self.vmin, self.vmax\n        if vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = np.ma.getmask(result)\n                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                     mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = result.data\n            mask = result.mask\n            if mask is np.ma.nomask:\n                mask = (resdat <= 0)\n            else:\n                mask |= resdat <= 0\n            np.copyto(resdat, 1, where=mask)\n            np.log(resdat, resdat)\n            resdat -= np.log(vmin)\n            resdat /= (np.log(vmax) - np.log(vmin))\n            result = np.ma.array(resdat, mask=mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result",
        "begin_line": 1139,
        "end_line": 1171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LogNorm.inverse#1173",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LogNorm",
        "signature": "lib.matplotlib.colors.LogNorm.inverse(self, value)",
        "snippet": "    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        self._check_vmin_vmax()\n        vmin, vmax = self.vmin, self.vmax\n\n        if np.iterable(value):\n            val = np.ma.asarray(value)\n            return vmin * np.ma.power((vmax / vmin), val)\n        else:\n            return vmin * pow((vmax / vmin), value)",
        "begin_line": 1173,
        "end_line": 1183,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LogNorm.autoscale_None#1189",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LogNorm",
        "signature": "lib.matplotlib.colors.LogNorm.autoscale_None(self, A)",
        "snippet": "    def autoscale_None(self, A):\n        # docstring inherited.\n        super().autoscale_None(np.ma.masked_less_equal(A, 0, copy=False))",
        "begin_line": 1189,
        "end_line": 1191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.SymLogNorm.__init__#1204",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.SymLogNorm",
        "signature": "lib.matplotlib.colors.SymLogNorm.__init__(self, linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=None)",
        "snippet": "    def __init__(self, linthresh, linscale=1.0, vmin=None, vmax=None,\n                 clip=False, *, base=None):\n        \"\"\"\n        Parameters\n        ----------\n        linthresh : float\n            The range within which the plot is linear (to avoid having the plot\n            go to infinity around zero).\n        linscale : float, default: 1\n            This allows the linear range (-*linthresh* to *linthresh*) to be\n            stretched relative to the logarithmic range. Its value is the\n            number of powers of *base* (decades for base 10) to use for each\n            half of the linear range. For example, when *linscale* == 1.0\n            (the default), the space used for the positive and negative halves\n            of the linear range will be equal to a decade in the logarithmic\n            range if ``base=10``.\n        base : float, default: None\n            For v3.2 the default is the old value of ``np.e``, but that is\n            deprecated for v3.3 when base will default to 10.  During the\n            transition, specify the *base* kwarg to avoid a deprecation\n            warning.\n        \"\"\"\n        Normalize.__init__(self, vmin, vmax, clip)\n        if base is None:\n            self._base = np.e\n            cbook.warn_deprecated(\n                \"3.3\", message=\"default base will change from np.e to 10.  To \"\n                \"suppress this warning specify the base kwarg.\")\n        else:\n            self._base = base\n        self._log_base = np.log(self._base)\n\n        self.linthresh = float(linthresh)\n        self._linscale_adj = (linscale / (1.0 - self._base ** -1))\n        if vmin is not None and vmax is not None:\n            self._transform_vmin_vmax()",
        "begin_line": 1204,
        "end_line": 1239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.SymLogNorm.__call__#1241",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.SymLogNorm",
        "signature": "lib.matplotlib.colors.SymLogNorm.__call__(self, value, clip=None)",
        "snippet": "    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = np.ma.getmask(result)\n                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                     mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = self._transform(result.data)\n            resdat -= self._lower\n            resdat /= (self._upper - self._lower)\n\n        if is_scalar:\n            result = result[0]\n        return result",
        "begin_line": 1241,
        "end_line": 1265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.SymLogNorm._transform#1267",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.SymLogNorm",
        "signature": "lib.matplotlib.colors.SymLogNorm._transform(self, a)",
        "snippet": "    def _transform(self, a):\n        \"\"\"Inplace transformation.\"\"\"\n        with np.errstate(invalid=\"ignore\"):\n            masked = np.abs(a) > self.linthresh\n        sign = np.sign(a[masked])\n        log = (self._linscale_adj +\n               np.log(np.abs(a[masked]) / self.linthresh) / self._log_base)\n        log *= sign * self.linthresh\n        a[masked] = log\n        a[~masked] *= self._linscale_adj\n        return a",
        "begin_line": 1267,
        "end_line": 1277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.SymLogNorm._inv_transform#1279",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.SymLogNorm",
        "signature": "lib.matplotlib.colors.SymLogNorm._inv_transform(self, a)",
        "snippet": "    def _inv_transform(self, a):\n        \"\"\"Inverse inplace Transformation.\"\"\"\n        masked = np.abs(a) > (self.linthresh * self._linscale_adj)\n        sign = np.sign(a[masked])\n        exp = np.power(self._base,\n                       sign * a[masked] / self.linthresh - self._linscale_adj)\n        exp *= sign * self.linthresh\n        a[masked] = exp\n        a[~masked] /= self._linscale_adj\n        return a",
        "begin_line": 1279,
        "end_line": 1288,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.SymLogNorm._transform_vmin_vmax#1290",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.SymLogNorm",
        "signature": "lib.matplotlib.colors.SymLogNorm._transform_vmin_vmax(self)",
        "snippet": "    def _transform_vmin_vmax(self):\n        \"\"\"Calculates vmin and vmax in the transformed system.\"\"\"\n        vmin, vmax = self.vmin, self.vmax\n        arr = np.array([vmax, vmin]).astype(float)\n        self._upper, self._lower = self._transform(arr)",
        "begin_line": 1290,
        "end_line": 1294,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.SymLogNorm.inverse#1296",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.SymLogNorm",
        "signature": "lib.matplotlib.colors.SymLogNorm.inverse(self, value)",
        "snippet": "    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        val = np.ma.asarray(value)\n        val = val * (self._upper - self._lower) + self._lower\n        return self._inv_transform(val)",
        "begin_line": 1296,
        "end_line": 1301,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.SymLogNorm.autoscale_None#1308",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.SymLogNorm",
        "signature": "lib.matplotlib.colors.SymLogNorm.autoscale_None(self, A)",
        "snippet": "    def autoscale_None(self, A):\n        # docstring inherited.\n        super().autoscale_None(A)\n        self._transform_vmin_vmax()",
        "begin_line": 1308,
        "end_line": 1311,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.PowerNorm.__init__#1319",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.PowerNorm",
        "signature": "lib.matplotlib.colors.PowerNorm.__init__(self, gamma, vmin=None, vmax=None, clip=False)",
        "snippet": "    def __init__(self, gamma, vmin=None, vmax=None, clip=False):\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.gamma = gamma",
        "begin_line": 1319,
        "end_line": 1321,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.PowerNorm.__call__#1323",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.PowerNorm",
        "signature": "lib.matplotlib.colors.PowerNorm.__call__(self, value, clip=None)",
        "snippet": "    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = np.ma.getmask(result)\n                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                     mask=mask)\n            resdat = result.data\n            resdat -= vmin\n            resdat[resdat < 0] = 0\n            np.power(resdat, gamma, resdat)\n            resdat /= (vmax - vmin) ** gamma\n\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result",
        "begin_line": 1323,
        "end_line": 1350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.PowerNorm.inverse#1352",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.PowerNorm",
        "signature": "lib.matplotlib.colors.PowerNorm.inverse(self, value)",
        "snippet": "    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(\"Not invertible until scaled\")\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n\n        if np.iterable(value):\n            val = np.ma.asarray(value)\n            return np.ma.power(val, 1. / gamma) * (vmax - vmin) + vmin\n        else:\n            return pow(value, 1. / gamma) * (vmax - vmin) + vmin",
        "begin_line": 1352,
        "end_line": 1362,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.BoundaryNorm.__init__#1376",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.BoundaryNorm",
        "signature": "lib.matplotlib.colors.BoundaryNorm.__init__(self, boundaries, ncolors, clip=False)",
        "snippet": "    def __init__(self, boundaries, ncolors, clip=False):\n        \"\"\"\n        Parameters\n        ----------\n        boundaries : array-like\n            Monotonically increasing sequence of boundaries\n        ncolors : int\n            Number of colors in the colormap to be used\n        clip : bool, optional\n            If clip is ``True``, out of range values are mapped to 0 if they\n            are below ``boundaries[0]`` or mapped to ncolors - 1 if they are\n            above ``boundaries[-1]``.\n\n            If clip is ``False``, out of range values are mapped to -1 if\n            they are below ``boundaries[0]`` or mapped to ncolors if they are\n            above ``boundaries[-1]``. These are then converted to valid indices\n            by :meth:`Colormap.__call__`.\n\n        Notes\n        -----\n        *boundaries* defines the edges of bins, and data falling within a bin\n        is mapped to the color with the same index.\n\n        If the number of bins doesn't equal *ncolors*, the color is chosen\n        by linear interpolation of the bin number onto color numbers.\n        \"\"\"\n        self.clip = clip\n        self.vmin = boundaries[0]\n        self.vmax = boundaries[-1]\n        self.boundaries = np.asarray(boundaries)\n        self.N = len(self.boundaries)\n        self.Ncmap = ncolors\n        if self.N - 1 == self.Ncmap:\n            self._interp = False\n        else:\n            self._interp = True",
        "begin_line": 1376,
        "end_line": 1411,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.BoundaryNorm.__call__#1413",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.BoundaryNorm",
        "signature": "lib.matplotlib.colors.BoundaryNorm.__call__(self, value, clip=None)",
        "snippet": "    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        xx, is_scalar = self.process_value(value)\n        mask = np.ma.getmaskarray(xx)\n        xx = np.atleast_1d(xx.filled(self.vmax + 1))\n        if clip:\n            np.clip(xx, self.vmin, self.vmax, out=xx)\n            max_col = self.Ncmap - 1\n        else:\n            max_col = self.Ncmap\n        iret = np.zeros(xx.shape, dtype=np.int16)\n        for i, b in enumerate(self.boundaries):\n            iret[xx >= b] = i\n        if self._interp:\n            scalefac = (self.Ncmap - 1) / (self.N - 2)\n            iret = (iret * scalefac).astype(np.int16)\n        iret[xx < self.vmin] = -1\n        iret[xx >= self.vmax] = max_col\n        ret = np.ma.array(iret, mask=mask)\n        if is_scalar:\n            ret = int(ret[0])  # assume python scalar\n        return ret",
        "begin_line": 1413,
        "end_line": 1436,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.NoNorm.__call__#1454",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.NoNorm",
        "signature": "lib.matplotlib.colors.NoNorm.__call__(self, value, clip=None)",
        "snippet": "    def __call__(self, value, clip=None):\n        return value",
        "begin_line": 1454,
        "end_line": 1455,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.rgb_to_hsv#1461",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors.rgb_to_hsv(arr)",
        "snippet": "def rgb_to_hsv(arr):\n    \"\"\"\n    Convert float rgb values (in the range [0, 1]), in a numpy array to hsv\n    values.\n\n    Parameters\n    ----------\n    arr : (..., 3) array-like\n       All values must be in the range [0, 1]\n\n    Returns\n    -------\n    hsv : (..., 3) ndarray\n       Colors converted to hsv values in range [0, 1]\n    \"\"\"\n    arr = np.asarray(arr)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if arr.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                         \"shape {} was found.\".format(arr.shape))\n\n    in_shape = arr.shape\n    arr = np.array(\n        arr, copy=False,\n        dtype=np.promote_types(arr.dtype, np.float32),  # Don't work on ints.\n        ndmin=2,  # In case input was 1D.\n    )\n    out = np.zeros_like(arr)\n    arr_max = arr.max(-1)\n    ipos = arr_max > 0\n    delta = arr.ptp(-1)\n    s = np.zeros_like(delta)\n    s[ipos] = delta[ipos] / arr_max[ipos]\n    ipos = delta > 0\n    # red is max\n    idx = (arr[..., 0] == arr_max) & ipos\n    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n    # green is max\n    idx = (arr[..., 1] == arr_max) & ipos\n    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]\n    # blue is max\n    idx = (arr[..., 2] == arr_max) & ipos\n    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]\n\n    out[..., 0] = (out[..., 0] / 6.0) % 1.0\n    out[..., 1] = s\n    out[..., 2] = arr_max\n\n    return out.reshape(in_shape)",
        "begin_line": 1461,
        "end_line": 1510,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.hsv_to_rgb#1513",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors.hsv_to_rgb(hsv)",
        "snippet": "def hsv_to_rgb(hsv):\n    \"\"\"\n    Convert hsv values to rgb.\n\n    Parameters\n    ----------\n    hsv : (..., 3) array-like\n       All values assumed to be in range [0, 1]\n\n    Returns\n    -------\n    rgb : (..., 3) ndarray\n       Colors converted to RGB values in range [0, 1]\n    \"\"\"\n    hsv = np.asarray(hsv)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if hsv.shape[-1] != 3:\n        raise ValueError(\"Last dimension of input array must be 3; \"\n                         \"shape {shp} was found.\".format(shp=hsv.shape))\n\n    in_shape = hsv.shape\n    hsv = np.array(\n        hsv, copy=False,\n        dtype=np.promote_types(hsv.dtype, np.float32),  # Don't work on ints.\n        ndmin=2,  # In case input was 1D.\n    )\n\n    h = hsv[..., 0]\n    s = hsv[..., 1]\n    v = hsv[..., 2]\n\n    r = np.empty_like(h)\n    g = np.empty_like(h)\n    b = np.empty_like(h)\n\n    i = (h * 6.0).astype(int)\n    f = (h * 6.0) - i\n    p = v * (1.0 - s)\n    q = v * (1.0 - s * f)\n    t = v * (1.0 - s * (1.0 - f))\n\n    idx = i % 6 == 0\n    r[idx] = v[idx]\n    g[idx] = t[idx]\n    b[idx] = p[idx]\n\n    idx = i == 1\n    r[idx] = q[idx]\n    g[idx] = v[idx]\n    b[idx] = p[idx]\n\n    idx = i == 2\n    r[idx] = p[idx]\n    g[idx] = v[idx]\n    b[idx] = t[idx]\n\n    idx = i == 3\n    r[idx] = p[idx]\n    g[idx] = q[idx]\n    b[idx] = v[idx]\n\n    idx = i == 4\n    r[idx] = t[idx]\n    g[idx] = p[idx]\n    b[idx] = v[idx]\n\n    idx = i == 5\n    r[idx] = v[idx]\n    g[idx] = p[idx]\n    b[idx] = q[idx]\n\n    idx = s == 0\n    r[idx] = v[idx]\n    g[idx] = v[idx]\n    b[idx] = v[idx]\n\n    rgb = np.stack([r, g, b], axis=-1)\n\n    return rgb.reshape(in_shape)",
        "begin_line": 1513,
        "end_line": 1592,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors._vector_magnitude#1595",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors._vector_magnitude(arr)",
        "snippet": "def _vector_magnitude(arr):\n    # things that don't work here:\n    #  * np.linalg.norm: drops mask from ma.array\n    #  * np.sum: drops mask from ma.array unless entire vector is masked\n    sum_sq = 0\n    for i in range(arr.shape[-1]):\n        sum_sq += arr[..., i, np.newaxis] ** 2\n    return np.sqrt(sum_sq)",
        "begin_line": 1595,
        "end_line": 1602,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LightSource.__init__#1616",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LightSource",
        "signature": "lib.matplotlib.colors.LightSource.__init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)",
        "snippet": "    def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,\n                 hsv_min_sat=1, hsv_max_sat=0):\n        \"\"\"\n        Specify the azimuth (measured clockwise from south) and altitude\n        (measured up from the plane of the surface) of the light source\n        in degrees.\n\n        Parameters\n        ----------\n        azdeg : float, default: 315 degrees (from the northwest)\n            The azimuth (0-360, degrees clockwise from North) of the light\n            source.\n        altdeg : float, default: 45 degrees\n            The altitude (0-90, degrees up from horizontal) of the light\n            source.\n\n        Notes\n        -----\n        For backwards compatibility, the parameters *hsv_min_val*,\n        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n        initialization as well.  However, these parameters will only be used if\n        \"blend_mode='hsv'\" is passed into :meth:`shade` or :meth:`shade_rgb`.\n        See the documentation for :meth:`blend_hsv` for more details.\n        \"\"\"\n        self.azdeg = azdeg\n        self.altdeg = altdeg\n        self.hsv_min_val = hsv_min_val\n        self.hsv_max_val = hsv_max_val\n        self.hsv_min_sat = hsv_min_sat\n        self.hsv_max_sat = hsv_max_sat",
        "begin_line": 1616,
        "end_line": 1645,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LightSource.hillshade#1660",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LightSource",
        "signature": "lib.matplotlib.colors.LightSource.hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.0)",
        "snippet": "    def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n        \"\"\"\n        Calculates the illumination intensity for a surface using the defined\n        azimuth and elevation for the light source.\n\n        This computes the normal vectors for the surface, and then passes them\n        on to `shade_normals`\n\n        Parameters\n        ----------\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate an\n            illumination map\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs. meters) or to\n            exaggerate or de-emphasize topographic effects.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n\n        Returns\n        -------\n        intensity : ndarray\n            A 2d array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        \"\"\"\n\n        # Because most image and raster GIS data has the first row in the array\n        # as the \"top\" of the image, dy is implicitly negative.  This is\n        # consistent to what `imshow` assumes, as well.\n        dy = -dy\n\n        # compute the normal vectors from the partial derivatives\n        e_dy, e_dx = np.gradient(vert_exag * elevation, dy, dx)\n\n        # .view is to keep subclasses\n        normal = np.empty(elevation.shape + (3,)).view(type(elevation))\n        normal[..., 0] = -e_dx\n        normal[..., 1] = -e_dy\n        normal[..., 2] = 1\n        normal /= _vector_magnitude(normal)\n\n        return self.shade_normals(normal, fraction)",
        "begin_line": 1660,
        "end_line": 1712,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LightSource.shade_normals#1714",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LightSource",
        "signature": "lib.matplotlib.colors.LightSource.shade_normals(self, normals, fraction=1.0)",
        "snippet": "    def shade_normals(self, normals, fraction=1.):\n        \"\"\"\n        Calculates the illumination intensity for the normal vectors of a\n        surface using the defined azimuth and elevation for the light source.\n\n        Imagine an artificial sun placed at infinity in some azimuth and\n        elevation position illuminating our surface. The parts of the surface\n        that slope toward the sun should brighten while those sides facing away\n        should become darker.\n\n        Parameters\n        ----------\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n\n        Returns\n        -------\n        intensity : ndarray\n            A 2d array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        \"\"\"\n\n        intensity = normals.dot(self.direction)\n\n        # Apply contrast stretch\n        imin, imax = intensity.min(), intensity.max()\n        intensity *= fraction\n\n        # Rescale to 0-1, keeping range before contrast stretch\n        # If constant slope, keep relative scaling (i.e. flat should be 0.5,\n        # fully occluded 0, etc.)\n        if (imax - imin) > 1e-6:\n            # Strictly speaking, this is incorrect. Negative values should be\n            # clipped to 0 because they're fully occluded. However, rescaling\n            # in this manner is consistent with the previous implementation and\n            # visually appears better than a \"hard\" clip.\n            intensity -= imin\n            intensity /= (imax - imin)\n        intensity = np.clip(intensity, 0, 1)\n\n        return intensity",
        "begin_line": 1714,
        "end_line": 1758,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LightSource.shade#1760",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LightSource",
        "signature": "lib.matplotlib.colors.LightSource.shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None, vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs)",
        "snippet": "    def shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None,\n              vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):\n        \"\"\"\n        Combine colormapped data values with an illumination intensity map\n        (a.k.a.  \"hillshade\") of the values.\n\n        Parameters\n        ----------\n        data : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        cmap : `~matplotlib.colors.Colormap`\n            The colormap used to color the *data* array. Note that this must be\n            a `~matplotlib.colors.Colormap` instance.  For example, rather than\n            passing in ``cmap='gist_earth'``, use\n            ``cmap=plt.get_cmap('gist_earth')`` instead.\n        norm : `~matplotlib.colors.Normalize` instance, optional\n            The normalization used to scale values before colormapping. If\n            None, the input will be linearly scaled between its min and max.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data\n            values with the illumination intensity.  Default is\n            \"overlay\".  Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to\n            combine an MxNx3 RGB array of floats (ranging 0 to 1) with\n            an MxNx1 hillshade array (also 0 to 1).  (Call signature\n            ``func(rgb, illum, **kwargs)``) Additional kwargs supplied\n            to this function will be passed on to the *blend_mode*\n            function.\n        vmin : scalar or None, optional\n            The minimum value used in colormapping *data*. If *None* the\n            minimum value in *data* is used. If *norm* is specified, then this\n            argument will be ignored.\n        vmax : scalar or None, optional\n            The maximum value used in colormapping *data*. If *None* the\n            maximum value in *data* is used. If *norm* is specified, then this\n            argument will be ignored.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs. meters) or to\n            exaggerate or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        rgba : ndarray\n            An MxNx4 array of floats ranging between 0-1.\n        \"\"\"\n        if vmin is None:\n            vmin = data.min()\n        if vmax is None:\n            vmax = data.max()\n        if norm is None:\n            norm = Normalize(vmin=vmin, vmax=vmax)\n\n        rgb0 = cmap(norm(data))\n        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode,\n                              vert_exag=vert_exag, dx=dx, dy=dy,\n                              fraction=fraction, **kwargs)\n        # Don't overwrite the alpha channel, if present.\n        rgb0[..., :3] = rgb1[..., :3]\n        return rgb0",
        "begin_line": 1760,
        "end_line": 1834,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LightSource.shade_rgb#1836",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LightSource",
        "signature": "lib.matplotlib.colors.LightSource.shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs)",
        "snippet": "    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',\n                  vert_exag=1, dx=1, dy=1, **kwargs):\n        \"\"\"\n        Use this light source to adjust the colors of the *rgb* input array to\n        give the impression of a shaded relief map with the given *elevation*.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            An (M, N) array of the height values used to generate a shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to \"hsv\". Note that for most topographic surfaces,\n            \"overlay\" or \"soft\" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature\n            ``func(rgb, illum, **kwargs)``)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs. meters) or to\n            exaggerate or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        shaded_rgb : ndarray\n            An (m, n, 3) array of floats ranging between 0-1.\n        \"\"\"\n        # Calculate the \"hillshade\" intensity.\n        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n        intensity = intensity[..., np.newaxis]\n\n        # Blend the hillshade and rgb data using the specified mode\n        lookup = {\n                'hsv': self.blend_hsv,\n                'soft': self.blend_soft_light,\n                'overlay': self.blend_overlay,\n                }\n        if blend_mode in lookup:\n            blend = lookup[blend_mode](rgb, intensity, **kwargs)\n        else:\n            try:\n                blend = blend_mode(rgb, intensity, **kwargs)\n            except TypeError as err:\n                raise ValueError('\"blend_mode\" must be callable or one of {}'\n                                 .format(lookup.keys)) from err\n\n        # Only apply result where hillshade intensity isn't masked\n        if hasattr(intensity, 'mask'):\n            mask = intensity.mask[..., 0]\n            for i in range(3):\n                blend[..., i][mask] = rgb[..., i][mask]\n\n        return blend",
        "begin_line": 1836,
        "end_line": 1907,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LightSource.blend_hsv#1909",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LightSource",
        "signature": "lib.matplotlib.colors.LightSource.blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None, hsv_min_val=None, hsv_min_sat=None)",
        "snippet": "    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                  hsv_min_val=None, hsv_min_sat=None):\n        \"\"\"\n        Take the input data array, convert to HSV values in the given colormap,\n        then adjust those color values to give the impression of a shaded\n        relief map with a specified light source.  RGBA values are returned,\n        which can then be used to plot the shaded image with imshow.\n\n        The color of the resulting image will be darkened by moving the (s, v)\n        values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the\n        shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,\n        hsv_max_val) in regions that are illuminated.  The default extremes are\n        chose so that completely shaded points are nearly black (s = 1, v = 0)\n        and completely illuminated points are nearly white (s = 0, v = 1).\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n        hsv_max_sat : number, optional, default: 1\n            The maximum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 1.\n        hsv_min_sat : number, optional\n            The minimum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 0.\n        hsv_max_val : number, optional\n            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 1.\n        hsv_min_val : number, optional\n            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift\n            the output image to. Defaults to 0.\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        # Backward compatibility...\n        if hsv_max_sat is None:\n            hsv_max_sat = self.hsv_max_sat\n        if hsv_max_val is None:\n            hsv_max_val = self.hsv_max_val\n        if hsv_min_sat is None:\n            hsv_min_sat = self.hsv_min_sat\n        if hsv_min_val is None:\n            hsv_min_val = self.hsv_min_val\n\n        # Expects a 2D intensity array scaled between -1 to 1...\n        intensity = intensity[..., 0]\n        intensity = 2 * intensity - 1\n\n        # Convert to rgb, then rgb to hsv\n        hsv = rgb_to_hsv(rgb[:, :, 0:3])\n        hue, sat, val = np.moveaxis(hsv, -1, 0)\n\n        # Modify hsv values (in place) to simulate illumination.\n        # putmask(A, mask, B) <=> A[mask] = B[mask]\n        np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity > 0),\n                   (1 - intensity) * sat + intensity * hsv_max_sat)\n        np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity < 0),\n                   (1 + intensity) * sat - intensity * hsv_min_sat)\n        np.putmask(val, intensity > 0,\n                   (1 - intensity) * val + intensity * hsv_max_val)\n        np.putmask(val, intensity < 0,\n                   (1 + intensity) * val - intensity * hsv_min_val)\n        np.clip(hsv[:, :, 1:], 0, 1, out=hsv[:, :, 1:])\n\n        # Convert modified hsv back to rgb.\n        return hsv_to_rgb(hsv)",
        "begin_line": 1909,
        "end_line": 1979,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LightSource.blend_soft_light#1981",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LightSource",
        "signature": "lib.matplotlib.colors.LightSource.blend_soft_light(self, rgb, intensity)",
        "snippet": "    def blend_soft_light(self, rgb, intensity):\n        \"\"\"\n        Combines an rgb image with an intensity map using \"soft light\"\n        blending.  Uses the \"pegtop\" formula.\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        return 2 * intensity * rgb + (1 - 2 * intensity) * rgb**2",
        "begin_line": 1981,
        "end_line": 1998,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.LightSource.blend_overlay#2000",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors.LightSource",
        "signature": "lib.matplotlib.colors.LightSource.blend_overlay(self, rgb, intensity)",
        "snippet": "    def blend_overlay(self, rgb, intensity):\n        \"\"\"\n        Combines an rgb image with an intensity map using \"overlay\" blending.\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        \"\"\"\n        low = 2 * intensity * rgb\n        high = 1 - 2 * (1 - intensity) * (1 - rgb)\n        return np.where(rgb <= 0.5, low, high)",
        "begin_line": 2000,
        "end_line": 2018,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.colors.from_levels_and_colors#2021",
        "src_path": "lib/matplotlib/colors.py",
        "class_name": "lib.matplotlib.colors",
        "signature": "lib.matplotlib.colors.from_levels_and_colors(levels, colors, extend='neither')",
        "snippet": "def from_levels_and_colors(levels, colors, extend='neither'):\n    \"\"\"\n    A helper routine to generate a cmap and a norm instance which\n    behave similar to contourf's levels and colors arguments.\n\n    Parameters\n    ----------\n    levels : sequence of numbers\n        The quantization levels used to construct the :class:`BoundaryNorm`.\n        Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.\n    colors : sequence of colors\n        The fill color to use for each level. If *extend* is \"neither\" there\n        must be ``n_level - 1`` colors. For an *extend* of \"min\" or \"max\" add\n        one extra color, and for an *extend* of \"both\" add two colors.\n    extend : {'neither', 'min', 'max', 'both'}, optional\n        The behaviour when a value falls out of range of the given levels.\n        See :func:`~matplotlib.pyplot.contourf` for details.\n\n    Returns\n    -------\n    cmap : `~matplotlib.colors.Normalize`\n    norm : `~matplotlib.colors.Colormap`\n    \"\"\"\n    slice_map = {\n        'both': slice(1, -1),\n        'min': slice(1, None),\n        'max': slice(0, -1),\n        'neither': slice(0, None),\n    }\n    cbook._check_in_list(slice_map, extend=extend)\n    color_slice = slice_map[extend]\n\n    n_data_colors = len(levels) - 1\n    n_expected = n_data_colors + color_slice.start - (color_slice.stop or 0)\n    if len(colors) != n_expected:\n        raise ValueError(\n            f'With extend == {extend!r} and {len(levels)} levels, '\n            f'expected {n_expected} colors, but got {len(colors)}')\n\n    cmap = ListedColormap(colors[color_slice], N=n_data_colors)\n\n    if extend in ['min', 'both']:\n        cmap.set_under(colors[0])\n    else:\n        cmap.set_under('none')\n\n    if extend in ['max', 'both']:\n        cmap.set_over(colors[-1])\n    else:\n        cmap.set_over('none')\n\n    cmap.colorbar_extend = extend\n\n    norm = BoundaryNorm(levels, ncolors=n_data_colors)\n    return cmap, norm",
        "begin_line": 2021,
        "end_line": 2075,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.path.Path.__init__#97",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.__init__(self, vertices, codes=None, _interpolation_steps=1, closed=False, readonly=False)",
        "snippet": "    def __init__(self, vertices, codes=None, _interpolation_steps=1,\n                 closed=False, readonly=False):\n        \"\"\"\n        Create a new path with the given vertices and codes.\n\n        Parameters\n        ----------\n        vertices : array-like\n            The ``(N, 2)`` float array, masked array or sequence of pairs\n            representing the vertices of the path.\n\n            If *vertices* contains masked values, they will be converted\n            to NaNs which are then handled correctly by the Agg\n            PathIterator and other consumers of path data, such as\n            :meth:`iter_segments`.\n        codes : array-like or None, optional\n            n-length array integers representing the codes of the path.\n            If not None, codes must be the same length as vertices.\n            If None, *vertices* will be treated as a series of line segments.\n        _interpolation_steps : int, optional\n            Used as a hint to certain projections, such as Polar, that this\n            path should be linearly interpolated immediately before drawing.\n            This attribute is primarily an implementation detail and is not\n            intended for public use.\n        closed : bool, optional\n            If *codes* is None and closed is True, vertices will be treated as\n            line segments of a closed polygon.  Note that the last vertex will\n            then be ignored (as the corresponding code will be set to\n            CLOSEPOLY).\n        readonly : bool, optional\n            Makes the path behave in an immutable way and sets the vertices\n            and codes as read-only arrays.\n        \"\"\"\n        vertices = _to_unmasked_float_array(vertices)\n        if vertices.ndim != 2 or vertices.shape[1] != 2:\n            raise ValueError(\n                \"'vertices' must be a 2D list or array with shape Nx2\")\n\n        if codes is not None:\n            codes = np.asarray(codes, self.code_type)\n            if codes.ndim != 1 or len(codes) != len(vertices):\n                raise ValueError(\"'codes' must be a 1D list or array with the \"\n                                 \"same length of 'vertices'\")\n            if len(codes) and codes[0] != self.MOVETO:\n                raise ValueError(\"The first element of 'code' must be equal \"\n                                 \"to 'MOVETO' ({})\".format(self.MOVETO))\n        elif closed and len(vertices):\n            codes = np.empty(len(vertices), dtype=self.code_type)\n            codes[0] = self.MOVETO\n            codes[1:-1] = self.LINETO\n            codes[-1] = self.CLOSEPOLY\n\n        self._vertices = vertices\n        self._codes = codes\n        self._interpolation_steps = _interpolation_steps\n        self._update_values()\n\n        if readonly:\n            self._vertices.flags.writeable = False\n            if self._codes is not None:\n                self._codes.flags.writeable = False\n            self._readonly = True\n        else:\n            self._readonly = False",
        "begin_line": 97,
        "end_line": 160,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.025,
            "pseudo_dstar_susp": 0.04,
            "pseudo_tarantula_susp": 0.0007230657989877079,
            "pseudo_op2_susp": 0.038461538461538464,
            "pseudo_barinel_susp": 0.0007230657989877079
        }
    },
    {
        "name": "lib.matplotlib.path.Path._update_values#191",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path._update_values(self)",
        "snippet": "    def _update_values(self):\n        self._simplify_threshold = mpl.rcParams['path.simplify_threshold']\n        self._should_simplify = (\n            self._simplify_threshold > 0 and\n            mpl.rcParams['path.simplify'] and\n            len(self._vertices) >= 128 and\n            (self._codes is None or np.all(self._codes <= Path.LINETO))\n        )",
        "begin_line": 191,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00033829499323410016,
            "pseudo_dstar_susp": 0.0004992511233150275,
            "pseudo_tarantula_susp": 0.00040016006402561027,
            "pseudo_op2_susp": 0.0004992511233150275,
            "pseudo_barinel_susp": 0.00040016006402561027
        }
    },
    {
        "name": "lib.matplotlib.path.Path.vertices#201",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.vertices(self)",
        "snippet": "    def vertices(self):\n        \"\"\"\n        The list of vertices in the `Path` as an Nx2 numpy array.\n        \"\"\"\n        return self._vertices",
        "begin_line": 201,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002770083102493075,
            "pseudo_dstar_susp": 0.009009009009009009,
            "pseudo_tarantula_susp": 0.00035523978685612787,
            "pseudo_op2_susp": 0.009009009009009009,
            "pseudo_barinel_susp": 0.00035523978685612787
        }
    },
    {
        "name": "lib.matplotlib.path.Path.vertices#208",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.vertices(self, vertices)",
        "snippet": "    def vertices(self, vertices):\n        if self._readonly:\n            raise AttributeError(\"Can't set vertices on a readonly Path\")\n        self._vertices = vertices\n        self._update_values()",
        "begin_line": 208,
        "end_line": 212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.28332714444857e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.path.Path.codes#215",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.codes(self)",
        "snippet": "    def codes(self):\n        \"\"\"\n        The list of codes in the `Path` as a 1-D numpy array.  Each\n        code is one of `STOP`, `MOVETO`, `LINETO`, `CURVE3`, `CURVE4`\n        or `CLOSEPOLY`.  For codes that correspond to more than one\n        vertex (`CURVE3` and `CURVE4`), that code will be repeated so\n        that the length of `self.vertices` and `self.codes` is always\n        the same.\n        \"\"\"\n        return self._codes",
        "begin_line": 215,
        "end_line": 224,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031210986267166043,
            "pseudo_dstar_susp": 0.0003074085459575776,
            "pseudo_tarantula_susp": 0.0003487966515521451,
            "pseudo_op2_susp": 0.0003074085459575776,
            "pseudo_barinel_susp": 0.0003487966515521451
        }
    },
    {
        "name": "lib.matplotlib.path.Path.simplify_threshold#234",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.simplify_threshold(self)",
        "snippet": "    def simplify_threshold(self):\n        \"\"\"\n        The fraction of a pixel difference below which vertices will\n        be simplified out.\n        \"\"\"\n        return self._simplify_threshold",
        "begin_line": 234,
        "end_line": 239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006882312456985547,
            "pseudo_dstar_susp": 0.004545454545454545,
            "pseudo_tarantula_susp": 0.00034328870580157915,
            "pseudo_op2_susp": 0.004545454545454545,
            "pseudo_barinel_susp": 0.00034328870580157915
        }
    },
    {
        "name": "lib.matplotlib.path.Path.should_simplify#255",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.should_simplify(self)",
        "snippet": "    def should_simplify(self):\n        \"\"\"\n        `True` if the vertices array should be simplified.\n        \"\"\"\n        return self._should_simplify",
        "begin_line": 255,
        "end_line": 259,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.104384471999351e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.path.Path.make_compound_path#327",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.make_compound_path(cls, *args)",
        "snippet": "    def make_compound_path(cls, *args):\n        \"\"\"Make a compound path from a list of Path objects.\"\"\"\n        # Handle an empty list in args (i.e. no args).\n        if not args:\n            return Path(np.empty([0, 2], dtype=np.float32))\n\n        vertices = np.concatenate([x.vertices for x in args])\n        codes = np.empty(len(vertices), dtype=cls.code_type)\n        i = 0\n        for path in args:\n            if path.codes is None:\n                codes[i] = cls.MOVETO\n                codes[i + 1:i + len(path.vertices)] = cls.LINETO\n            else:\n                codes[i:i + len(path.codes)] = path.codes\n            i += len(path.vertices)\n\n        return cls(vertices, codes)",
        "begin_line": 327,
        "end_line": 344,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.path.Path.__repr__#346",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return \"Path(%r, %r)\" % (self.vertices, self.codes)",
        "begin_line": 346,
        "end_line": 347,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.path.Path.__len__#349",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.__len__(self)",
        "snippet": "    def __len__(self):\n        return len(self.vertices)",
        "begin_line": 349,
        "end_line": 350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.path.Path.iter_segments#352",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.iter_segments(self, transform=None, remove_nans=True, clip=None, snap=False, stroke_width=1.0, simplify=None, curves=True, sketch=None)",
        "snippet": "    def iter_segments(self, transform=None, remove_nans=True, clip=None,\n                      snap=False, stroke_width=1.0, simplify=None,\n                      curves=True, sketch=None):\n        \"\"\"\n        Iterates over all of the curve segments in the path.  Each iteration\n        returns a 2-tuple ``(vertices, code)``, where ``vertices`` is a\n        sequence of 1-3 coordinate pairs, and ``code`` is a `Path` code.\n\n        Additionally, this method can provide a number of standard cleanups and\n        conversions to the path.\n\n        Parameters\n        ----------\n        transform : None or :class:`~matplotlib.transforms.Transform`\n            If not None, the given affine transformation will be applied to the\n            path.\n        remove_nans : bool, optional\n            Whether to remove all NaNs from the path and skip over them using\n            MOVETO commands.\n        clip : None or (float, float, float, float), optional\n            If not None, must be a four-tuple (x1, y1, x2, y2)\n            defining a rectangle in which to clip the path.\n        snap : None or bool, optional\n            If True, snap all nodes to pixels; if False, don't snap them.\n            If None, perform snapping if the path contains only segments\n            parallel to the x or y axes, and no more than 1024 of them.\n        stroke_width : float, optional\n            The width of the stroke being drawn (used for path snapping).\n        simplify : None or bool, optional\n            Whether to simplify the path by removing vertices\n            that do not affect its appearance.  If None, use the\n            :attr:`should_simplify` attribute.  See also :rc:`path.simplify`\n            and :rc:`path.simplify_threshold`.\n        curves : bool, optional\n            If True, curve segments will be returned as curve segments.\n            If False, all curves will be converted to line segments.\n        sketch : None or sequence, optional\n            If not None, must be a 3-tuple of the form\n            (scale, length, randomness), representing the sketch parameters.\n        \"\"\"\n        if not len(self):\n            return\n\n        cleaned = self.cleaned(transform=transform,\n                               remove_nans=remove_nans, clip=clip,\n                               snap=snap, stroke_width=stroke_width,\n                               simplify=simplify, curves=curves,\n                               sketch=sketch)\n\n        # Cache these object lookups for performance in the loop.\n        NUM_VERTICES_FOR_CODE = self.NUM_VERTICES_FOR_CODE\n        STOP = self.STOP\n\n        vertices = iter(cleaned.vertices)\n        codes = iter(cleaned.codes)\n        for curr_vertices, code in zip(vertices, codes):\n            if code == STOP:\n                break\n            extra_vertices = NUM_VERTICES_FOR_CODE[code] - 1\n            if extra_vertices:\n                for i in range(extra_vertices):\n                    next(codes)\n                    curr_vertices = np.append(curr_vertices, next(vertices))\n            yield curr_vertices, code",
        "begin_line": 352,
        "end_line": 415,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041736227045075126,
            "pseudo_dstar_susp": 0.0003787878787878788,
            "pseudo_tarantula_susp": 0.0010638297872340426,
            "pseudo_op2_susp": 0.0003787878787878788,
            "pseudo_barinel_susp": 0.0010638297872340426
        }
    },
    {
        "name": "lib.matplotlib.path.Path.cleaned#418",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.cleaned(self, transform=None, remove_nans=False, clip=None, quantize=False, simplify=False, curves=False, stroke_width=1.0, snap=False, sketch=None)",
        "snippet": "    def cleaned(self, transform=None, remove_nans=False, clip=None,\n                quantize=False, simplify=False, curves=False,\n                stroke_width=1.0, snap=False, sketch=None):\n        \"\"\"\n        Return a new Path with vertices and codes cleaned according to the\n        parameters.\n\n        See Also\n        --------\n        Path.iter_segments : for details of the keyword arguments.\n        \"\"\"\n        vertices, codes = _path.cleanup_path(\n            self, transform, remove_nans, clip, snap, stroke_width, simplify,\n            curves, sketch)\n        pth = Path._fast_from_codes_and_verts(vertices, codes, self)\n        if not simplify:\n            pth._should_simplify = False\n        return pth",
        "begin_line": 418,
        "end_line": 435,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00037778617302606723,
            "pseudo_dstar_susp": 0.00034916201117318437,
            "pseudo_tarantula_susp": 0.0007358351729212656,
            "pseudo_op2_susp": 0.00034916201117318437,
            "pseudo_barinel_susp": 0.0007358351729212656
        }
    },
    {
        "name": "lib.matplotlib.path.Path.transformed#437",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.transformed(self, transform)",
        "snippet": "    def transformed(self, transform):\n        \"\"\"\n        Return a transformed copy of the path.\n\n        See Also\n        --------\n        matplotlib.transforms.TransformedPath\n            A specialized path class that will cache the transformed result and\n            automatically update when the transform changes.\n        \"\"\"\n        return Path(transform.transform(self.vertices), self.codes,\n                    self._interpolation_steps)",
        "begin_line": 437,
        "end_line": 448,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005107252298263534,
            "pseudo_dstar_susp": 0.0004073319755600815,
            "pseudo_tarantula_susp": 0.0018726591760299626,
            "pseudo_op2_susp": 0.0004073319755600815,
            "pseudo_barinel_susp": 0.0018726591760299626
        }
    },
    {
        "name": "lib.matplotlib.path.Path.contains_point#450",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.contains_point(self, point, transform=None, radius=0.0)",
        "snippet": "    def contains_point(self, point, transform=None, radius=0.0):\n        \"\"\"\n        Return whether the (closed) path contains the given point.\n\n        Parameters\n        ----------\n        point : (float, float)\n            The point (x, y) to check.\n        transform : `matplotlib.transforms.Transform`, optional\n            If not ``None``, *point* will be compared to ``self`` transformed\n            by *transform*; i.e. for a correct check, *transform* should\n            transform the path into the coordinate system of *point*.\n        radius : float, default: 0\n            Add an additional margin on the path in coordinates of *point*.\n            The path is extended tangentially by *radius/2*; i.e. if you would\n            draw the path with a linewidth of *radius*, all points on the line\n            would still be considered to be contained in the area. Conversely,\n            negative values shrink the area: Points on the imaginary line\n            will be considered outside the area.\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        if transform is not None:\n            transform = transform.frozen()\n        # `point_in_path` does not handle nonlinear transforms, so we\n        # transform the path ourselves.  If *transform* is affine, letting\n        # `point_in_path` handle the transform avoids allocating an extra\n        # buffer.\n        if transform and not transform.is_affine:\n            self = transform.transform_path(self)\n            transform = None\n        return _path.point_in_path(point[0], point[1], radius, self, transform)",
        "begin_line": 450,
        "end_line": 483,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.path.Path.contains_points#485",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.contains_points(self, points, transform=None, radius=0.0)",
        "snippet": "    def contains_points(self, points, transform=None, radius=0.0):\n        \"\"\"\n        Return whether the (closed) path contains the given point.\n\n        Parameters\n        ----------\n        points : (N, 2) array\n            The points to check. Columns contain x and y values.\n        transform : `matplotlib.transforms.Transform`, optional\n            If not ``None``, *points* will be compared to ``self`` transformed\n            by *transform*; i.e. for a correct check, *transform* should\n            transform the path into the coordinate system of *points*.\n        radius : float, default: 0.\n            Add an additional margin on the path in coordinates of *points*.\n            The path is extended tangentially by *radius/2*; i.e. if you would\n            draw the path with a linewidth of *radius*, all points on the line\n            would still be considered to be contained in the area. Conversely,\n            negative values shrink the area: Points on the imaginary line\n            will be considered outside the area.\n\n        Returns\n        -------\n        length-N bool array\n        \"\"\"\n        if transform is not None:\n            transform = transform.frozen()\n        result = _path.points_in_path(points, radius, self, transform)\n        return result.astype('bool')",
        "begin_line": 485,
        "end_line": 512,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.path.Path.get_extents#525",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.get_extents(self, transform=None)",
        "snippet": "    def get_extents(self, transform=None):\n        \"\"\"\n        Returns the extents (*xmin*, *ymin*, *xmax*, *ymax*) of the path.\n\n        Unlike computing the extents on the *vertices* alone, this\n        algorithm will take into account the curves and deal with\n        control points appropriately.\n        \"\"\"\n        from .transforms import Bbox\n        path = self\n        if transform is not None:\n            transform = transform.frozen()\n            if not transform.is_affine:\n                path = self.transformed(transform)\n                transform = None\n        return Bbox(_path.get_path_extents(path, transform))",
        "begin_line": 525,
        "end_line": 540,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00031969309462915604,
            "pseudo_dstar_susp": 0.00031279324366593683,
            "pseudo_tarantula_susp": 0.0003937007874015748,
            "pseudo_op2_susp": 0.00031279324366593683,
            "pseudo_barinel_susp": 0.0003937007874015748
        }
    },
    {
        "name": "lib.matplotlib.path.Path.intersects_bbox#552",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.intersects_bbox(self, bbox, filled=True)",
        "snippet": "    def intersects_bbox(self, bbox, filled=True):\n        \"\"\"\n        Returns whether this path intersects a given `~.transforms.Bbox`.\n\n        *filled*, when True, treats the path as if it was filled.\n        That is, if the path completely encloses the bounding box,\n        :meth:`intersects_bbox` will return True.\n\n        The bounding box is always considered filled.\n        \"\"\"\n        return _path.path_intersects_rectangle(\n            self, bbox.x0, bbox.y0, bbox.x1, bbox.y1, filled)",
        "begin_line": 552,
        "end_line": 563,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.path.Path.to_polygons#583",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.to_polygons(self, transform=None, width=0, height=0, closed_only=True)",
        "snippet": "    def to_polygons(self, transform=None, width=0, height=0, closed_only=True):\n        \"\"\"\n        Convert this path to a list of polygons or polylines.  Each\n        polygon/polyline is an Nx2 array of vertices.  In other words,\n        each polygon has no ``MOVETO`` instructions or curves.  This\n        is useful for displaying in backends that do not support\n        compound paths or Bezier curves.\n\n        If *width* and *height* are both non-zero then the lines will\n        be simplified so that vertices outside of (0, 0), (width,\n        height) will be clipped.\n\n        If *closed_only* is `True` (default), only closed polygons,\n        with the last point being the same as the first point, will be\n        returned.  Any unclosed polylines in the path will be\n        explicitly closed.  If *closed_only* is `False`, any unclosed\n        polygons in the path will be returned as unclosed polygons,\n        and the closed polygons will be returned explicitly closed by\n        setting the last point to the same as the first point.\n        \"\"\"\n        if len(self.vertices) == 0:\n            return []\n\n        if transform is not None:\n            transform = transform.frozen()\n\n        if self.codes is None and (width == 0 or height == 0):\n            vertices = self.vertices\n            if closed_only:\n                if len(vertices) < 3:\n                    return []\n                elif np.any(vertices[0] != vertices[-1]):\n                    vertices = [*vertices, vertices[0]]\n\n            if transform is None:\n                return [vertices]\n            else:\n                return [transform.transform(vertices)]\n\n        # Deal with the case where there are curves and/or multiple\n        # subpaths (using extension code)\n        return _path.convert_path_to_polygons(\n            self, transform, width, height, closed_only)",
        "begin_line": 583,
        "end_line": 625,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.path.Path.unit_rectangle#630",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.unit_rectangle(cls)",
        "snippet": "    def unit_rectangle(cls):\n        \"\"\"\n        Return a `Path` instance of the unit rectangle from (0, 0) to (1, 1).\n        \"\"\"\n        if cls._unit_rectangle is None:\n            cls._unit_rectangle = cls([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]],\n                                      closed=True, readonly=True)\n        return cls._unit_rectangle",
        "begin_line": 630,
        "end_line": 637,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00032808398950131233,
            "pseudo_dstar_susp": 0.0004977600796416127,
            "pseudo_tarantula_susp": 0.000341180484476288,
            "pseudo_op2_susp": 0.0004977600796416127,
            "pseudo_barinel_susp": 0.000341180484476288
        }
    },
    {
        "name": "lib.matplotlib.path.Path.unit_regular_polygon#642",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.unit_regular_polygon(cls, numVertices)",
        "snippet": "    def unit_regular_polygon(cls, numVertices):\n        \"\"\"\n        Return a :class:`Path` instance for a unit regular polygon with the\n        given *numVertices* and radius of 1.0, centered at (0, 0).\n        \"\"\"\n        if numVertices <= 16:\n            path = cls._unit_regular_polygons.get(numVertices)\n        else:\n            path = None\n        if path is None:\n            theta = ((2 * np.pi / numVertices) * np.arange(numVertices + 1)\n                     # This initial rotation is to make sure the polygon always\n                     # \"points-up\".\n                     + np.pi / 2)\n            verts = np.column_stack((np.cos(theta), np.sin(theta)))\n            path = cls(verts, closed=True, readonly=True)\n            if numVertices <= 16:\n                cls._unit_regular_polygons[numVertices] = path\n        return path",
        "begin_line": 642,
        "end_line": 660,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.path.Path.unit_circle#699",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.unit_circle(cls)",
        "snippet": "    def unit_circle(cls):\n        \"\"\"\n        Return the readonly :class:`Path` of the unit circle.\n\n        For most cases, :func:`Path.circle` will be what you want.\n        \"\"\"\n        if cls._unit_circle is None:\n            cls._unit_circle = cls.circle(center=(0, 0), radius=1,\n                                          readonly=True)\n        return cls._unit_circle",
        "begin_line": 699,
        "end_line": 708,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00037778617302606723,
            "pseudo_dstar_susp": 0.00034916201117318437,
            "pseudo_tarantula_susp": 0.0007358351729212656,
            "pseudo_op2_susp": 0.00034916201117318437,
            "pseudo_barinel_susp": 0.0007358351729212656
        }
    },
    {
        "name": "lib.matplotlib.path.Path.circle#711",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.circle(cls, center=(0.0, 0.0), radius=1.0, readonly=False)",
        "snippet": "    def circle(cls, center=(0., 0.), radius=1., readonly=False):\n        \"\"\"\n        Return a `Path` representing a circle of a given radius and center.\n\n        Parameters\n        ----------\n        center : (float, float), default: (0, 0)\n            The center of the circle.\n        radius : float, default: 1\n            The radius of the circle.\n        readonly : bool\n            Whether the created path should have the \"readonly\" argument\n            set when creating the Path instance.\n\n        Notes\n        -----\n        The circle is approximated using 8 cubic Bezier curves, as described in\n\n          Lancaster, Don.  `Approximating a Circle or an Ellipse Using Four\n          Bezier Cubic Splines <http://www.tinaja.com/glib/ellipse4.pdf>`_.\n        \"\"\"\n        MAGIC = 0.2652031\n        SQRTHALF = np.sqrt(0.5)\n        MAGIC45 = SQRTHALF * MAGIC\n\n        vertices = np.array([[0.0, -1.0],\n\n                             [MAGIC, -1.0],\n                             [SQRTHALF-MAGIC45, -SQRTHALF-MAGIC45],\n                             [SQRTHALF, -SQRTHALF],\n\n                             [SQRTHALF+MAGIC45, -SQRTHALF+MAGIC45],\n                             [1.0, -MAGIC],\n                             [1.0, 0.0],\n\n                             [1.0, MAGIC],\n                             [SQRTHALF+MAGIC45, SQRTHALF-MAGIC45],\n                             [SQRTHALF, SQRTHALF],\n\n                             [SQRTHALF-MAGIC45, SQRTHALF+MAGIC45],\n                             [MAGIC, 1.0],\n                             [0.0, 1.0],\n\n                             [-MAGIC, 1.0],\n                             [-SQRTHALF+MAGIC45, SQRTHALF+MAGIC45],\n                             [-SQRTHALF, SQRTHALF],\n\n                             [-SQRTHALF-MAGIC45, SQRTHALF-MAGIC45],\n                             [-1.0, MAGIC],\n                             [-1.0, 0.0],\n\n                             [-1.0, -MAGIC],\n                             [-SQRTHALF-MAGIC45, -SQRTHALF+MAGIC45],\n                             [-SQRTHALF, -SQRTHALF],\n\n                             [-SQRTHALF+MAGIC45, -SQRTHALF-MAGIC45],\n                             [-MAGIC, -1.0],\n                             [0.0, -1.0],\n\n                             [0.0, -1.0]],\n                            dtype=float)\n\n        codes = [cls.CURVE4] * 26\n        codes[0] = cls.MOVETO\n        codes[-1] = cls.CLOSEPOLY\n        return Path(vertices * radius + center, codes, readonly=readonly)",
        "begin_line": 711,
        "end_line": 776,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.path.Path.arc#823",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path.Path",
        "signature": "lib.matplotlib.path.Path.arc(cls, theta1, theta2, n=None, is_wedge=False)",
        "snippet": "    def arc(cls, theta1, theta2, n=None, is_wedge=False):\n        \"\"\"\n        Return the unit circle arc from angles *theta1* to *theta2* (in\n        degrees).\n\n        *theta2* is unwrapped to produce the shortest arc within 360 degrees.\n        That is, if *theta2* > *theta1* + 360, the arc will be from *theta1* to\n        *theta2* - 360 and not a full circle plus some extra overlap.\n\n        If *n* is provided, it is the number of spline segments to make.\n        If *n* is not provided, the number of spline segments is\n        determined based on the delta between *theta1* and *theta2*.\n\n           Masionobe, L.  2003.  `Drawing an elliptical arc using\n           polylines, quadratic or cubic Bezier curves\n           <http://www.spaceroots.org/documents/ellipse/index.html>`_.\n        \"\"\"\n        halfpi = np.pi * 0.5\n\n        eta1 = theta1\n        eta2 = theta2 - 360 * np.floor((theta2 - theta1) / 360)\n        # Ensure 2pi range is not flattened to 0 due to floating-point errors,\n        # but don't try to expand existing 0 range.\n        if theta2 != theta1 and eta2 <= eta1:\n            eta2 += 360\n        eta1, eta2 = np.deg2rad([eta1, eta2])\n\n        # number of curve segments to make\n        if n is None:\n            n = int(2 ** np.ceil((eta2 - eta1) / halfpi))\n        if n < 1:\n            raise ValueError(\"n must be >= 1 or None\")\n\n        deta = (eta2 - eta1) / n\n        t = np.tan(0.5 * deta)\n        alpha = np.sin(deta) * (np.sqrt(4.0 + 3.0 * t * t) - 1) / 3.0\n\n        steps = np.linspace(eta1, eta2, n + 1, True)\n        cos_eta = np.cos(steps)\n        sin_eta = np.sin(steps)\n\n        xA = cos_eta[:-1]\n        yA = sin_eta[:-1]\n        xA_dot = -yA\n        yA_dot = xA\n\n        xB = cos_eta[1:]\n        yB = sin_eta[1:]\n        xB_dot = -yB\n        yB_dot = xB\n\n        if is_wedge:\n            length = n * 3 + 4\n            vertices = np.zeros((length, 2), float)\n            codes = np.full(length, cls.CURVE4, dtype=cls.code_type)\n            vertices[1] = [xA[0], yA[0]]\n            codes[0:2] = [cls.MOVETO, cls.LINETO]\n            codes[-2:] = [cls.LINETO, cls.CLOSEPOLY]\n            vertex_offset = 2\n            end = length - 2\n        else:\n            length = n * 3 + 1\n            vertices = np.empty((length, 2), float)\n            codes = np.full(length, cls.CURVE4, dtype=cls.code_type)\n            vertices[0] = [xA[0], yA[0]]\n            codes[0] = cls.MOVETO\n            vertex_offset = 1\n            end = length\n\n        vertices[vertex_offset:end:3, 0] = xA + alpha * xA_dot\n        vertices[vertex_offset:end:3, 1] = yA + alpha * yA_dot\n        vertices[vertex_offset+1:end:3, 0] = xB - alpha * xB_dot\n        vertices[vertex_offset+1:end:3, 1] = yB - alpha * yB_dot\n        vertices[vertex_offset+2:end:3, 0] = xB\n        vertices[vertex_offset+2:end:3, 1] = yB\n\n        return cls(vertices, codes, readonly=True)",
        "begin_line": 823,
        "end_line": 899,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.path.get_path_collection_extents#947",
        "src_path": "lib/matplotlib/path.py",
        "class_name": "lib.matplotlib.path",
        "signature": "lib.matplotlib.path.get_path_collection_extents(master_transform, paths, transforms, offsets, offset_transform)",
        "snippet": "def get_path_collection_extents(\n        master_transform, paths, transforms, offsets, offset_transform):\n    r\"\"\"\n    Given a sequence of `Path`\\s, `~.Transform`\\s objects, and offsets, as\n    found in a `~.PathCollection`, returns the bounding box that encapsulates\n    all of them.\n\n    Parameters\n    ----------\n    master_transform : `~.Transform`\n        Global transformation applied to all paths.\n    paths : list of `Path`\n    transform : list of `~.Affine2D`\n    offsets : (N, 2) array-like\n    offset_transform : `~.Affine2D`\n        Transform applied to the offsets before offsetting the path.\n\n    Notes\n    -----\n    The way that *paths*, *transforms* and *offsets* are combined\n    follows the same method as for collections:  Each is iterated over\n    independently, so if you have 3 paths, 2 transforms and 1 offset,\n    their combinations are as follows:\n\n        (A, A, A), (B, B, A), (C, A, A)\n    \"\"\"\n    from .transforms import Bbox\n    if len(paths) == 0:\n        raise ValueError(\"No paths provided\")\n    return Bbox.from_extents(*_path.get_path_collection_extents(\n        master_transform, paths, np.atleast_3d(transforms),\n        offsets, offset_transform))",
        "begin_line": 947,
        "end_line": 978,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAffine.__init__#116",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAffine",
        "signature": "lib.matplotlib.projections.polar.PolarAffine.__init__(self, scale_transform, limits)",
        "snippet": "    def __init__(self, scale_transform, limits):\n        \"\"\"\n        *limits* is the view limit of the data.  The only part of\n        its bounds that is used is the y limits (for the radius limits).\n        The theta range is handled by the non-affine transform.\n        \"\"\"\n        mtransforms.Affine2DBase.__init__(self)\n        self._scale_transform = scale_transform\n        self._limits = limits\n        self.set_children(scale_transform, limits)\n        self._mtx = None",
        "begin_line": 116,
        "end_line": 126,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.ThetaLocator.set_axis#237",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.ThetaLocator",
        "signature": "lib.matplotlib.projections.polar.ThetaLocator.set_axis(self, axis)",
        "snippet": "    def set_axis(self, axis):\n        self.axis = _AxisWrapper(axis)\n        self.base.set_axis(self.axis)",
        "begin_line": 237,
        "end_line": 239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.46880030300161e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.ThetaTick.__init__#283",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.ThetaTick",
        "signature": "lib.matplotlib.projections.polar.ThetaTick.__init__(self, axes, *args, **kwargs)",
        "snippet": "    def __init__(self, axes, *args, **kwargs):\n        self._text1_translate = mtransforms.ScaledTranslation(\n            0, 0, axes.figure.dpi_scale_trans)\n        self._text2_translate = mtransforms.ScaledTranslation(\n            0, 0, axes.figure.dpi_scale_trans)\n        super().__init__(axes, *args, **kwargs)\n        self.label1.set(\n            rotation_mode='anchor',\n            transform=self.label1.get_transform() + self._text1_translate)\n        self.label2.set(\n            rotation_mode='anchor',\n            transform=self.label2.get_transform() + self._text2_translate)",
        "begin_line": 283,
        "end_line": 294,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.ThetaTick.update_position#315",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.ThetaTick",
        "signature": "lib.matplotlib.projections.polar.ThetaTick.update_position(self, loc)",
        "snippet": "    def update_position(self, loc):\n        super().update_position(loc)\n        axes = self.axes\n        angle = loc * axes.get_theta_direction() + axes.get_theta_offset()\n        text_angle = np.rad2deg(angle) % 360 - 90\n        angle -= np.pi / 2\n\n        marker = self.tick1line.get_marker()\n        if marker in (mmarkers.TICKUP, '|'):\n            trans = mtransforms.Affine2D().scale(1, 1).rotate(angle)\n        elif marker == mmarkers.TICKDOWN:\n            trans = mtransforms.Affine2D().scale(1, -1).rotate(angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick1line._marker._transform\n        self.tick1line._marker._transform = trans\n\n        marker = self.tick2line.get_marker()\n        if marker in (mmarkers.TICKUP, '|'):\n            trans = mtransforms.Affine2D().scale(1, 1).rotate(angle)\n        elif marker == mmarkers.TICKDOWN:\n            trans = mtransforms.Affine2D().scale(1, -1).rotate(angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick2line._marker._transform\n        self.tick2line._marker._transform = trans\n\n        mode, user_angle = self._labelrotation\n        if mode == 'default':\n            text_angle = user_angle\n        else:\n            if text_angle > 90:\n                text_angle -= 180\n            elif text_angle < -90:\n                text_angle += 180\n            text_angle += user_angle\n        self.label1.set_rotation(text_angle)\n        self.label2.set_rotation(text_angle)\n\n        # This extra padding helps preserve the look from previous releases but\n        # is also needed because labels are anchored to their center.\n        pad = self._pad + 7\n        self._update_padding(pad,\n                             self._loc * axes.get_theta_direction() +\n                             axes.get_theta_offset())",
        "begin_line": 315,
        "end_line": 359,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.RadialLocator.__init__#417",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.RadialLocator",
        "signature": "lib.matplotlib.projections.polar.RadialLocator.__init__(self, base, axes=None)",
        "snippet": "    def __init__(self, base, axes=None):\n        self.base = base\n        self._axes = axes",
        "begin_line": 417,
        "end_line": 419,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.RadialLocator.nonsingular#450",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.RadialLocator",
        "signature": "lib.matplotlib.projections.polar.RadialLocator.nonsingular(self, vmin, vmax)",
        "snippet": "    def nonsingular(self, vmin, vmax):\n        # docstring inherited\n        return ((0, 1) if (vmin, vmax) == (-np.inf, np.inf)  # Init. limits.\n                else self.base.nonsingular(vmin, vmax))",
        "begin_line": 450,
        "end_line": 453,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar._ThetaShift.__init__#479",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar._ThetaShift",
        "signature": "lib.matplotlib.projections.polar._ThetaShift.__init__(self, axes, pad, mode)",
        "snippet": "    def __init__(self, axes, pad, mode):\n        mtransforms.ScaledTranslation.__init__(self, pad, pad,\n                                               axes.figure.dpi_scale_trans)\n        self.set_children(axes._realViewLim)\n        self.axes = axes\n        self.mode = mode\n        self.pad = pad",
        "begin_line": 479,
        "end_line": 485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.RadialTick._determine_anchor#530",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.RadialTick",
        "signature": "lib.matplotlib.projections.polar.RadialTick._determine_anchor(self, mode, angle, start)",
        "snippet": "    def _determine_anchor(self, mode, angle, start):\n        # Note: angle is the (spine angle - 90) because it's used for the tick\n        # & text setup, so all numbers below are -90 from (normed) spine angle.\n        if mode == 'auto':\n            if start:\n                if -90 <= angle <= 90:\n                    return 'left', 'center'\n                else:\n                    return 'right', 'center'\n            else:\n                if -90 <= angle <= 90:\n                    return 'right', 'center'\n                else:\n                    return 'left', 'center'\n        else:\n            if start:\n                if angle < -68.5:\n                    return 'center', 'top'\n                elif angle < -23.5:\n                    return 'left', 'top'\n                elif angle < 22.5:\n                    return 'left', 'center'\n                elif angle < 67.5:\n                    return 'left', 'bottom'\n                elif angle < 112.5:\n                    return 'center', 'bottom'\n                elif angle < 157.5:\n                    return 'right', 'bottom'\n                elif angle < 202.5:\n                    return 'right', 'center'\n                elif angle < 247.5:\n                    return 'right', 'top'\n                else:\n                    return 'center', 'top'\n            else:\n                if angle < -68.5:\n                    return 'center', 'bottom'\n                elif angle < -23.5:\n                    return 'right', 'bottom'\n                elif angle < 22.5:\n                    return 'right', 'center'\n                elif angle < 67.5:\n                    return 'right', 'top'\n                elif angle < 112.5:\n                    return 'center', 'top'\n                elif angle < 157.5:\n                    return 'left', 'top'\n                elif angle < 202.5:\n                    return 'left', 'center'\n                elif angle < 247.5:\n                    return 'left', 'bottom'\n                else:\n                    return 'center', 'bottom'",
        "begin_line": 530,
        "end_line": 582,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.RadialTick.update_position#584",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.RadialTick",
        "signature": "lib.matplotlib.projections.polar.RadialTick.update_position(self, loc)",
        "snippet": "    def update_position(self, loc):\n        super().update_position(loc)\n        axes = self.axes\n        thetamin = axes.get_thetamin()\n        thetamax = axes.get_thetamax()\n        direction = axes.get_theta_direction()\n        offset_rad = axes.get_theta_offset()\n        offset = np.rad2deg(offset_rad)\n        full = _is_full_circle_deg(thetamin, thetamax)\n\n        if full:\n            angle = (axes.get_rlabel_position() * direction +\n                     offset) % 360 - 90\n            tick_angle = 0\n        else:\n            angle = (thetamin * direction + offset) % 360 - 90\n            if direction > 0:\n                tick_angle = np.deg2rad(angle)\n            else:\n                tick_angle = np.deg2rad(angle + 180)\n        text_angle = (angle + 90) % 180 - 90  # between -90 and +90.\n        mode, user_angle = self._labelrotation\n        if mode == 'auto':\n            text_angle += user_angle\n        else:\n            text_angle = user_angle\n\n        if full:\n            ha = self.label1.get_horizontalalignment()\n            va = self.label1.get_verticalalignment()\n        else:\n            ha, va = self._determine_anchor(mode, angle, direction > 0)\n        self.label1.set_horizontalalignment(ha)\n        self.label1.set_verticalalignment(va)\n        self.label1.set_rotation(text_angle)\n\n        marker = self.tick1line.get_marker()\n        if marker == mmarkers.TICKLEFT:\n            trans = mtransforms.Affine2D().rotate(tick_angle)\n        elif marker == '_':\n            trans = mtransforms.Affine2D().rotate(tick_angle + np.pi / 2)\n        elif marker == mmarkers.TICKRIGHT:\n            trans = mtransforms.Affine2D().scale(-1, 1).rotate(tick_angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick1line._marker._transform\n        self.tick1line._marker._transform = trans\n\n        if full:\n            self.label2.set_visible(False)\n            self.tick2line.set_visible(False)\n        angle = (thetamax * direction + offset) % 360 - 90\n        if direction > 0:\n            tick_angle = np.deg2rad(angle)\n        else:\n            tick_angle = np.deg2rad(angle + 180)\n        text_angle = (angle + 90) % 180 - 90  # between -90 and +90.\n        mode, user_angle = self._labelrotation\n        if mode == 'auto':\n            text_angle += user_angle\n        else:\n            text_angle = user_angle\n\n        ha, va = self._determine_anchor(mode, angle, direction < 0)\n        self.label2.set_ha(ha)\n        self.label2.set_va(va)\n        self.label2.set_rotation(text_angle)\n\n        marker = self.tick2line.get_marker()\n        if marker == mmarkers.TICKLEFT:\n            trans = mtransforms.Affine2D().rotate(tick_angle)\n        elif marker == '_':\n            trans = mtransforms.Affine2D().rotate(tick_angle + np.pi / 2)\n        elif marker == mmarkers.TICKRIGHT:\n            trans = mtransforms.Affine2D().scale(-1, 1).rotate(tick_angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick2line._marker._transform\n        self.tick2line._marker._transform = trans",
        "begin_line": 584,
        "end_line": 662,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.RadialAxis.cla#691",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.RadialAxis",
        "signature": "lib.matplotlib.projections.polar.RadialAxis.cla(self)",
        "snippet": "    def cla(self):\n        super().cla()\n        self.set_ticks_position('none')\n        self._wrap_locator_formatter()",
        "begin_line": 691,
        "end_line": 694,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.cla#795",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.cla(self)",
        "snippet": "    def cla(self):\n        Axes.cla(self)\n\n        self.title.set_y(1.05)\n\n        start = self.spines.get('start', None)\n        if start:\n            start.set_visible(False)\n        end = self.spines.get('end', None)\n        if end:\n            end.set_visible(False)\n        self.set_xlim(0.0, 2 * np.pi)\n\n        self.grid(rcParams['polaraxes.grid'])\n        inner = self.spines.get('inner', None)\n        if inner:\n            inner.set_visible(False)\n\n        self.set_rorigin(None)\n        self.set_theta_offset(self._default_theta_offset)\n        self.set_theta_direction(self._default_theta_direction)",
        "begin_line": 795,
        "end_line": 815,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000708215297450425,
            "pseudo_dstar_susp": 0.0004268032437046522,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0004268032437046522,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes._init_axis#817",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes._init_axis(self)",
        "snippet": "    def _init_axis(self):\n        # This is moved out of __init__ because non-separable axes don't use it\n        self.xaxis = ThetaAxis(self)\n        self.yaxis = RadialAxis(self)\n        # Calling polar_axes.xaxis.cla() or polar_axes.xaxis.cla()\n        # results in weird artifacts. Therefore we disable this for\n        # now.\n        # self.spines['polar'].register_axis(self.yaxis)\n        self._update_transScale()",
        "begin_line": 817,
        "end_line": 825,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes._set_lim_and_transforms#827",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes._set_lim_and_transforms(self)",
        "snippet": "    def _set_lim_and_transforms(self):\n        # A view limit where the minimum radius can be locked if the user\n        # specifies an alternate origin.\n        self._originViewLim = mtransforms.LockableBbox(self.viewLim)\n\n        # Handle angular offset and direction.\n        self._direction = mtransforms.Affine2D() \\\n            .scale(self._default_theta_direction, 1.0)\n        self._theta_offset = mtransforms.Affine2D() \\\n            .translate(self._default_theta_offset, 0.0)\n        self.transShift = self._direction + self._theta_offset\n        # A view limit shifted to the correct location after accounting for\n        # orientation and offset.\n        self._realViewLim = mtransforms.TransformedBbox(self.viewLim,\n                                                        self.transShift)\n\n        # Transforms the x and y axis separately by a scale factor\n        # It is assumed that this part will have non-linear components\n        self.transScale = mtransforms.TransformWrapper(\n            mtransforms.IdentityTransform())\n\n        # Scale view limit into a bbox around the selected wedge. This may be\n        # smaller than the usual unit axes rectangle if not plotting the full\n        # circle.\n        self.axesLim = _WedgeBbox((0.5, 0.5),\n                                  self._realViewLim, self._originViewLim)\n\n        # Scale the wedge to fill the axes.\n        self.transWedge = mtransforms.BboxTransformFrom(self.axesLim)\n\n        # Scale the axes to fill the figure.\n        self.transAxes = mtransforms.BboxTransformTo(self.bbox)\n\n        # A (possibly non-linear) projection on the (already scaled)\n        # data.  This one is aware of rmin\n        self.transProjection = self.PolarTransform(\n            self,\n            _apply_theta_transforms=False)\n        # Add dependency on rorigin.\n        self.transProjection.set_children(self._originViewLim)\n\n        # An affine transformation on the data, generally to limit the\n        # range of the axes\n        self.transProjectionAffine = self.PolarAffine(self.transScale,\n                                                      self._originViewLim)\n\n        # The complete data transformation stack -- from data all the\n        # way to display coordinates\n        self.transData = (\n            self.transScale + self.transShift + self.transProjection +\n            (self.transProjectionAffine + self.transWedge + self.transAxes))\n\n        # This is the transform for theta-axis ticks.  It is\n        # equivalent to transData, except it always puts r == 0.0 and r == 1.0\n        # at the edge of the axis circles.\n        self._xaxis_transform = (\n            mtransforms.blended_transform_factory(\n                mtransforms.IdentityTransform(),\n                mtransforms.BboxTransformTo(self.viewLim)) +\n            self.transData)\n        # The theta labels are flipped along the radius, so that text 1 is on\n        # the outside by default. This should work the same as before.\n        flipr_transform = mtransforms.Affine2D() \\\n            .translate(0.0, -0.5) \\\n            .scale(1.0, -1.0) \\\n            .translate(0.0, 0.5)\n        self._xaxis_text_transform = flipr_transform + self._xaxis_transform\n\n        # This is the transform for r-axis ticks.  It scales the theta\n        # axis so the gridlines from 0.0 to 1.0, now go from thetamin to\n        # thetamax.\n        self._yaxis_transform = (\n            mtransforms.blended_transform_factory(\n                mtransforms.BboxTransformTo(self.viewLim),\n                mtransforms.IdentityTransform()) +\n            self.transData)\n        # The r-axis labels are put at an angle and padded in the r-direction\n        self._r_label_position = mtransforms.Affine2D() \\\n            .translate(self._default_rlabel_position, 0.0)\n        self._yaxis_text_transform = mtransforms.TransformWrapper(\n            self._r_label_position + self.transData)",
        "begin_line": 827,
        "end_line": 907,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_transform#909",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_transform(self, which='grid')",
        "snippet": "    def get_xaxis_transform(self, which='grid'):\n        cbook._check_in_list(['tick1', 'tick2', 'grid'], which=which)\n        return self._xaxis_transform",
        "begin_line": 909,
        "end_line": 911,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text1_transform#913",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text1_transform(self, pad)",
        "snippet": "    def get_xaxis_text1_transform(self, pad):\n        return self._xaxis_text_transform, 'center', 'center'",
        "begin_line": 913,
        "end_line": 914,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text2_transform#916",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text2_transform(self, pad)",
        "snippet": "    def get_xaxis_text2_transform(self, pad):\n        return self._xaxis_text_transform, 'center', 'center'",
        "begin_line": 916,
        "end_line": 917,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_transform#919",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_transform(self, which='grid')",
        "snippet": "    def get_yaxis_transform(self, which='grid'):\n        if which in ('tick1', 'tick2'):\n            return self._yaxis_text_transform\n        elif which == 'grid':\n            return self._yaxis_transform\n        else:\n            cbook._check_in_list(['tick1', 'tick2', 'grid'], which=which)",
        "begin_line": 919,
        "end_line": 925,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.draw#950",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.draw(self, renderer, *args, **kwargs)",
        "snippet": "    def draw(self, renderer, *args, **kwargs):\n        thetamin, thetamax = np.rad2deg(self._realViewLim.intervalx)\n        if thetamin > thetamax:\n            thetamin, thetamax = thetamax, thetamin\n        rmin, rmax = ((self._realViewLim.intervaly - self.get_rorigin()) *\n                      self.get_rsign())\n        if isinstance(self.patch, mpatches.Wedge):\n            # Backwards-compatibility: Any subclassed Axes might override the\n            # patch to not be the Wedge that PolarAxes uses.\n            center = self.transWedge.transform((0.5, 0.5))\n            self.patch.set_center(center)\n            self.patch.set_theta1(thetamin)\n            self.patch.set_theta2(thetamax)\n\n            edge, _ = self.transWedge.transform((1, 0))\n            radius = edge - center[0]\n            width = min(radius * (rmax - rmin) / rmax, radius)\n            self.patch.set_radius(radius)\n            self.patch.set_width(width)\n\n            inner_width = radius - width\n            inner = self.spines.get('inner', None)\n            if inner:\n                inner.set_visible(inner_width != 0.0)\n\n        visible = not _is_full_circle_deg(thetamin, thetamax)\n        # For backwards compatibility, any subclassed Axes might override the\n        # spines to not include start/end that PolarAxes uses.\n        start = self.spines.get('start', None)\n        end = self.spines.get('end', None)\n        if start:\n            start.set_visible(visible)\n        if end:\n            end.set_visible(visible)\n        if visible:\n            yaxis_text_transform = self._yaxis_transform\n        else:\n            yaxis_text_transform = self._r_label_position + self.transData\n        if self._yaxis_text_transform != yaxis_text_transform:\n            self._yaxis_text_transform.set(yaxis_text_transform)\n            self.yaxis.reset_ticks()\n            self.yaxis.set_clip_path(self.patch)\n\n        Axes.draw(self, renderer, *args, **kwargs)",
        "begin_line": 950,
        "end_line": 993,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes._gen_axes_patch#995",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes._gen_axes_patch(self)",
        "snippet": "    def _gen_axes_patch(self):\n        return mpatches.Wedge((0.5, 0.5), 0.5, 0.0, 360.0)",
        "begin_line": 995,
        "end_line": 996,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes._gen_axes_spines#998",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes._gen_axes_spines(self)",
        "snippet": "    def _gen_axes_spines(self):\n        spines = OrderedDict([\n            ('polar', mspines.Spine.arc_spine(self, 'top',\n                                              (0.5, 0.5), 0.5, 0.0, 360.0)),\n            ('start', mspines.Spine.linear_spine(self, 'left')),\n            ('end', mspines.Spine.linear_spine(self, 'right')),\n            ('inner', mspines.Spine.arc_spine(self, 'bottom',\n                                              (0.5, 0.5), 0.0, 0.0, 360.0))\n        ])\n        spines['polar'].set_transform(self.transWedge + self.transAxes)\n        spines['inner'].set_transform(self.transWedge + self.transAxes)\n        spines['start'].set_transform(self._yaxis_transform)\n        spines['end'].set_transform(self._yaxis_transform)\n        return spines",
        "begin_line": 998,
        "end_line": 1011,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.get_thetamin#1025",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.get_thetamin(self)",
        "snippet": "    def get_thetamin(self):\n        \"\"\"Get the minimum theta limit in degrees.\"\"\"\n        return np.rad2deg(self.viewLim.xmin)",
        "begin_line": 1025,
        "end_line": 1027,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.get_rmin#1150",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.get_rmin(self)",
        "snippet": "    def get_rmin(self):\n        \"\"\"\n        Returns\n        -------\n        float\n            The inner radial limit.\n        \"\"\"\n        return self.viewLim.ymin",
        "begin_line": 1150,
        "end_line": 1157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.set_rorigin#1159",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.set_rorigin(self, rorigin)",
        "snippet": "    def set_rorigin(self, rorigin):\n        \"\"\"\n        Update the radial origin.\n\n        Parameters\n        ----------\n        rorigin : float\n        \"\"\"\n        self._originViewLim.locked_y0 = rorigin",
        "begin_line": 1159,
        "end_line": 1167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000708215297450425,
            "pseudo_dstar_susp": 0.0004268032437046522,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0004268032437046522,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.set_ylim#1199",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.set_ylim(self, bottom=None, top=None, emit=True, auto=False, *, ymin=None, ymax=None)",
        "snippet": "    def set_ylim(self, bottom=None, top=None, emit=True, auto=False,\n                 *, ymin=None, ymax=None):\n        \"\"\"\n        Set the data limits for the radial axis.\n\n        Parameters\n        ----------\n        bottom : scalar, optional\n            The bottom limit (default: None, which leaves the bottom\n            limit unchanged).\n            The bottom and top ylims may be passed as the tuple\n            (*bottom*, *top*) as the first positional argument (or as\n            the *bottom* keyword argument).\n\n        top : scalar, optional\n            The top limit (default: None, which leaves the top limit\n            unchanged).\n\n        emit : bool, default: True\n            Whether to notify observers of limit change.\n\n        auto : bool or None, default: False\n            Whether to turn on autoscaling of the y-axis. True turns on,\n            False turns off, None leaves unchanged.\n\n        ymin, ymax : scalar, optional\n            These arguments are deprecated and will be removed in a future\n            version.  They are equivalent to *bottom* and *top* respectively,\n            and it is an error to pass both *ymin* and *bottom* or\n            *ymax* and *top*.\n\n        Returns\n        -------\n        bottom, top : (float, float)\n            The new y-axis limits in data coordinates.\n        \"\"\"\n        if ymin is not None:\n            if bottom is not None:\n                raise ValueError('Cannot supply both positional \"bottom\" '\n                                 'argument and kwarg \"ymin\"')\n            else:\n                bottom = ymin\n        if ymax is not None:\n            if top is not None:\n                raise ValueError('Cannot supply both positional \"top\" '\n                                 'argument and kwarg \"ymax\"')\n            else:\n                top = ymax\n        if top is None and np.iterable(bottom):\n            bottom, top = bottom[0], bottom[1]\n        return super().set_ylim(bottom=bottom, top=top, emit=emit, auto=auto)",
        "begin_line": 1199,
        "end_line": 1249,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.get_rlabel_position#1251",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.get_rlabel_position(self)",
        "snippet": "    def get_rlabel_position(self):\n        \"\"\"\n        Returns\n        -------\n        float\n            The theta position of the radius labels in degrees.\n        \"\"\"\n        return np.rad2deg(self._r_label_position.get_matrix()[0, 2])",
        "begin_line": 1251,
        "end_line": 1258,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.set_rlabel_position#1260",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.set_rlabel_position(self, value)",
        "snippet": "    def set_rlabel_position(self, value):\n        \"\"\"Updates the theta position of the radius labels.\n\n        Parameters\n        ----------\n        value : number\n            The angular position of the radius labels in degrees.\n        \"\"\"\n        self._r_label_position.clear().translate(np.deg2rad(value), 0.0)",
        "begin_line": 1260,
        "end_line": 1268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.polar.PolarAxes.get_data_ratio#1394",
        "src_path": "lib/matplotlib/projections/polar.py",
        "class_name": "lib.matplotlib.projections.polar.PolarAxes",
        "signature": "lib.matplotlib.projections.polar.PolarAxes.get_data_ratio(self)",
        "snippet": "    def get_data_ratio(self):\n        \"\"\"\n        Return the aspect ratio of the data itself.  For a polar plot,\n        this should always be 1.0\n        \"\"\"\n        return 1.0",
        "begin_line": 1394,
        "end_line": 1399,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.hatch.HorizontalHatch.__init__#13",
        "src_path": "lib/matplotlib/hatch.py",
        "class_name": "lib.matplotlib.hatch.HorizontalHatch",
        "signature": "lib.matplotlib.hatch.HorizontalHatch.__init__(self, hatch, density)",
        "snippet": "    def __init__(self, hatch, density):\n        self.num_lines = int((hatch.count('-') + hatch.count('+')) * density)\n        self.num_vertices = self.num_lines * 2",
        "begin_line": 13,
        "end_line": 15,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.hatch.HorizontalHatch.set_vertices_and_codes#17",
        "src_path": "lib/matplotlib/hatch.py",
        "class_name": "lib.matplotlib.hatch.HorizontalHatch",
        "signature": "lib.matplotlib.hatch.HorizontalHatch.set_vertices_and_codes(self, vertices, codes)",
        "snippet": "    def set_vertices_and_codes(self, vertices, codes):\n        steps, stepsize = np.linspace(0.0, 1.0, self.num_lines, False,\n                                      retstep=True)\n        steps += stepsize / 2.\n        vertices[0::2, 0] = 0.0\n        vertices[0::2, 1] = steps\n        vertices[1::2, 0] = 1.0\n        vertices[1::2, 1] = steps\n        codes[0::2] = Path.MOVETO\n        codes[1::2] = Path.LINETO",
        "begin_line": 17,
        "end_line": 26,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.tripcolor.tripcolor#9",
        "src_path": "lib/matplotlib/tri/tripcolor.py",
        "class_name": "lib.matplotlib.tri.tripcolor",
        "signature": "lib.matplotlib.tri.tripcolor.tripcolor(ax, *args, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None, shading='flat', facecolors=None, **kwargs)",
        "snippet": "def tripcolor(ax, *args, alpha=1.0, norm=None, cmap=None, vmin=None,\n              vmax=None, shading='flat', facecolors=None, **kwargs):\n    \"\"\"\n    Create a pseudocolor plot of an unstructured triangular grid.\n\n    The triangulation can be specified in one of two ways; either::\n\n      tripcolor(triangulation, ...)\n\n    where triangulation is a :class:`matplotlib.tri.Triangulation`\n    object, or\n\n    ::\n\n      tripcolor(x, y, ...)\n      tripcolor(x, y, triangles, ...)\n      tripcolor(x, y, triangles=triangles, ...)\n      tripcolor(x, y, mask=mask, ...)\n      tripcolor(x, y, triangles, mask=mask, ...)\n\n    in which case a Triangulation object will be created.  See\n    :class:`~matplotlib.tri.Triangulation` for a explanation of these\n    possibilities.\n\n    The next argument must be *C*, the array of color values, either\n    one per point in the triangulation if color values are defined at\n    points, or one per triangle in the triangulation if color values\n    are defined at triangles. If there are the same number of points\n    and triangles in the triangulation it is assumed that color\n    values are defined at points; to force the use of color values at\n    triangles use the kwarg ``facecolors=C`` instead of just ``C``.\n\n    *shading* may be 'flat' (the default) or 'gouraud'. If *shading*\n    is 'flat' and C values are defined at points, the color values\n    used for each triangle are from the mean C of the triangle's\n    three points. If *shading* is 'gouraud' then color values must be\n    defined at points.\n\n    The remaining kwargs are the same as for\n    :meth:`~matplotlib.axes.Axes.pcolor`.\n    \"\"\"\n    cbook._check_in_list(['flat', 'gouraud'], shading=shading)\n\n    tri, args, kwargs = Triangulation.get_from_args_and_kwargs(*args, **kwargs)\n\n    # C is the colors array defined at either points or faces (i.e. triangles).\n    # If facecolors is None, C are defined at points.\n    # If facecolors is not None, C are defined at faces.\n    if facecolors is not None:\n        C = facecolors\n    else:\n        C = np.asarray(args[0])\n\n    # If there are a different number of points and triangles in the\n    # triangulation, can omit facecolors kwarg as it is obvious from\n    # length of C whether it refers to points or faces.\n    # Do not do this for gouraud shading.\n    if (facecolors is None and len(C) == len(tri.triangles) and\n            len(C) != len(tri.x) and shading != 'gouraud'):\n        facecolors = C\n\n    # Check length of C is OK.\n    if ((facecolors is None and len(C) != len(tri.x)) or\n            (facecolors is not None and len(C) != len(tri.triangles))):\n        raise ValueError('Length of color values array must be the same '\n                         'as either the number of triangulation points '\n                         'or triangles')\n\n    # Handling of linewidths, shading, edgecolors and antialiased as\n    # in Axes.pcolor\n    linewidths = (0.25,)\n    if 'linewidth' in kwargs:\n        kwargs['linewidths'] = kwargs.pop('linewidth')\n    kwargs.setdefault('linewidths', linewidths)\n\n    edgecolors = 'none'\n    if 'edgecolor' in kwargs:\n        kwargs['edgecolors'] = kwargs.pop('edgecolor')\n    ec = kwargs.setdefault('edgecolors', edgecolors)\n\n    if 'antialiased' in kwargs:\n        kwargs['antialiaseds'] = kwargs.pop('antialiased')\n    if 'antialiaseds' not in kwargs and ec.lower() == \"none\":\n        kwargs['antialiaseds'] = False\n\n    if shading == 'gouraud':\n        if facecolors is not None:\n            raise ValueError('Gouraud shading does not support the use '\n                             'of facecolors kwarg')\n        if len(C) != len(tri.x):\n            raise ValueError('For gouraud shading, the length of color '\n                             'values array must be the same as the '\n                             'number of triangulation points')\n        collection = TriMesh(tri, **kwargs)\n    else:\n        # Vertices of triangles.\n        maskedTris = tri.get_masked_triangles()\n        verts = np.stack((tri.x[maskedTris], tri.y[maskedTris]), axis=-1)\n\n        # Color values.\n        if facecolors is None:\n            # One color per triangle, the mean of the 3 vertex color values.\n            C = C[maskedTris].mean(axis=1)\n        elif tri.mask is not None:\n            # Remove color values of masked triangles.\n            C = C[~tri.mask]\n\n        collection = PolyCollection(verts, **kwargs)\n\n    collection.set_alpha(alpha)\n    collection.set_array(C)\n    cbook._check_isinstance((Normalize, None), norm=norm)\n    collection.set_cmap(cmap)\n    collection.set_norm(norm)\n    collection._scale_norm(norm, vmin, vmax)\n    ax.grid(False)\n\n    minx = tri.x.min()\n    maxx = tri.x.max()\n    miny = tri.y.min()\n    maxy = tri.y.max()\n    corners = (minx, miny), (maxx, maxy)\n    ax.update_datalim(corners)\n    ax.autoscale_view()\n    ax.add_collection(collection)\n    return collection",
        "begin_line": 9,
        "end_line": 134,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.units.ConversionInterface.is_numlike#141",
        "src_path": "lib/matplotlib/units.py",
        "class_name": "lib.matplotlib.units.ConversionInterface",
        "signature": "lib.matplotlib.units.ConversionInterface.is_numlike(x)",
        "snippet": "    def is_numlike(x):\n        \"\"\"\n        The Matplotlib datalim, autoscaling, locators etc work with scalars\n        which are the units converted to floats given the current unit.  The\n        converter may be passed these floats, or arrays of them, even when\n        units are set.\n        \"\"\"\n        if np.iterable(x):\n            for thisx in x:\n                if thisx is ma.masked:\n                    continue\n                return isinstance(thisx, Number)\n        else:\n            return isinstance(x, Number)",
        "begin_line": 141,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.534091765237701e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.units.Registry.get_converter#196",
        "src_path": "lib/matplotlib/units.py",
        "class_name": "lib.matplotlib.units.Registry",
        "signature": "lib.matplotlib.units.Registry.get_converter(self, x)",
        "snippet": "    def get_converter(self, x):\n        \"\"\"Get the converter interface instance for *x*, or None.\"\"\"\n        if hasattr(x, \"values\"):\n            x = x.values  # Unpack pandas Series and DataFrames.\n        if isinstance(x, np.ndarray):\n            # In case x in a masked array, access the underlying data (only its\n            # type matters).  If x is a regular ndarray, getdata() just returns\n            # the array itself.\n            x = np.ma.getdata(x).ravel()\n            # If there are no elements in x, infer the units from its dtype\n            if not x.size:\n                return self.get_converter(np.array([0], dtype=x.dtype))\n        for cls in type(x).__mro__:  # Look up in the cache.\n            try:\n                return self[cls]\n            except KeyError:\n                pass\n        try:  # If cache lookup fails, look up based on first element...\n            first = cbook.safe_first_element(x)\n        except (TypeError, StopIteration):\n            pass\n        else:\n            # ... and avoid infinite recursion for pathological iterables for\n            # which indexing returns instances of the same iterable class.\n            if type(first) is not type(x):\n                return self.get_converter(first)\n        return None",
        "begin_line": 196,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.244801854669275e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tight_layout._get_left#17",
        "src_path": "lib/matplotlib/tight_layout.py",
        "class_name": "lib.matplotlib.tight_layout",
        "signature": "lib.matplotlib.tight_layout._get_left(tight_bbox, axes_bbox)",
        "snippet": "def _get_left(tight_bbox, axes_bbox):\n    return axes_bbox.xmin - tight_bbox.xmin",
        "begin_line": 17,
        "end_line": 18,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.910273545397844e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tight_layout._get_right#21",
        "src_path": "lib/matplotlib/tight_layout.py",
        "class_name": "lib.matplotlib.tight_layout",
        "signature": "lib.matplotlib.tight_layout._get_right(tight_bbox, axes_bbox)",
        "snippet": "def _get_right(tight_bbox, axes_bbox):\n    return tight_bbox.xmax - axes_bbox.xmax",
        "begin_line": 21,
        "end_line": 22,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.239268352970256e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tight_layout._get_bottom#25",
        "src_path": "lib/matplotlib/tight_layout.py",
        "class_name": "lib.matplotlib.tight_layout",
        "signature": "lib.matplotlib.tight_layout._get_bottom(tight_bbox, axes_bbox)",
        "snippet": "def _get_bottom(tight_bbox, axes_bbox):\n    return axes_bbox.ymin - tight_bbox.ymin",
        "begin_line": 25,
        "end_line": 26,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.239268352970256e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tight_layout._get_top#29",
        "src_path": "lib/matplotlib/tight_layout.py",
        "class_name": "lib.matplotlib.tight_layout",
        "signature": "lib.matplotlib.tight_layout._get_top(tight_bbox, axes_bbox)",
        "snippet": "def _get_top(tight_bbox, axes_bbox):\n    return tight_bbox.ymax - axes_bbox.ymax",
        "begin_line": 29,
        "end_line": 30,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.252867871585376e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tight_layout.auto_adjust_subplotpars#33",
        "src_path": "lib/matplotlib/tight_layout.py",
        "class_name": "lib.matplotlib.tight_layout",
        "signature": "lib.matplotlib.tight_layout.auto_adjust_subplotpars(fig, renderer, nrows_ncols, num1num2_list, subplot_list, ax_bbox_list=None, pad=1.08, h_pad=None, w_pad=None, rect=None)",
        "snippet": "def auto_adjust_subplotpars(\n        fig, renderer, nrows_ncols, num1num2_list, subplot_list,\n        ax_bbox_list=None, pad=1.08, h_pad=None, w_pad=None, rect=None):\n    \"\"\"\n    Return a dict of subplot parameters to adjust spacing between subplots\n    or ``None`` if resulting axes would have zero height or width.\n\n    Note that this function ignores geometry information of subplot\n    itself, but uses what is given by the *nrows_ncols* and *num1num2_list*\n    parameters.  Also, the results could be incorrect if some subplots have\n    ``adjustable=datalim``.\n\n    Parameters\n    ----------\n    nrows_ncols : Tuple[int, int]\n        Number of rows and number of columns of the grid.\n    num1num2_list : List[int]\n        List of numbers specifying the area occupied by the subplot\n    subplot_list : list of subplots\n        List of subplots that will be used to calculate optimal subplot_params.\n    pad : float\n        Padding between the figure edge and the edges of subplots, as a\n        fraction of the font size.\n    h_pad, w_pad : float\n        Padding (height/width) between edges of adjacent subplots, as a\n        fraction of the font size.  Defaults to *pad*.\n    rect : Tuple[float, float, float, float]\n        [left, bottom, right, top] in normalized (0, 1) figure coordinates.\n    \"\"\"\n    rows, cols = nrows_ncols\n\n    font_size_inches = (\n        FontProperties(size=rcParams[\"font.size\"]).get_size_in_points() / 72)\n    pad_inches = pad * font_size_inches\n    if h_pad is not None:\n        vpad_inches = h_pad * font_size_inches\n    else:\n        vpad_inches = pad_inches\n\n    if w_pad is not None:\n        hpad_inches = w_pad * font_size_inches\n    else:\n        hpad_inches = pad_inches\n\n    if len(num1num2_list) != len(subplot_list) or len(subplot_list) == 0:\n        raise ValueError\n\n    if rect is None:\n        margin_left = margin_bottom = margin_right = margin_top = None\n    else:\n        margin_left, margin_bottom, _right, _top = rect\n        if _right:\n            margin_right = 1 - _right\n        else:\n            margin_right = None\n        if _top:\n            margin_top = 1 - _top\n        else:\n            margin_top = None\n\n    vspaces = [[] for _ in range((rows + 1) * cols)]\n    hspaces = [[] for _ in range(rows * (cols + 1))]\n\n    union = Bbox.union\n\n    if ax_bbox_list is None:\n        ax_bbox_list = [\n            union([ax.get_position(original=True) for ax in subplots])\n            for subplots in subplot_list]\n\n    for subplots, ax_bbox, (num1, num2) in zip(subplot_list,\n                                               ax_bbox_list,\n                                               num1num2_list):\n        if all(not ax.get_visible() for ax in subplots):\n            continue\n\n        tight_bbox_raw = union([ax.get_tightbbox(renderer) for ax in subplots\n                                if ax.get_visible()])\n        tight_bbox = TransformedBbox(tight_bbox_raw,\n                                     fig.transFigure.inverted())\n\n        row1, col1 = divmod(num1, cols)\n\n        if num2 is None:\n            # left\n            hspaces[row1 * (cols + 1) + col1].append(\n                                        _get_left(tight_bbox, ax_bbox))\n            # right\n            hspaces[row1 * (cols + 1) + (col1 + 1)].append(\n                                        _get_right(tight_bbox, ax_bbox))\n            # top\n            vspaces[row1 * cols + col1].append(\n                                        _get_top(tight_bbox, ax_bbox))\n            # bottom\n            vspaces[(row1 + 1) * cols + col1].append(\n                                        _get_bottom(tight_bbox, ax_bbox))\n\n        else:\n            row2, col2 = divmod(num2, cols)\n\n            for row_i in range(row1, row2 + 1):\n                # left\n                hspaces[row_i * (cols + 1) + col1].append(\n                                    _get_left(tight_bbox, ax_bbox))\n                # right\n                hspaces[row_i * (cols + 1) + (col2 + 1)].append(\n                                    _get_right(tight_bbox, ax_bbox))\n            for col_i in range(col1, col2 + 1):\n                # top\n                vspaces[row1 * cols + col_i].append(\n                                    _get_top(tight_bbox, ax_bbox))\n                # bottom\n                vspaces[(row2 + 1) * cols + col_i].append(\n                                    _get_bottom(tight_bbox, ax_bbox))\n\n    fig_width_inch, fig_height_inch = fig.get_size_inches()\n\n    # margins can be negative for axes with aspect applied. And we\n    # append + [0] to make minimum margins 0\n\n    if not margin_left:\n        margin_left = max([sum(s) for s in hspaces[::cols + 1]] + [0])\n        margin_left += pad_inches / fig_width_inch\n\n    if not margin_right:\n        margin_right = max([sum(s) for s in hspaces[cols::cols + 1]] + [0])\n        margin_right += pad_inches / fig_width_inch\n\n    if not margin_top:\n        margin_top = max([sum(s) for s in vspaces[:cols]] + [0])\n        margin_top += pad_inches / fig_height_inch\n\n    if not margin_bottom:\n        margin_bottom = max([sum(s) for s in vspaces[-cols:]] + [0])\n        margin_bottom += pad_inches / fig_height_inch\n\n    if margin_left + margin_right >= 1:\n        cbook._warn_external('Tight layout not applied. The left and right '\n                             'margins cannot be made large enough to '\n                             'accommodate all axes decorations. ')\n        return None\n    if margin_bottom + margin_top >= 1:\n        cbook._warn_external('Tight layout not applied. The bottom and top '\n                             'margins cannot be made large enough to '\n                             'accommodate all axes decorations. ')\n        return None\n\n    kwargs = dict(left=margin_left,\n                  right=1 - margin_right,\n                  bottom=margin_bottom,\n                  top=1 - margin_top)\n    if cols > 1:\n        hspace = (\n            max(sum(s)\n                for i in range(rows)\n                for s in hspaces[i * (cols + 1) + 1:(i + 1) * (cols + 1) - 1])\n            + hpad_inches / fig_width_inch)\n        # axes widths:\n        h_axes = (1 - margin_right - margin_left - hspace * (cols - 1)) / cols\n        if h_axes < 0:\n            cbook._warn_external('Tight layout not applied. tight_layout '\n                                 'cannot make axes width small enough to '\n                                 'accommodate all axes decorations')\n            return None\n        else:\n            kwargs[\"wspace\"] = hspace / h_axes\n\n    if rows > 1:\n        vspace = (max(sum(s) for s in vspaces[cols:-cols])\n                  + vpad_inches / fig_height_inch)\n        v_axes = (1 - margin_top - margin_bottom - vspace * (rows - 1)) / rows\n        if v_axes < 0:\n            cbook._warn_external('Tight layout not applied. tight_layout '\n                                 'cannot make axes height small enough to '\n                                 'accommodate all axes decorations')\n            return None\n        else:\n            kwargs[\"hspace\"] = vspace / v_axes\n\n    return kwargs",
        "begin_line": 33,
        "end_line": 212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.539709649871905e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tight_layout.get_renderer#215",
        "src_path": "lib/matplotlib/tight_layout.py",
        "class_name": "lib.matplotlib.tight_layout",
        "signature": "lib.matplotlib.tight_layout.get_renderer(fig)",
        "snippet": "def get_renderer(fig):\n    if fig._cachedRenderer:\n        renderer = fig._cachedRenderer\n    else:\n        canvas = fig.canvas\n\n        if canvas and hasattr(canvas, \"get_renderer\"):\n            renderer = canvas.get_renderer()\n        else:  # Some noninteractive backends have no renderer until draw time.\n            cbook._warn_external(\"tight_layout: falling back to Agg renderer\")\n            from matplotlib.backends.backend_agg import FigureCanvasAgg\n            canvas = FigureCanvasAgg(fig)\n            renderer = canvas.get_renderer()\n\n    return renderer",
        "begin_line": 215,
        "end_line": 229,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.007687379884689e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tight_layout.get_subplotspec_list#232",
        "src_path": "lib/matplotlib/tight_layout.py",
        "class_name": "lib.matplotlib.tight_layout",
        "signature": "lib.matplotlib.tight_layout.get_subplotspec_list(axes_list, grid_spec=None)",
        "snippet": "def get_subplotspec_list(axes_list, grid_spec=None):\n    \"\"\"Return a list of subplotspec from the given list of axes.\n\n    For an instance of axes that does not support subplotspec, None is inserted\n    in the list.\n\n    If grid_spec is given, None is inserted for those not from the given\n    grid_spec.\n    \"\"\"\n    subplotspec_list = []\n    for ax in axes_list:\n        axes_or_locator = ax.get_axes_locator()\n        if axes_or_locator is None:\n            axes_or_locator = ax\n\n        if hasattr(axes_or_locator, \"get_subplotspec\"):\n            subplotspec = axes_or_locator.get_subplotspec()\n            subplotspec = subplotspec.get_topmost_subplotspec()\n            gs = subplotspec.get_gridspec()\n            if grid_spec is not None:\n                if gs != grid_spec:\n                    subplotspec = None\n            elif gs.locally_modified_subplot_params():\n                subplotspec = None\n        else:\n            subplotspec = None\n\n        subplotspec_list.append(subplotspec)\n\n    return subplotspec_list",
        "begin_line": 232,
        "end_line": 261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.28332714444857e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tight_layout.get_tight_layout_figure#264",
        "src_path": "lib/matplotlib/tight_layout.py",
        "class_name": "lib.matplotlib.tight_layout",
        "signature": "lib.matplotlib.tight_layout.get_tight_layout_figure(fig, axes_list, subplotspec_list, renderer, pad=1.08, h_pad=None, w_pad=None, rect=None)",
        "snippet": "def get_tight_layout_figure(fig, axes_list, subplotspec_list, renderer,\n                            pad=1.08, h_pad=None, w_pad=None, rect=None):\n    \"\"\"\n    Return subplot parameters for tight-layouted-figure with specified padding.\n\n    Parameters\n    ----------\n    fig : Figure\n    axes_list : list of Axes\n    subplotspec_list : list of `.SubplotSpec`\n        The subplotspecs of each axes.\n    renderer : renderer\n    pad : float\n        Padding between the figure edge and the edges of subplots, as a\n        fraction of the font size.\n    h_pad, w_pad : float\n        Padding (height/width) between edges of adjacent subplots.  Defaults to\n        *pad*.\n    rect : Tuple[float, float, float, float], optional\n        (left, bottom, right, top) rectangle in normalized figure coordinates\n        that the whole subplots area (including labels) will fit into.\n        Defaults to using the entire figure.\n\n    Returns\n    -------\n    subplotspec or None\n        subplotspec kwargs to be passed to `.Figure.subplots_adjust` or\n        None if tight_layout could not be accomplished.\n\n    \"\"\"\n\n    subplot_list = []\n    nrows_list = []\n    ncols_list = []\n    ax_bbox_list = []\n\n    # Multiple axes can share same subplot_interface (e.g., axes_grid1); thus\n    # we need to join them together.\n    subplot_dict = {}\n\n    subplotspec_list2 = []\n\n    for ax, subplotspec in zip(axes_list, subplotspec_list):\n        if subplotspec is None:\n            continue\n\n        subplots = subplot_dict.setdefault(subplotspec, [])\n\n        if not subplots:\n            myrows, mycols, _, _ = subplotspec.get_geometry()\n            nrows_list.append(myrows)\n            ncols_list.append(mycols)\n            subplotspec_list2.append(subplotspec)\n            subplot_list.append(subplots)\n            ax_bbox_list.append(subplotspec.get_position(fig))\n\n        subplots.append(ax)\n\n    if len(nrows_list) == 0 or len(ncols_list) == 0:\n        return {}\n\n    max_nrows = max(nrows_list)\n    max_ncols = max(ncols_list)\n\n    num1num2_list = []\n    for subplotspec in subplotspec_list2:\n        rows, cols, num1, num2 = subplotspec.get_geometry()\n        div_row, mod_row = divmod(max_nrows, rows)\n        div_col, mod_col = divmod(max_ncols, cols)\n        if mod_row != 0:\n            cbook._warn_external('tight_layout not applied: number of rows '\n                                 'in subplot specifications must be '\n                                 'multiples of one another.')\n            return {}\n        if mod_col != 0:\n            cbook._warn_external('tight_layout not applied: number of '\n                                 'columns in subplot specifications must be '\n                                 'multiples of one another.')\n            return {}\n\n        rowNum1, colNum1 = divmod(num1, cols)\n        if num2 is None:\n            rowNum2, colNum2 = rowNum1, colNum1\n        else:\n            rowNum2, colNum2 = divmod(num2, cols)\n\n        num1num2_list.append((rowNum1 * div_row * max_ncols +\n                              colNum1 * div_col,\n                              ((rowNum2 + 1) * div_row - 1) * max_ncols +\n                              (colNum2 + 1) * div_col - 1))\n\n    kwargs = auto_adjust_subplotpars(fig, renderer,\n                                     nrows_ncols=(max_nrows, max_ncols),\n                                     num1num2_list=num1num2_list,\n                                     subplot_list=subplot_list,\n                                     ax_bbox_list=ax_bbox_list,\n                                     pad=pad, h_pad=h_pad, w_pad=w_pad)\n\n    # kwargs can be none if tight_layout fails...\n    if rect is not None and kwargs is not None:\n        # if rect is given, the whole subplots area (including\n        # labels) will fit into the rect instead of the\n        # figure. Note that the rect argument of\n        # *auto_adjust_subplotpars* specify the area that will be\n        # covered by the total area of axes.bbox. Thus we call\n        # auto_adjust_subplotpars twice, where the second run\n        # with adjusted rect parameters.\n\n        left, bottom, right, top = rect\n        if left is not None:\n            left += kwargs[\"left\"]\n        if bottom is not None:\n            bottom += kwargs[\"bottom\"]\n        if right is not None:\n            right -= (1 - kwargs[\"right\"])\n        if top is not None:\n            top -= (1 - kwargs[\"top\"])\n\n        kwargs = auto_adjust_subplotpars(fig, renderer,\n                                         nrows_ncols=(max_nrows, max_ncols),\n                                         num1num2_list=num1num2_list,\n                                         subplot_list=subplot_list,\n                                         ax_bbox_list=ax_bbox_list,\n                                         pad=pad, h_pad=h_pad, w_pad=w_pad,\n                                         rect=(left, bottom, right, top))\n\n    return kwargs",
        "begin_line": 264,
        "end_line": 390,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._recache#226",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._recache(self)",
        "snippet": "    def _recache(self):\n        if self._marker_function is None:\n            return\n        self._path = _empty_path\n        self._transform = IdentityTransform()\n        self._alt_path = None\n        self._alt_transform = None\n        self._snap_threshold = None\n        self._joinstyle = 'round'\n        self._capstyle = 'butt'\n        self._filled = True\n        self._marker_function()",
        "begin_line": 226,
        "end_line": 237,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035335689045936395,
            "pseudo_dstar_susp": 0.005154639175257732,
            "pseudo_tarantula_susp": 0.0005621135469364812,
            "pseudo_op2_susp": 0.00510204081632653,
            "pseudo_barinel_susp": 0.0005621135469364812
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle.is_filled#242",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle.is_filled(self)",
        "snippet": "    def is_filled(self):\n        return self._filled",
        "begin_line": 242,
        "end_line": 243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.496251874062968e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle.get_fillstyle#245",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle.get_fillstyle(self)",
        "snippet": "    def get_fillstyle(self):\n        return self._fillstyle",
        "begin_line": 245,
        "end_line": 246,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.457121551081282e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle.set_fillstyle#248",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle.set_fillstyle(self, fillstyle)",
        "snippet": "    def set_fillstyle(self, fillstyle):\n        \"\"\"\n        Sets fillstyle\n\n        Parameters\n        ----------\n        fillstyle : string amongst known fillstyles\n        \"\"\"\n        if fillstyle is None:\n            fillstyle = rcParams['markers.fillstyle']\n        cbook._check_in_list(self.fillstyles, fillstyle=fillstyle)\n        self._fillstyle = fillstyle\n        self._recache()",
        "begin_line": 248,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002336448598130841,
            "pseudo_dstar_susp": 0.001075268817204301,
            "pseudo_tarantula_susp": 0.0007980845969672786,
            "pseudo_op2_susp": 0.001075268817204301,
            "pseudo_barinel_susp": 0.0007980845969672786
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle.get_marker#268",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle.get_marker(self)",
        "snippet": "    def get_marker(self):\n        return self._marker",
        "begin_line": 268,
        "end_line": 269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle.set_marker#271",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle.set_marker(self, marker)",
        "snippet": "    def set_marker(self, marker):\n        if (isinstance(marker, np.ndarray) and marker.ndim == 2 and\n                marker.shape[1] == 2):\n            self._marker_function = self._set_vertices\n        elif isinstance(marker, str) and cbook.is_math_text(marker):\n            self._marker_function = self._set_mathtext_path\n        elif isinstance(marker, Path):\n            self._marker_function = self._set_path_marker\n        elif (isinstance(marker, Sized) and len(marker) in (2, 3) and\n                marker[1] in (0, 1, 2)):\n            self._marker_function = self._set_tuple_marker\n        elif (not isinstance(marker, (np.ndarray, list)) and\n              marker in self.markers):\n            self._marker_function = getattr(\n                self, '_set_' + self.markers[marker])\n        elif isinstance(marker, MarkerStyle):\n            self.__dict__.update(marker.__dict__)\n        else:\n            try:\n                Path(marker)\n                self._marker_function = self._set_vertices\n            except ValueError as err:\n                raise ValueError('Unrecognized marker style {!r}'\n                                 .format(marker)) from err\n\n        if not isinstance(marker, MarkerStyle):\n            self._marker = marker\n            self._recache()",
        "begin_line": 271,
        "end_line": 298,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018050541516245488,
            "pseudo_dstar_susp": 0.001004016064257028,
            "pseudo_tarantula_susp": 0.0016181229773462784,
            "pseudo_op2_susp": 0.001004016064257028,
            "pseudo_barinel_susp": 0.0016181229773462784
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle.get_transform#303",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle.get_transform(self)",
        "snippet": "    def get_transform(self):\n        return self._transform.frozen()",
        "begin_line": 303,
        "end_line": 304,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_nothing#315",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_nothing(self)",
        "snippet": "    def _set_nothing(self):\n        self._filled = False",
        "begin_line": 315,
        "end_line": 316,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029498525073746312,
            "pseudo_dstar_susp": 0.0011560693641618498,
            "pseudo_tarantula_susp": 0.0009337068160597573,
            "pseudo_op2_susp": 0.0011560693641618498,
            "pseudo_barinel_susp": 0.0009337068160597573
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_triangle_left#463",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_triangle_left(self)",
        "snippet": "    def _set_triangle_left(self):\n        return self._set_triangle(90.0, 3)",
        "begin_line": 463,
        "end_line": 464,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_square#469",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_square(self)",
        "snippet": "    def _set_square(self):\n        self._transform = Affine2D().translate(-0.5, -0.5)\n        self._snap_threshold = 2.0\n        fs = self.get_fillstyle()\n        if not self._half_fill():\n            self._path = Path.unit_rectangle()\n        else:\n            # build a bottom filled square out of two rectangles, one\n            # filled.  Use the rotation to support left, right, bottom\n            # or top\n            if fs == 'bottom':\n                rotate = 0.\n            elif fs == 'top':\n                rotate = 180.\n            elif fs == 'left':\n                rotate = 270.\n            else:\n                rotate = 90.\n\n            self._path = Path([[0.0, 0.0], [1.0, 0.0], [1.0, 0.5],\n                               [0.0, 0.5], [0.0, 0.0]])\n            self._alt_path = Path([[0.0, 0.5], [1.0, 0.5], [1.0, 1.0],\n                                   [0.0, 1.0], [0.0, 0.5]])\n            self._transform.rotate_deg(rotate)\n            self._alt_transform = self._transform\n\n        self._joinstyle = 'miter'",
        "begin_line": 469,
        "end_line": 495,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_pentagon#522",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_pentagon(self)",
        "snippet": "    def _set_pentagon(self):\n        self._transform = Affine2D().scale(0.5)\n        self._snap_threshold = 5.0\n\n        polypath = Path.unit_regular_polygon(5)\n        fs = self.get_fillstyle()\n\n        if not self._half_fill():\n            self._path = polypath\n        else:\n            verts = polypath.vertices\n\n            y = (1 + np.sqrt(5)) / 4.\n            top = Path([verts[0], verts[1], verts[4], verts[0]])\n            bottom = Path([verts[1], verts[2], verts[3], verts[4], verts[1]])\n            left = Path([verts[0], verts[1], verts[2], [0, -y], verts[0]])\n            right = Path([verts[0], verts[4], verts[3], [0, -y], verts[0]])\n\n            if fs == 'top':\n                mpath, mpath_alt = top, bottom\n            elif fs == 'bottom':\n                mpath, mpath_alt = bottom, top\n            elif fs == 'left':\n                mpath, mpath_alt = left, right\n            else:\n                mpath, mpath_alt = right, left\n            self._path = mpath\n            self._alt_path = mpath_alt\n            self._alt_transform = self._transform\n\n        self._joinstyle = 'miter'",
        "begin_line": 522,
        "end_line": 552,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_star#554",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_star(self)",
        "snippet": "    def _set_star(self):\n        self._transform = Affine2D().scale(0.5)\n        self._snap_threshold = 5.0\n\n        fs = self.get_fillstyle()\n        polypath = Path.unit_regular_star(5, innerCircle=0.381966)\n\n        if not self._half_fill():\n            self._path = polypath\n        else:\n            verts = polypath.vertices\n\n            top = Path(np.vstack((verts[0:4, :], verts[7:10, :], verts[0])))\n            bottom = Path(np.vstack((verts[3:8, :], verts[3])))\n            left = Path(np.vstack((verts[0:6, :], verts[0])))\n            right = Path(np.vstack((verts[0], verts[5:10, :], verts[0])))\n\n            if fs == 'top':\n                mpath, mpath_alt = top, bottom\n            elif fs == 'bottom':\n                mpath, mpath_alt = bottom, top\n            elif fs == 'left':\n                mpath, mpath_alt = left, right\n            else:\n                mpath, mpath_alt = right, left\n            self._path = mpath\n            self._alt_path = mpath_alt\n            self._alt_transform = self._transform\n\n        self._joinstyle = 'bevel'",
        "begin_line": 554,
        "end_line": 583,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_hexagon1#585",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_hexagon1(self)",
        "snippet": "    def _set_hexagon1(self):\n        self._transform = Affine2D().scale(0.5)\n        self._snap_threshold = None\n\n        fs = self.get_fillstyle()\n        polypath = Path.unit_regular_polygon(6)\n\n        if not self._half_fill():\n            self._path = polypath\n        else:\n            verts = polypath.vertices\n\n            # not drawing inside lines\n            x = np.abs(np.cos(5 * np.pi / 6.))\n            top = Path(np.vstack(([-x, 0], verts[(1, 0, 5), :], [x, 0])))\n            bottom = Path(np.vstack(([-x, 0], verts[2:5, :], [x, 0])))\n            left = Path(verts[(0, 1, 2, 3), :])\n            right = Path(verts[(0, 5, 4, 3), :])\n\n            if fs == 'top':\n                mpath, mpath_alt = top, bottom\n            elif fs == 'bottom':\n                mpath, mpath_alt = bottom, top\n            elif fs == 'left':\n                mpath, mpath_alt = left, right\n            else:\n                mpath, mpath_alt = right, left\n\n            self._path = mpath\n            self._alt_path = mpath_alt\n            self._alt_transform = self._transform\n\n        self._joinstyle = 'miter'",
        "begin_line": 585,
        "end_line": 617,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_hexagon2#619",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_hexagon2(self)",
        "snippet": "    def _set_hexagon2(self):\n        self._transform = Affine2D().scale(0.5).rotate_deg(30)\n        self._snap_threshold = None\n\n        fs = self.get_fillstyle()\n        polypath = Path.unit_regular_polygon(6)\n\n        if not self._half_fill():\n            self._path = polypath\n        else:\n            verts = polypath.vertices\n\n            # not drawing inside lines\n            x, y = np.sqrt(3) / 4, 3 / 4.\n            top = Path(verts[(1, 0, 5, 4, 1), :])\n            bottom = Path(verts[(1, 2, 3, 4), :])\n            left = Path(np.vstack(([x, y], verts[(0, 1, 2), :],\n                                   [-x, -y], [x, y])))\n            right = Path(np.vstack(([x, y], verts[(5, 4, 3), :], [-x, -y])))\n\n            if fs == 'top':\n                mpath, mpath_alt = top, bottom\n            elif fs == 'bottom':\n                mpath, mpath_alt = bottom, top\n            elif fs == 'left':\n                mpath, mpath_alt = left, right\n            else:\n                mpath, mpath_alt = right, left\n\n            self._path = mpath\n            self._alt_path = mpath_alt\n            self._alt_transform = self._transform\n\n        self._joinstyle = 'miter'",
        "begin_line": 619,
        "end_line": 652,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_vline#686",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_vline(self)",
        "snippet": "    def _set_vline(self):\n        self._transform = Affine2D().scale(0.5)\n        self._snap_threshold = 1.0\n        self._filled = False\n        self._path = self._line_marker_path",
        "begin_line": 686,
        "end_line": 690,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_tickleft#698",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_tickleft(self)",
        "snippet": "    def _set_tickleft(self):\n        self._transform = Affine2D().scale(-1.0, 1.0)\n        self._snap_threshold = 1.0\n        self._filled = False\n        self._path = self._tickhoriz_path",
        "begin_line": 698,
        "end_line": 702,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003472222222222222,
            "pseudo_dstar_susp": 0.0011655011655011655,
            "pseudo_tarantula_susp": 0.001049317943336831,
            "pseudo_op2_susp": 0.0011655011655011655,
            "pseudo_barinel_susp": 0.001049317943336831
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_tickright#704",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_tickright(self)",
        "snippet": "    def _set_tickright(self):\n        self._transform = Affine2D().scale(1.0, 1.0)\n        self._snap_threshold = 1.0\n        self._filled = False\n        self._path = self._tickhoriz_path",
        "begin_line": 704,
        "end_line": 708,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028328611898017,
            "pseudo_dstar_susp": 0.001145475372279496,
            "pseudo_tarantula_susp": 0.0015337423312883436,
            "pseudo_op2_susp": 0.001145475372279496,
            "pseudo_barinel_susp": 0.0015337423312883436
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_tickup#712",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_tickup(self)",
        "snippet": "    def _set_tickup(self):\n        self._transform = Affine2D().scale(1.0, 1.0)\n        self._snap_threshold = 1.0\n        self._filled = False\n        self._path = self._tickvert_path",
        "begin_line": 712,
        "end_line": 716,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0032258064516129032,
            "pseudo_dstar_susp": 0.0011627906976744186,
            "pseudo_tarantula_susp": 0.0016666666666666668,
            "pseudo_op2_susp": 0.0011627906976744186,
            "pseudo_barinel_susp": 0.0016666666666666668
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_tickdown#718",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_tickdown(self)",
        "snippet": "    def _set_tickdown(self):\n        self._transform = Affine2D().scale(1.0, -1.0)\n        self._snap_threshold = 1.0\n        self._filled = False\n        self._path = self._tickvert_path",
        "begin_line": 718,
        "end_line": 722,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0034482758620689655,
            "pseudo_dstar_susp": 0.0011641443538998836,
            "pseudo_tarantula_susp": 0.0010460251046025104,
            "pseudo_op2_susp": 0.0011641443538998836,
            "pseudo_barinel_susp": 0.0010460251046025104
        }
    },
    {
        "name": "lib.matplotlib.markers.MarkerStyle._set_plus_filled#818",
        "src_path": "lib/matplotlib/markers.py",
        "class_name": "lib.matplotlib.markers.MarkerStyle",
        "signature": "lib.matplotlib.markers.MarkerStyle._set_plus_filled(self)",
        "snippet": "    def _set_plus_filled(self):\n        self._transform = Affine2D().translate(-0.5, -0.5)\n        self._snap_threshold = 5.0\n        self._joinstyle = 'miter'\n        fs = self.get_fillstyle()\n        if not self._half_fill():\n            self._path = self._plus_filled_path\n        else:\n            # Rotate top half path to support all partitions\n            if fs == 'top':\n                rotate, rotate_alt = 0, 180\n            elif fs == 'bottom':\n                rotate, rotate_alt = 180, 0\n            elif fs == 'left':\n                rotate, rotate_alt = 90, 270\n            else:\n                rotate, rotate_alt = 270, 90\n\n            self._path = self._plus_filled_path_t\n            self._alt_path = self._plus_filled_path_t\n            self._alt_transform = Affine2D().translate(-0.5, -0.5)\n            self._transform.rotate_deg(rotate)\n            self._alt_transform.rotate_deg(rotate_alt)",
        "begin_line": 818,
        "end_line": 840,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.projections.__init__.ProjectionRegistry.get_projection_class#19",
        "src_path": "lib/matplotlib/projections/__init__.py",
        "class_name": "lib.matplotlib.projections.__init__.ProjectionRegistry",
        "signature": "lib.matplotlib.projections.__init__.ProjectionRegistry.get_projection_class(self, name)",
        "snippet": "    def get_projection_class(self, name):\n        \"\"\"Get a projection class from its *name*.\"\"\"\n        return self._all_projection_types[name]",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003968253968253968,
            "pseudo_dstar_susp": 0.006622516556291391,
            "pseudo_tarantula_susp": 0.0005564830272676684,
            "pseudo_op2_susp": 0.00641025641025641,
            "pseudo_barinel_susp": 0.0005564830272676684
        }
    },
    {
        "name": "lib.matplotlib.projections.__init__.get_projection_class#44",
        "src_path": "lib/matplotlib/projections/__init__.py",
        "class_name": "lib.matplotlib.projections.__init__",
        "signature": "lib.matplotlib.projections.__init__.get_projection_class(projection=None)",
        "snippet": "def get_projection_class(projection=None):\n    \"\"\"\n    Get a projection class from its name.\n\n    If *projection* is None, a standard rectilinear projection is returned.\n    \"\"\"\n    if projection is None:\n        projection = 'rectilinear'\n\n    try:\n        return projection_registry.get_projection_class(projection)\n    except KeyError as err:\n        raise ValueError(\"Unknown projection %r\" % projection) from err",
        "begin_line": 44,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.030303030303030304,
            "pseudo_dstar_susp": 0.037037037037037035,
            "pseudo_tarantula_susp": 0.0006027727546714888,
            "pseudo_op2_susp": 0.03125,
            "pseudo_barinel_susp": 0.0006027727546714888
        }
    },
    {
        "name": "lib.matplotlib.testing.__init__.set_font_settings_for_testing#20",
        "src_path": "lib/matplotlib/testing/__init__.py",
        "class_name": "lib.matplotlib.testing.__init__",
        "signature": "lib.matplotlib.testing.__init__.set_font_settings_for_testing()",
        "snippet": "def set_font_settings_for_testing():\n    mpl.rcParams['font.family'] = 'DejaVu Sans'\n    mpl.rcParams['text.hinting'] = 'none'\n    mpl.rcParams['text.hinting_factor'] = 8",
        "begin_line": 20,
        "end_line": 23,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007194244604316547,
            "pseudo_dstar_susp": 0.004878048780487805,
            "pseudo_tarantula_susp": 0.00033715441672285906,
            "pseudo_op2_susp": 0.004878048780487805,
            "pseudo_barinel_susp": 0.00033715441672285906
        }
    },
    {
        "name": "lib.matplotlib.testing.__init__.setup#30",
        "src_path": "lib/matplotlib/testing/__init__.py",
        "class_name": "lib.matplotlib.testing.__init__",
        "signature": "lib.matplotlib.testing.__init__.setup()",
        "snippet": "def setup():\n    # The baseline images are created in this locale, so we should use\n    # it during all of the tests.\n\n    try:\n        locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')\n    except locale.Error:\n        try:\n            locale.setlocale(locale.LC_ALL, 'English_United States.1252')\n        except locale.Error:\n            _log.warning(\n                \"Could not set locale to English/United States. \"\n                \"Some date-related tests may fail.\")\n\n    mpl.use('Agg')\n\n    with cbook._suppress_matplotlib_deprecation_warning():\n        mpl.rcdefaults()  # Start with all defaults\n\n    # These settings *must* be hardcoded for running the comparison tests and\n    # are not necessarily the default values as specified in rcsetup.py.\n    set_font_settings_for_testing()\n    set_reproducibility_for_testing()",
        "begin_line": 30,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00211864406779661,
            "pseudo_dstar_susp": 0.010752688172043012,
            "pseudo_tarantula_susp": 0.000343878954607978,
            "pseudo_op2_susp": 0.011111111111111112,
            "pseudo_barinel_susp": 0.000343878954607978
        }
    },
    {
        "name": "lib.matplotlib.streamplot.streamplot#20",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot.streamplot(axes, x, y, u, v, density=1, linewidth=None, color=None, cmap=None, norm=None, arrowsize=1, arrowstyle='-|>', minlength=0.1, transform=None, zorder=None, start_points=None, maxlength=4.0, integration_direction='both')",
        "snippet": "def streamplot(axes, x, y, u, v, density=1, linewidth=None, color=None,\n               cmap=None, norm=None, arrowsize=1, arrowstyle='-|>',\n               minlength=0.1, transform=None, zorder=None, start_points=None,\n               maxlength=4.0, integration_direction='both'):\n    \"\"\"\n    Draw streamlines of a vector flow.\n\n    Parameters\n    ----------\n    x, y : 1D arrays\n        An evenly spaced grid.\n    u, v : 2D arrays\n        *x* and *y*-velocities. The number of rows and columns must match\n        the length of *y* and *x*, respectively.\n    density : float or (float, float)\n        Controls the closeness of streamlines. When ``density = 1``, the domain\n        is divided into a 30x30 grid. *density* linearly scales this grid.\n        Each cell in the grid can have, at most, one traversing streamline.\n        For different densities in each direction, use a tuple\n        (density_x, density_y).\n    linewidth : float or 2D array\n        The width of the stream lines. With a 2D array the line width can be\n        varied across the grid. The array must have the same shape as *u*\n        and *v*.\n    color : color or 2D array\n        The streamline color. If given an array, its values are converted to\n        colors using *cmap* and *norm*.  The array must have the same shape\n        as *u* and *v*.\n    cmap : `~matplotlib.colors.Colormap`\n        Colormap used to plot streamlines and arrows. This is only used if\n        *color* is an array.\n    norm : `~matplotlib.colors.Normalize`\n        Normalize object used to scale luminance data to 0, 1. If ``None``,\n        stretch (min, max) to (0, 1). This is only used if *color* is an array.\n    arrowsize : float\n        Scaling factor for the arrow size.\n    arrowstyle : str\n        Arrow style specification.\n        See `~matplotlib.patches.FancyArrowPatch`.\n    minlength : float\n        Minimum length of streamline in axes coordinates.\n    start_points : Nx2 array\n        Coordinates of starting points for the streamlines in data coordinates\n        (the same coordinates as the *x* and *y* arrays).\n    zorder : int\n        The zorder of the stream lines and arrows.\n        Artists with lower zorder values are drawn first.\n    maxlength : float\n        Maximum length of streamline in axes coordinates.\n    integration_direction : {'forward', 'backward', 'both'}, default: 'both'\n        Integrate the streamline in forward, backward or both directions.\n\n    Returns\n    -------\n    stream_container : StreamplotSet\n        Container object with attributes\n\n        - ``lines``: `.LineCollection` of streamlines\n\n        - ``arrows``: `.PatchCollection` containing `.FancyArrowPatch`\n          objects representing the arrows half-way along stream lines.\n\n        This container will probably change in the future to allow changes\n        to the colormap, alpha, etc. for both lines and arrows, but these\n        changes should be backward compatible.\n    \"\"\"\n    grid = Grid(x, y)\n    mask = StreamMask(density)\n    dmap = DomainMap(grid, mask)\n\n    if zorder is None:\n        zorder = mlines.Line2D.zorder\n\n    # default to data coordinates\n    if transform is None:\n        transform = axes.transData\n\n    if color is None:\n        color = axes._get_lines.get_next_color()\n\n    if linewidth is None:\n        linewidth = matplotlib.rcParams['lines.linewidth']\n\n    line_kw = {}\n    arrow_kw = dict(arrowstyle=arrowstyle, mutation_scale=10 * arrowsize)\n\n    cbook._check_in_list(['both', 'forward', 'backward'],\n                         integration_direction=integration_direction)\n\n    if integration_direction == 'both':\n        maxlength /= 2.\n\n    use_multicolor_lines = isinstance(color, np.ndarray)\n    if use_multicolor_lines:\n        if color.shape != grid.shape:\n            raise ValueError(\"If 'color' is given, it must match the shape of \"\n                             \"'Grid(x, y)'\")\n        line_colors = []\n        color = np.ma.masked_invalid(color)\n    else:\n        line_kw['color'] = color\n        arrow_kw['color'] = color\n\n    if isinstance(linewidth, np.ndarray):\n        if linewidth.shape != grid.shape:\n            raise ValueError(\"If 'linewidth' is given, it must match the \"\n                             \"shape of 'Grid(x, y)'\")\n        line_kw['linewidth'] = []\n    else:\n        line_kw['linewidth'] = linewidth\n        arrow_kw['linewidth'] = linewidth\n\n    line_kw['zorder'] = zorder\n    arrow_kw['zorder'] = zorder\n\n    # Sanity checks.\n    if u.shape != grid.shape or v.shape != grid.shape:\n        raise ValueError(\"'u' and 'v' must match the shape of 'Grid(x, y)'\")\n\n    u = np.ma.masked_invalid(u)\n    v = np.ma.masked_invalid(v)\n\n    integrate = get_integrator(u, v, dmap, minlength, maxlength,\n                               integration_direction)\n\n    trajectories = []\n    if start_points is None:\n        for xm, ym in _gen_starting_points(mask.shape):\n            if mask[ym, xm] == 0:\n                xg, yg = dmap.mask2grid(xm, ym)\n                t = integrate(xg, yg)\n                if t is not None:\n                    trajectories.append(t)\n    else:\n        sp2 = np.asanyarray(start_points, dtype=float).copy()\n\n        # Check if start_points are outside the data boundaries\n        for xs, ys in sp2:\n            if not (grid.x_origin <= xs <= grid.x_origin + grid.width and\n                    grid.y_origin <= ys <= grid.y_origin + grid.height):\n                raise ValueError(\"Starting point ({}, {}) outside of data \"\n                                 \"boundaries\".format(xs, ys))\n\n        # Convert start_points from data to array coords\n        # Shift the seed points from the bottom left of the data so that\n        # data2grid works properly.\n        sp2[:, 0] -= grid.x_origin\n        sp2[:, 1] -= grid.y_origin\n\n        for xs, ys in sp2:\n            xg, yg = dmap.data2grid(xs, ys)\n            t = integrate(xg, yg)\n            if t is not None:\n                trajectories.append(t)\n\n    if use_multicolor_lines:\n        if norm is None:\n            norm = mcolors.Normalize(color.min(), color.max())\n        if cmap is None:\n            cmap = cm.get_cmap(matplotlib.rcParams['image.cmap'])\n        else:\n            cmap = cm.get_cmap(cmap)\n\n    streamlines = []\n    arrows = []\n    for t in trajectories:\n        tgx = np.array(t[0])\n        tgy = np.array(t[1])\n        # Rescale from grid-coordinates to data-coordinates.\n        tx, ty = dmap.grid2data(*np.array(t))\n        tx += grid.x_origin\n        ty += grid.y_origin\n\n        points = np.transpose([tx, ty]).reshape(-1, 1, 2)\n        streamlines.extend(np.hstack([points[:-1], points[1:]]))\n\n        # Add arrows half way along each trajectory.\n        s = np.cumsum(np.hypot(np.diff(tx), np.diff(ty)))\n        n = np.searchsorted(s, s[-1] / 2.)\n        arrow_tail = (tx[n], ty[n])\n        arrow_head = (np.mean(tx[n:n + 2]), np.mean(ty[n:n + 2]))\n\n        if isinstance(linewidth, np.ndarray):\n            line_widths = interpgrid(linewidth, tgx, tgy)[:-1]\n            line_kw['linewidth'].extend(line_widths)\n            arrow_kw['linewidth'] = line_widths[n]\n\n        if use_multicolor_lines:\n            color_values = interpgrid(color, tgx, tgy)[:-1]\n            line_colors.append(color_values)\n            arrow_kw['color'] = cmap(norm(color_values[n]))\n\n        p = patches.FancyArrowPatch(\n            arrow_tail, arrow_head, transform=transform, **arrow_kw)\n        axes.add_patch(p)\n        arrows.append(p)\n\n    lc = mcollections.LineCollection(\n        streamlines, transform=transform, **line_kw)\n    lc.sticky_edges.x[:] = [grid.x_origin, grid.x_origin + grid.width]\n    lc.sticky_edges.y[:] = [grid.y_origin, grid.y_origin + grid.height]\n    if use_multicolor_lines:\n        lc.set_array(np.ma.hstack(line_colors))\n        lc.set_cmap(cmap)\n        lc.set_norm(norm)\n    axes.add_collection(lc)\n    axes.autoscale_view()\n\n    ac = matplotlib.collections.PatchCollection(arrows)\n    stream_container = StreamplotSet(lc, ac)\n    return stream_container",
        "begin_line": 20,
        "end_line": 230,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.19793966151582e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.StreamplotSet.__init__#235",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.StreamplotSet",
        "signature": "lib.matplotlib.streamplot.StreamplotSet.__init__(self, lines, arrows, **kwargs)",
        "snippet": "    def __init__(self, lines, arrows, **kwargs):\n        if kwargs:\n            cbook.warn_deprecated(\n                \"3.3\",\n                message=\"Passing arbitrary keyword arguments to StreamplotSet \"\n                        \"is deprecated.\")\n        self.lines = lines\n        self.arrows = arrows",
        "begin_line": 235,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.DomainMap.__init__#266",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.DomainMap",
        "signature": "lib.matplotlib.streamplot.DomainMap.__init__(self, grid, mask)",
        "snippet": "    def __init__(self, grid, mask):\n        self.grid = grid\n        self.mask = mask\n        # Constants for conversion between grid- and mask-coordinates\n        self.x_grid2mask = (mask.nx - 1) / (grid.nx - 1)\n        self.y_grid2mask = (mask.ny - 1) / (grid.ny - 1)\n\n        self.x_mask2grid = 1. / self.x_grid2mask\n        self.y_mask2grid = 1. / self.y_grid2mask\n\n        self.x_data2grid = 1. / grid.dx\n        self.y_data2grid = 1. / grid.dy",
        "begin_line": 266,
        "end_line": 277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.DomainMap.grid2mask#279",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.DomainMap",
        "signature": "lib.matplotlib.streamplot.DomainMap.grid2mask(self, xi, yi)",
        "snippet": "    def grid2mask(self, xi, yi):\n        \"\"\"Return nearest space in mask-coords from given grid-coords.\"\"\"\n        return (int(xi * self.x_grid2mask + 0.5),\n                int(yi * self.y_grid2mask + 0.5))",
        "begin_line": 279,
        "end_line": 282,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.DomainMap.data2grid#287",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.DomainMap",
        "signature": "lib.matplotlib.streamplot.DomainMap.data2grid(self, xd, yd)",
        "snippet": "    def data2grid(self, xd, yd):\n        return xd * self.x_data2grid, yd * self.y_data2grid",
        "begin_line": 287,
        "end_line": 288,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.DomainMap.grid2data#290",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.DomainMap",
        "signature": "lib.matplotlib.streamplot.DomainMap.grid2data(self, xg, yg)",
        "snippet": "    def grid2data(self, xg, yg):\n        return xg / self.x_data2grid, yg / self.y_data2grid",
        "begin_line": 290,
        "end_line": 291,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.DomainMap.start_trajectory#293",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.DomainMap",
        "signature": "lib.matplotlib.streamplot.DomainMap.start_trajectory(self, xg, yg)",
        "snippet": "    def start_trajectory(self, xg, yg):\n        xm, ym = self.grid2mask(xg, yg)\n        self.mask._start_trajectory(xm, ym)",
        "begin_line": 293,
        "end_line": 295,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.DomainMap.reset_start_point#297",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.DomainMap",
        "signature": "lib.matplotlib.streamplot.DomainMap.reset_start_point(self, xg, yg)",
        "snippet": "    def reset_start_point(self, xg, yg):\n        xm, ym = self.grid2mask(xg, yg)\n        self.mask._current_xy = (xm, ym)",
        "begin_line": 297,
        "end_line": 299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.DomainMap.update_trajectory#301",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.DomainMap",
        "signature": "lib.matplotlib.streamplot.DomainMap.update_trajectory(self, xg, yg)",
        "snippet": "    def update_trajectory(self, xg, yg):\n        if not self.grid.within_grid(xg, yg):\n            raise InvalidIndexError\n        xm, ym = self.grid2mask(xg, yg)\n        self.mask._update_trajectory(xm, ym)",
        "begin_line": 301,
        "end_line": 305,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.DomainMap.undo_trajectory#307",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.DomainMap",
        "signature": "lib.matplotlib.streamplot.DomainMap.undo_trajectory(self)",
        "snippet": "    def undo_trajectory(self):\n        self.mask._undo_trajectory()",
        "begin_line": 307,
        "end_line": 308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.Grid.__init__#313",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.Grid",
        "signature": "lib.matplotlib.streamplot.Grid.__init__(self, x, y)",
        "snippet": "    def __init__(self, x, y):\n\n        if x.ndim == 1:\n            pass\n        elif x.ndim == 2:\n            x_row = x[0, :]\n            if not np.allclose(x_row, x):\n                raise ValueError(\"The rows of 'x' must be equal\")\n            x = x_row\n        else:\n            raise ValueError(\"'x' can have at maximum 2 dimensions\")\n\n        if y.ndim == 1:\n            pass\n        elif y.ndim == 2:\n            y_col = y[:, 0]\n            if not np.allclose(y_col, y.T):\n                raise ValueError(\"The columns of 'y' must be equal\")\n            y = y_col\n        else:\n            raise ValueError(\"'y' can have at maximum 2 dimensions\")\n\n        self.nx = len(x)\n        self.ny = len(y)\n\n        self.dx = x[1] - x[0]\n        self.dy = y[1] - y[0]\n\n        self.x_origin = x[0]\n        self.y_origin = y[0]\n\n        self.width = x[-1] - x[0]\n        self.height = y[-1] - y[0]\n\n        if not np.allclose(np.diff(x), self.width / (self.nx - 1)):\n            raise ValueError(\"'x' values must be equally spaced\")\n        if not np.allclose(np.diff(y), self.height / (self.ny - 1)):\n            raise ValueError(\"'y' values must be equally spaced\")",
        "begin_line": 313,
        "end_line": 350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.Grid.shape#353",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.Grid",
        "signature": "lib.matplotlib.streamplot.Grid.shape(self)",
        "snippet": "    def shape(self):\n        return self.ny, self.nx",
        "begin_line": 353,
        "end_line": 354,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.Grid.within_grid#356",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.Grid",
        "signature": "lib.matplotlib.streamplot.Grid.within_grid(self, xi, yi)",
        "snippet": "    def within_grid(self, xi, yi):\n        \"\"\"Return True if point is a valid index of grid.\"\"\"\n        # Note that xi/yi can be floats; so, for example, we can't simply check\n        # `xi < self.nx` since *xi* can be `self.nx - 1 < xi < self.nx`\n        return 0 <= xi <= self.nx - 1 and 0 <= yi <= self.ny - 1",
        "begin_line": 356,
        "end_line": 360,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.StreamMask.__init__#372",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.StreamMask",
        "signature": "lib.matplotlib.streamplot.StreamMask.__init__(self, density)",
        "snippet": "    def __init__(self, density):\n        try:\n            self.nx, self.ny = (30 * np.broadcast_to(density, 2)).astype(int)\n        except ValueError as err:\n            raise ValueError(\"'density' must be a scalar or be of length \"\n                             \"2\") from err\n        if self.nx < 0 or self.ny < 0:\n            raise ValueError(\"'density' must be positive\")\n        self._mask = np.zeros((self.ny, self.nx))\n        self.shape = self._mask.shape\n\n        self._current_xy = None",
        "begin_line": 372,
        "end_line": 383,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.StreamMask.__getitem__#385",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.StreamMask",
        "signature": "lib.matplotlib.streamplot.StreamMask.__getitem__(self, args)",
        "snippet": "    def __getitem__(self, args):\n        return self._mask[args]",
        "begin_line": 385,
        "end_line": 386,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.StreamMask._start_trajectory#388",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.StreamMask",
        "signature": "lib.matplotlib.streamplot.StreamMask._start_trajectory(self, xm, ym)",
        "snippet": "    def _start_trajectory(self, xm, ym):\n        \"\"\"Start recording streamline trajectory\"\"\"\n        self._traj = []\n        self._update_trajectory(xm, ym)",
        "begin_line": 388,
        "end_line": 391,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.StreamMask._undo_trajectory#393",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.StreamMask",
        "signature": "lib.matplotlib.streamplot.StreamMask._undo_trajectory(self)",
        "snippet": "    def _undo_trajectory(self):\n        \"\"\"Remove current trajectory from mask\"\"\"\n        for t in self._traj:\n            self._mask[t] = 0",
        "begin_line": 393,
        "end_line": 396,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.StreamMask._update_trajectory#398",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot.StreamMask",
        "signature": "lib.matplotlib.streamplot.StreamMask._update_trajectory(self, xm, ym)",
        "snippet": "    def _update_trajectory(self, xm, ym):\n        \"\"\"Update current trajectory position in mask.\n\n        If the new position has already been filled, raise `InvalidIndexError`.\n        \"\"\"\n        if self._current_xy != (xm, ym):\n            if self[ym, xm] == 0:\n                self._traj.append((ym, xm))\n                self._mask[ym, xm] = 1\n                self._current_xy = (xm, ym)\n            else:\n                raise InvalidIndexError",
        "begin_line": 398,
        "end_line": 409,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.get_integrator#423",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot.get_integrator(u, v, dmap, minlength, maxlength, integration_direction)",
        "snippet": "def get_integrator(u, v, dmap, minlength, maxlength, integration_direction):\n\n    # rescale velocity onto grid-coordinates for integrations.\n    u, v = dmap.data2grid(u, v)\n\n    # speed (path length) will be in axes-coordinates\n    u_ax = u / (dmap.grid.nx - 1)\n    v_ax = v / (dmap.grid.ny - 1)\n    speed = np.ma.sqrt(u_ax ** 2 + v_ax ** 2)\n\n    def forward_time(xi, yi):\n        if not dmap.grid.within_grid(xi, yi):\n            raise OutOfBounds\n        ds_dt = interpgrid(speed, xi, yi)\n        if ds_dt == 0:\n            raise TerminateTrajectory()\n        dt_ds = 1. / ds_dt\n        ui = interpgrid(u, xi, yi)\n        vi = interpgrid(v, xi, yi)\n        return ui * dt_ds, vi * dt_ds\n\n    def backward_time(xi, yi):\n        dxi, dyi = forward_time(xi, yi)\n        return -dxi, -dyi\n\n    def integrate(x0, y0):\n        \"\"\"Return x, y grid-coordinates of trajectory based on starting point.\n\n        Integrate both forward and backward in time from starting point in\n        grid coordinates.\n\n        Integration is terminated when a trajectory reaches a domain boundary\n        or when it crosses into an already occupied cell in the StreamMask. The\n        resulting trajectory is None if it is shorter than `minlength`.\n        \"\"\"\n\n        stotal, x_traj, y_traj = 0., [], []\n\n        try:\n            dmap.start_trajectory(x0, y0)\n        except InvalidIndexError:\n            return None\n        if integration_direction in ['both', 'backward']:\n            s, xt, yt = _integrate_rk12(x0, y0, dmap, backward_time, maxlength)\n            stotal += s\n            x_traj += xt[::-1]\n            y_traj += yt[::-1]\n\n        if integration_direction in ['both', 'forward']:\n            dmap.reset_start_point(x0, y0)\n            s, xt, yt = _integrate_rk12(x0, y0, dmap, forward_time, maxlength)\n            if len(x_traj) > 0:\n                xt = xt[1:]\n                yt = yt[1:]\n            stotal += s\n            x_traj += xt\n            y_traj += yt\n\n        if stotal > minlength:\n            return x_traj, y_traj\n        else:  # reject short trajectories\n            dmap.undo_trajectory()\n            return None\n\n    return integrate",
        "begin_line": 423,
        "end_line": 487,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.forward_time#433",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot.forward_time(xi, yi)",
        "snippet": "    def forward_time(xi, yi):\n        if not dmap.grid.within_grid(xi, yi):\n            raise OutOfBounds\n        ds_dt = interpgrid(speed, xi, yi)\n        if ds_dt == 0:\n            raise TerminateTrajectory()\n        dt_ds = 1. / ds_dt\n        ui = interpgrid(u, xi, yi)\n        vi = interpgrid(v, xi, yi)\n        return ui * dt_ds, vi * dt_ds",
        "begin_line": 433,
        "end_line": 442,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.backward_time#444",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot.backward_time(xi, yi)",
        "snippet": "    def backward_time(xi, yi):\n        dxi, dyi = forward_time(xi, yi)\n        return -dxi, -dyi",
        "begin_line": 444,
        "end_line": 446,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.integrate#448",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot.integrate(x0, y0)",
        "snippet": "    def integrate(x0, y0):\n        \"\"\"Return x, y grid-coordinates of trajectory based on starting point.\n\n        Integrate both forward and backward in time from starting point in\n        grid coordinates.\n\n        Integration is terminated when a trajectory reaches a domain boundary\n        or when it crosses into an already occupied cell in the StreamMask. The\n        resulting trajectory is None if it is shorter than `minlength`.\n        \"\"\"\n\n        stotal, x_traj, y_traj = 0., [], []\n\n        try:\n            dmap.start_trajectory(x0, y0)\n        except InvalidIndexError:\n            return None\n        if integration_direction in ['both', 'backward']:\n            s, xt, yt = _integrate_rk12(x0, y0, dmap, backward_time, maxlength)\n            stotal += s\n            x_traj += xt[::-1]\n            y_traj += yt[::-1]\n\n        if integration_direction in ['both', 'forward']:\n            dmap.reset_start_point(x0, y0)\n            s, xt, yt = _integrate_rk12(x0, y0, dmap, forward_time, maxlength)\n            if len(x_traj) > 0:\n                xt = xt[1:]\n                yt = yt[1:]\n            stotal += s\n            x_traj += xt\n            y_traj += yt\n\n        if stotal > minlength:\n            return x_traj, y_traj\n        else:  # reject short trajectories\n            dmap.undo_trajectory()\n            return None",
        "begin_line": 448,
        "end_line": 485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot._integrate_rk12#494",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot._integrate_rk12(x0, y0, dmap, f, maxlength)",
        "snippet": "def _integrate_rk12(x0, y0, dmap, f, maxlength):\n    \"\"\"2nd-order Runge-Kutta algorithm with adaptive step size.\n\n    This method is also referred to as the improved Euler's method, or Heun's\n    method. This method is favored over higher-order methods because:\n\n    1. To get decent looking trajectories and to sample every mask cell\n       on the trajectory we need a small timestep, so a lower order\n       solver doesn't hurt us unless the data is *very* high resolution.\n       In fact, for cases where the user inputs\n       data smaller or of similar grid size to the mask grid, the higher\n       order corrections are negligible because of the very fast linear\n       interpolation used in `interpgrid`.\n\n    2. For high resolution input data (i.e. beyond the mask\n       resolution), we must reduce the timestep. Therefore, an adaptive\n       timestep is more suited to the problem as this would be very hard\n       to judge automatically otherwise.\n\n    This integrator is about 1.5 - 2x as fast as both the RK4 and RK45\n    solvers in most setups on my machine. I would recommend removing the\n    other two to keep things simple.\n    \"\"\"\n    # This error is below that needed to match the RK4 integrator. It\n    # is set for visual reasons -- too low and corners start\n    # appearing ugly and jagged. Can be tuned.\n    maxerror = 0.003\n\n    # This limit is important (for all integrators) to avoid the\n    # trajectory skipping some mask cells. We could relax this\n    # condition if we use the code which is commented out below to\n    # increment the location gradually. However, due to the efficient\n    # nature of the interpolation, this doesn't boost speed by much\n    # for quite a bit of complexity.\n    maxds = min(1. / dmap.mask.nx, 1. / dmap.mask.ny, 0.1)\n\n    ds = maxds\n    stotal = 0\n    xi = x0\n    yi = y0\n    xf_traj = []\n    yf_traj = []\n\n    while True:\n        try:\n            if dmap.grid.within_grid(xi, yi):\n                xf_traj.append(xi)\n                yf_traj.append(yi)\n            else:\n                raise OutOfBounds\n\n            # Compute the two intermediate gradients.\n            # f should raise OutOfBounds if the locations given are\n            # outside the grid.\n            k1x, k1y = f(xi, yi)\n            k2x, k2y = f(xi + ds * k1x, yi + ds * k1y)\n\n        except OutOfBounds:\n            # Out of the domain during this step.\n            # Take an Euler step to the boundary to improve neatness\n            # unless the trajectory is currently empty.\n            if xf_traj:\n                ds, xf_traj, yf_traj = _euler_step(xf_traj, yf_traj,\n                                                   dmap, f)\n                stotal += ds\n            break\n        except TerminateTrajectory:\n            break\n\n        dx1 = ds * k1x\n        dy1 = ds * k1y\n        dx2 = ds * 0.5 * (k1x + k2x)\n        dy2 = ds * 0.5 * (k1y + k2y)\n\n        nx, ny = dmap.grid.shape\n        # Error is normalized to the axes coordinates\n        error = np.hypot((dx2 - dx1) / (nx - 1), (dy2 - dy1) / (ny - 1))\n\n        # Only save step if within error tolerance\n        if error < maxerror:\n            xi += dx2\n            yi += dy2\n            try:\n                dmap.update_trajectory(xi, yi)\n            except InvalidIndexError:\n                break\n            if stotal + ds > maxlength:\n                break\n            stotal += ds\n\n        # recalculate stepsize based on step error\n        if error == 0:\n            ds = maxds\n        else:\n            ds = min(maxds, 0.85 * ds * (maxerror / error) ** 0.5)\n\n    return stotal, xf_traj, yf_traj",
        "begin_line": 494,
        "end_line": 590,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot._euler_step#593",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot._euler_step(xf_traj, yf_traj, dmap, f)",
        "snippet": "def _euler_step(xf_traj, yf_traj, dmap, f):\n    \"\"\"Simple Euler integration step that extends streamline to boundary.\"\"\"\n    ny, nx = dmap.grid.shape\n    xi = xf_traj[-1]\n    yi = yf_traj[-1]\n    cx, cy = f(xi, yi)\n    if cx == 0:\n        dsx = np.inf\n    elif cx < 0:\n        dsx = xi / -cx\n    else:\n        dsx = (nx - 1 - xi) / cx\n    if cy == 0:\n        dsy = np.inf\n    elif cy < 0:\n        dsy = yi / -cy\n    else:\n        dsy = (ny - 1 - yi) / cy\n    ds = min(dsx, dsy)\n    xf_traj.append(xi + cx * ds)\n    yf_traj.append(yi + cy * ds)\n    return ds, xf_traj, yf_traj",
        "begin_line": 593,
        "end_line": 614,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot.interpgrid#620",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot.interpgrid(a, xi, yi)",
        "snippet": "def interpgrid(a, xi, yi):\n    \"\"\"Fast 2D, linear interpolation on an integer grid\"\"\"\n\n    Ny, Nx = np.shape(a)\n    if isinstance(xi, np.ndarray):\n        x = xi.astype(int)\n        y = yi.astype(int)\n        # Check that xn, yn don't exceed max index\n        xn = np.clip(x + 1, 0, Nx - 1)\n        yn = np.clip(y + 1, 0, Ny - 1)\n    else:\n        x = int(xi)\n        y = int(yi)\n        # conditional is faster than clipping for integers\n        if x == (Nx - 1):\n            xn = x\n        else:\n            xn = x + 1\n        if y == (Ny - 1):\n            yn = y\n        else:\n            yn = y + 1\n\n    a00 = a[y, x]\n    a01 = a[y, xn]\n    a10 = a[yn, x]\n    a11 = a[yn, xn]\n    xt = xi - x\n    yt = yi - y\n    a0 = a00 * (1 - xt) + a01 * xt\n    a1 = a10 * (1 - xt) + a11 * xt\n    ai = a0 * (1 - yt) + a1 * yt\n\n    if not isinstance(xi, np.ndarray):\n        if np.ma.is_masked(ai):\n            raise TerminateTrajectory\n\n    return ai",
        "begin_line": 620,
        "end_line": 657,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.streamplot._gen_starting_points#660",
        "src_path": "lib/matplotlib/streamplot.py",
        "class_name": "lib.matplotlib.streamplot",
        "signature": "lib.matplotlib.streamplot._gen_starting_points(shape)",
        "snippet": "def _gen_starting_points(shape):\n    \"\"\"Yield starting points for streamlines.\n\n    Trying points on the boundary first gives higher quality streamlines.\n    This algorithm starts with a point on the mask corner and spirals inward.\n    This algorithm is inefficient, but fast compared to rest of streamplot.\n    \"\"\"\n    ny, nx = shape\n    xfirst = 0\n    yfirst = 1\n    xlast = nx - 1\n    ylast = ny - 1\n    x, y = 0, 0\n    direction = 'right'\n    for i in range(nx * ny):\n        yield x, y\n\n        if direction == 'right':\n            x += 1\n            if x >= xlast:\n                xlast -= 1\n                direction = 'up'\n        elif direction == 'up':\n            y += 1\n            if y >= ylast:\n                ylast -= 1\n                direction = 'left'\n        elif direction == 'left':\n            x -= 1\n            if x <= xfirst:\n                xfirst += 1\n                direction = 'down'\n        elif direction == 'down':\n            y -= 1\n            if y <= yfirst:\n                yfirst += 1\n                direction = 'right'",
        "begin_line": 660,
        "end_line": 696,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.spines.Spine.__init__#36",
        "src_path": "lib/matplotlib/spines.py",
        "class_name": "lib.matplotlib.spines.Spine",
        "signature": "lib.matplotlib.spines.Spine.__init__(self, axes, spine_type, path, **kwargs)",
        "snippet": "    def __init__(self, axes, spine_type, path, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        axes : `~matplotlib.axes.Axes`\n            The `~.axes.Axes` instance containing the spine.\n        spine_type : str\n            The spine type.\n        path : `~matplotlib.path.Path`\n            The `.Path` instance used to draw the spine.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            Valid keyword arguments are:\n\n            %(Patch)s\n        \"\"\"\n        super().__init__(**kwargs)\n        self.axes = axes\n        self.set_figure(self.axes.figure)\n        self.spine_type = spine_type\n        self.set_facecolor('none')\n        self.set_edgecolor(rcParams['axes.edgecolor'])\n        self.set_linewidth(rcParams['axes.linewidth'])\n        self.set_capstyle('projecting')\n        self.axis = None\n\n        self.set_zorder(2.5)\n        self.set_transform(self.axes.transData)  # default transform\n\n        self._bounds = None  # default bounds\n        self._smart_bounds = False  # deprecated in 3.2\n\n        # Defer initial position determination. (Not much support for\n        # non-rectangular axes is currently implemented, and this lets\n        # them pass through the spines machinery without errors.)\n        self._position = None\n        cbook._check_isinstance(matplotlib.path.Path, path=path)\n        self._path = path\n\n        # To support drawing both linear and circular spines, this\n        # class implements Patch behavior three ways. If\n        # self._patch_type == 'line', behave like a mpatches.PathPatch\n        # instance. If self._patch_type == 'circle', behave like a\n        # mpatches.Ellipse instance. If self._patch_type == 'arc', behave like\n        # a mpatches.Arc instance.\n        self._patch_type = 'line'\n\n        # Behavior copied from mpatches.Ellipse:\n        # Note: This cannot be calculated until this is added to an Axes\n        self._patch_transform = mtransforms.IdentityTransform()",
        "begin_line": 36,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03125,
            "pseudo_dstar_susp": 0.038461538461538464,
            "pseudo_tarantula_susp": 0.0006138735420503376,
            "pseudo_op2_susp": 0.03225806451612903,
            "pseudo_barinel_susp": 0.0006138735420503376
        }
    },
    {
        "name": "lib.matplotlib.spines.Spine.set_patch_arc#106",
        "src_path": "lib/matplotlib/spines.py",
        "class_name": "lib.matplotlib.spines.Spine",
        "signature": "lib.matplotlib.spines.Spine.set_patch_arc(self, center, radius, theta1, theta2)",
        "snippet": "    def set_patch_arc(self, center, radius, theta1, theta2):\n        \"\"\"Set the spine to be arc-like.\"\"\"\n        self._patch_type = 'arc'\n        self._center = center\n        self._width = radius * 2\n        self._height = radius * 2\n        self._theta1 = theta1\n        self._theta2 = theta2\n        self._path = mpath.Path.arc(theta1, theta2)\n        # arc drawn on axes transform\n        self.set_transform(self.axes.transAxes)\n        self.stale = True",
        "begin_line": 106,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003484320557491289,
            "pseudo_dstar_susp": 0.0006688963210702341,
            "pseudo_tarantula_susp": 0.0023094688221709007,
            "pseudo_op2_susp": 0.0006688963210702341,
            "pseudo_barinel_susp": 0.0023094688221709007
        }
    },
    {
        "name": "lib.matplotlib.spines.Spine.get_patch_transform#153",
        "src_path": "lib/matplotlib/spines.py",
        "class_name": "lib.matplotlib.spines.Spine",
        "signature": "lib.matplotlib.spines.Spine.get_patch_transform(self)",
        "snippet": "    def get_patch_transform(self):\n        if self._patch_type in ('arc', 'circle'):\n            self._recompute_transform()\n            return self._patch_transform\n        else:\n            return super().get_patch_transform()",
        "begin_line": 153,
        "end_line": 158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.400828892835997e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.spines.Spine.get_window_extent#160",
        "src_path": "lib/matplotlib/spines.py",
        "class_name": "lib.matplotlib.spines.Spine",
        "signature": "lib.matplotlib.spines.Spine.get_window_extent(self, renderer=None)",
        "snippet": "    def get_window_extent(self, renderer=None):\n        \"\"\"\n        Return the window extent of the spines in display space, including\n        padding for ticks (but not their labels)\n\n        See Also\n        --------\n        matplotlib.axes.Axes.get_tightbbox\n        matplotlib.axes.Axes.get_window_extent\n        \"\"\"\n        # make sure the location is updated so that transforms etc are correct:\n        self._adjust_location()\n        bb = super().get_window_extent(renderer=renderer)\n        if self.axis is None:\n            return bb\n        bboxes = [bb]\n        tickstocheck = [self.axis.majorTicks[0]]\n        if len(self.axis.minorTicks) > 1:\n            # only pad for minor ticks if there are more than one\n            # of them.  There is always one...\n            tickstocheck.append(self.axis.minorTicks[1])\n        for tick in tickstocheck:\n            bb0 = bb.frozen()\n            tickl = tick._size\n            tickdir = tick._tickdir\n            if tickdir == 'out':\n                padout = 1\n                padin = 0\n            elif tickdir == 'in':\n                padout = 0\n                padin = 1\n            else:\n                padout = 0.5\n                padin = 0.5\n            padout = padout * tickl / 72 * self.figure.dpi\n            padin = padin * tickl / 72 * self.figure.dpi\n\n            if tick.tick1line.get_visible():\n                if self.spine_type == 'left':\n                    bb0.x0 = bb0.x0 - padout\n                    bb0.x1 = bb0.x1 + padin\n                elif self.spine_type == 'bottom':\n                    bb0.y0 = bb0.y0 - padout\n                    bb0.y1 = bb0.y1 + padin\n\n            if tick.tick2line.get_visible():\n                if self.spine_type == 'right':\n                    bb0.x1 = bb0.x1 + padout\n                    bb0.x0 = bb0.x0 - padin\n                elif self.spine_type == 'top':\n                    bb0.y1 = bb0.y1 + padout\n                    bb0.y0 = bb0.y0 - padout\n            bboxes.append(bb0)\n\n        return mtransforms.Bbox.union(bboxes)",
        "begin_line": 160,
        "end_line": 214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.192692118630181e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.spines.Spine._ensure_position_is_set#219",
        "src_path": "lib/matplotlib/spines.py",
        "class_name": "lib.matplotlib.spines.Spine",
        "signature": "lib.matplotlib.spines.Spine._ensure_position_is_set(self)",
        "snippet": "    def _ensure_position_is_set(self):\n        if self._position is None:\n            # default position\n            self._position = ('outward', 0.0)  # in points\n            self.set_position(self._position)",
        "begin_line": 219,
        "end_line": 223,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010775862068965517,
            "pseudo_dstar_susp": 0.00546448087431694,
            "pseudo_tarantula_susp": 0.0003676470588235294,
            "pseudo_op2_susp": 0.005434782608695652,
            "pseudo_barinel_susp": 0.0003676470588235294
        }
    },
    {
        "name": "lib.matplotlib.spines.Spine.register_axis#225",
        "src_path": "lib/matplotlib/spines.py",
        "class_name": "lib.matplotlib.spines.Spine",
        "signature": "lib.matplotlib.spines.Spine.register_axis(self, axis)",
        "snippet": "    def register_axis(self, axis):\n        \"\"\"Register an axis.\n\n        An axis should be registered with its corresponding spine from\n        the Axes instance. This allows the spine to clear any axis\n        properties when needed.\n        \"\"\"\n        self.axis = axis\n        if self.axis is not None:\n            self.axis.cla()\n        self.stale = True",
        "begin_line": 225,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008064516129032258,
            "pseudo_dstar_susp": 0.008771929824561403,
            "pseudo_tarantula_susp": 0.000544069640914037,
            "pseudo_op2_susp": 0.008333333333333333,
            "pseudo_barinel_susp": 0.000544069640914037
        }
    },
    {
        "name": "lib.matplotlib.spines.Spine.cla#237",
        "src_path": "lib/matplotlib/spines.py",
        "class_name": "lib.matplotlib.spines.Spine",
        "signature": "lib.matplotlib.spines.Spine.cla(self)",
        "snippet": "    def cla(self):\n        \"\"\"Clear the current spine.\"\"\"\n        self._position = None  # clear position\n        if self.axis is not None:\n            self.axis.cla()",
        "begin_line": 237,
        "end_line": 241,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0078125,
            "pseudo_dstar_susp": 0.008333333333333333,
            "pseudo_tarantula_susp": 0.0004997501249375312,
            "pseudo_op2_susp": 0.007874015748031496,
            "pseudo_barinel_susp": 0.0004997501249375312
        }
    },
    {
        "name": "lib.matplotlib.spines.Spine._adjust_location#265",
        "src_path": "lib/matplotlib/spines.py",
        "class_name": "lib.matplotlib.spines.Spine",
        "signature": "lib.matplotlib.spines.Spine._adjust_location(self)",
        "snippet": "    def _adjust_location(self):\n        \"\"\"Automatically set spine bounds to the view interval.\"\"\"\n\n        if self.spine_type == 'circle':\n            return\n\n        if self._bounds is None:\n            if self.spine_type in ('left', 'right'):\n                low, high = self.axes.viewLim.intervaly\n            elif self.spine_type in ('top', 'bottom'):\n                low, high = self.axes.viewLim.intervalx\n            else:\n                raise ValueError('unknown spine spine_type: %s' %\n                                 self.spine_type)\n\n            if self._smart_bounds:  # deprecated in 3.2\n                # attempt to set bounds in sophisticated way\n\n                # handle inverted limits\n                viewlim_low, viewlim_high = sorted([low, high])\n\n                if self.spine_type in ('left', 'right'):\n                    datalim_low, datalim_high = self.axes.dataLim.intervaly\n                    ticks = self.axes.get_yticks()\n                elif self.spine_type in ('top', 'bottom'):\n                    datalim_low, datalim_high = self.axes.dataLim.intervalx\n                    ticks = self.axes.get_xticks()\n                # handle inverted limits\n                ticks = np.sort(ticks)\n                datalim_low, datalim_high = sorted([datalim_low, datalim_high])\n\n                if datalim_low < viewlim_low:\n                    # Data extends past view. Clip line to view.\n                    low = viewlim_low\n                else:\n                    # Data ends before view ends.\n                    cond = (ticks <= datalim_low) & (ticks >= viewlim_low)\n                    tickvals = ticks[cond]\n                    if len(tickvals):\n                        # A tick is less than or equal to lowest data point.\n                        low = tickvals[-1]\n                    else:\n                        # No tick is available\n                        low = datalim_low\n                    low = max(low, viewlim_low)\n\n                if datalim_high > viewlim_high:\n                    # Data extends past view. Clip line to view.\n                    high = viewlim_high\n                else:\n                    # Data ends before view ends.\n                    cond = (ticks >= datalim_high) & (ticks <= viewlim_high)\n                    tickvals = ticks[cond]\n                    if len(tickvals):\n                        # A tick is greater than or equal to highest data\n                        # point.\n                        high = tickvals[0]\n                    else:\n                        # No tick is available\n                        high = datalim_high\n                    high = min(high, viewlim_high)\n\n        else:\n            low, high = self._bounds\n\n        if self._patch_type == 'arc':\n            if self.spine_type in ('bottom', 'top'):\n                try:\n                    direction = self.axes.get_theta_direction()\n                except AttributeError:\n                    direction = 1\n                try:\n                    offset = self.axes.get_theta_offset()\n                except AttributeError:\n                    offset = 0\n                low = low * direction + offset\n                high = high * direction + offset\n                if low > high:\n                    low, high = high, low\n\n                self._path = mpath.Path.arc(np.rad2deg(low), np.rad2deg(high))\n\n                if self.spine_type == 'bottom':\n                    rmin, rmax = self.axes.viewLim.intervaly\n                    try:\n                        rorigin = self.axes.get_rorigin()\n                    except AttributeError:\n                        rorigin = rmin\n                    scaled_diameter = (rmin - rorigin) / (rmax - rorigin)\n                    self._height = scaled_diameter\n                    self._width = scaled_diameter\n\n            else:\n                raise ValueError('unable to set bounds for spine \"%s\"' %\n                                 self.spine_type)\n        else:\n            v1 = self._path.vertices\n            assert v1.shape == (2, 2), 'unexpected vertices shape'\n            if self.spine_type in ['left', 'right']:\n                v1[0, 1] = low\n                v1[1, 1] = high\n            elif self.spine_type in ['bottom', 'top']:\n                v1[0, 0] = low\n                v1[1, 0] = high\n            else:\n                raise ValueError('unable to set bounds for spine \"%s\"' %\n                                 self.spine_type)",
        "begin_line": 265,
        "end_line": 371,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004589261128958238,
            "pseudo_dstar_susp": 0.0003966679888932963,
            "pseudo_tarantula_susp": 0.0016181229773462784,
            "pseudo_op2_susp": 0.0003966679888932963,
            "pseudo_barinel_susp": 0.0016181229773462784
        }
    },
    {
        "name": "lib.matplotlib.spines.Spine.draw#374",
        "src_path": "lib/matplotlib/spines.py",
        "class_name": "lib.matplotlib.spines.Spine",
        "signature": "lib.matplotlib.spines.Spine.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        self._adjust_location()\n        ret = super().draw(renderer)\n        self.stale = False\n        return ret",
        "begin_line": 374,
        "end_line": 378,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.584951456310679e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.spines.Spine.get_spine_transform#416",
        "src_path": "lib/matplotlib/spines.py",
        "class_name": "lib.matplotlib.spines.Spine",
        "signature": "lib.matplotlib.spines.Spine.get_spine_transform(self)",
        "snippet": "    def get_spine_transform(self):\n        \"\"\"Return the spine transform.\"\"\"\n        self._ensure_position_is_set()\n\n        position = self._position\n        if isinstance(position, str):\n            if position == 'center':\n                position = ('axes', 0.5)\n            elif position == 'zero':\n                position = ('data', 0)\n        assert len(position) == 2, 'position should be 2-tuple'\n        position_type, amount = position\n        cbook._check_in_list(['axes', 'outward', 'data'],\n                             position_type=position_type)\n        if self.spine_type in ['left', 'right']:\n            base_transform = self.axes.get_yaxis_transform(which='grid')\n        elif self.spine_type in ['top', 'bottom']:\n            base_transform = self.axes.get_xaxis_transform(which='grid')\n        else:\n            raise ValueError(f'unknown spine spine_type: {self.spine_type!r}')\n\n        if position_type == 'outward':\n            if amount == 0:  # short circuit commonest case\n                return base_transform\n            else:\n                offset_vec = {'left': (-1, 0), 'right': (1, 0),\n                              'bottom': (0, -1), 'top': (0, 1),\n                              }[self.spine_type]\n                # calculate x and y offset in dots\n                offset_dots = amount * np.array(offset_vec) / 72\n                return (base_transform\n                        + mtransforms.ScaledTranslation(\n                            *offset_dots, self.figure.dpi_scale_trans))\n        elif position_type == 'axes':\n            if self.spine_type in ['left', 'right']:\n                # keep y unchanged, fix x at amount\n                return (mtransforms.Affine2D.from_values(0, 0, 0, 1, amount, 0)\n                        + base_transform)\n            elif self.spine_type in ['bottom', 'top']:\n                # keep x unchanged, fix y at amount\n                return (mtransforms.Affine2D.from_values(1, 0, 0, 0, 0, amount)\n                        + base_transform)\n        elif position_type == 'data':\n            if self.spine_type in ('right', 'top'):\n                # The right and top spines have a default position of 1 in\n                # axes coordinates.  When specifying the position in data\n                # coordinates, we need to calculate the position relative to 0.\n                amount -= 1\n            if self.spine_type in ('left', 'right'):\n                return mtransforms.blended_transform_factory(\n                    mtransforms.Affine2D().translate(amount, 0)\n                    + self.axes.transData,\n                    self.axes.transData)\n            elif self.spine_type in ('bottom', 'top'):\n                return mtransforms.blended_transform_factory(\n                    self.axes.transData,\n                    mtransforms.Affine2D().translate(0, amount)\n                    + self.axes.transData)",
        "begin_line": 416,
        "end_line": 473,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017301038062283738,
            "pseudo_dstar_susp": 0.002564102564102564,
            "pseudo_tarantula_susp": 0.0008305647840531562,
            "pseudo_op2_susp": 0.002564102564102564,
            "pseudo_barinel_susp": 0.0008305647840531562
        }
    },
    {
        "name": "lib.matplotlib.spines.Spine.linear_spine#510",
        "src_path": "lib/matplotlib/spines.py",
        "class_name": "lib.matplotlib.spines.Spine",
        "signature": "lib.matplotlib.spines.Spine.linear_spine(cls, axes, spine_type, **kwargs)",
        "snippet": "    def linear_spine(cls, axes, spine_type, **kwargs):\n        \"\"\"\n        Returns a linear `Spine`.\n        \"\"\"\n        # all values of 0.999 get replaced upon call to set_bounds()\n        if spine_type == 'left':\n            path = mpath.Path([(0.0, 0.999), (0.0, 0.999)])\n        elif spine_type == 'right':\n            path = mpath.Path([(1.0, 0.999), (1.0, 0.999)])\n        elif spine_type == 'bottom':\n            path = mpath.Path([(0.999, 0.0), (0.999, 0.0)])\n        elif spine_type == 'top':\n            path = mpath.Path([(0.999, 1.0), (0.999, 1.0)])\n        else:\n            raise ValueError('unable to make path for spine \"%s\"' % spine_type)\n        result = cls(axes, spine_type, path, **kwargs)\n        result.set_visible(rcParams['axes.spines.{0}'.format(spine_type)])\n\n        return result",
        "begin_line": 510,
        "end_line": 528,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024630541871921183,
            "pseudo_dstar_susp": 0.0024330900243309003,
            "pseudo_tarantula_susp": 0.0008368200836820083,
            "pseudo_op2_susp": 0.0024330900243309003,
            "pseudo_barinel_susp": 0.0008368200836820083
        }
    },
    {
        "name": "lib.matplotlib.backend_tools.ToolHelpBase.format_shortcut#1036",
        "src_path": "lib/matplotlib/backend_tools.py",
        "class_name": "lib.matplotlib.backend_tools.ToolHelpBase",
        "signature": "lib.matplotlib.backend_tools.ToolHelpBase.format_shortcut(key_sequence)",
        "snippet": "    def format_shortcut(key_sequence):\n        \"\"\"\n        Converts a shortcut string from the notation used in rc config to the\n        standard notation for displaying shortcuts, e.g. 'ctrl+a' -> 'Ctrl+A'.\n        \"\"\"\n        return (key_sequence if len(key_sequence) == 1 else\n                re.sub(r\"\\+[A-Z]\", r\"+Shift\\g<0>\", key_sequence).title())",
        "begin_line": 1036,
        "end_line": 1042,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.testing.conftest.mpl_test_settings#33",
        "src_path": "lib/matplotlib/testing/conftest.py",
        "class_name": "lib.matplotlib.testing.conftest",
        "signature": "lib.matplotlib.testing.conftest.mpl_test_settings(request)",
        "snippet": "def mpl_test_settings(request):\n    from matplotlib.testing.decorators import _cleanup_cm\n\n    with _cleanup_cm():\n\n        backend = None\n        backend_marker = request.node.get_closest_marker('backend')\n        if backend_marker is not None:\n            assert len(backend_marker.args) == 1, \\\n                \"Marker 'backend' must specify 1 backend.\"\n            backend, = backend_marker.args\n            skip_on_importerror = backend_marker.kwargs.get(\n                'skip_on_importerror', False)\n            prev_backend = matplotlib.get_backend()\n\n            # special case Qt backend importing to avoid conflicts\n            if backend.lower().startswith('qt4'):\n                if any(k in sys.modules for k in ('PyQt5', 'PySide2')):\n                    pytest.skip('Qt5 binding already imported')\n                try:\n                    import PyQt4\n                # RuntimeError if PyQt5 already imported.\n                except (ImportError, RuntimeError):\n                    try:\n                        import PySide\n                    except ImportError:\n                        pytest.skip(\"Failed to import a Qt4 binding.\")\n            elif backend.lower().startswith('qt5'):\n                if any(k in sys.modules for k in ('PyQt4', 'PySide')):\n                    pytest.skip('Qt4 binding already imported')\n                try:\n                    import PyQt5\n                # RuntimeError if PyQt4 already imported.\n                except (ImportError, RuntimeError):\n                    try:\n                        import PySide2\n                    except ImportError:\n                        pytest.skip(\"Failed to import a Qt5 binding.\")\n\n        # Default of cleanup and image_comparison too.\n        style = [\"classic\", \"_classic_test_patch\"]\n        style_marker = request.node.get_closest_marker('style')\n        if style_marker is not None:\n            assert len(style_marker.args) == 1, \\\n                \"Marker 'style' must specify 1 style.\"\n            style, = style_marker.args\n\n        matplotlib.testing.setup()\n        if backend is not None:\n            # This import must come after setup() so it doesn't load the\n            # default backend prematurely.\n            import matplotlib.pyplot as plt\n            try:\n                plt.switch_backend(backend)\n            except ImportError as exc:\n                # Should only occur for the cairo backend tests, if neither\n                # pycairo nor cairocffi are installed.\n                if 'cairo' in backend.lower() or skip_on_importerror:\n                    pytest.skip(\"Failed to switch to backend {} ({}).\"\n                                .format(backend, exc))\n                else:\n                    raise\n        with cbook._suppress_matplotlib_deprecation_warning():\n            matplotlib.style.use(style)\n        try:\n            yield\n        finally:\n            if backend is not None:\n                plt.switch_backend(prev_backend)",
        "begin_line": 33,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00037979491074819596,
            "pseudo_dstar_susp": 0.000777000777000777,
            "pseudo_tarantula_susp": 0.0002990430622009569,
            "pseudo_op2_susp": 0.000777000777000777,
            "pseudo_barinel_susp": 0.0002990430622009569
        }
    },
    {
        "name": "lib.matplotlib.testing.conftest.pd#127",
        "src_path": "lib/matplotlib/testing/conftest.py",
        "class_name": "lib.matplotlib.testing.conftest",
        "signature": "lib.matplotlib.testing.conftest.pd()",
        "snippet": "def pd():\n    \"\"\"Fixture to import and configure pandas.\"\"\"\n    pd = pytest.importorskip('pandas')\n    try:\n        from pandas.plotting import (\n            deregister_matplotlib_converters as deregister)\n        deregister()\n    except ImportError:\n        pass\n    return pd",
        "begin_line": 127,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.RendererPS.__init__#145",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.RendererPS",
        "signature": "lib.matplotlib.backends.backend_ps.RendererPS.__init__(self, width, height, pswriter, imagedpi=72)",
        "snippet": "    def __init__(self, width, height, pswriter, imagedpi=72):\n        # Although postscript itself is dpi independent, we need to inform the\n        # image code about a requested dpi to generate high resolution images\n        # and them scale them before embedding them.\n        super().__init__(width, height)\n        self._pswriter = pswriter\n        if mpl.rcParams['text.usetex']:\n            self.textcnt = 0\n            self.psfrag = []\n        self.imagedpi = imagedpi\n\n        # current renderer state (None=uninitialised)\n        self.color = None\n        self.linewidth = None\n        self.linejoin = None\n        self.linecap = None\n        self.linedash = None\n        self.fontname = None\n        self.fontsize = None\n        self._hatches = {}\n        self.image_magnification = imagedpi / 72\n        self._clip_paths = {}\n        self._path_collection_id = 0\n\n        self._character_tracker = _backend_pdf_ps.CharacterTracker()\n        self.mathtext_parser = MathTextParser(\"PS\")",
        "begin_line": 145,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.582217645039479e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.RendererPS.set_linecap#209",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.RendererPS",
        "signature": "lib.matplotlib.backends.backend_ps.RendererPS.set_linecap(self, linecap, store=True)",
        "snippet": "    def set_linecap(self, linecap, store=True):\n        if linecap != self.linecap:\n            self._pswriter.write(\"%d setlinecap\\n\" % linecap)\n            if store:\n                self.linecap = linecap",
        "begin_line": 209,
        "end_line": 213,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.480325644504748e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash#215",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.RendererPS",
        "signature": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash(self, offset, seq, store=True)",
        "snippet": "    def set_linedash(self, offset, seq, store=True):\n        if self.linedash is not None:\n            oldo, oldseq = self.linedash\n            if np.array_equal(seq, oldseq) and oldo == offset:\n                return\n\n        if seq is not None and len(seq):\n            s = \"[%s] %d setdash\\n\" % (_nums_to_str(*seq), offset)\n            self._pswriter.write(s)\n        else:\n            self._pswriter.write(\"[] 0 setdash\\n\")\n        if store:\n            self.linedash = (offset, seq)",
        "begin_line": 215,
        "end_line": 227,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.946144211844694e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image#283",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.RendererPS",
        "signature": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image(self, gc, x, y, im, transform=None)",
        "snippet": "    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        imagecmd = \"false 3 colorimage\"\n        data = im[::-1, :, :3]  # Vertically flipped rgb values.\n        # data.tobytes().hex() has no spaces, so can be linewrapped by relying\n        # on textwrap.fill breaking long words.\n        hexlines = textwrap.fill(data.tobytes().hex(), 128)\n\n        if transform is None:\n            matrix = \"1 0 0 1 0 0\"\n            xscale = w / self.image_magnification\n            yscale = h / self.image_magnification\n        else:\n            matrix = \" \".join(map(str, transform.frozen().to_values()))\n            xscale = 1.0\n            yscale = 1.0\n\n        bbox = gc.get_clip_rectangle()\n        clippath, clippath_trans = gc.get_clip_path()\n\n        clip = []\n        if bbox is not None:\n            clipx, clipy, clipw, cliph = bbox.bounds\n            clip.append(\n                '%s clipbox' % _nums_to_str(clipw, cliph, clipx, clipy))\n        if clippath is not None:\n            id = self._get_clip_path(clippath, clippath_trans)\n            clip.append('%s' % id)\n        clip = '\\n'.join(clip)\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{clip}\n{x:f} {y:f} translate\n[{matrix}] concat\n{xscale:f} {yscale:f} scale\n/DataString {w:d} string def\n{w:d} {h:d} 8 [ {w:d} 0 0 -{h:d} 0 {h:d} ]\n{{\ncurrentfile DataString readhexstring pop\n}} bind {imagecmd}\n{hexlines}\ngrestore\n\"\"\")",
        "begin_line": 283,
        "end_line": 328,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path#356",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.RendererPS",
        "signature": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path(self, gc, path, transform, rgbFace=None)",
        "snippet": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        clip = rgbFace is None and gc.get_hatch_path() is None\n        simplify = path.should_simplify and clip\n        ps = self._convert_path(path, transform, clip=clip, simplify=simplify)\n        self._draw_ps(ps, gc, rgbFace)",
        "begin_line": 356,
        "end_line": 361,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.999000099990002e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text#503",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.RendererPS",
        "signature": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None)",
        "snippet": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # local to avoid repeated attribute lookups\n        write = self._pswriter.write\n        if debugPS:\n            write(\"% text\\n\")\n\n        if _is_transparent(gc.get_rgb()):\n            return  # Special handling for fully transparent.\n\n        if ismath == 'TeX':\n            return self.draw_tex(gc, x, y, s, prop, angle)\n\n        elif ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        elif mpl.rcParams['ps.useafm']:\n            self.set_color(*gc.get_rgb())\n\n            font = self._get_font_afm(prop)\n            fontname = font.get_fontname()\n            fontsize = prop.get_size_in_points()\n            scale = 0.001 * fontsize\n\n            thisx = 0\n            thisy = font.get_str_bbox_and_descent(s)[4] * scale\n            last_name = None\n            lines = []\n            for c in s:\n                name = uni2type1.get(ord(c), f\"uni{ord(c):04X}\")\n                try:\n                    width = font.get_width_from_char_name(name)\n                except KeyError:\n                    name = 'question'\n                    width = font.get_width_char('?')\n                if last_name is not None:\n                    kern = font.get_kern_dist_from_name(last_name, name)\n                else:\n                    kern = 0\n                last_name = name\n                thisx += kern * scale\n\n                lines.append('%f %f m /%s glyphshow' % (thisx, thisy, name))\n\n                thisx += width * scale\n\n            thetext = \"\\n\".join(lines)\n            self._pswriter.write(f\"\"\"\\\ngsave\n/{fontname} findfont\n{fontsize} scalefont\nsetfont\n{x:f} {y:f} translate\n{angle:f} rotate\n{thetext}\ngrestore\n\"\"\")\n\n        else:\n            font = self._get_font_ttf(prop)\n            font.set_text(s, 0, flags=LOAD_NO_HINTING)\n            self._character_tracker.track(font, s)\n\n            self.set_color(*gc.get_rgb())\n            ps_name = (font.postscript_name\n                       .encode('ascii', 'replace').decode('ascii'))\n            self.set_font(ps_name, prop.get_size_in_points())\n\n            thetext = '\\n'.join(\n                '%f 0 m /%s glyphshow' % (x, font.get_glyph_name(glyph_idx))\n                for glyph_idx, x in _text_layout.layout(s, font))\n            self._pswriter.write(f\"\"\"\\\ngsave\n{x:f} {y:f} translate\n{angle:f} rotate\n{thetext}\ngrestore\n\"\"\")",
        "begin_line": 503,
        "end_line": 581,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.RendererPS.new_gc#583",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.RendererPS",
        "signature": "lib.matplotlib.backends.backend_ps.RendererPS.new_gc(self)",
        "snippet": "    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextPS()",
        "begin_line": 583,
        "end_line": 585,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.RendererPS._draw_ps#652",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.RendererPS",
        "signature": "lib.matplotlib.backends.backend_ps.RendererPS._draw_ps(self, ps, gc, rgbFace, fill=True, stroke=True, command=None)",
        "snippet": "    def _draw_ps(self, ps, gc, rgbFace, fill=True, stroke=True, command=None):\n        \"\"\"\n        Emit the PostScript snippet 'ps' with all the attributes from 'gc'\n        applied.  'ps' must consist of PostScript commands to construct a path.\n\n        The fill and/or stroke kwargs can be set to False if the\n        'ps' string already includes filling and/or stroking, in\n        which case _draw_ps is just supplying properties and\n        clipping.\n        \"\"\"\n        # local variable eliminates all repeated attribute lookups\n        write = self._pswriter.write\n        if debugPS and command:\n            write(\"% \"+command+\"\\n\")\n        mightstroke = (gc.get_linewidth() > 0\n                       and not _is_transparent(gc.get_rgb()))\n        if not mightstroke:\n            stroke = False\n        if _is_transparent(rgbFace):\n            fill = False\n        hatch = gc.get_hatch()\n\n        if mightstroke:\n            self.set_linewidth(gc.get_linewidth())\n            jint = gc.get_joinstyle()\n            self.set_linejoin(jint)\n            cint = gc.get_capstyle()\n            self.set_linecap(cint)\n            self.set_linedash(*gc.get_dashes())\n            self.set_color(*gc.get_rgb()[:3])\n        write('gsave\\n')\n\n        cliprect = gc.get_clip_rectangle()\n        if cliprect:\n            x, y, w, h = cliprect.bounds\n            write('%1.4g %1.4g %1.4g %1.4g clipbox\\n' % (w, h, x, y))\n        clippath, clippath_trans = gc.get_clip_path()\n        if clippath:\n            id = self._get_clip_path(clippath, clippath_trans)\n            write('%s\\n' % id)\n\n        # Jochen, is the strip necessary? - this could be a honking big string\n        write(ps.strip())\n        write(\"\\n\")\n\n        if fill:\n            if stroke or hatch:\n                write(\"gsave\\n\")\n            self.set_color(*rgbFace[:3], store=False)\n            write(\"fill\\n\")\n            if stroke or hatch:\n                write(\"grestore\\n\")\n\n        if hatch:\n            hatch_name = self.create_hatch(hatch)\n            write(\"gsave\\n\")\n            write(\"%f %f %f \" % gc.get_hatch_color()[:3])\n            write(\"%s setpattern fill grestore\\n\" % hatch_name)\n\n        if stroke:\n            write(\"stroke\\n\")\n\n        write(\"grestore\\n\")",
        "begin_line": 652,
        "end_line": 714,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.999000099990002e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_ps#757",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.FigureCanvasPS",
        "signature": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_ps(self, outfile, *args, **kwargs)",
        "snippet": "    def print_ps(self, outfile, *args, **kwargs):\n        return self._print_ps(outfile, 'ps', *args, **kwargs)",
        "begin_line": 757,
        "end_line": 758,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.FigureCanvasPS._print_ps#763",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.FigureCanvasPS",
        "signature": "lib.matplotlib.backends.backend_ps.FigureCanvasPS._print_ps(self, outfile, format, *args, dpi=72, metadata=None, papertype=None, orientation='portrait', **kwargs)",
        "snippet": "    def _print_ps(\n            self, outfile, format, *args,\n            dpi=72, metadata=None, papertype=None, orientation='portrait',\n            **kwargs):\n\n        self.figure.set_dpi(72)  # Override the dpi kwarg\n\n        dsc_comments = {}\n        if isinstance(outfile, (str, os.PathLike)):\n            dsc_comments[\"Title\"] = \\\n                os.fspath(outfile).encode(\"ascii\", \"replace\").decode(\"ascii\")\n        dsc_comments[\"Creator\"] = (metadata or {}).get(\n            \"Creator\",\n            f\"matplotlib version {mpl.__version__}, http://matplotlib.org/\")\n        # See https://reproducible-builds.org/specs/source-date-epoch/\n        source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n        dsc_comments[\"CreationDate\"] = (\n            datetime.datetime.utcfromtimestamp(\n                int(source_date_epoch)).strftime(\"%a %b %d %H:%M:%S %Y\")\n            if source_date_epoch\n            else time.ctime())\n        dsc_comments = \"\\n\".join(\n            f\"%%{k}: {v}\" for k, v in dsc_comments.items())\n\n        if papertype is None:\n            papertype = mpl.rcParams['ps.papersize']\n        papertype = papertype.lower()\n        cbook._check_in_list(['auto', *papersize], papertype=papertype)\n\n        orientation = cbook._check_getitem(\n            _Orientation, orientation=orientation.lower())\n\n        printer = (self._print_figure_tex\n                   if mpl.rcParams['text.usetex'] else\n                   self._print_figure)\n        printer(outfile, format, dpi=dpi, dsc_comments=dsc_comments,\n                orientation=orientation, papertype=papertype, **kwargs)",
        "begin_line": 763,
        "end_line": 799,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.530162965786715e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.FigureCanvasPS._print_figure#802",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.FigureCanvasPS",
        "signature": "lib.matplotlib.backends.backend_ps.FigureCanvasPS._print_figure(self, outfile, format, *, dpi, dsc_comments, orientation, papertype, dryrun=False, bbox_inches_restore=None, **kwargs)",
        "snippet": "    def _print_figure(\n            self, outfile, format, *,\n            dpi, dsc_comments, orientation, papertype,\n            dryrun=False, bbox_inches_restore=None, **kwargs):\n        \"\"\"\n        Render the figure to a filesystem path or a file-like object.\n\n        Parameters are as for `.print_figure`, except that *dsc_comments* is a\n        all string containing Document Structuring Convention comments,\n        generated from the *metadata* parameter to `.print_figure`.\n        \"\"\"\n        is_eps = format == 'eps'\n        if isinstance(outfile, (str, os.PathLike)):\n            outfile = os.fspath(outfile)\n            passed_in_file_object = False\n        elif is_writable_file_like(outfile):\n            passed_in_file_object = True\n        else:\n            raise ValueError(\"outfile must be a path or a file-like object\")\n\n        # find the appropriate papertype\n        width, height = self.figure.get_size_inches()\n        if papertype == 'auto':\n            papertype = _get_papertype(\n                *orientation.swap_if_landscape((width, height)))\n        paper_width, paper_height = orientation.swap_if_landscape(\n            papersize[papertype])\n\n        if mpl.rcParams['ps.usedistiller']:\n            # distillers improperly clip eps files if pagesize is too small\n            if width > paper_width or height > paper_height:\n                papertype = _get_papertype(\n                    *orientation.swap_if_landscape(width, height))\n                paper_width, paper_height = orientation.swap_if_landscape(\n                    papersize[papertype])\n\n        # center the figure on the paper\n        xo = 72 * 0.5 * (paper_width - width)\n        yo = 72 * 0.5 * (paper_height - height)\n\n        l, b, w, h = self.figure.bbox.bounds\n        llx = xo\n        lly = yo\n        urx = llx + w\n        ury = lly + h\n        rotation = 0\n        if orientation is _Orientation.landscape:\n            llx, lly, urx, ury = lly, llx, ury, urx\n            xo, yo = 72 * paper_height - yo, xo\n            rotation = 90\n        bbox = (llx, lly, urx, ury)\n\n        if dryrun:\n            class NullWriter:\n                def write(self, *args, **kwargs):\n                    pass\n\n            self._pswriter = NullWriter()\n        else:\n            self._pswriter = StringIO()\n\n        # mixed mode rendering\n        ps_renderer = RendererPS(width, height, self._pswriter, imagedpi=dpi)\n        renderer = MixedModeRenderer(\n            self.figure, width, height, dpi, ps_renderer,\n            bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n\n        if dryrun:  # return immediately if dryrun (tightbbox=True)\n            return\n\n        def print_figure_impl(fh):\n            # write the PostScript headers\n            if is_eps:\n                print(\"%!PS-Adobe-3.0 EPSF-3.0\", file=fh)\n            else:\n                print(f\"%!PS-Adobe-3.0\\n\"\n                      f\"%%DocumentPaperSizes: {papertype}\\n\"\n                      f\"%%Pages: 1\\n\",\n                      end=\"\", file=fh)\n            print(f\"{dsc_comments}\\n\"\n                  f\"%%Orientation: {orientation.name}\\n\"\n                  f\"%%BoundingBox: {bbox[0]} {bbox[1]} {bbox[2]} {bbox[3]}\\n\"\n                  f\"%%EndComments\\n\",\n                  end=\"\", file=fh)\n\n            Ndict = len(psDefs)\n            print(\"%%BeginProlog\", file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                Ndict += len(ps_renderer._character_tracker.used)\n            print(\"/mpldict %d dict def\" % Ndict, file=fh)\n            print(\"mpldict begin\", file=fh)\n            print(\"\\n\".join(psDefs), file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                for font_path, chars \\\n                        in ps_renderer._character_tracker.used.items():\n                    if not chars:\n                        continue\n                    font = get_font(font_path)\n                    glyph_ids = [font.get_char_index(c) for c in chars]\n                    fonttype = mpl.rcParams['ps.fonttype']\n                    # Can't use more than 255 chars from a single Type 3 font.\n                    if len(glyph_ids) > 255:\n                        fonttype = 42\n                    # The ttf to ps (subsetting) support doesn't work for\n                    # OpenType fonts that are Postscript inside (like the STIX\n                    # fonts).  This will simply turn that off to avoid errors.\n                    if is_opentype_cff_font(font_path):\n                        raise RuntimeError(\n                            \"OpenType CFF fonts can not be saved using \"\n                            \"the internal Postscript backend at this \"\n                            \"time; consider using the Cairo backend\")\n                    fh.flush()\n                    try:\n                        convert_ttf_to_ps(os.fsencode(font_path),\n                                          fh, fonttype, glyph_ids)\n                    except RuntimeError:\n                        _log.warning(\"The PostScript backend does not \"\n                                     \"currently support the selected font.\")\n                        raise\n            print(\"end\", file=fh)\n            print(\"%%EndProlog\", file=fh)\n\n            if not is_eps:\n                print(\"%%Page: 1 1\", file=fh)\n            print(\"mpldict begin\", file=fh)\n\n            print(\"%s translate\" % _nums_to_str(xo, yo), file=fh)\n            if rotation:\n                print(\"%d rotate\" % rotation, file=fh)\n            print(\"%s clipbox\" % _nums_to_str(width*72, height*72, 0, 0),\n                  file=fh)\n\n            # write the figure\n            content = self._pswriter.getvalue()\n            if not isinstance(content, str):\n                content = content.decode('ascii')\n            print(content, file=fh)\n\n            # write the trailer\n            print(\"end\", file=fh)\n            print(\"showpage\", file=fh)\n            if not is_eps:\n                print(\"%%EOF\", file=fh)\n            fh.flush()\n\n        if mpl.rcParams['ps.usedistiller']:\n            # We are going to use an external program to process the output.\n            # Write to a temporary file.\n            with TemporaryDirectory() as tmpdir:\n                tmpfile = os.path.join(tmpdir, \"tmp.ps\")\n                with open(tmpfile, 'w', encoding='latin-1') as fh:\n                    print_figure_impl(fh)\n                if mpl.rcParams['ps.usedistiller'] == 'ghostscript':\n                    _try_distill(gs_distill,\n                                 tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                    _try_distill(xpdf_distill,\n                                 tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                _move_path_to_path_or_stream(tmpfile, outfile)\n\n        else:\n            # Write directly to outfile.\n            if passed_in_file_object:\n                requires_unicode = file_requires_unicode(outfile)\n\n                if not requires_unicode:\n                    fh = TextIOWrapper(outfile, encoding=\"latin-1\")\n                    # Prevent the TextIOWrapper from closing the underlying\n                    # file.\n                    fh.close = lambda: None\n                else:\n                    fh = outfile\n\n                print_figure_impl(fh)\n            else:\n                with open(outfile, 'w', encoding='latin-1') as fh:\n                    print_figure_impl(fh)",
        "begin_line": 802,
        "end_line": 980,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_figure_impl#874",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps.FigureCanvasPS",
        "signature": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_figure_impl(fh)",
        "snippet": "        def print_figure_impl(fh):\n            # write the PostScript headers\n            if is_eps:\n                print(\"%!PS-Adobe-3.0 EPSF-3.0\", file=fh)\n            else:\n                print(f\"%!PS-Adobe-3.0\\n\"\n                      f\"%%DocumentPaperSizes: {papertype}\\n\"\n                      f\"%%Pages: 1\\n\",\n                      end=\"\", file=fh)\n            print(f\"{dsc_comments}\\n\"\n                  f\"%%Orientation: {orientation.name}\\n\"\n                  f\"%%BoundingBox: {bbox[0]} {bbox[1]} {bbox[2]} {bbox[3]}\\n\"\n                  f\"%%EndComments\\n\",\n                  end=\"\", file=fh)\n\n            Ndict = len(psDefs)\n            print(\"%%BeginProlog\", file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                Ndict += len(ps_renderer._character_tracker.used)\n            print(\"/mpldict %d dict def\" % Ndict, file=fh)\n            print(\"mpldict begin\", file=fh)\n            print(\"\\n\".join(psDefs), file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                for font_path, chars \\\n                        in ps_renderer._character_tracker.used.items():\n                    if not chars:\n                        continue\n                    font = get_font(font_path)\n                    glyph_ids = [font.get_char_index(c) for c in chars]\n                    fonttype = mpl.rcParams['ps.fonttype']\n                    # Can't use more than 255 chars from a single Type 3 font.\n                    if len(glyph_ids) > 255:\n                        fonttype = 42\n                    # The ttf to ps (subsetting) support doesn't work for\n                    # OpenType fonts that are Postscript inside (like the STIX\n                    # fonts).  This will simply turn that off to avoid errors.\n                    if is_opentype_cff_font(font_path):\n                        raise RuntimeError(\n                            \"OpenType CFF fonts can not be saved using \"\n                            \"the internal Postscript backend at this \"\n                            \"time; consider using the Cairo backend\")\n                    fh.flush()\n                    try:\n                        convert_ttf_to_ps(os.fsencode(font_path),\n                                          fh, fonttype, glyph_ids)\n                    except RuntimeError:\n                        _log.warning(\"The PostScript backend does not \"\n                                     \"currently support the selected font.\")\n                        raise\n            print(\"end\", file=fh)\n            print(\"%%EndProlog\", file=fh)\n\n            if not is_eps:\n                print(\"%%Page: 1 1\", file=fh)\n            print(\"mpldict begin\", file=fh)\n\n            print(\"%s translate\" % _nums_to_str(xo, yo), file=fh)\n            if rotation:\n                print(\"%d rotate\" % rotation, file=fh)\n            print(\"%s clipbox\" % _nums_to_str(width*72, height*72, 0, 0),\n                  file=fh)\n\n            # write the figure\n            content = self._pswriter.getvalue()\n            if not isinstance(content, str):\n                content = content.decode('ascii')\n            print(content, file=fh)\n\n            # write the trailer\n            print(\"end\", file=fh)\n            print(\"showpage\", file=fh)\n            if not is_eps:\n                print(\"%%EOF\", file=fh)\n            fh.flush()",
        "begin_line": 874,
        "end_line": 947,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps._try_distill#1137",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps",
        "signature": "lib.matplotlib.backends.backend_ps._try_distill(func, *args, **kwargs)",
        "snippet": "def _try_distill(func, *args, **kwargs):\n    try:\n        func(*args, **kwargs)\n    except mpl.ExecutableNotFoundError as exc:\n        _log.warning(\"%s.  Distillation step skipped.\", exc)",
        "begin_line": 1137,
        "end_line": 1141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_ps.gs_distill#1144",
        "src_path": "lib/matplotlib/backends/backend_ps.py",
        "class_name": "lib.matplotlib.backends.backend_ps",
        "signature": "lib.matplotlib.backends.backend_ps.gs_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False)",
        "snippet": "def gs_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False):\n    \"\"\"\n    Use ghostscript's pswrite or epswrite device to distill a file.\n    This yields smaller files without illegal encapsulated postscript\n    operators. The output is low-level, converting text to outlines.\n    \"\"\"\n\n    if eps:\n        paper_option = \"-dEPSCrop\"\n    else:\n        paper_option = \"-sPAPERSIZE=%s\" % ptype\n\n    psfile = tmpfile + '.ps'\n    dpi = mpl.rcParams['ps.distiller.res']\n\n    cbook._check_and_log_subprocess(\n        [mpl._get_executable_info(\"gs\").executable,\n         \"-dBATCH\", \"-dNOPAUSE\", \"-r%d\" % dpi, \"-sDEVICE=ps2write\",\n         paper_option, \"-sOutputFile=%s\" % psfile, tmpfile],\n        _log)\n\n    os.remove(tmpfile)\n    shutil.move(psfile, tmpfile)\n\n    # While it is best if above steps preserve the original bounding\n    # box, there seem to be cases when it is not. For those cases,\n    # the original bbox can be restored during the pstoeps step.\n\n    if eps:\n        # For some versions of gs, above steps result in an ps file where the\n        # original bbox is no more correct. Do not adjust bbox for now.\n        pstoeps(tmpfile, bbox, rotated=rotated)",
        "begin_line": 1144,
        "end_line": 1175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triangulation.Triangulation.__init__#38",
        "src_path": "lib/matplotlib/tri/triangulation.py",
        "class_name": "lib.matplotlib.tri.triangulation.Triangulation",
        "signature": "lib.matplotlib.tri.triangulation.Triangulation.__init__(self, x, y, triangles=None, mask=None)",
        "snippet": "    def __init__(self, x, y, triangles=None, mask=None):\n        from matplotlib import _qhull\n\n        self.x = np.asarray(x, dtype=np.float64)\n        self.y = np.asarray(y, dtype=np.float64)\n        if self.x.shape != self.y.shape or self.x.ndim != 1:\n            raise ValueError(\"x and y must be equal-length 1-D arrays\")\n\n        self.mask = None\n        self._edges = None\n        self._neighbors = None\n        self.is_delaunay = False\n\n        if triangles is None:\n            # No triangulation specified, so use matplotlib._qhull to obtain\n            # Delaunay triangulation.\n            self.triangles, self._neighbors = _qhull.delaunay(x, y)\n            self.is_delaunay = True\n        else:\n            # Triangulation specified. Copy, since we may correct triangle\n            # orientation.\n            self.triangles = np.array(triangles, dtype=np.int32, order='C')\n            if self.triangles.ndim != 2 or self.triangles.shape[1] != 3:\n                raise ValueError('triangles must be a (?, 3) array')\n            if self.triangles.max() >= len(self.x):\n                raise ValueError('triangles max element is out of bounds')\n            if self.triangles.min() < 0:\n                raise ValueError('triangles min element is out of bounds')\n\n        if mask is not None:\n            self.mask = np.asarray(mask, dtype=bool)\n            if self.mask.shape != (self.triangles.shape[0],):\n                raise ValueError('mask array must have same length as '\n                                 'triangles array')\n\n        # Underlying C++ object is not created until first needed.\n        self._cpp_triangulation = None\n\n        # Default TriFinder not created until needed.\n        self._trifinder = None",
        "begin_line": 38,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.061265618702137e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triangulation.Triangulation.edges#90",
        "src_path": "lib/matplotlib/tri/triangulation.py",
        "class_name": "lib.matplotlib.tri.triangulation.Triangulation",
        "signature": "lib.matplotlib.tri.triangulation.Triangulation.edges(self)",
        "snippet": "    def edges(self):\n        \"\"\"\n        Return integer array of shape (nedges, 2) containing all edges of\n        non-masked triangles.\n\n        Each row defines an edge by it's start point index and end point\n        index.  Each edge appears only once, i.e. for an edge between points\n        *i*  and *j*, there will only be either *(i, j)* or *(j, i)*.\n        \"\"\"\n        if self._edges is None:\n            self._edges = self.get_cpp_triangulation().get_edges()\n        return self._edges",
        "begin_line": 90,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.003201280512204e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triangulation.Triangulation.get_cpp_triangulation#103",
        "src_path": "lib/matplotlib/tri/triangulation.py",
        "class_name": "lib.matplotlib.tri.triangulation.Triangulation",
        "signature": "lib.matplotlib.tri.triangulation.Triangulation.get_cpp_triangulation(self)",
        "snippet": "    def get_cpp_triangulation(self):\n        \"\"\"\n        Return the underlying C++ Triangulation object, creating it\n        if necessary.\n        \"\"\"\n        from matplotlib import _tri\n        if self._cpp_triangulation is None:\n            self._cpp_triangulation = _tri.Triangulation(\n                self.x, self.y, self.triangles, self.mask, self._edges,\n                self._neighbors, not self.is_delaunay)\n        return self._cpp_triangulation",
        "begin_line": 103,
        "end_line": 113,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.300821781356355e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triangulation.Triangulation.neighbors#180",
        "src_path": "lib/matplotlib/tri/triangulation.py",
        "class_name": "lib.matplotlib.tri.triangulation.Triangulation",
        "signature": "lib.matplotlib.tri.triangulation.Triangulation.neighbors(self)",
        "snippet": "    def neighbors(self):\n        \"\"\"\n        Return integer array of shape (ntri, 3) containing neighbor triangles.\n\n        For each triangle, the indices of the three triangles that\n        share the same edges, or -1 if there is no such neighboring\n        triangle.  ``neighbors[i, j]`` is the triangle that is the neighbor\n        to the edge from point index ``triangles[i, j]`` to point index\n        ``triangles[i, (j+1)%3]``.\n        \"\"\"\n        if self._neighbors is None:\n            self._neighbors = self.get_cpp_triangulation().get_neighbors()\n        return self._neighbors",
        "begin_line": 180,
        "end_line": 192,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.406893652795292e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourLabeler.get_label_width#241",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourLabeler",
        "signature": "lib.matplotlib.contour.ContourLabeler.get_label_width(self, lev, fmt, fsize)",
        "snippet": "    def get_label_width(self, lev, fmt, fsize):\n        \"\"\"\n        Return the width of the label in points.\n        \"\"\"\n        if not isinstance(lev, str):\n            lev = self.get_text(lev, fmt)\n        lev, ismath = text.Text()._preprocess_math(lev)\n        if ismath == 'TeX':\n            lw, _, _ = (texmanager.TexManager()\n                        .get_text_width_height_descent(lev, fsize))\n        elif ismath:\n            if not hasattr(self, '_mathtext_parser'):\n                self._mathtext_parser = mathtext.MathTextParser('bitmap')\n            img, _ = self._mathtext_parser.parse(lev, dpi=72,\n                                                 prop=self.labelFontProps)\n            _, lw = np.shape(img)  # at dpi=72, the units are PostScript points\n        else:\n            # width is much less than \"font size\"\n            lw = len(lev) * fsize * 0.6\n        return lw",
        "begin_line": 241,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.19793966151582e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourLabeler.add_label_near#458",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourLabeler",
        "signature": "lib.matplotlib.contour.ContourLabeler.add_label_near(self, x, y, inline=True, inline_spacing=5, transform=None)",
        "snippet": "    def add_label_near(self, x, y, inline=True, inline_spacing=5,\n                       transform=None):\n        \"\"\"\n        Add a label near the point (x, y). If transform is None\n        (default), (x, y) is in data coordinates; if transform is\n        False, (x, y) is in display coordinates; otherwise, the\n        specified transform will be used to translate (x, y) into\n        display coordinates.\n\n        Parameters\n        ----------\n        x, y : float\n            The approximate location of the label.\n\n        inline : bool, default: True\n            If *True* remove the segment of the contour beneath the label.\n\n        inline_spacing : int, default: 5\n            Space in pixels to leave on each side of label when placing\n            inline. This spacing will be exact for labels at locations where\n            the contour is straight, less so for labels on curved contours.\n        \"\"\"\n\n        if transform is None:\n            transform = self.ax.transData\n\n        if transform:\n            x, y = transform.transform((x, y))\n\n        # find the nearest contour _in screen units_\n        conmin, segmin, imin, xmin, ymin = self.find_nearest_contour(\n            x, y, self.labelIndiceList)[:5]\n\n        # The calc_label_rot_and_inline routine requires that (xmin, ymin)\n        # be a vertex in the path. So, if it isn't, add a vertex here\n\n        # grab the paths from the collections\n        paths = self.collections[conmin].get_paths()\n        # grab the correct segment\n        active_path = paths[segmin]\n        # grab its vertices\n        lc = active_path.vertices\n        # sort out where the new vertex should be added data-units\n        xcmin = self.ax.transData.inverted().transform([xmin, ymin])\n        # if there isn't a vertex close enough\n        if not np.allclose(xcmin, lc[imin]):\n            # insert new data into the vertex list\n            lc = np.row_stack([lc[:imin], xcmin, lc[imin:]])\n            # replace the path with the new one\n            paths[segmin] = mpath.Path(lc)\n\n        # Get index of nearest level in subset of levels used for labeling\n        lmin = self.labelIndiceList.index(conmin)\n\n        # Coordinates of contour\n        paths = self.collections[conmin].get_paths()\n        lc = paths[segmin].vertices\n\n        # In pixel/screen space\n        slc = self.ax.transData.transform(lc)\n\n        # Get label width for rotating labels and breaking contours\n        lw = self.get_label_width(self.labelLevelList[lmin],\n                                  self.labelFmt, self.labelFontSizeList[lmin])\n        # lw is in points.\n        lw *= self.ax.figure.dpi / 72.0  # scale to screen coordinates\n        # now lw in pixels\n\n        # Figure out label rotation.\n        rotation, nlc = self.calc_label_rot_and_inline(\n            slc, imin, lw, lc if inline else None, inline_spacing)\n\n        self.add_label(xmin, ymin, rotation, self.labelLevelList[lmin],\n                       self.labelCValueList[lmin])\n\n        if inline:\n            # Remove old, not looping over paths so we can do this up front\n            paths.pop(segmin)\n\n            # Add paths if not empty or single point\n            for n in nlc:\n                if len(n) > 1:\n                    paths.append(mpath.Path(n))",
        "begin_line": 458,
        "end_line": 540,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourLabeler.labels#548",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourLabeler",
        "signature": "lib.matplotlib.contour.ContourLabeler.labels(self, inline, inline_spacing)",
        "snippet": "    def labels(self, inline, inline_spacing):\n\n        if self._use_clabeltext:\n            add_label = self.add_label_clabeltext\n        else:\n            add_label = self.add_label\n\n        for icon, lev, fsize, cvalue in zip(\n                self.labelIndiceList, self.labelLevelList,\n                self.labelFontSizeList, self.labelCValueList):\n\n            con = self.collections[icon]\n            trans = con.get_transform()\n            lw = self.get_label_width(lev, self.labelFmt, fsize)\n            lw *= self.ax.figure.dpi / 72.0  # scale to screen coordinates\n            additions = []\n            paths = con.get_paths()\n            for segNum, linepath in enumerate(paths):\n                lc = linepath.vertices  # Line contour\n                slc0 = trans.transform(lc)  # Line contour in screen coords\n\n                # For closed polygons, add extra point to avoid division by\n                # zero in print_label and locate_label.  Other than these\n                # functions, this is not necessary and should probably be\n                # eventually removed.\n                if _is_closed_polygon(lc):\n                    slc = np.row_stack([slc0, slc0[1:2]])\n                else:\n                    slc = slc0\n\n                # Check if long enough for a label\n                if self.print_label(slc, lw):\n                    x, y, ind = self.locate_label(slc, lw)\n\n                    rotation, new = self.calc_label_rot_and_inline(\n                        slc0, ind, lw, lc if inline else None, inline_spacing)\n\n                    # Actually add the label\n                    add_label(x, y, rotation, lev, cvalue)\n\n                    # If inline, add new contours\n                    if inline:\n                        for n in new:\n                            # Add path if not empty or single point\n                            if len(n) > 1:\n                                additions.append(mpath.Path(n))\n                else:  # If not adding label, keep old path\n                    additions.append(linepath)\n\n            # After looping over all segments on a contour, replace old paths\n            # by new ones if inlining.\n            if inline:\n                paths[:] = additions",
        "begin_line": 548,
        "end_line": 600,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour._find_closest_point_on_leg#603",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour",
        "signature": "lib.matplotlib.contour._find_closest_point_on_leg(p1, p2, p0)",
        "snippet": "def _find_closest_point_on_leg(p1, p2, p0):\n    \"\"\"Find the closest point to p0 on line segment connecting p1 and p2.\"\"\"\n\n    # handle degenerate case\n    if np.all(p2 == p1):\n        d = np.sum((p0 - p1)**2)\n        return d, p1\n\n    d21 = p2 - p1\n    d01 = p0 - p1\n\n    # project on to line segment to find closest point\n    proj = np.dot(d01, d21) / np.dot(d21, d21)\n    if proj < 0:\n        proj = 0\n    if proj > 1:\n        proj = 1\n    pc = p1 + proj * d21\n\n    # find squared distance\n    d = np.sum((pc-p0)**2)\n\n    return d, pc",
        "begin_line": 603,
        "end_line": 625,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet.__init__#728",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet.__init__(self, ax, *args, levels=None, filled=False, linewidths=None, linestyles=None, alpha=None, origin=None, extent=None, cmap=None, colors=None, norm=None, vmin=None, vmax=None, extend='neither', antialiased=None, **kwargs)",
        "snippet": "    def __init__(self, ax, *args,\n                 levels=None, filled=False, linewidths=None, linestyles=None,\n                 alpha=None, origin=None, extent=None,\n                 cmap=None, colors=None, norm=None, vmin=None, vmax=None,\n                 extend='neither', antialiased=None,\n                 **kwargs):\n        \"\"\"\n        Draw contour lines or filled regions, depending on\n        whether keyword arg *filled* is ``False`` (default) or ``True``.\n\n        Call signature::\n\n            ContourSet(ax, levels, allsegs, [allkinds], **kwargs)\n\n        Parameters\n        ----------\n        ax : `~.axes.Axes`\n            The `~.axes.Axes` object to draw on.\n\n        levels : [level0, level1, ..., leveln]\n            A list of floating point numbers indicating the contour\n            levels.\n\n        allsegs : [level0segs, level1segs, ...]\n            List of all the polygon segments for all the *levels*.\n            For contour lines ``len(allsegs) == len(levels)``, and for\n            filled contour regions ``len(allsegs) = len(levels)-1``. The lists\n            should look like ::\n\n                level0segs = [polygon0, polygon1, ...]\n                polygon0 = [[x0, y0], [x1, y1], ...]\n\n        allkinds : [level0kinds, level1kinds, ...], optional\n            Optional list of all the polygon vertex kinds (code types), as\n            described and used in Path. This is used to allow multiply-\n            connected paths such as holes within filled polygons.\n            If not ``None``, ``len(allkinds) == len(allsegs)``. The lists\n            should look like ::\n\n                level0kinds = [polygon0kinds, ...]\n                polygon0kinds = [vertexcode0, vertexcode1, ...]\n\n            If *allkinds* is not ``None``, usually all polygons for a\n            particular contour level are grouped together so that\n            ``level0segs = [polygon0]`` and ``level0kinds = [polygon0kinds]``.\n\n        **kwargs\n            Keyword arguments are as described in the docstring of\n            `~.Axes.contour`.\n        \"\"\"\n        self.ax = ax\n        self.levels = levels\n        self.filled = filled\n        self.linewidths = linewidths\n        self.linestyles = linestyles\n        self.hatches = kwargs.pop('hatches', [None])\n        self.alpha = alpha\n        self.origin = origin\n        self.extent = extent\n        self.colors = colors\n        self.extend = extend\n        self.antialiased = antialiased\n        if self.antialiased is None and self.filled:\n            # Eliminate artifacts; we are not stroking the boundaries.\n            self.antialiased = False\n            # The default for line contours will be taken from the\n            # LineCollection default, which uses :rc:`lines.antialiased`.\n\n        self.nchunk = kwargs.pop('nchunk', 0)\n        self.locator = kwargs.pop('locator', None)\n        if (isinstance(norm, mcolors.LogNorm)\n                or isinstance(self.locator, ticker.LogLocator)):\n            self.logscale = True\n            if norm is None:\n                norm = mcolors.LogNorm()\n        else:\n            self.logscale = False\n\n        cbook._check_in_list([None, 'lower', 'upper', 'image'], origin=origin)\n        if self.extent is not None and len(self.extent) != 4:\n            raise ValueError(\n                \"If given, 'extent' must be None or (x0, x1, y0, y1)\")\n        if self.colors is not None and cmap is not None:\n            raise ValueError('Either colors or cmap must be None')\n        if self.origin == 'image':\n            self.origin = mpl.rcParams['image.origin']\n\n        self._transform = kwargs.pop('transform', None)\n\n        kwargs = self._process_args(*args, **kwargs)\n        self._process_levels()\n\n        if self.colors is not None:\n            ncolors = len(self.levels)\n            if self.filled:\n                ncolors -= 1\n            i0 = 0\n\n            # Handle the case where colors are given for the extended\n            # parts of the contour.\n            extend_min = self.extend in ['min', 'both']\n            extend_max = self.extend in ['max', 'both']\n            use_set_under_over = False\n            # if we are extending the lower end, and we've been given enough\n            # colors then skip the first color in the resulting cmap. For the\n            # extend_max case we don't need to worry about passing more colors\n            # than ncolors as ListedColormap will clip.\n            total_levels = ncolors + int(extend_min) + int(extend_max)\n            if len(self.colors) == total_levels and (extend_min or extend_max):\n                use_set_under_over = True\n                if extend_min:\n                    i0 = 1\n\n            cmap = mcolors.ListedColormap(self.colors[i0:None], N=ncolors)\n\n            if use_set_under_over:\n                if extend_min:\n                    cmap.set_under(self.colors[0])\n                if extend_max:\n                    cmap.set_over(self.colors[-1])\n\n        if self.filled:\n            self.collections = cbook.silent_list('mcoll.PathCollection')\n        else:\n            self.collections = cbook.silent_list('mcoll.LineCollection')\n        # label lists must be initialized here\n        self.labelTexts = []\n        self.labelCValues = []\n\n        kw = {'cmap': cmap}\n        if norm is not None:\n            kw['norm'] = norm\n        # sets self.cmap, norm if needed;\n        cm.ScalarMappable.__init__(self, **kw)\n        if vmin is not None:\n            self.norm.vmin = vmin\n        if vmax is not None:\n            self.norm.vmax = vmax\n        self._process_colors()\n\n        self.allsegs, self.allkinds = self._get_allsegs_and_allkinds()\n\n        if self.filled:\n            if self.linewidths is not None:\n                cbook._warn_external('linewidths is ignored by contourf')\n\n            # Lower and upper contour levels.\n            lowers, uppers = self._get_lowers_and_uppers()\n\n            # Ensure allkinds can be zipped below.\n            if self.allkinds is None:\n                self.allkinds = [None] * len(self.allsegs)\n\n            # Default zorder taken from Collection\n            self._contour_zorder = kwargs.pop('zorder', 1)\n            for level, level_upper, segs, kinds in \\\n                    zip(lowers, uppers, self.allsegs, self.allkinds):\n                paths = self._make_paths(segs, kinds)\n\n                col = mcoll.PathCollection(\n                    paths,\n                    antialiaseds=(self.antialiased,),\n                    edgecolors='none',\n                    alpha=self.alpha,\n                    transform=self.get_transform(),\n                    zorder=self._contour_zorder)\n                self.ax.add_collection(col, autolim=False)\n                self.collections.append(col)\n        else:\n            tlinewidths = self._process_linewidths()\n            self.tlinewidths = tlinewidths\n            tlinestyles = self._process_linestyles()\n            aa = self.antialiased\n            if aa is not None:\n                aa = (self.antialiased,)\n            # Default zorder taken from LineCollection\n            self._contour_zorder = kwargs.pop('zorder', 2)\n            for level, width, lstyle, segs in \\\n                    zip(self.levels, tlinewidths, tlinestyles, self.allsegs):\n                col = mcoll.LineCollection(\n                    segs,\n                    antialiaseds=aa,\n                    linewidths=width,\n                    linestyles=[lstyle],\n                    alpha=self.alpha,\n                    transform=self.get_transform(),\n                    zorder=self._contour_zorder)\n                col.set_label('_nolegend_')\n                self.ax.add_collection(col, autolim=False)\n                self.collections.append(col)\n\n        for col in self.collections:\n            col.sticky_edges.x[:] = [self._mins[0], self._maxs[0]]\n            col.sticky_edges.y[:] = [self._mins[1], self._maxs[1]]\n        self.ax.update_datalim([self._mins, self._maxs])\n        self.ax.autoscale_view(tight=True)\n\n        self.changed()  # set the colors\n\n        if kwargs:\n            s = \", \".join(map(repr, kwargs))\n            cbook._warn_external('The following kwargs were not used by '\n                                 'contour: ' + s)",
        "begin_line": 728,
        "end_line": 930,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet._autolev#1098",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet._autolev(self, N)",
        "snippet": "    def _autolev(self, N):\n        \"\"\"\n        Select contour levels to span the data.\n\n        The target number of levels, *N*, is used only when the\n        scale is not log and default locator is used.\n\n        We need two more levels for filled contours than for\n        line contours, because for the latter we need to specify\n        the lower and upper boundary of each range. For example,\n        a single contour boundary, say at z = 0, requires only\n        one contour line, but two filled regions, and therefore\n        three levels to provide boundaries for both regions.\n        \"\"\"\n        if self.locator is None:\n            if self.logscale:\n                self.locator = ticker.LogLocator()\n            else:\n                self.locator = ticker.MaxNLocator(N + 1, min_n_ticks=1)\n\n        lev = self.locator.tick_values(self.zmin, self.zmax)\n\n        try:\n            if self.locator._symmetric:\n                return lev\n        except AttributeError:\n            pass\n\n        # Trim excess levels the locator may have supplied.\n        under = np.nonzero(lev < self.zmin)[0]\n        i0 = under[-1] if len(under) else 0\n        over = np.nonzero(lev > self.zmax)[0]\n        i1 = over[0] + 1 if len(over) else len(lev)\n        if self.extend in ('min', 'both'):\n            i0 += 1\n        if self.extend in ('max', 'both'):\n            i1 -= 1\n\n        if i1 - i0 < 3:\n            i0, i1 = 0, len(lev)\n\n        return lev[i0:i1]",
        "begin_line": 1098,
        "end_line": 1139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.154155986818015e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet._process_contour_level_args#1141",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet._process_contour_level_args(self, args)",
        "snippet": "    def _process_contour_level_args(self, args):\n        \"\"\"\n        Determine the contour levels and store in self.levels.\n        \"\"\"\n        if self.levels is None:\n            if len(args) == 0:\n                levels_arg = 7  # Default, hard-wired.\n            else:\n                levels_arg = args[0]\n        else:\n            levels_arg = self.levels\n        if isinstance(levels_arg, Integral):\n            self.levels = self._autolev(levels_arg)\n        else:\n            self.levels = np.asarray(levels_arg).astype(np.float64)\n\n        if not self.filled:\n            inside = (self.levels > self.zmin) & (self.levels < self.zmax)\n            levels_in = self.levels[inside]\n            if len(levels_in) == 0:\n                self.levels = [self.zmin]\n                cbook._warn_external(\n                    \"No contour levels were found within the data range.\")\n\n        if self.filled and len(self.levels) < 2:\n            raise ValueError(\"Filled contours require at least 2 levels.\")\n\n        if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n            raise ValueError(\"Contour levels must be increasing\")",
        "begin_line": 1141,
        "end_line": 1169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet._process_levels#1171",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet._process_levels(self)",
        "snippet": "    def _process_levels(self):\n        \"\"\"\n        Assign values to :attr:`layers` based on :attr:`levels`,\n        adding extended layers as needed if contours are filled.\n\n        For line contours, layers simply coincide with levels;\n        a line is a thin layer.  No extended levels are needed\n        with line contours.\n        \"\"\"\n        # Make a private _levels to include extended regions; we\n        # want to leave the original levels attribute unchanged.\n        # (Colorbar needs this even for line contours.)\n        self._levels = list(self.levels)\n\n        if self.logscale:\n            lower, upper = 1e-250, 1e250\n        else:\n            lower, upper = -1e250, 1e250\n\n        if self.extend in ('both', 'min'):\n            self._levels.insert(0, lower)\n        if self.extend in ('both', 'max'):\n            self._levels.append(upper)\n        self._levels = np.asarray(self._levels)\n\n        if not self.filled:\n            self.layers = self.levels\n            return\n\n        # Layer values are mid-way between levels in screen space.\n        if self.logscale:\n            # Avoid overflow by taking sqrt before multiplying.\n            self.layers = (np.sqrt(self._levels[:-1])\n                           * np.sqrt(self._levels[1:]))\n        else:\n            self.layers = 0.5 * (self._levels[:-1] + self._levels[1:])",
        "begin_line": 1171,
        "end_line": 1206,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet._process_colors#1208",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet._process_colors(self)",
        "snippet": "    def _process_colors(self):\n        \"\"\"\n        Color argument processing for contouring.\n\n        Note that we base the color mapping on the contour levels\n        and layers, not on the actual range of the Z values.  This\n        means we don't have to worry about bad values in Z, and we\n        always have the full dynamic range available for the selected\n        levels.\n\n        The color is based on the midpoint of the layer, except for\n        extended end layers.  By default, the norm vmin and vmax\n        are the extreme values of the non-extended levels.  Hence,\n        the layer color extremes are not the extreme values of\n        the colormap itself, but approach those values as the number\n        of levels increases.  An advantage of this scheme is that\n        line contours, when added to filled contours, take on\n        colors that are consistent with those of the filled regions;\n        for example, a contour line on the boundary between two\n        regions will have a color intermediate between those\n        of the regions.\n\n        \"\"\"\n        self.monochrome = self.cmap.monochrome\n        if self.colors is not None:\n            # Generate integers for direct indexing.\n            i0, i1 = 0, len(self.levels)\n            if self.filled:\n                i1 -= 1\n                # Out of range indices for over and under:\n                if self.extend in ('both', 'min'):\n                    i0 -= 1\n                if self.extend in ('both', 'max'):\n                    i1 += 1\n            self.cvalues = list(range(i0, i1))\n            self.set_norm(mcolors.NoNorm())\n        else:\n            self.cvalues = self.layers\n        self.set_array(self.levels)\n        self.autoscale_None()\n        if self.extend in ('both', 'max', 'min'):\n            self.norm.clip = False",
        "begin_line": 1208,
        "end_line": 1249,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet._process_linewidths#1253",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet._process_linewidths(self)",
        "snippet": "    def _process_linewidths(self):\n        linewidths = self.linewidths\n        Nlev = len(self.levels)\n        if linewidths is None:\n            tlinewidths = [(mpl.rcParams['lines.linewidth'],)] * Nlev\n        else:\n            if not np.iterable(linewidths):\n                linewidths = [linewidths] * Nlev\n            else:\n                linewidths = list(linewidths)\n                if len(linewidths) < Nlev:\n                    nreps = int(np.ceil(Nlev / len(linewidths)))\n                    linewidths = linewidths * nreps\n                if len(linewidths) > Nlev:\n                    linewidths = linewidths[:Nlev]\n            tlinewidths = [(w,) for w in linewidths]\n        return tlinewidths",
        "begin_line": 1253,
        "end_line": 1269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet._process_linestyles#1271",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet._process_linestyles(self)",
        "snippet": "    def _process_linestyles(self):\n        linestyles = self.linestyles\n        Nlev = len(self.levels)\n        if linestyles is None:\n            tlinestyles = ['solid'] * Nlev\n            if self.monochrome:\n                neg_ls = mpl.rcParams['contour.negative_linestyle']\n                eps = - (self.zmax - self.zmin) * 1e-15\n                for i, lev in enumerate(self.levels):\n                    if lev < eps:\n                        tlinestyles[i] = neg_ls\n        else:\n            if isinstance(linestyles, str):\n                tlinestyles = [linestyles] * Nlev\n            elif np.iterable(linestyles):\n                tlinestyles = list(linestyles)\n                if len(tlinestyles) < Nlev:\n                    nreps = int(np.ceil(Nlev / len(linestyles)))\n                    tlinestyles = tlinestyles * nreps\n                if len(tlinestyles) > Nlev:\n                    tlinestyles = tlinestyles[:Nlev]\n            else:\n                raise ValueError(\"Unrecognized type for linestyles kwarg\")\n        return tlinestyles",
        "begin_line": 1271,
        "end_line": 1294,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.ContourSet.find_nearest_contour#1308",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.ContourSet",
        "signature": "lib.matplotlib.contour.ContourSet.find_nearest_contour(self, x, y, indices=None, pixel=True)",
        "snippet": "    def find_nearest_contour(self, x, y, indices=None, pixel=True):\n        \"\"\"\n        Find the point in the contour plot that is closest to ``(x, y)``.\n\n        Parameters\n        ----------\n        x, y: float\n            The reference point.\n        indices : list of int or None, default: None\n            Indices of contour levels to consider.  If None (the default), all\n            levels are considered.\n        pixel : bool, default: True\n            If *True*, measure distance in pixel (screen) space, which is\n            useful for manual contour labeling; else, measure distance in axes\n            space.\n\n        Returns\n        -------\n        contour : `.Collection`\n            The contour that is closest to ``(x, y)``.\n        segment : int\n            The index of the `.Path` in *contour* that is closest to\n            ``(x, y)``.\n        index : int\n            The index of the path segment in *segment* that is closest to\n            ``(x, y)``.\n        xmin, ymin : float\n            The point in the contour plot that is closest to ``(x, y)``.\n        d : float\n            The distance from ``(xmin, ymin)`` to ``(x, y)``.\n        \"\"\"\n\n        # This function uses a method that is probably quite\n        # inefficient based on converting each contour segment to\n        # pixel coordinates and then comparing the given point to\n        # those coordinates for each contour.  This will probably be\n        # quite slow for complex contours, but for normal use it works\n        # sufficiently well that the time is not noticeable.\n        # Nonetheless, improvements could probably be made.\n\n        if indices is None:\n            indices = list(range(len(self.levels)))\n\n        dmin = np.inf\n        conmin = None\n        segmin = None\n        xmin = None\n        ymin = None\n\n        point = np.array([x, y])\n\n        for icon in indices:\n            con = self.collections[icon]\n            trans = con.get_transform()\n            paths = con.get_paths()\n\n            for segNum, linepath in enumerate(paths):\n                lc = linepath.vertices\n                # transfer all data points to screen coordinates if desired\n                if pixel:\n                    lc = trans.transform(lc)\n\n                d, xc, leg = _find_closest_point_on_path(lc, point)\n                if d < dmin:\n                    dmin = d\n                    conmin = icon\n                    segmin = segNum\n                    imin = leg[1]\n                    xmin = xc[0]\n                    ymin = xc[1]\n\n        return (conmin, segmin, imin, xmin, ymin, dmin)",
        "begin_line": 1308,
        "end_line": 1379,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.QuadContourSet._process_args#1404",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.QuadContourSet",
        "signature": "lib.matplotlib.contour.QuadContourSet._process_args(self, *args, **kwargs)",
        "snippet": "    def _process_args(self, *args, **kwargs):\n        \"\"\"\n        Process args and kwargs.\n        \"\"\"\n        if isinstance(args[0], QuadContourSet):\n            if self.levels is None:\n                self.levels = args[0].levels\n            self.zmin = args[0].zmin\n            self.zmax = args[0].zmax\n            self._corner_mask = args[0]._corner_mask\n            contour_generator = args[0]._contour_generator\n            self._mins = args[0]._mins\n            self._maxs = args[0]._maxs\n        else:\n            import matplotlib._contour as _contour\n\n            self._corner_mask = kwargs.pop('corner_mask', None)\n            if self._corner_mask is None:\n                self._corner_mask = mpl.rcParams['contour.corner_mask']\n\n            x, y, z = self._contour_args(args, kwargs)\n\n            _mask = ma.getmask(z)\n            if _mask is ma.nomask or not _mask.any():\n                _mask = None\n\n            contour_generator = _contour.QuadContourGenerator(\n                x, y, z.filled(), _mask, self._corner_mask, self.nchunk)\n\n            t = self.get_transform()\n\n            # if the transform is not trans data, and some part of it\n            # contains transData, transform the xs and ys to data coordinates\n            if (t != self.ax.transData and\n                    any(t.contains_branch_seperately(self.ax.transData))):\n                trans_to_data = t - self.ax.transData\n                pts = np.vstack([x.flat, y.flat]).T\n                transformed_pts = trans_to_data.transform(pts)\n                x = transformed_pts[..., 0]\n                y = transformed_pts[..., 1]\n\n            self._mins = [ma.min(x), ma.min(y)]\n            self._maxs = [ma.max(x), ma.max(y)]\n\n        self._contour_generator = contour_generator\n\n        return kwargs",
        "begin_line": 1404,
        "end_line": 1450,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.QuadContourSet._get_allsegs_and_allkinds#1452",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.QuadContourSet",
        "signature": "lib.matplotlib.contour.QuadContourSet._get_allsegs_and_allkinds(self)",
        "snippet": "    def _get_allsegs_and_allkinds(self):\n        \"\"\"Compute ``allsegs`` and ``allkinds`` using C extension.\"\"\"\n        allsegs = []\n        if self.filled:\n            lowers, uppers = self._get_lowers_and_uppers()\n            allkinds = []\n            for level, level_upper in zip(lowers, uppers):\n                vertices, kinds = \\\n                    self._contour_generator.create_filled_contour(\n                        level, level_upper)\n                allsegs.append(vertices)\n                allkinds.append(kinds)\n        else:\n            allkinds = None\n            for level in self.levels:\n                vertices = self._contour_generator.create_contour(level)\n                allsegs.append(vertices)\n        return allsegs, allkinds",
        "begin_line": 1452,
        "end_line": 1469,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.QuadContourSet._contour_args#1471",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.QuadContourSet",
        "signature": "lib.matplotlib.contour.QuadContourSet._contour_args(self, args, kwargs)",
        "snippet": "    def _contour_args(self, args, kwargs):\n        if self.filled:\n            fn = 'contourf'\n        else:\n            fn = 'contour'\n        Nargs = len(args)\n        if Nargs <= 2:\n            z = ma.asarray(args[0], dtype=np.float64)\n            x, y = self._initialize_x_y(z)\n            args = args[1:]\n        elif Nargs <= 4:\n            x, y, z = self._check_xyz(args[:3], kwargs)\n            args = args[3:]\n        else:\n            raise TypeError(\"Too many arguments to %s; see help(%s)\" %\n                            (fn, fn))\n        z = ma.masked_invalid(z, copy=False)\n        self.zmax = float(z.max())\n        self.zmin = float(z.min())\n        if self.logscale and self.zmin <= 0:\n            z = ma.masked_where(z <= 0, z)\n            cbook._warn_external('Log scale: values of z <= 0 have been '\n                                 'masked')\n            self.zmin = float(z.min())\n        self._process_contour_level_args(args)\n        return (x, y, z)",
        "begin_line": 1471,
        "end_line": 1496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.QuadContourSet._check_xyz#1498",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.QuadContourSet",
        "signature": "lib.matplotlib.contour.QuadContourSet._check_xyz(self, args, kwargs)",
        "snippet": "    def _check_xyz(self, args, kwargs):\n        \"\"\"\n        Check that the shapes of the input arrays match; if x and y are 1D,\n        convert them to 2D using meshgrid.\n        \"\"\"\n        x, y = args[:2]\n        kwargs = self.ax._process_unit_info(xdata=x, ydata=y, kwargs=kwargs)\n        x = self.ax.convert_xunits(x)\n        y = self.ax.convert_yunits(y)\n\n        x = np.asarray(x, dtype=np.float64)\n        y = np.asarray(y, dtype=np.float64)\n        z = ma.asarray(args[2], dtype=np.float64)\n\n        if z.ndim != 2:\n            raise TypeError(f\"Input z must be 2D, not {z.ndim}D\")\n        if z.shape[0] < 2 or z.shape[1] < 2:\n            raise TypeError(f\"Input z must be at least a (2, 2) shaped array, \"\n                            f\"but has shape {z.shape}\")\n        Ny, Nx = z.shape\n\n        if x.ndim != y.ndim:\n            raise TypeError(f\"Number of dimensions of x ({x.ndim}) and y \"\n                            f\"({y.ndim}) do not match\")\n        if x.ndim == 1:\n            nx, = x.shape\n            ny, = y.shape\n            if nx != Nx:\n                raise TypeError(f\"Length of x ({nx}) must match number of \"\n                                f\"columns in z ({Nx})\")\n            if ny != Ny:\n                raise TypeError(f\"Length of y ({ny}) must match number of \"\n                                f\"rows in z ({Ny})\")\n            x, y = np.meshgrid(x, y)\n        elif x.ndim == 2:\n            if x.shape != z.shape:\n                raise TypeError(\n                    f\"Shapes of x {x.shape} and z {z.shape} do not match\")\n            if y.shape != z.shape:\n                raise TypeError(\n                    f\"Shapes of y {y.shape} and z {z.shape} do not match\")\n        else:\n            raise TypeError(f\"Inputs x and y must be 1D or 2D, not {x.ndim}D\")\n\n        return x, y, z",
        "begin_line": 1498,
        "end_line": 1542,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.contour.QuadContourSet._initialize_x_y#1544",
        "src_path": "lib/matplotlib/contour.py",
        "class_name": "lib.matplotlib.contour.QuadContourSet",
        "signature": "lib.matplotlib.contour.QuadContourSet._initialize_x_y(self, z)",
        "snippet": "    def _initialize_x_y(self, z):\n        \"\"\"\n        Return X, Y arrays such that contour(Z) will match imshow(Z)\n        if origin is not None.\n        The center of pixel Z[i, j] depends on origin:\n        if origin is None, x = j, y = i;\n        if origin is 'lower', x = j + 0.5, y = i + 0.5;\n        if origin is 'upper', x = j + 0.5, y = Nrows - i - 0.5\n        If extent is not None, x and y will be scaled to match,\n        as in imshow.\n        If origin is None and extent is not None, then extent\n        will give the minimum and maximum values of x and y.\n        \"\"\"\n        if z.ndim != 2:\n            raise TypeError(f\"Input z must be 2D, not {z.ndim}D\")\n        elif z.shape[0] < 2 or z.shape[1] < 2:\n            raise TypeError(f\"Input z must be at least a (2, 2) shaped array, \"\n                            f\"but has shape {z.shape}\")\n        else:\n            Ny, Nx = z.shape\n        if self.origin is None:  # Not for image-matching.\n            if self.extent is None:\n                return np.meshgrid(np.arange(Nx), np.arange(Ny))\n            else:\n                x0, x1, y0, y1 = self.extent\n                x = np.linspace(x0, x1, Nx)\n                y = np.linspace(y0, y1, Ny)\n                return np.meshgrid(x, y)\n        # Match image behavior:\n        if self.extent is None:\n            x0, x1, y0, y1 = (0, Nx, 0, Ny)\n        else:\n            x0, x1, y0, y1 = self.extent\n        dx = (x1 - x0) / Nx\n        dy = (y1 - y0) / Ny\n        x = x0 + (np.arange(Nx) + 0.5) * dx\n        y = y0 + (np.arange(Ny) + 0.5) * dy\n        if self.origin == 'upper':\n            y = y[::-1]\n        return np.meshgrid(x, y)",
        "begin_line": 1544,
        "end_line": 1583,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerBase.update_prop#72",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerBase",
        "signature": "lib.matplotlib.legend_handler.HandlerBase.update_prop(self, legend_handle, orig_handle, legend)",
        "snippet": "    def update_prop(self, legend_handle, orig_handle, legend):\n\n        self._update_prop(legend_handle, orig_handle)\n\n        legend._set_artist_props(legend_handle)\n        legend_handle.set_clip_box(None)\n        legend_handle.set_clip_path(None)",
        "begin_line": 72,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002849002849002849,
            "pseudo_dstar_susp": 0.0006265664160401002,
            "pseudo_tarantula_susp": 0.002398081534772182,
            "pseudo_op2_susp": 0.0006265664160401002,
            "pseudo_barinel_susp": 0.002398081534772182
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerBase.adjust_drawing_area#80",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerBase",
        "signature": "lib.matplotlib.legend_handler.HandlerBase.adjust_drawing_area(self, legend, orig_handle, xdescent, ydescent, width, height, fontsize)",
        "snippet": "    def adjust_drawing_area(self, legend, orig_handle,\n                            xdescent, ydescent, width, height, fontsize,\n                            ):\n        xdescent = xdescent - self._xpad * fontsize\n        ydescent = ydescent - self._ypad * fontsize\n        width = width - self._xpad * fontsize\n        height = height - self._ypad * fontsize\n        return xdescent, ydescent, width, height",
        "begin_line": 80,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006779661016949153,
            "pseudo_dstar_susp": 0.0006640106241699867,
            "pseudo_tarantula_susp": 0.000968054211035818,
            "pseudo_op2_susp": 0.0006640106241699867,
            "pseudo_barinel_susp": 0.000968054211035818
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerBase.legend_artist#89",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerBase",
        "signature": "lib.matplotlib.legend_handler.HandlerBase.legend_artist(self, legend, orig_handle, fontsize, handlebox)",
        "snippet": "    def legend_artist(self, legend, orig_handle,\n                      fontsize, handlebox):\n        \"\"\"\n        Return the artist that this HandlerBase generates for the given\n        original artist/handle.\n\n        Parameters\n        ----------\n        legend : `~matplotlib.legend.Legend`\n            The legend for which these legend artists are being created.\n        orig_handle : :class:`matplotlib.artist.Artist` or similar\n            The object for which these legend artists are being created.\n        fontsize : int\n            The fontsize in pixels. The artists being created should\n            be scaled according to the given fontsize.\n        handlebox : `matplotlib.offsetbox.OffsetBox`\n            The box which has been created to hold this legend entry's\n            artists. Artists created in the `legend_artist` method must\n            be added to this handlebox inside this method.\n\n        \"\"\"\n        xdescent, ydescent, width, height = self.adjust_drawing_area(\n                 legend, orig_handle,\n                 handlebox.xdescent, handlebox.ydescent,\n                 handlebox.width, handlebox.height,\n                 fontsize)\n        artists = self.create_artists(legend, orig_handle,\n                                      xdescent, ydescent, width, height,\n                                      fontsize, handlebox.get_transform())\n\n        # create_artists will return a list of artists.\n        for a in artists:\n            handlebox.add_artist(a)\n\n        # we only return the first artist\n        return artists[0]",
        "begin_line": 89,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007178750897343862,
            "pseudo_dstar_susp": 0.0006747638326585695,
            "pseudo_tarantula_susp": 0.0009487666034155598,
            "pseudo_op2_susp": 0.0006747638326585695,
            "pseudo_barinel_susp": 0.0009487666034155598
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerNpoints.get_numpoints#155",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerNpoints",
        "signature": "lib.matplotlib.legend_handler.HandlerNpoints.get_numpoints(self, legend)",
        "snippet": "    def get_numpoints(self, legend):\n        if self._numpoints is None:\n            return legend.numpoints\n        else:\n            return self._numpoints",
        "begin_line": 155,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.825346394845998e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerNpoints.get_xdata#161",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerNpoints",
        "signature": "lib.matplotlib.legend_handler.HandlerNpoints.get_xdata(self, legend, xdescent, ydescent, width, height, fontsize)",
        "snippet": "    def get_xdata(self, legend, xdescent, ydescent, width, height, fontsize):\n        numpoints = self.get_numpoints(legend)\n        if numpoints > 1:\n            # we put some pad here to compensate the size of the marker\n            pad = self._marker_pad * fontsize\n            xdata = np.linspace(-xdescent + pad,\n                                -xdescent + width - pad,\n                                numpoints)\n            xdata_marker = xdata\n        else:\n            xdata = [-xdescent, -xdescent + width]\n            xdata_marker = [-xdescent + 0.5 * width]\n        return xdata, xdata_marker",
        "begin_line": 161,
        "end_line": 173,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.104980424292088e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerLine2D.create_artists#229",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerLine2D",
        "signature": "lib.matplotlib.legend_handler.HandlerLine2D.create_artists(self, legend, orig_handle, xdescent, ydescent, width, height, fontsize, trans)",
        "snippet": "    def create_artists(self, legend, orig_handle,\n                       xdescent, ydescent, width, height, fontsize,\n                       trans):\n\n        xdata, xdata_marker = self.get_xdata(legend, xdescent, ydescent,\n                                             width, height, fontsize)\n\n        ydata = np.full_like(xdata, ((height - ydescent) / 2))\n        legline = Line2D(xdata, ydata)\n\n        self.update_prop(legline, orig_handle, legend)\n        legline.set_drawstyle('default')\n        legline.set_marker(\"\")\n\n        legline_marker = Line2D(xdata_marker, ydata[:len(xdata_marker)])\n        self.update_prop(legline_marker, orig_handle, legend)\n        legline_marker.set_linestyle('None')\n        if legend.markerscale != 1:\n            newsz = legline_marker.get_markersize() * legend.markerscale\n            legline_marker.set_markersize(newsz)\n        # we don't want to add this to the return list because\n        # the texts and handles are assumed to be in one-to-one\n        # correspondence.\n        legline._legmarker = legline_marker\n\n        legline.set_transform(trans)\n        legline_marker.set_transform(trans)\n\n        return [legline, legline_marker]",
        "begin_line": 229,
        "end_line": 257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0032679738562091504,
            "pseudo_dstar_susp": 0.0006684491978609625,
            "pseudo_tarantula_susp": 0.0020325203252032522,
            "pseudo_op2_susp": 0.0006684491978609625,
            "pseudo_barinel_susp": 0.0020325203252032522
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerPatch._create_patch#286",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerPatch",
        "signature": "lib.matplotlib.legend_handler.HandlerPatch._create_patch(self, legend, orig_handle, xdescent, ydescent, width, height, fontsize)",
        "snippet": "    def _create_patch(self, legend, orig_handle,\n                      xdescent, ydescent, width, height, fontsize):\n        if self._patch_func is None:\n            p = Rectangle(xy=(-xdescent, -ydescent),\n                          width=width, height=height)\n        else:\n            p = self._patch_func(legend=legend, orig_handle=orig_handle,\n                                 xdescent=xdescent, ydescent=ydescent,\n                                 width=width, height=height, fontsize=fontsize)\n        return p",
        "begin_line": 286,
        "end_line": 295,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerPatch.create_artists#297",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerPatch",
        "signature": "lib.matplotlib.legend_handler.HandlerPatch.create_artists(self, legend, orig_handle, xdescent, ydescent, width, height, fontsize, trans)",
        "snippet": "    def create_artists(self, legend, orig_handle,\n                       xdescent, ydescent, width, height, fontsize, trans):\n        p = self._create_patch(legend, orig_handle,\n                               xdescent, ydescent, width, height, fontsize)\n        self.update_prop(p, orig_handle, legend)\n        p.set_transform(trans)\n        return [p]",
        "begin_line": 297,
        "end_line": 303,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.legend_handler.HandlerRegularPolyCollection.get_numpoints#346",
        "src_path": "lib/matplotlib/legend_handler.py",
        "class_name": "lib.matplotlib.legend_handler.HandlerRegularPolyCollection",
        "signature": "lib.matplotlib.legend_handler.HandlerRegularPolyCollection.get_numpoints(self, legend)",
        "snippet": "    def get_numpoints(self, legend):\n        if self._numpoints is None:\n            return legend.scatterpoints\n        else:\n            return self._numpoints",
        "begin_line": 346,
        "end_line": 350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__#15",
        "src_path": "lib/matplotlib/backends/backend_mixed.py",
        "class_name": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer",
        "signature": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__(self, figure, width, height, dpi, vector_renderer, raster_renderer_class=None, bbox_inches_restore=None)",
        "snippet": "    def __init__(self, figure, width, height, dpi, vector_renderer,\n                 raster_renderer_class=None,\n                 bbox_inches_restore=None):\n        \"\"\"\n        Parameters\n        ----------\n        figure : `matplotlib.figure.Figure`\n            The figure instance.\n\n        width : scalar\n            The width of the canvas in logical units\n\n        height : scalar\n            The height of the canvas in logical units\n\n        dpi : float\n            The dpi of the canvas\n\n        vector_renderer : `matplotlib.backend_bases.RendererBase`\n            An instance of a subclass of\n            `~matplotlib.backend_bases.RendererBase` that will be used for the\n            vector drawing.\n\n        raster_renderer_class : `matplotlib.backend_bases.RendererBase`\n            The renderer class to use for the raster drawing.  If not provided,\n            this will use the Agg backend (which is currently the only viable\n            option anyway.)\n\n        \"\"\"\n        if raster_renderer_class is None:\n            raster_renderer_class = RendererAgg\n\n        self._raster_renderer_class = raster_renderer_class\n        self._width = width\n        self._height = height\n        self.dpi = dpi\n\n        self._vector_renderer = vector_renderer\n\n        self._raster_renderer = None\n        self._rasterizing = 0\n\n        # A reference to the figure is needed as we need to change\n        # the figure dpi before and after the rasterization. Although\n        # this looks ugly, I couldn't find a better solution. -JJL\n        self.figure = figure\n        self._figdpi = figure.get_dpi()\n\n        self._bbox_inches_restore = bbox_inches_restore\n\n        self._renderer = vector_renderer",
        "begin_line": 15,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003952569169960474,
            "pseudo_dstar_susp": 0.00036310820624546115,
            "pseudo_tarantula_susp": 0.00089126559714795,
            "pseudo_op2_susp": 0.00036310820624546115,
            "pseudo_barinel_susp": 0.00089126559714795
        }
    },
    {
        "name": "lib.matplotlib.widgets.Widget.get_active#76",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.Widget",
        "signature": "lib.matplotlib.widgets.Widget.get_active(self)",
        "snippet": "    def get_active(self):\n        \"\"\"Get whether the widget is active.\n        \"\"\"\n        return self._active",
        "begin_line": 76,
        "end_line": 79,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.480325644504748e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.AxesWidget.connect_event#119",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.AxesWidget",
        "signature": "lib.matplotlib.widgets.AxesWidget.connect_event(self, event, callback)",
        "snippet": "    def connect_event(self, event, callback):\n        \"\"\"\n        Connect callback with an event.\n\n        This should be used in lieu of ``figure.canvas.mpl_connect`` since this\n        function stores callback ids for later clean up.\n        \"\"\"\n        cid = self.canvas.mpl_connect(event, callback)\n        self.cids.append(cid)",
        "begin_line": 119,
        "end_line": 127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.59600806064677e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.Slider.__init__#259",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.Slider",
        "signature": "lib.matplotlib.widgets.Slider.__init__(self, ax, label, valmin, valmax, valinit=0.5, valfmt='%1.2f', closedmin=True, closedmax=True, slidermin=None, slidermax=None, dragging=True, valstep=None, orientation='horizontal', **kwargs)",
        "snippet": "    def __init__(self, ax, label, valmin, valmax, valinit=0.5, valfmt='%1.2f',\n                 closedmin=True, closedmax=True, slidermin=None,\n                 slidermax=None, dragging=True, valstep=None,\n                 orientation='horizontal', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        ax : Axes\n            The Axes to put the slider in.\n\n        label : str\n            Slider label.\n\n        valmin : float\n            The minimum value of the slider.\n\n        valmax : float\n            The maximum value of the slider.\n\n        valinit : float, default: 0.5\n            The slider initial position.\n\n        valfmt : str, default: \"%1.2f\"\n            Used to format the slider value, fprint format string.\n\n        closedmin : bool, default: True\n            Whether the slider interval is closed on the bottom.\n\n        closedmax : bool, default: True\n            Whether the slider interval is closed on the top.\n\n        slidermin : Slider, default: None\n            Do not allow the current slider to have a value less than\n            the value of the Slider *slidermin*.\n\n        slidermax : Slider, default: None\n            Do not allow the current slider to have a value greater than\n            the value of the Slider *slidermax*.\n\n        dragging : bool, default: True\n            If True the slider can be dragged by the mouse.\n\n        valstep : float, default: None\n            If given, the slider will snap to multiples of *valstep*.\n\n        orientation : {'horizontal', 'vertical'}, default: 'horizontal'\n            The orientation of the slider.\n\n        Notes\n        -----\n        Additional kwargs are passed on to ``self.poly`` which is the\n        `~matplotlib.patches.Rectangle` that draws the slider knob.  See the\n        `.Rectangle` documentation for valid property names (``facecolor``,\n        ``edgecolor``, ``alpha``, etc.).\n        \"\"\"\n        if ax.name == '3d':\n            raise ValueError('Sliders cannot be added to 3D Axes')\n\n        AxesWidget.__init__(self, ax)\n\n        if slidermin is not None and not hasattr(slidermin, 'val'):\n            raise ValueError(\"Argument slidermin ({}) has no 'val'\"\n                             .format(type(slidermin)))\n        if slidermax is not None and not hasattr(slidermax, 'val'):\n            raise ValueError(\"Argument slidermax ({}) has no 'val'\"\n                             .format(type(slidermax)))\n        if orientation not in ['horizontal', 'vertical']:\n            raise ValueError(\"Argument orientation ({}) must be either\"\n                             \"'horizontal' or 'vertical'\".format(orientation))\n\n        self.orientation = orientation\n        self.closedmin = closedmin\n        self.closedmax = closedmax\n        self.slidermin = slidermin\n        self.slidermax = slidermax\n        self.drag_active = False\n        self.valmin = valmin\n        self.valmax = valmax\n        self.valstep = valstep\n        valinit = self._value_in_bounds(valinit)\n        if valinit is None:\n            valinit = valmin\n        self.val = valinit\n        self.valinit = valinit\n        if orientation == 'vertical':\n            self.poly = ax.axhspan(valmin, valinit, 0, 1, **kwargs)\n            self.hline = ax.axhline(valinit, 0, 1, color='r', lw=1)\n        else:\n            self.poly = ax.axvspan(valmin, valinit, 0, 1, **kwargs)\n            self.vline = ax.axvline(valinit, 0, 1, color='r', lw=1)\n\n        self.valfmt = valfmt\n        ax.set_yticks([])\n        if orientation == 'vertical':\n            ax.set_ylim((valmin, valmax))\n        else:\n            ax.set_xlim((valmin, valmax))\n        ax.set_xticks([])\n        ax.set_navigate(False)\n\n        self.connect_event('button_press_event', self._update)\n        self.connect_event('button_release_event', self._update)\n        if dragging:\n            self.connect_event('motion_notify_event', self._update)\n        if orientation == 'vertical':\n            self.label = ax.text(0.5, 1.02, label, transform=ax.transAxes,\n                                 verticalalignment='bottom',\n                                 horizontalalignment='center')\n\n            self.valtext = ax.text(0.5, -0.02, valfmt % valinit,\n                                   transform=ax.transAxes,\n                                   verticalalignment='top',\n                                   horizontalalignment='center')\n        else:\n            self.label = ax.text(-0.02, 0.5, label, transform=ax.transAxes,\n                                 verticalalignment='center',\n                                 horizontalalignment='right')\n\n            self.valtext = ax.text(1.02, 0.5, valfmt % valinit,\n                                   transform=ax.transAxes,\n                                   verticalalignment='center',\n                                   horizontalalignment='left')\n\n        self.cnt = 0\n        self.observers = {}\n\n        self.set_val(valinit)",
        "begin_line": 259,
        "end_line": 385,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.CheckButtons.__init__#526",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.CheckButtons",
        "signature": "lib.matplotlib.widgets.CheckButtons.__init__(self, ax, labels, actives=None)",
        "snippet": "    def __init__(self, ax, labels, actives=None):\n        \"\"\"\n        Add check buttons to `matplotlib.axes.Axes` instance *ax*\n\n        Parameters\n        ----------\n        ax : `~matplotlib.axes.Axes`\n            The parent axes for the widget.\n\n        labels : list of str\n            The labels of the check buttons.\n\n        actives : list of bool, optional\n            The initial check states of the buttons. The list must have the\n            same length as *labels*. If not given, all buttons are unchecked.\n        \"\"\"\n        AxesWidget.__init__(self, ax)\n\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_navigate(False)\n\n        if actives is None:\n            actives = [False] * len(labels)\n\n        if len(labels) > 1:\n            dy = 1. / (len(labels) + 1)\n            ys = np.linspace(1 - dy, dy, len(labels))\n        else:\n            dy = 0.25\n            ys = [0.5]\n\n        axcolor = ax.get_facecolor()\n\n        self.labels = []\n        self.lines = []\n        self.rectangles = []\n\n        lineparams = {'color': 'k', 'linewidth': 1.25,\n                      'transform': ax.transAxes, 'solid_capstyle': 'butt'}\n        for y, label, active in zip(ys, labels, actives):\n            t = ax.text(0.25, y, label, transform=ax.transAxes,\n                        horizontalalignment='left',\n                        verticalalignment='center')\n\n            w, h = dy / 2, dy / 2\n            x, y = 0.05, y - h / 2\n\n            p = Rectangle(xy=(x, y), width=w, height=h, edgecolor='black',\n                          facecolor=axcolor, transform=ax.transAxes)\n\n            l1 = Line2D([x, x + w], [y + h, y], **lineparams)\n            l2 = Line2D([x, x + w], [y, y + h], **lineparams)\n\n            l1.set_visible(active)\n            l2.set_visible(active)\n            self.labels.append(t)\n            self.rectangles.append(p)\n            self.lines.append((l1, l2))\n            ax.add_patch(p)\n            ax.add_line(l1)\n            ax.add_line(l2)\n\n        self.connect_event('button_press_event', self._clicked)\n\n        self.cnt = 0\n        self.observers = {}",
        "begin_line": 526,
        "end_line": 592,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.RadioButtons.__init__#990",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RadioButtons",
        "signature": "lib.matplotlib.widgets.RadioButtons.__init__(self, ax, labels, active=0, activecolor='blue')",
        "snippet": "    def __init__(self, ax, labels, active=0, activecolor='blue'):\n        \"\"\"\n        Add radio buttons to an `~.axes.Axes`.\n\n        Parameters\n        ----------\n        ax : `~matplotlib.axes.Axes`\n            The axes to add the buttons to.\n        labels : list of str\n            The button labels.\n        active : int\n            The index of the initially selected button.\n        activecolor : color\n            The color of the selected button.\n        \"\"\"\n        AxesWidget.__init__(self, ax)\n        self.activecolor = activecolor\n        self.value_selected = None\n\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_navigate(False)\n        dy = 1. / (len(labels) + 1)\n        ys = np.linspace(1 - dy, dy, len(labels))\n        cnt = 0\n        axcolor = ax.get_facecolor()\n\n        # scale the radius of the circle with the spacing between each one\n        circle_radius = dy / 2 - 0.01\n        # default to hard-coded value if the radius becomes too large\n        circle_radius = min(circle_radius, 0.05)\n\n        self.labels = []\n        self.circles = []\n        for y, label in zip(ys, labels):\n            t = ax.text(0.25, y, label, transform=ax.transAxes,\n                        horizontalalignment='left',\n                        verticalalignment='center')\n\n            if cnt == active:\n                self.value_selected = label\n                facecolor = activecolor\n            else:\n                facecolor = axcolor\n\n            p = Circle(xy=(0.15, y), radius=circle_radius, edgecolor='black',\n                       facecolor=facecolor, transform=ax.transAxes)\n\n            self.labels.append(t)\n            self.circles.append(p)\n            ax.add_patch(p)\n            cnt += 1\n\n        self.connect_event('button_press_event', self._clicked)\n\n        self.cnt = 0\n        self.observers = {}",
        "begin_line": 990,
        "end_line": 1046,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.__init__#1440",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.__init__(self, ax, onselect, useblit=False, button=None, state_modifier_keys=None)",
        "snippet": "    def __init__(self, ax, onselect, useblit=False, button=None,\n                 state_modifier_keys=None):\n        AxesWidget.__init__(self, ax)\n\n        self.visible = True\n        self.onselect = onselect\n        self.useblit = useblit and self.canvas.supports_blit\n        self.connect_default_events()\n\n        self.state_modifier_keys = dict(move=' ', clear='escape',\n                                        square='shift', center='control')\n        self.state_modifier_keys.update(state_modifier_keys or {})\n\n        self.background = None\n        self.artists = []\n\n        if isinstance(button, Integral):\n            self.validButtons = [button]\n        else:\n            self.validButtons = button\n\n        # will save the data (position at mouseclick)\n        self.eventpress = None\n        # will save the data (pos. at mouserelease)\n        self.eventrelease = None\n        self._prev_event = None\n        self.state = set()",
        "begin_line": 1440,
        "end_line": 1466,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.update_background#1473",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.update_background(self, event)",
        "snippet": "    def update_background(self, event):\n        \"\"\"force an update of the background\"\"\"\n        # If you add a call to `ignore` here, you'll want to check edge case:\n        # `release` can call a draw event even when `ignore` is True.\n        if self.useblit:\n            self.background = self.canvas.copy_from_bbox(self.ax.bbox)",
        "begin_line": 1473,
        "end_line": 1478,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.connect_default_events#1480",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.connect_default_events(self)",
        "snippet": "    def connect_default_events(self):\n        \"\"\"Connect the major canvas events to methods.\"\"\"\n        self.connect_event('motion_notify_event', self.onmove)\n        self.connect_event('button_press_event', self.press)\n        self.connect_event('button_release_event', self.release)\n        self.connect_event('draw_event', self.update_background)\n        self.connect_event('key_press_event', self.on_key_press)\n        self.connect_event('key_release_event', self.on_key_release)\n        self.connect_event('scroll_event', self.on_scroll)",
        "begin_line": 1480,
        "end_line": 1488,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.ignore#1490",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.ignore(self, event)",
        "snippet": "    def ignore(self, event):\n        # docstring inherited\n        if not self.active or not self.ax.get_visible():\n            return True\n        # If canvas was locked\n        if not self.canvas.widgetlock.available(self):\n            return True\n        if not hasattr(event, 'button'):\n            event.button = None\n        # Only do rectangle selection if event was triggered\n        # with a desired button\n        if (self.validButtons is not None\n                and event.button not in self.validButtons):\n            return True\n        # If no button was pressed yet ignore the event if it was out\n        # of the axes\n        if self.eventpress is None:\n            return event.inaxes != self.ax\n        # If a button was pressed, check if the release-button is the same.\n        if event.button == self.eventpress.button:\n            return False\n        # If a button was pressed, check if the release-button is the same.\n        return (event.inaxes != self.ax or\n                event.button != self.eventpress.button)",
        "begin_line": 1490,
        "end_line": 1513,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.update#1515",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.update(self)",
        "snippet": "    def update(self):\n        \"\"\"\n        Draw using blit() or draw_idle() depending on ``self.useblit``.\n        \"\"\"\n        if not self.ax.get_visible():\n            return False\n        if self.useblit:\n            if self.background is not None:\n                self.canvas.restore_region(self.background)\n            for artist in self.artists:\n                self.ax.draw_artist(artist)\n            self.canvas.blit(self.ax.bbox)\n        else:\n            self.canvas.draw_idle()\n        return False",
        "begin_line": 1515,
        "end_line": 1529,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget._get_data#1531",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget._get_data(self, event)",
        "snippet": "    def _get_data(self, event):\n        \"\"\"Get the xdata and ydata for event, with limits\"\"\"\n        if event.xdata is None:\n            return None, None\n        x0, x1 = self.ax.get_xbound()\n        y0, y1 = self.ax.get_ybound()\n        xdata = max(x0, event.xdata)\n        xdata = min(x1, xdata)\n        ydata = max(y0, event.ydata)\n        ydata = min(y1, ydata)\n        return xdata, ydata",
        "begin_line": 1531,
        "end_line": 1541,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget._clean_event#1543",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget._clean_event(self, event)",
        "snippet": "    def _clean_event(self, event):\n        \"\"\"Clean up an event\n\n        Use prev event if there is no xdata\n        Limit the xdata and ydata to the axes limits\n        Set the prev event\n        \"\"\"\n        if event.xdata is None:\n            event = self._prev_event\n        else:\n            event = copy.copy(event)\n        event.xdata, event.ydata = self._get_data(event)\n\n        self._prev_event = event\n        return event",
        "begin_line": 1543,
        "end_line": 1557,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.press#1559",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.press(self, event)",
        "snippet": "    def press(self, event):\n        \"\"\"Button press handler and validator\"\"\"\n        if not self.ignore(event):\n            event = self._clean_event(event)\n            self.eventpress = event\n            self._prev_event = event\n            key = event.key or ''\n            key = key.replace('ctrl', 'control')\n            # move state is locked in on a button press\n            if key == self.state_modifier_keys['move']:\n                self.state.add('move')\n            self._press(event)\n            return True\n        return False",
        "begin_line": 1559,
        "end_line": 1572,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.release#1577",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.release(self, event)",
        "snippet": "    def release(self, event):\n        \"\"\"Button release event handler and validator\"\"\"\n        if not self.ignore(event) and self.eventpress:\n            event = self._clean_event(event)\n            self.eventrelease = event\n            self._release(event)\n            self.eventpress = None\n            self.eventrelease = None\n            self.state.discard('move')\n            return True\n        return False",
        "begin_line": 1577,
        "end_line": 1587,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.onmove#1592",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.onmove(self, event)",
        "snippet": "    def onmove(self, event):\n        \"\"\"Cursor move event handler and validator\"\"\"\n        if not self.ignore(event) and self.eventpress:\n            event = self._clean_event(event)\n            self._onmove(event)\n            return True\n        return False",
        "begin_line": 1592,
        "end_line": 1598,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.on_key_press#1611",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.on_key_press(self, event)",
        "snippet": "    def on_key_press(self, event):\n        \"\"\"Key press event handler and validator for all selection widgets\"\"\"\n        if self.active:\n            key = event.key or ''\n            key = key.replace('ctrl', 'control')\n            if key == self.state_modifier_keys['clear']:\n                for artist in self.artists:\n                    artist.set_visible(False)\n                self.update()\n                return\n            for (state, modifier) in self.state_modifier_keys.items():\n                if modifier in key:\n                    self.state.add(state)\n            self._on_key_press(event)",
        "begin_line": 1611,
        "end_line": 1624,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.on_key_release#1630",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.on_key_release(self, event)",
        "snippet": "    def on_key_release(self, event):\n        \"\"\"Key release event handler and validator.\"\"\"\n        if self.active:\n            key = event.key or ''\n            for (state, modifier) in self.state_modifier_keys.items():\n                if modifier in key:\n                    self.state.discard(state)\n            self._on_key_release(event)",
        "begin_line": 1630,
        "end_line": 1637,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget._on_key_release#1639",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget._on_key_release(self, event)",
        "snippet": "    def _on_key_release(self, event):\n        \"\"\"Key release event handler.\"\"\"",
        "begin_line": 1639,
        "end_line": 1640,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets._SelectorWidget.set_visible#1642",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets._SelectorWidget",
        "signature": "lib.matplotlib.widgets._SelectorWidget.set_visible(self, visible)",
        "snippet": "    def set_visible(self, visible):\n        \"\"\"Set the visibility of our artists.\"\"\"\n        self.visible = visible\n        for artist in self.artists:\n            artist.set_visible(visible)",
        "begin_line": 1642,
        "end_line": 1646,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.SpanSelector.__init__#1703",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.SpanSelector",
        "signature": "lib.matplotlib.widgets.SpanSelector.__init__(self, ax, onselect, direction, minspan=None, useblit=False, rectprops=None, onmove_callback=None, span_stays=False, button=None)",
        "snippet": "    def __init__(self, ax, onselect, direction, minspan=None, useblit=False,\n                 rectprops=None, onmove_callback=None, span_stays=False,\n                 button=None):\n\n        _SelectorWidget.__init__(self, ax, onselect, useblit=useblit,\n                                 button=button)\n\n        if rectprops is None:\n            rectprops = dict(facecolor='red', alpha=0.5)\n\n        rectprops['animated'] = self.useblit\n\n        cbook._check_in_list(['horizontal', 'vertical'], direction=direction)\n        self.direction = direction\n\n        self.rect = None\n        self.pressv = None\n\n        self.rectprops = rectprops\n        self.onmove_callback = onmove_callback\n        self.minspan = minspan\n        self.span_stays = span_stays\n\n        # Needed when dragging out of axes\n        self.prev = (0, 0)\n\n        # Reset canvas so that `new_axes` connects events.\n        self.canvas = None\n        self.new_axes(ax)",
        "begin_line": 1703,
        "end_line": 1731,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.SpanSelector.new_axes#1733",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.SpanSelector",
        "signature": "lib.matplotlib.widgets.SpanSelector.new_axes(self, ax)",
        "snippet": "    def new_axes(self, ax):\n        \"\"\"Set SpanSelector to operate on a new Axes.\"\"\"\n        self.ax = ax\n        if self.canvas is not ax.figure.canvas:\n            if self.canvas is not None:\n                self.disconnect_events()\n\n            self.canvas = ax.figure.canvas\n            self.connect_default_events()\n\n        if self.direction == 'horizontal':\n            trans = blended_transform_factory(self.ax.transData,\n                                              self.ax.transAxes)\n            w, h = 0, 1\n        else:\n            trans = blended_transform_factory(self.ax.transAxes,\n                                              self.ax.transData)\n            w, h = 1, 0\n        self.rect = Rectangle((0, 0), w, h,\n                              transform=trans,\n                              visible=False,\n                              **self.rectprops)\n        if self.span_stays:\n            self.stay_rect = Rectangle((0, 0), w, h,\n                                       transform=trans,\n                                       visible=False,\n                                       **self.rectprops)\n            self.stay_rect.set_animated(False)\n            self.ax.add_patch(self.stay_rect)\n\n        self.ax.add_patch(self.rect)\n        self.artists = [self.rect]",
        "begin_line": 1733,
        "end_line": 1764,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.SpanSelector.ignore#1766",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.SpanSelector",
        "signature": "lib.matplotlib.widgets.SpanSelector.ignore(self, event)",
        "snippet": "    def ignore(self, event):\n        # docstring inherited\n        return _SelectorWidget.ignore(self, event) or not self.visible",
        "begin_line": 1766,
        "end_line": 1768,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.SpanSelector._release#1788",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.SpanSelector",
        "signature": "lib.matplotlib.widgets.SpanSelector._release(self, event)",
        "snippet": "    def _release(self, event):\n        \"\"\"on button release event\"\"\"\n        if self.pressv is None:\n            return\n\n        self.rect.set_visible(False)\n\n        if self.span_stays:\n            self.stay_rect.set_x(self.rect.get_x())\n            self.stay_rect.set_y(self.rect.get_y())\n            self.stay_rect.set_width(self.rect.get_width())\n            self.stay_rect.set_height(self.rect.get_height())\n            self.stay_rect.set_visible(True)\n\n        self.canvas.draw_idle()\n        vmin = self.pressv\n        xdata, ydata = self._get_data(event)\n        if self.direction == 'horizontal':\n            vmax = xdata or self.prev[0]\n        else:\n            vmax = ydata or self.prev[1]\n\n        if vmin > vmax:\n            vmin, vmax = vmax, vmin\n        span = vmax - vmin\n        if self.minspan is not None and span < self.minspan:\n            return\n        self.onselect(vmin, vmax)\n        self.pressv = None\n        return False",
        "begin_line": 1788,
        "end_line": 1817,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.SpanSelector._onmove#1824",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.SpanSelector",
        "signature": "lib.matplotlib.widgets.SpanSelector._onmove(self, event)",
        "snippet": "    def _onmove(self, event):\n        \"\"\"on motion notify event\"\"\"\n        if self.pressv is None:\n            return\n\n        self._set_span_xy(event)\n\n        if self.onmove_callback is not None:\n            vmin = self.pressv\n            xdata, ydata = self._get_data(event)\n            if self.direction == 'horizontal':\n                vmax = xdata or self.prev[0]\n            else:\n                vmax = ydata or self.prev[1]\n\n            if vmin > vmax:\n                vmin, vmax = vmax, vmin\n            self.onmove_callback(vmin, vmax)\n\n        self.update()\n        return False",
        "begin_line": 1824,
        "end_line": 1844,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.SpanSelector._set_span_xy#1846",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.SpanSelector",
        "signature": "lib.matplotlib.widgets.SpanSelector._set_span_xy(self, event)",
        "snippet": "    def _set_span_xy(self, event):\n        \"\"\"Setting the span coordinates\"\"\"\n        x, y = self._get_data(event)\n        if x is None:\n            return\n\n        self.prev = x, y\n        if self.direction == 'horizontal':\n            v = x\n        else:\n            v = y\n\n        minv, maxv = v, self.pressv\n        if minv > maxv:\n            minv, maxv = maxv, minv\n        if self.direction == 'horizontal':\n            self.rect.set_x(minv)\n            self.rect.set_width(maxv - minv)\n        else:\n            self.rect.set_y(minv)\n            self.rect.set_height(maxv - minv)",
        "begin_line": 1846,
        "end_line": 1866,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.ToolHandles.__init__#1885",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.ToolHandles",
        "signature": "lib.matplotlib.widgets.ToolHandles.__init__(self, ax, x, y, marker='o', marker_props=None, useblit=True)",
        "snippet": "    def __init__(self, ax, x, y, marker='o', marker_props=None, useblit=True):\n        self.ax = ax\n        props = dict(marker=marker, markersize=7, mfc='w', ls='none',\n                     alpha=0.5, visible=False, label='_nolegend_')\n        props.update(marker_props if marker_props is not None else {})\n        self._markers = Line2D(x, y, animated=useblit, **props)\n        self.ax.add_line(self._markers)\n        self.artist = self._markers",
        "begin_line": 1885,
        "end_line": 1892,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.ToolHandles.y#1899",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.ToolHandles",
        "signature": "lib.matplotlib.widgets.ToolHandles.y(self)",
        "snippet": "    def y(self):\n        return self._markers.get_ydata()",
        "begin_line": 1899,
        "end_line": 1900,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.ToolHandles.set_data#1902",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.ToolHandles",
        "signature": "lib.matplotlib.widgets.ToolHandles.set_data(self, pts, y=None)",
        "snippet": "    def set_data(self, pts, y=None):\n        \"\"\"Set x and y positions of handles\"\"\"\n        if y is not None:\n            x = pts\n            pts = np.array([x, y])\n        self._markers.set_data(pts)",
        "begin_line": 1902,
        "end_line": 1907,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector.__init__#1965",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector.__init__(self, ax, onselect, drawtype='box', minspanx=None, minspany=None, useblit=False, lineprops=None, rectprops=None, spancoords='data', button=None, maxdist=10, marker_props=None, interactive=False, state_modifier_keys=None)",
        "snippet": "    def __init__(self, ax, onselect, drawtype='box',\n                 minspanx=None, minspany=None, useblit=False,\n                 lineprops=None, rectprops=None, spancoords='data',\n                 button=None, maxdist=10, marker_props=None,\n                 interactive=False, state_modifier_keys=None):\n        r\"\"\"\n        Create a selector in *ax*.  When a selection is made, clear\n        the span and call onselect with::\n\n          onselect(pos_1, pos_2)\n\n        and clear the drawn box/line. The ``pos_1`` and ``pos_2`` are\n        arrays of length 2 containing the x- and y-coordinate.\n\n        If *minspanx* is not *None* then events smaller than *minspanx*\n        in x direction are ignored (it's the same for y).\n\n        The rectangle is drawn with *rectprops*; default::\n\n          rectprops = dict(facecolor='red', edgecolor = 'black',\n                           alpha=0.2, fill=True)\n\n        The line is drawn with *lineprops*; default::\n\n          lineprops = dict(color='black', linestyle='-',\n                           linewidth = 2, alpha=0.5)\n\n        Use *drawtype* if you want the mouse to draw a line,\n        a box or nothing between click and actual position by setting\n\n        ``drawtype = 'line'``, ``drawtype='box'`` or ``drawtype = 'none'``.\n        Drawing a line would result in a line from vertex A to vertex C in\n        a rectangle ABCD.\n\n        *spancoords* is one of 'data' or 'pixels'.  If 'data', *minspanx*\n        and *minspanx* will be interpreted in the same coordinates as\n        the x and y axis. If 'pixels', they are in pixels.\n\n        *button* is the `.MouseButton` or list of `.MouseButton`\\s used for\n        rectangle selection.  Default is *None*, which means any button.\n\n        *interactive* will draw a set of handles and allow you interact\n        with the widget after it is drawn.\n\n        *state_modifier_keys* are keyboard modifiers that affect the behavior\n        of the widget.\n\n        The defaults are:\n        dict(move=' ', clear='escape', square='shift', center='ctrl')\n\n        Keyboard modifiers, which:\n        'move': Move the existing shape.\n        'clear': Clear the current shape.\n        'square': Makes the shape square.\n        'center': Make the initial point the center of the shape.\n        'square' and 'center' can be combined.\n        \"\"\"\n        _SelectorWidget.__init__(self, ax, onselect, useblit=useblit,\n                                 button=button,\n                                 state_modifier_keys=state_modifier_keys)\n\n        self.to_draw = None\n        self.visible = True\n        self.interactive = interactive\n\n        if drawtype == 'none':  # draw a line but make it invisible\n            drawtype = 'line'\n            self.visible = False\n\n        if drawtype == 'box':\n            if rectprops is None:\n                rectprops = dict(facecolor='red', edgecolor='black',\n                                 alpha=0.2, fill=True)\n            rectprops['animated'] = self.useblit\n            self.rectprops = rectprops\n            self.to_draw = self._shape_klass((0, 0), 0, 1, visible=False,\n                                             **self.rectprops)\n            self.ax.add_patch(self.to_draw)\n        if drawtype == 'line':\n            if lineprops is None:\n                lineprops = dict(color='black', linestyle='-',\n                                 linewidth=2, alpha=0.5)\n            lineprops['animated'] = self.useblit\n            self.lineprops = lineprops\n            self.to_draw = Line2D([0, 0], [0, 0], visible=False,\n                                  **self.lineprops)\n            self.ax.add_line(self.to_draw)\n\n        self.minspanx = minspanx\n        self.minspany = minspany\n\n        cbook._check_in_list(['data', 'pixels'], spancoords=spancoords)\n        self.spancoords = spancoords\n        self.drawtype = drawtype\n\n        self.maxdist = maxdist\n\n        if rectprops is None:\n            props = dict(mec='r')\n        else:\n            props = dict(mec=rectprops.get('edgecolor', 'r'))\n        self._corner_order = ['NW', 'NE', 'SE', 'SW']\n        xc, yc = self.corners\n        self._corner_handles = ToolHandles(self.ax, xc, yc, marker_props=props,\n                                           useblit=self.useblit)\n\n        self._edge_order = ['W', 'N', 'E', 'S']\n        xe, ye = self.edge_centers\n        self._edge_handles = ToolHandles(self.ax, xe, ye, marker='s',\n                                         marker_props=props,\n                                         useblit=self.useblit)\n\n        xc, yc = self.center\n        self._center_handle = ToolHandles(self.ax, [xc], [yc], marker='s',\n                                          marker_props=props,\n                                          useblit=self.useblit)\n\n        self.active_handle = None\n\n        self.artists = [self.to_draw, self._center_handle.artist,\n                        self._corner_handles.artist,\n                        self._edge_handles.artist]\n\n        if not self.interactive:\n            self.artists = [self.to_draw]\n\n        self._extents_on_press = None",
        "begin_line": 1965,
        "end_line": 2091,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector._press#2093",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector._press(self, event)",
        "snippet": "    def _press(self, event):\n        \"\"\"on button press event\"\"\"\n        # make the drawed box/line visible get the click-coordinates,\n        # button, ...\n        if self.interactive and self.to_draw.get_visible():\n            self._set_active_handle(event)\n        else:\n            self.active_handle = None\n\n        if self.active_handle is None or not self.interactive:\n            # Clear previous rectangle before drawing new rectangle.\n            self.update()\n\n        if not self.interactive:\n            x = event.xdata\n            y = event.ydata\n            self.extents = x, x, y, y\n\n        self.set_visible(self.visible)",
        "begin_line": 2093,
        "end_line": 2111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector._release#2113",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector._release(self, event)",
        "snippet": "    def _release(self, event):\n        \"\"\"on button release event\"\"\"\n        if not self.interactive:\n            self.to_draw.set_visible(False)\n\n        # update the eventpress and eventrelease with the resulting extents\n        x1, x2, y1, y2 = self.extents\n        self.eventpress.xdata = x1\n        self.eventpress.ydata = y1\n        xy1 = self.ax.transData.transform([x1, y1])\n        self.eventpress.x, self.eventpress.y = xy1\n\n        self.eventrelease.xdata = x2\n        self.eventrelease.ydata = y2\n        xy2 = self.ax.transData.transform([x2, y2])\n        self.eventrelease.x, self.eventrelease.y = xy2\n\n        if self.spancoords == 'data':\n            xmin, ymin = self.eventpress.xdata, self.eventpress.ydata\n            xmax, ymax = self.eventrelease.xdata, self.eventrelease.ydata\n            # calculate dimensions of box or line get values in the right order\n        elif self.spancoords == 'pixels':\n            xmin, ymin = self.eventpress.x, self.eventpress.y\n            xmax, ymax = self.eventrelease.x, self.eventrelease.y\n        else:\n            cbook._check_in_list(['data', 'pixels'],\n                                 spancoords=self.spancoords)\n\n        if xmin > xmax:\n            xmin, xmax = xmax, xmin\n        if ymin > ymax:\n            ymin, ymax = ymax, ymin\n\n        spanx = xmax - xmin\n        spany = ymax - ymin\n        xproblems = self.minspanx is not None and spanx < self.minspanx\n        yproblems = self.minspany is not None and spany < self.minspany\n\n        # check if drawn distance (if it exists) is not too small in\n        # either x or y-direction\n        if self.drawtype != 'none' and (xproblems or yproblems):\n            for artist in self.artists:\n                artist.set_visible(False)\n            self.update()\n            return\n\n        # call desired function\n        self.onselect(self.eventpress, self.eventrelease)\n        self.update()\n\n        return False",
        "begin_line": 2113,
        "end_line": 2163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector._onmove#2165",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector._onmove(self, event)",
        "snippet": "    def _onmove(self, event):\n        \"\"\"on motion notify event if box/line is wanted\"\"\"\n        # resize an existing shape\n        if self.active_handle and self.active_handle != 'C':\n            x1, x2, y1, y2 = self._extents_on_press\n            if self.active_handle in ['E', 'W'] + self._corner_order:\n                x2 = event.xdata\n            if self.active_handle in ['N', 'S'] + self._corner_order:\n                y2 = event.ydata\n\n        # move existing shape\n        elif (('move' in self.state or self.active_handle == 'C')\n              and self._extents_on_press is not None):\n            x1, x2, y1, y2 = self._extents_on_press\n            dx = event.xdata - self.eventpress.xdata\n            dy = event.ydata - self.eventpress.ydata\n            x1 += dx\n            x2 += dx\n            y1 += dy\n            y2 += dy\n\n        # new shape\n        else:\n            center = [self.eventpress.xdata, self.eventpress.ydata]\n            center_pix = [self.eventpress.x, self.eventpress.y]\n            dx = (event.xdata - center[0]) / 2.\n            dy = (event.ydata - center[1]) / 2.\n\n            # square shape\n            if 'square' in self.state:\n                dx_pix = abs(event.x - center_pix[0])\n                dy_pix = abs(event.y - center_pix[1])\n                if not dx_pix:\n                    return\n                maxd = max(abs(dx_pix), abs(dy_pix))\n                if abs(dx_pix) < maxd:\n                    dx *= maxd / (abs(dx_pix) + 1e-6)\n                if abs(dy_pix) < maxd:\n                    dy *= maxd / (abs(dy_pix) + 1e-6)\n\n            # from center\n            if 'center' in self.state:\n                dx *= 2\n                dy *= 2\n\n            # from corner\n            else:\n                center[0] += dx\n                center[1] += dy\n\n            x1, x2, y1, y2 = (center[0] - dx, center[0] + dx,\n                              center[1] - dy, center[1] + dy)\n\n        self.extents = x1, x2, y1, y2",
        "begin_line": 2165,
        "end_line": 2218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector._rect_bbox#2221",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector._rect_bbox(self)",
        "snippet": "    def _rect_bbox(self):\n        if self.drawtype == 'box':\n            x0 = self.to_draw.get_x()\n            y0 = self.to_draw.get_y()\n            width = self.to_draw.get_width()\n            height = self.to_draw.get_height()\n            return x0, y0, width, height\n        else:\n            x, y = self.to_draw.get_data()\n            x0, x1 = min(x), max(x)\n            y0, y1 = min(y), max(y)\n            return x0, y0, x1 - x0, y1 - y0",
        "begin_line": 2221,
        "end_line": 2232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector.corners#2235",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector.corners(self)",
        "snippet": "    def corners(self):\n        \"\"\"Corners of rectangle from lower left, moving clockwise.\"\"\"\n        x0, y0, width, height = self._rect_bbox\n        xc = x0, x0 + width, x0 + width, x0\n        yc = y0, y0, y0 + height, y0 + height\n        return xc, yc",
        "begin_line": 2235,
        "end_line": 2240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector.edge_centers#2243",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector.edge_centers(self)",
        "snippet": "    def edge_centers(self):\n        \"\"\"Midpoint of rectangle edges from left, moving clockwise.\"\"\"\n        x0, y0, width, height = self._rect_bbox\n        w = width / 2.\n        h = height / 2.\n        xe = x0, x0 + w, x0 + width, x0 + w\n        ye = y0 + h, y0, y0 + h, y0 + height\n        return xe, ye",
        "begin_line": 2243,
        "end_line": 2250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector.center#2253",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector.center(self)",
        "snippet": "    def center(self):\n        \"\"\"Center of rectangle\"\"\"\n        x0, y0, width, height = self._rect_bbox\n        return x0 + width / 2., y0 + height / 2.",
        "begin_line": 2253,
        "end_line": 2256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector.extents#2259",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector.extents(self)",
        "snippet": "    def extents(self):\n        \"\"\"Return (xmin, xmax, ymin, ymax).\"\"\"\n        x0, y0, width, height = self._rect_bbox\n        xmin, xmax = sorted([x0, x0 + width])\n        ymin, ymax = sorted([y0, y0 + height])\n        return xmin, xmax, ymin, ymax",
        "begin_line": 2259,
        "end_line": 2264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector.extents#2267",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector.extents(self, extents)",
        "snippet": "    def extents(self, extents):\n        # Update displayed shape\n        self.draw_shape(extents)\n        # Update displayed handles\n        self._corner_handles.set_data(*self.corners)\n        self._edge_handles.set_data(*self.edge_centers)\n        self._center_handle.set_data(*self.center)\n        self.set_visible(self.visible)\n        self.update()",
        "begin_line": 2267,
        "end_line": 2275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector.draw_shape#2277",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector.draw_shape(self, extents)",
        "snippet": "    def draw_shape(self, extents):\n        x0, x1, y0, y1 = extents\n        xmin, xmax = sorted([x0, x1])\n        ymin, ymax = sorted([y0, y1])\n        xlim = sorted(self.ax.get_xlim())\n        ylim = sorted(self.ax.get_ylim())\n\n        xmin = max(xlim[0], xmin)\n        ymin = max(ylim[0], ymin)\n        xmax = min(xmax, xlim[1])\n        ymax = min(ymax, ylim[1])\n\n        if self.drawtype == 'box':\n            self.to_draw.set_x(xmin)\n            self.to_draw.set_y(ymin)\n            self.to_draw.set_width(xmax - xmin)\n            self.to_draw.set_height(ymax - ymin)\n\n        elif self.drawtype == 'line':\n            self.to_draw.set_data([xmin, xmax], [ymin, ymax])",
        "begin_line": 2277,
        "end_line": 2296,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector._set_active_handle#2298",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector._set_active_handle(self, event)",
        "snippet": "    def _set_active_handle(self, event):\n        \"\"\"Set active handle based on the location of the mouse event\"\"\"\n        # Note: event.xdata/ydata in data coordinates, event.x/y in pixels\n        c_idx, c_dist = self._corner_handles.closest(event.x, event.y)\n        e_idx, e_dist = self._edge_handles.closest(event.x, event.y)\n        m_idx, m_dist = self._center_handle.closest(event.x, event.y)\n\n        if 'move' in self.state:\n            self.active_handle = 'C'\n            self._extents_on_press = self.extents\n\n        # Set active handle as closest handle, if mouse click is close enough.\n        elif m_dist < self.maxdist * 2:\n            self.active_handle = 'C'\n        elif c_dist > self.maxdist and e_dist > self.maxdist:\n            self.active_handle = None\n            return\n        elif c_dist < e_dist:\n            self.active_handle = self._corner_order[c_idx]\n        else:\n            self.active_handle = self._edge_order[e_idx]\n\n        # Save coordinates of rectangle at the start of handle movement.\n        x1, x2, y1, y2 = self.extents\n        # Switch variables so that only x2 and/or y2 are updated on move.\n        if self.active_handle in ['W', 'SW', 'NW']:\n            x1, x2 = x2, event.xdata\n        if self.active_handle in ['N', 'NW', 'NE']:\n            y1, y2 = y2, event.ydata\n        self._extents_on_press = x1, x2, y1, y2",
        "begin_line": 2298,
        "end_line": 2327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.RectangleSelector.geometry#2330",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.RectangleSelector",
        "signature": "lib.matplotlib.widgets.RectangleSelector.geometry(self)",
        "snippet": "    def geometry(self):\n        \"\"\"\n        Return an array of shape (2, 5) containing the\n        x (``RectangleSelector.geometry[1, :]``) and\n        y (``RectangleSelector.geometry[0, :]``) coordinates\n        of the four corners of the rectangle starting and ending\n        in the top left corner.\n        \"\"\"\n        if hasattr(self.to_draw, 'get_verts'):\n            xfm = self.ax.transData.inverted()\n            y, x = xfm.transform(self.to_draw.get_verts()).T\n            return np.array([x, y])\n        else:\n            return np.array(self.to_draw.get_data())",
        "begin_line": 2330,
        "end_line": 2343,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.EllipseSelector.draw_shape#2384",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.EllipseSelector",
        "signature": "lib.matplotlib.widgets.EllipseSelector.draw_shape(self, extents)",
        "snippet": "    def draw_shape(self, extents):\n        x1, x2, y1, y2 = extents\n        xmin, xmax = sorted([x1, x2])\n        ymin, ymax = sorted([y1, y2])\n        center = [x1 + (x2 - x1) / 2., y1 + (y2 - y1) / 2.]\n        a = (xmax - xmin) / 2.\n        b = (ymax - ymin) / 2.\n\n        if self.drawtype == 'box':\n            self.to_draw.center = center\n            self.to_draw.width = 2 * a\n            self.to_draw.height = 2 * b\n        else:\n            rad = np.deg2rad(np.arange(31) * 12)\n            x = a * np.cos(rad) + center[0]\n            y = b * np.sin(rad) + center[1]\n            self.to_draw.set_data(x, y)",
        "begin_line": 2384,
        "end_line": 2400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.EllipseSelector._rect_bbox#2403",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.EllipseSelector",
        "signature": "lib.matplotlib.widgets.EllipseSelector._rect_bbox(self)",
        "snippet": "    def _rect_bbox(self):\n        if self.drawtype == 'box':\n            x, y = self.to_draw.center\n            width = self.to_draw.width\n            height = self.to_draw.height\n            return x - width / 2., y - height / 2., width, height\n        else:\n            x, y = self.to_draw.get_data()\n            x0, x1 = min(x), max(x)\n            y0, y1 = min(y), max(y)\n            return x0, y0, x1 - x0, y1 - y0",
        "begin_line": 2403,
        "end_line": 2413,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.LassoSelector.__init__#2450",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.LassoSelector",
        "signature": "lib.matplotlib.widgets.LassoSelector.__init__(self, ax, onselect=None, useblit=True, lineprops=None, button=None)",
        "snippet": "    def __init__(self, ax, onselect=None, useblit=True, lineprops=None,\n                 button=None):\n        _SelectorWidget.__init__(self, ax, onselect, useblit=useblit,\n                                 button=button)\n        self.verts = None\n        if lineprops is None:\n            lineprops = dict()\n        # self.useblit may be != useblit, if the canvas doesn't support blit.\n        lineprops.update(animated=self.useblit, visible=False)\n        self.line = Line2D([], [], **lineprops)\n        self.ax.add_line(self.line)\n        self.artists = [self.line]",
        "begin_line": 2450,
        "end_line": 2461,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.LassoSelector._press#2466",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.LassoSelector",
        "signature": "lib.matplotlib.widgets.LassoSelector._press(self, event)",
        "snippet": "    def _press(self, event):\n        self.verts = [self._get_data(event)]\n        self.line.set_visible(True)",
        "begin_line": 2466,
        "end_line": 2468,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.LassoSelector._release#2473",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.LassoSelector",
        "signature": "lib.matplotlib.widgets.LassoSelector._release(self, event)",
        "snippet": "    def _release(self, event):\n        if self.verts is not None:\n            self.verts.append(self._get_data(event))\n            self.onselect(self.verts)\n        self.line.set_data([[], []])\n        self.line.set_visible(False)\n        self.verts = None",
        "begin_line": 2473,
        "end_line": 2479,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.LassoSelector._onmove#2481",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.LassoSelector",
        "signature": "lib.matplotlib.widgets.LassoSelector._onmove(self, event)",
        "snippet": "    def _onmove(self, event):\n        if self.verts is None:\n            return\n        self.verts.append(self._get_data(event))\n\n        self.line.set_data(list(zip(*self.verts)))\n\n        self.update()",
        "begin_line": 2481,
        "end_line": 2488,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector.__init__#2531",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector.__init__(self, ax, onselect, useblit=False, lineprops=None, markerprops=None, vertex_select_radius=15)",
        "snippet": "    def __init__(self, ax, onselect, useblit=False,\n                 lineprops=None, markerprops=None, vertex_select_radius=15):\n        # The state modifiers 'move', 'square', and 'center' are expected by\n        # _SelectorWidget but are not supported by PolygonSelector\n        # Note: could not use the existing 'move' state modifier in-place of\n        # 'move_all' because _SelectorWidget automatically discards 'move'\n        # from the state on button release.\n        state_modifier_keys = dict(clear='escape', move_vertex='control',\n                                   move_all='shift', move='not-applicable',\n                                   square='not-applicable',\n                                   center='not-applicable')\n        _SelectorWidget.__init__(self, ax, onselect, useblit=useblit,\n                                 state_modifier_keys=state_modifier_keys)\n\n        self._xs, self._ys = [0], [0]\n        self._polygon_completed = False\n\n        if lineprops is None:\n            lineprops = dict(color='k', linestyle='-', linewidth=2, alpha=0.5)\n        lineprops['animated'] = self.useblit\n        self.line = Line2D(self._xs, self._ys, **lineprops)\n        self.ax.add_line(self.line)\n\n        if markerprops is None:\n            markerprops = dict(mec='k', mfc=lineprops.get('color', 'k'))\n        self._polygon_handles = ToolHandles(self.ax, self._xs, self._ys,\n                                            useblit=self.useblit,\n                                            marker_props=markerprops)\n\n        self._active_handle_idx = -1\n        self.vertex_select_radius = vertex_select_radius\n\n        self.artists = [self.line, self._polygon_handles.artist]\n        self.set_visible(True)",
        "begin_line": 2531,
        "end_line": 2564,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector._release#2578",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector._release(self, event)",
        "snippet": "    def _release(self, event):\n        \"\"\"Button release event handler\"\"\"\n        # Release active tool handle.\n        if self._active_handle_idx >= 0:\n            self._active_handle_idx = -1\n\n        # Complete the polygon.\n        elif (len(self._xs) > 3\n              and self._xs[-1] == self._xs[0]\n              and self._ys[-1] == self._ys[0]):\n            self._polygon_completed = True\n\n        # Place new vertex.\n        elif (not self._polygon_completed\n              and 'move_all' not in self.state\n              and 'move_vertex' not in self.state):\n            self._xs.insert(-1, event.xdata)\n            self._ys.insert(-1, event.ydata)\n\n        if self._polygon_completed:\n            self.onselect(self.verts)",
        "begin_line": 2578,
        "end_line": 2598,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector.onmove#2600",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector.onmove(self, event)",
        "snippet": "    def onmove(self, event):\n        \"\"\"Cursor move event handler and validator\"\"\"\n        # Method overrides _SelectorWidget.onmove because the polygon selector\n        # needs to process the move callback even if there is no button press.\n        # _SelectorWidget.onmove include logic to ignore move event if\n        # eventpress is None.\n        if not self.ignore(event):\n            event = self._clean_event(event)\n            self._onmove(event)\n            return True\n        return False",
        "begin_line": 2600,
        "end_line": 2610,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector._onmove#2612",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector._onmove(self, event)",
        "snippet": "    def _onmove(self, event):\n        \"\"\"Cursor move event handler\"\"\"\n        # Move the active vertex (ToolHandle).\n        if self._active_handle_idx >= 0:\n            idx = self._active_handle_idx\n            self._xs[idx], self._ys[idx] = event.xdata, event.ydata\n            # Also update the end of the polygon line if the first vertex is\n            # the active handle and the polygon is completed.\n            if idx == 0 and self._polygon_completed:\n                self._xs[-1], self._ys[-1] = event.xdata, event.ydata\n\n        # Move all vertices.\n        elif 'move_all' in self.state and self.eventpress:\n            dx = event.xdata - self.eventpress.xdata\n            dy = event.ydata - self.eventpress.ydata\n            for k in range(len(self._xs)):\n                self._xs[k] = self._xs_at_press[k] + dx\n                self._ys[k] = self._ys_at_press[k] + dy\n\n        # Do nothing if completed or waiting for a move.\n        elif (self._polygon_completed\n              or 'move_vertex' in self.state or 'move_all' in self.state):\n            return\n\n        # Position pending vertex.\n        else:\n            # Calculate distance to the start vertex.\n            x0, y0 = self.line.get_transform().transform((self._xs[0],\n                                                          self._ys[0]))\n            v0_dist = np.hypot(x0 - event.x, y0 - event.y)\n            # Lock on to the start vertex if near it and ready to complete.\n            if len(self._xs) > 3 and v0_dist < self.vertex_select_radius:\n                self._xs[-1], self._ys[-1] = self._xs[0], self._ys[0]\n            else:\n                self._xs[-1], self._ys[-1] = event.xdata, event.ydata\n\n        self._draw_polygon()",
        "begin_line": 2612,
        "end_line": 2648,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector._on_key_press#2650",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector._on_key_press(self, event)",
        "snippet": "    def _on_key_press(self, event):\n        \"\"\"Key press event handler\"\"\"\n        # Remove the pending vertex if entering the 'move_vertex' or\n        # 'move_all' mode\n        if (not self._polygon_completed\n                and ('move_vertex' in self.state or 'move_all' in self.state)):\n            self._xs, self._ys = self._xs[:-1], self._ys[:-1]\n            self._draw_polygon()",
        "begin_line": 2650,
        "end_line": 2657,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector._on_key_release#2659",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector._on_key_release(self, event)",
        "snippet": "    def _on_key_release(self, event):\n        \"\"\"Key release event handler\"\"\"\n        # Add back the pending vertex if leaving the 'move_vertex' or\n        # 'move_all' mode (by checking the released key)\n        if (not self._polygon_completed\n                and\n                (event.key == self.state_modifier_keys.get('move_vertex')\n                 or event.key == self.state_modifier_keys.get('move_all'))):\n            self._xs.append(event.xdata)\n            self._ys.append(event.ydata)\n            self._draw_polygon()\n        # Reset the polygon if the released key is the 'clear' key.\n        elif event.key == self.state_modifier_keys.get('clear'):\n            event = self._clean_event(event)\n            self._xs, self._ys = [event.xdata], [event.ydata]\n            self._polygon_completed = False\n            self.set_visible(True)",
        "begin_line": 2659,
        "end_line": 2675,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector._draw_polygon#2677",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector._draw_polygon(self)",
        "snippet": "    def _draw_polygon(self):\n        \"\"\"Redraw the polygon based on the new vertex positions.\"\"\"\n        self.line.set_data(self._xs, self._ys)\n        # Only show one tool handle at the start and end vertex of the polygon\n        # if the polygon is completed or the user is locked on to the start\n        # vertex.\n        if (self._polygon_completed\n                or (len(self._xs) > 3\n                    and self._xs[-1] == self._xs[0]\n                    and self._ys[-1] == self._ys[0])):\n            self._polygon_handles.set_data(self._xs[:-1], self._ys[:-1])\n        else:\n            self._polygon_handles.set_data(self._xs, self._ys)\n        self.update()",
        "begin_line": 2677,
        "end_line": 2690,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.widgets.PolygonSelector.verts#2693",
        "src_path": "lib/matplotlib/widgets.py",
        "class_name": "lib.matplotlib.widgets.PolygonSelector",
        "signature": "lib.matplotlib.widgets.PolygonSelector.verts(self)",
        "snippet": "    def verts(self):\n        \"\"\"The polygon vertices, as a list of ``(x, y)`` pairs.\"\"\"\n        return list(zip(self._xs[:-1], self._ys[:-1]))",
        "begin_line": 2693,
        "end_line": 2695,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.lines._get_dash_pattern#33",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines",
        "signature": "lib.matplotlib.lines._get_dash_pattern(style)",
        "snippet": "def _get_dash_pattern(style):\n    \"\"\"Convert linestyle -> dash pattern\n    \"\"\"\n    # go from short hand -> full strings\n    if isinstance(style, str):\n        style = ls_mapper.get(style, style)\n    # un-dashed styles\n    if style in ['solid', 'None']:\n        offset = 0\n        dashes = None\n    # dashed styles\n    elif style in ['dashed', 'dashdot', 'dotted']:\n        offset = 0\n        dashes = tuple(rcParams['lines.{}_pattern'.format(style)])\n    #\n    elif isinstance(style, tuple):\n        offset, dashes = style\n        if offset is None:\n            cbook.warn_deprecated(\n                \"3.3\", message=\"Passing the dash offset as None is deprecated \"\n                \"since %(since)s and support for it will be removed \"\n                \"%(removal)s; pass it as zero instead.\")\n            offset = 0\n    else:\n        raise ValueError('Unrecognized linestyle: %s' % str(style))\n\n    # normalize offset to be positive and shorter than the dash cycle\n    if dashes is not None:\n        dsum = sum(dashes)\n        if dsum:\n            offset %= dsum\n\n    return offset, dashes",
        "begin_line": 33,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.015384615384615385,
            "pseudo_dstar_susp": 0.018518518518518517,
            "pseudo_tarantula_susp": 0.0006165228113440197,
            "pseudo_op2_susp": 0.01639344262295082,
            "pseudo_barinel_susp": 0.0006165228113440197
        }
    },
    {
        "name": "lib.matplotlib.lines._scale_dashes#68",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines",
        "signature": "lib.matplotlib.lines._scale_dashes(offset, dashes, lw)",
        "snippet": "def _scale_dashes(offset, dashes, lw):\n    if not rcParams['lines.scale_dashes']:\n        return offset, dashes\n    scaled_offset = offset * lw\n    scaled_dashes = ([x * lw if x is not None else None for x in dashes]\n                     if dashes is not None else None)\n    return scaled_offset, scaled_dashes",
        "begin_line": 68,
        "end_line": 74,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.05555555555555555,
            "pseudo_dstar_susp": 0.5,
            "pseudo_tarantula_susp": 0.0005724098454493417,
            "pseudo_op2_susp": 0.14285714285714285,
            "pseudo_barinel_susp": 0.0005724098454493417
        }
    },
    {
        "name": "lib.matplotlib.lines._mark_every_path#114",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines",
        "signature": "lib.matplotlib.lines._mark_every_path(markevery, tpath, affine, ax_transform)",
        "snippet": "def _mark_every_path(markevery, tpath, affine, ax_transform):\n    \"\"\"\n    Helper function that sorts out how to deal the input\n    `markevery` and returns the points where markers should be drawn.\n\n    Takes in the `markevery` value and the line path and returns the\n    sub-sampled path.\n    \"\"\"\n    # pull out the two bits of data we want from the path\n    codes, verts = tpath.codes, tpath.vertices\n\n    def _slice_or_none(in_v, slc):\n        \"\"\"Helper function to cope with `codes` being an ndarray or `None`.\"\"\"\n        if in_v is None:\n            return None\n        return in_v[slc]\n\n    # if just an int, assume starting at 0 and make a tuple\n    if isinstance(markevery, Integral):\n        markevery = (0, markevery)\n    # if just a float, assume starting at 0.0 and make a tuple\n    elif isinstance(markevery, Real):\n        markevery = (0.0, markevery)\n\n    if isinstance(markevery, tuple):\n        if len(markevery) != 2:\n            raise ValueError('`markevery` is a tuple but its len is not 2; '\n                             'markevery={}'.format(markevery))\n        start, step = markevery\n        # if step is an int, old behavior\n        if isinstance(step, Integral):\n            # tuple of 2 int is for backwards compatibility,\n            if not isinstance(start, Integral):\n                raise ValueError(\n                    '`markevery` is a tuple with len 2 and second element is '\n                    'an int, but the first element is not an int; markevery={}'\n                    .format(markevery))\n            # just return, we are done here\n\n            return Path(verts[slice(start, None, step)],\n                        _slice_or_none(codes, slice(start, None, step)))\n\n        elif isinstance(step, Real):\n            if not isinstance(start, Real):\n                raise ValueError(\n                    '`markevery` is a tuple with len 2 and second element is '\n                    'a float, but the first element is not a float or an int; '\n                    'markevery={}'.format(markevery))\n            # calc cumulative distance along path (in display coords):\n            disp_coords = affine.transform(tpath.vertices)\n            delta = np.empty((len(disp_coords), 2))\n            delta[0, :] = 0\n            delta[1:, :] = disp_coords[1:, :] - disp_coords[:-1, :]\n            delta = np.hypot(*delta.T).cumsum()\n            # calc distance between markers along path based on the axes\n            # bounding box diagonal being a distance of unity:\n            (x0, y0), (x1, y1) = ax_transform.transform([[0, 0], [1, 1]])\n            scale = np.hypot(x1 - x0, y1 - y0)\n            marker_delta = np.arange(start * scale, delta[-1], step * scale)\n            # find closest actual data point that is closest to\n            # the theoretical distance along the path:\n            inds = np.abs(delta[np.newaxis, :] - marker_delta[:, np.newaxis])\n            inds = inds.argmin(axis=1)\n            inds = np.unique(inds)\n            # return, we are done here\n            return Path(verts[inds], _slice_or_none(codes, inds))\n        else:\n            raise ValueError(\n                f\"markevery={markevery!r} is a tuple with len 2, but its \"\n                f\"second element is not an int or a float\")\n\n    elif isinstance(markevery, slice):\n        # mazol tov, it's already a slice, just return\n        return Path(verts[markevery], _slice_or_none(codes, markevery))\n\n    elif np.iterable(markevery):\n        # fancy indexing\n        try:\n            return Path(verts[markevery], _slice_or_none(codes, markevery))\n        except (ValueError, IndexError) as err:\n            raise ValueError(\n                f\"markevery={markevery!r} is iterable but not a valid numpy \"\n                f\"fancy index\") from err\n    else:\n        raise ValueError(f\"markevery={markevery!r} is not a recognized value\")",
        "begin_line": 114,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.056719303899453e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.lines._slice_or_none#125",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines",
        "signature": "lib.matplotlib.lines._slice_or_none(in_v, slc)",
        "snippet": "    def _slice_or_none(in_v, slc):\n        \"\"\"Helper function to cope with `codes` being an ndarray or `None`.\"\"\"\n        if in_v is None:\n            return None\n        return in_v[slc]",
        "begin_line": 125,
        "end_line": 129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.999000099990002e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.__init__#270",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.__init__(self, xdata, ydata, linewidth=None, linestyle=None, color=None, marker=None, markersize=None, markeredgewidth=None, markeredgecolor=None, markerfacecolor=None, markerfacecoloralt='none', fillstyle=None, antialiased=None, dash_capstyle=None, solid_capstyle=None, dash_joinstyle=None, solid_joinstyle=None, pickradius=5, drawstyle=None, markevery=None, **kwargs)",
        "snippet": "    def __init__(self, xdata, ydata,\n                 linewidth=None,  # all Nones default to rc\n                 linestyle=None,\n                 color=None,\n                 marker=None,\n                 markersize=None,\n                 markeredgewidth=None,\n                 markeredgecolor=None,\n                 markerfacecolor=None,\n                 markerfacecoloralt='none',\n                 fillstyle=None,\n                 antialiased=None,\n                 dash_capstyle=None,\n                 solid_capstyle=None,\n                 dash_joinstyle=None,\n                 solid_joinstyle=None,\n                 pickradius=5,\n                 drawstyle=None,\n                 markevery=None,\n                 **kwargs\n                 ):\n        \"\"\"\n        Create a `.Line2D` instance with *x* and *y* data in sequences of\n        *xdata*, *ydata*.\n\n        Additional keyword arguments are `.Line2D` properties:\n\n        %(_Line2D_docstr)s\n\n        See :meth:`set_linestyle` for a description of the line styles,\n        :meth:`set_marker` for a description of the markers, and\n        :meth:`set_drawstyle` for a description of the draw styles.\n\n        \"\"\"\n        Artist.__init__(self)\n\n        #convert sequences to numpy arrays\n        if not np.iterable(xdata):\n            raise RuntimeError('xdata must be a sequence')\n        if not np.iterable(ydata):\n            raise RuntimeError('ydata must be a sequence')\n\n        if linewidth is None:\n            linewidth = rcParams['lines.linewidth']\n\n        if linestyle is None:\n            linestyle = rcParams['lines.linestyle']\n        if marker is None:\n            marker = rcParams['lines.marker']\n        if markerfacecolor is None:\n            markerfacecolor = rcParams['lines.markerfacecolor']\n        if markeredgecolor is None:\n            markeredgecolor = rcParams['lines.markeredgecolor']\n        if color is None:\n            color = rcParams['lines.color']\n\n        if markersize is None:\n            markersize = rcParams['lines.markersize']\n        if antialiased is None:\n            antialiased = rcParams['lines.antialiased']\n        if dash_capstyle is None:\n            dash_capstyle = rcParams['lines.dash_capstyle']\n        if dash_joinstyle is None:\n            dash_joinstyle = rcParams['lines.dash_joinstyle']\n        if solid_capstyle is None:\n            solid_capstyle = rcParams['lines.solid_capstyle']\n        if solid_joinstyle is None:\n            solid_joinstyle = rcParams['lines.solid_joinstyle']\n\n        if isinstance(linestyle, str):\n            ds, ls = self._split_drawstyle_linestyle(linestyle)\n            if ds is not None and drawstyle is not None and ds != drawstyle:\n                raise ValueError(\"Inconsistent drawstyle ({!r}) and linestyle \"\n                                 \"({!r})\".format(drawstyle, linestyle))\n            linestyle = ls\n\n            if ds is not None:\n                drawstyle = ds\n\n        if drawstyle is None:\n            drawstyle = 'default'\n\n        self._dashcapstyle = None\n        self._dashjoinstyle = None\n        self._solidjoinstyle = None\n        self._solidcapstyle = None\n        self.set_dash_capstyle(dash_capstyle)\n        self.set_dash_joinstyle(dash_joinstyle)\n        self.set_solid_capstyle(solid_capstyle)\n        self.set_solid_joinstyle(solid_joinstyle)\n\n        self._linestyles = None\n        self._drawstyle = None\n        self._linewidth = linewidth\n\n        # scaled dash + offset\n        self._dashSeq = None\n        self._dashOffset = 0\n        # unscaled dash + offset\n        # this is needed scaling the dash pattern by linewidth\n        self._us_dashSeq = None\n        self._us_dashOffset = 0\n\n        self.set_linewidth(linewidth)\n        self.set_linestyle(linestyle)\n        self.set_drawstyle(drawstyle)\n\n        self._color = None\n        self.set_color(color)\n        self._marker = MarkerStyle(marker, fillstyle)\n\n        self._markevery = None\n        self._markersize = None\n        self._antialiased = None\n\n        self.set_markevery(markevery)\n        self.set_antialiased(antialiased)\n        self.set_markersize(markersize)\n\n        self._markeredgecolor = None\n        self._markeredgewidth = None\n        self._markerfacecolor = None\n        self._markerfacecoloralt = None\n\n        self.set_markerfacecolor(markerfacecolor)\n        self.set_markerfacecoloralt(markerfacecoloralt)\n        self.set_markeredgecolor(markeredgecolor)\n        self.set_markeredgewidth(markeredgewidth)\n\n        # update kwargs before updating data to give the caller a\n        # chance to init axes (and hence unit support)\n        self.update(kwargs)\n        self.pickradius = pickradius\n        self.ind_offset = 0\n\n        self._xorig = np.asarray([])\n        self._yorig = np.asarray([])\n        self._invalidx = True\n        self._invalidy = True\n        self._x = None\n        self._y = None\n        self._xy = None\n        self._path = None\n        self._transformed_path = None\n        self._subslice = False\n        self._x_filled = None  # used in subslicing; only x is needed\n\n        self.set_data(xdata, ydata)",
        "begin_line": 270,
        "end_line": 417,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002506265664160401,
            "pseudo_dstar_susp": 0.002976190476190476,
            "pseudo_tarantula_susp": 0.0007942811755361397,
            "pseudo_op2_susp": 0.002976190476190476,
            "pseudo_barinel_susp": 0.0007942811755361397
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_pickradius#497",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_pickradius(self, d)",
        "snippet": "    def set_pickradius(self, d):\n        \"\"\"Set the pick radius used for containment tests.\n\n        See `.contains` for more details.\n\n        Parameters\n        ----------\n        d : float\n            Pick radius, in points.\n        \"\"\"\n        if not isinstance(d, Number) or d < 0:\n            raise ValueError(\"pick radius should be a distance\")\n        self._pickradius = d",
        "begin_line": 497,
        "end_line": 509,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010893246187363835,
            "pseudo_dstar_susp": 0.0018315018315018315,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.0018315018315018315,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_markevery#541",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_markevery(self, every)",
        "snippet": "    def set_markevery(self, every):\n        \"\"\"\n        Set the markevery property to subsample the plot when using markers.\n\n        e.g., if ``every=5``, every 5-th marker will be plotted.\n\n        Parameters\n        ----------\n        every : None or int or (int, int) or slice or List[int] or float or \\\n(float, float)\n            Which markers to plot.\n\n            - every=None, every point will be plotted.\n            - every=N, every N-th marker will be plotted starting with\n              marker 0.\n            - every=(start, N), every N-th marker, starting at point\n              start, will be plotted.\n            - every=slice(start, end, N), every N-th marker, starting at\n              point start, up to but not including point end, will be plotted.\n            - every=[i, j, m, n], only markers at points i, j, m, and n\n              will be plotted.\n            - every=0.1, (i.e. a float) then markers will be spaced at\n              approximately equal distances along the line; the distance\n              along the line between markers is determined by multiplying the\n              display-coordinate distance of the axes bounding-box diagonal\n              by the value of every.\n            - every=(0.5, 0.1) (i.e. a length-2 tuple of float), the same\n              functionality as every=0.1 is exhibited but the first marker will\n              be 0.5 multiplied by the display-coordinate-diagonal-distance\n              along the line.\n\n            For examples see\n            :doc:`/gallery/lines_bars_and_markers/markevery_demo`.\n\n        Notes\n        -----\n        Setting the markevery property will only show markers at actual data\n        points.  When using float arguments to set the markevery property\n        on irregularly spaced data, the markers will likely not appear evenly\n        spaced because the actual data points do not coincide with the\n        theoretical spacing between markers.\n\n        When using a start offset to specify the first marker, the offset will\n        be from the first data point which may be different from the first\n        the visible data point if the plot is zoomed in.\n\n        If zooming in on a plot when using float arguments then the actual\n        data points that have markers will change because the distance between\n        markers is always determined from the display-coordinates\n        axes-bounding-box-diagonal regardless of the actual axes data limits.\n\n        \"\"\"\n        if self._markevery != every:\n            self.stale = True\n        self._markevery = every",
        "begin_line": 541,
        "end_line": 595,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002777777777777778,
            "pseudo_dstar_susp": 0.0011389521640091116,
            "pseudo_tarantula_susp": 0.0008849557522123894,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0008849557522123894
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_markevery#597",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_markevery(self)",
        "snippet": "    def get_markevery(self):\n        \"\"\"\n        Return the markevery setting for marker subsampling.\n\n        See also `~.Line2D.set_markevery`.\n        \"\"\"\n        return self._markevery",
        "begin_line": 597,
        "end_line": 603,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.axes#627",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.axes(self, ax)",
        "snippet": "    def axes(self, ax):\n        # call the set method from the base-class property\n        Artist.axes.fset(self, ax)\n        if ax is not None:\n            # connect unit-related callbacks\n            if ax.xaxis is not None:\n                self._xcid = ax.xaxis.callbacks.connect('units',\n                                                        self.recache_always)\n            if ax.yaxis is not None:\n                self._ycid = ax.yaxis.callbacks.connect('units',\n                                                        self.recache_always)",
        "begin_line": 627,
        "end_line": 637,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012738853503184713,
            "pseudo_dstar_susp": 0.00234192037470726,
            "pseudo_tarantula_susp": 0.0005449591280653951,
            "pseudo_op2_susp": 0.00234192037470726,
            "pseudo_barinel_susp": 0.0005449591280653951
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_data#639",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_data(self, *args)",
        "snippet": "    def set_data(self, *args):\n        \"\"\"\n        Set the x and y data.\n\n        Parameters\n        ----------\n        *args : (2, N) array or two 1D arrays\n        \"\"\"\n        if len(args) == 1:\n            (x, y), = args\n        else:\n            x, y = args\n\n        self.set_xdata(x)\n        self.set_ydata(y)",
        "begin_line": 639,
        "end_line": 653,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019193857965451055,
            "pseudo_dstar_susp": 0.0018315018315018315,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0018315018315018315,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.recache#658",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.recache(self, always=False)",
        "snippet": "    def recache(self, always=False):\n        if always or self._invalidx:\n            xconv = self.convert_xunits(self._xorig)\n            x = _to_unmasked_float_array(xconv).ravel()\n        else:\n            x = self._x\n        if always or self._invalidy:\n            yconv = self.convert_yunits(self._yorig)\n            y = _to_unmasked_float_array(yconv).ravel()\n        else:\n            y = self._y\n\n        self._xy = np.column_stack(np.broadcast_arrays(x, y)).astype(float)\n        self._x, self._y = self._xy.T  # views\n\n        self._subslice = False\n        if (self.axes and len(x) > 1000 and self._is_sorted(x) and\n                self.axes.name == 'rectilinear' and\n                self.axes.get_xscale() == 'linear' and\n                self._markevery is None and\n                self.get_clip_on()):\n            self._subslice = True\n            nanmask = np.isnan(x)\n            if nanmask.any():\n                self._x_filled = self._x.copy()\n                indices = np.arange(len(x))\n                self._x_filled[nanmask] = np.interp(\n                    indices[nanmask], indices[~nanmask], self._x[~nanmask])\n            else:\n                self._x_filled = self._x\n\n        if self._path is not None:\n            interpolation_steps = self._path._interpolation_steps\n        else:\n            interpolation_steps = 1\n        xy = STEP_LOOKUP_MAP[self._drawstyle](*self._xy.T)\n        self._path = Path(np.asarray(xy).T,\n                          _interpolation_steps=interpolation_steps)\n        self._transformed_path = None\n        self._invalidx = False\n        self._invalidy = False",
        "begin_line": 658,
        "end_line": 698,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002352941176470588,
            "pseudo_dstar_susp": 0.002898550724637681,
            "pseudo_tarantula_susp": 0.0013157894736842105,
            "pseudo_op2_susp": 0.002898550724637681,
            "pseudo_barinel_susp": 0.0013157894736842105
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D._transform_path#700",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D._transform_path(self, subslice=None)",
        "snippet": "    def _transform_path(self, subslice=None):\n        \"\"\"\n        Puts a TransformedPath instance at self._transformed_path;\n        all invalidation of the transform is then handled by the\n        TransformedPath instance.\n        \"\"\"\n        # Masked arrays are now handled by the Path class itself\n        if subslice is not None:\n            xy = STEP_LOOKUP_MAP[self._drawstyle](*self._xy[subslice, :].T)\n            _path = Path(np.asarray(xy).T,\n                         _interpolation_steps=self._path._interpolation_steps)\n        else:\n            _path = self._path\n        self._transformed_path = TransformedPath(_path, self.get_transform())",
        "begin_line": 700,
        "end_line": 713,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.104980424292088e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_transform#724",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_transform(self, t)",
        "snippet": "    def set_transform(self, t):\n        \"\"\"\n        Set the Transformation instance used by this artist.\n\n        Parameters\n        ----------\n        t : `matplotlib.transforms.Transform`\n        \"\"\"\n        Artist.set_transform(self, t)\n        self._invalidx = True\n        self._invalidy = True\n        self.stale = True",
        "begin_line": 724,
        "end_line": 735,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015600624024961,
            "pseudo_dstar_susp": 0.0009615384615384616,
            "pseudo_tarantula_susp": 0.0017482517482517483,
            "pseudo_op2_susp": 0.0009615384615384616,
            "pseudo_barinel_susp": 0.0017482517482517483
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.draw#743",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        # docstring inherited\n\n        if not self.get_visible():\n            return\n\n        if self._invalidy or self._invalidx:\n            self.recache()\n        self.ind_offset = 0  # Needed for contains() method.\n        if self._subslice and self.axes:\n            x0, x1 = self.axes.get_xbound()\n            i0 = self._x_filled.searchsorted(x0, 'left')\n            i1 = self._x_filled.searchsorted(x1, 'right')\n            subslice = slice(max(i0 - 1, 0), i1 + 1)\n            self.ind_offset = subslice.start\n            self._transform_path(subslice)\n        else:\n            subslice = None\n\n        if self.get_path_effects():\n            from matplotlib.patheffects import PathEffectRenderer\n            renderer = PathEffectRenderer(self.get_path_effects(), renderer)\n\n        renderer.open_group('line2d', self.get_gid())\n        if self._lineStyles[self._linestyle] != '_draw_nothing':\n            tpath, affine = (self._get_transformed_path()\n                             .get_transformed_path_and_affine())\n            if len(tpath.vertices):\n                gc = renderer.new_gc()\n                self._set_gc_clip(gc)\n\n                lc_rgba = mcolors.to_rgba(self._color, self._alpha)\n                gc.set_foreground(lc_rgba, isRGBA=True)\n\n                gc.set_antialiased(self._antialiased)\n                gc.set_linewidth(self._linewidth)\n\n                if self.is_dashed():\n                    cap = self._dashcapstyle\n                    join = self._dashjoinstyle\n                else:\n                    cap = self._solidcapstyle\n                    join = self._solidjoinstyle\n                gc.set_joinstyle(join)\n                gc.set_capstyle(cap)\n                gc.set_snap(self.get_snap())\n                if self.get_sketch_params() is not None:\n                    gc.set_sketch_params(*self.get_sketch_params())\n\n                gc.set_dashes(self._dashOffset, self._dashSeq)\n                renderer.draw_path(gc, tpath, affine.frozen())\n                gc.restore()\n\n        if self._marker and self._markersize > 0:\n            gc = renderer.new_gc()\n            self._set_gc_clip(gc)\n            gc.set_linewidth(self._markeredgewidth)\n            gc.set_antialiased(self._antialiased)\n\n            ec_rgba = mcolors.to_rgba(\n                self.get_markeredgecolor(), self._alpha)\n            fc_rgba = mcolors.to_rgba(\n                self._get_markerfacecolor(), self._alpha)\n            fcalt_rgba = mcolors.to_rgba(\n                self._get_markerfacecolor(alt=True), self._alpha)\n            # If the edgecolor is \"auto\", it is set according to the *line*\n            # color but inherits the alpha value of the *face* color, if any.\n            if (cbook._str_equal(self._markeredgecolor, \"auto\")\n                    and not cbook._str_lower_equal(\n                        self.get_markerfacecolor(), \"none\")):\n                ec_rgba = ec_rgba[:3] + (fc_rgba[3],)\n            gc.set_foreground(ec_rgba, isRGBA=True)\n            if self.get_sketch_params() is not None:\n                scale, length, randomness = self.get_sketch_params()\n                gc.set_sketch_params(scale/2, length/2, 2*randomness)\n\n            marker = self._marker\n\n            # Markers *must* be drawn ignoring the drawstyle (but don't pay the\n            # recaching if drawstyle is already \"default\").\n            if self.get_drawstyle() != \"default\":\n                with cbook._setattr_cm(\n                        self, _drawstyle=\"default\", _transformed_path=None):\n                    self.recache()\n                    self._transform_path(subslice)\n                    tpath, affine = (self._get_transformed_path()\n                                     .get_transformed_points_and_affine())\n            else:\n                tpath, affine = (self._get_transformed_path()\n                                 .get_transformed_points_and_affine())\n\n            if len(tpath.vertices):\n                # subsample the markers if markevery is not None\n                markevery = self.get_markevery()\n                if markevery is not None:\n                    subsampled = _mark_every_path(markevery, tpath,\n                                                  affine, self.axes.transAxes)\n                else:\n                    subsampled = tpath\n\n                snap = marker.get_snap_threshold()\n                if isinstance(snap, Real):\n                    snap = renderer.points_to_pixels(self._markersize) >= snap\n                gc.set_snap(snap)\n                gc.set_joinstyle(marker.get_joinstyle())\n                gc.set_capstyle(marker.get_capstyle())\n                marker_path = marker.get_path()\n                marker_trans = marker.get_transform()\n                w = renderer.points_to_pixels(self._markersize)\n\n                if cbook._str_equal(marker.get_marker(), \",\"):\n                    gc.set_linewidth(0)\n                else:\n                    # Don't scale for pixels, and don't stroke them\n                    marker_trans = marker_trans.scale(w)\n                renderer.draw_markers(gc, marker_path, marker_trans,\n                                      subsampled, affine.frozen(),\n                                      fc_rgba)\n\n                alt_marker_path = marker.get_alt_path()\n                if alt_marker_path:\n                    alt_marker_trans = marker.get_alt_transform()\n                    alt_marker_trans = alt_marker_trans.scale(w)\n                    renderer.draw_markers(\n                            gc, alt_marker_path, alt_marker_trans, subsampled,\n                            affine.frozen(), fcalt_rgba)\n\n            gc.restore()\n\n        renderer.close_group('line2d')\n        self.stale = False",
        "begin_line": 743,
        "end_line": 873,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041050903119868636,
            "pseudo_dstar_susp": 0.00037425149700598805,
            "pseudo_tarantula_susp": 0.001004016064257028,
            "pseudo_op2_susp": 0.00037425149700598805,
            "pseudo_barinel_susp": 0.0010030090270812437
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_color#879",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_color(self)",
        "snippet": "    def get_color(self):\n        \"\"\"\n        Return the line color.\n\n        See also `~.Line2D.set_color`.\n        \"\"\"\n        return self._color",
        "begin_line": 879,
        "end_line": 885,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_drawstyle#887",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_drawstyle(self)",
        "snippet": "    def get_drawstyle(self):\n        \"\"\"\n        Return the drawstyle.\n\n        See also `~.Line2D.set_drawstyle`.\n        \"\"\"\n        return self._drawstyle",
        "begin_line": 887,
        "end_line": 893,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.649770781074301e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_linestyle#895",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_linestyle(self)",
        "snippet": "    def get_linestyle(self):\n        \"\"\"\n        Return the linestyle.\n\n        See also `~.Line2D.set_linestyle`.\n        \"\"\"\n        return self._linestyle",
        "begin_line": 895,
        "end_line": 901,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_linewidth#903",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_linewidth(self)",
        "snippet": "    def get_linewidth(self):\n        \"\"\"\n        Return the linewidth in points.\n\n        See also `~.Line2D.set_linewidth`.\n        \"\"\"\n        return self._linewidth",
        "begin_line": 903,
        "end_line": 909,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_marker#911",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_marker(self)",
        "snippet": "    def get_marker(self):\n        \"\"\"\n        Return the line marker.\n\n        See also `~.Line2D.set_marker`.\n        \"\"\"\n        return self._marker.get_marker()",
        "begin_line": 911,
        "end_line": 917,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040290088638195,
            "pseudo_dstar_susp": 0.00036859565057132326,
            "pseudo_tarantula_susp": 0.000942507068803016,
            "pseudo_op2_susp": 0.00036859565057132326,
            "pseudo_barinel_susp": 0.000942507068803016
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_markeredgecolor#919",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_markeredgecolor(self)",
        "snippet": "    def get_markeredgecolor(self):\n        \"\"\"\n        Return the marker edge color.\n\n        See also `~.Line2D.set_markeredgecolor`.\n        \"\"\"\n        mec = self._markeredgecolor\n        if cbook._str_equal(mec, 'auto'):\n            if rcParams['_internal.classic_mode']:\n                if self._marker.get_marker() in ('.', ','):\n                    return self._color\n                if self._marker.is_filled() and self.get_fillstyle() != 'none':\n                    return 'k'  # Bad hard-wired default...\n            return self._color\n        else:\n            return mec",
        "begin_line": 919,
        "end_line": 934,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003009328919650918,
            "pseudo_dstar_susp": 0.00030048076923076925,
            "pseudo_tarantula_susp": 0.0003160556257901391,
            "pseudo_op2_susp": 0.00030048076923076925,
            "pseudo_barinel_susp": 0.0003160556257901391
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D._get_markerfacecolor#944",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D._get_markerfacecolor(self, alt=False)",
        "snippet": "    def _get_markerfacecolor(self, alt=False):\n        fc = self._markerfacecoloralt if alt else self._markerfacecolor\n        if cbook._str_lower_equal(fc, 'auto'):\n            if self.get_fillstyle() == 'none':\n                return 'none'\n            else:\n                return self._color\n        else:\n            return fc",
        "begin_line": 944,
        "end_line": 952,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00030395136778115504,
            "pseudo_dstar_susp": 0.0003022061045633122,
            "pseudo_tarantula_susp": 0.00032175032175032174,
            "pseudo_op2_susp": 0.0003022061045633122,
            "pseudo_barinel_susp": 0.0003219575016097875
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_data#978",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_data(self, orig=True)",
        "snippet": "    def get_data(self, orig=True):\n        \"\"\"\n        Return the xdata, ydata.\n\n        If *orig* is *True*, return the original data.\n        \"\"\"\n        return self.get_xdata(orig=orig), self.get_ydata(orig=orig)",
        "begin_line": 978,
        "end_line": 984,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_xdata#986",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_xdata(self, orig=True)",
        "snippet": "    def get_xdata(self, orig=True):\n        \"\"\"\n        Return the xdata.\n\n        If *orig* is *True*, return the original data, else the\n        processed data.\n        \"\"\"\n        if orig:\n            return self._xorig\n        if self._invalidx:\n            self.recache()\n        return self._x",
        "begin_line": 986,
        "end_line": 997,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_ydata#999",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_ydata(self, orig=True)",
        "snippet": "    def get_ydata(self, orig=True):\n        \"\"\"\n        Return the ydata.\n\n        If *orig* is *True*, return the original data, else the\n        processed data.\n        \"\"\"\n        if orig:\n            return self._yorig\n        if self._invalidy:\n            self.recache()\n        return self._y",
        "begin_line": 999,
        "end_line": 1010,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_path#1012",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_path(self)",
        "snippet": "    def get_path(self):\n        \"\"\"\n        Return the :class:`~matplotlib.path.Path` object associated\n        with this line.\n        \"\"\"\n        if self._invalidy or self._invalidx:\n            self.recache()\n        return self._path",
        "begin_line": 1012,
        "end_line": 1019,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013513513513513514,
            "pseudo_dstar_susp": 0.0009157509157509158,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.0009157509157509158,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_antialiased#1029",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_antialiased(self, b)",
        "snippet": "    def set_antialiased(self, b):\n        \"\"\"\n        Set whether to use antialiased rendering.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        if self._antialiased != b:\n            self.stale = True\n        self._antialiased = b",
        "begin_line": 1029,
        "end_line": 1039,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012484394506866417,
            "pseudo_dstar_susp": 0.002277904328018223,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.002277904328018223,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_color#1041",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_color(self, color)",
        "snippet": "    def set_color(self, color):\n        \"\"\"\n        Set the color of the line.\n\n        Parameters\n        ----------\n        color : color\n        \"\"\"\n        self._color = color\n        self.stale = True",
        "begin_line": 1041,
        "end_line": 1050,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012484394506866417,
            "pseudo_dstar_susp": 0.002277904328018223,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.002277904328018223,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_drawstyle#1052",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_drawstyle(self, drawstyle)",
        "snippet": "    def set_drawstyle(self, drawstyle):\n        \"\"\"\n        Set the drawstyle of the plot.\n\n        The drawstyle determines how the points are connected.\n\n        Parameters\n        ----------\n        drawstyle : {'default', 'steps', 'steps-pre', 'steps-mid', \\\n'steps-post'}, default: 'default'\n            For 'default', the points are connected with straight lines.\n\n            The steps variants connect the points with step-like lines,\n            i.e. horizontal lines with vertical steps. They differ in the\n            location of the step:\n\n            - 'steps-pre': The step is at the beginning of the line segment,\n              i.e. the line will be at the y-value of point to the right.\n            - 'steps-mid': The step is halfway between the points.\n            - 'steps-post: The step is at the end of the line segment,\n              i.e. the line will be at the y-value of the point to the left.\n            - 'steps' is equal to 'steps-pre' and is maintained for\n              backward-compatibility.\n\n            For examples see :doc:`/gallery/lines_bars_and_markers/step_demo`.\n        \"\"\"\n        if drawstyle is None:\n            drawstyle = 'default'\n        cbook._check_in_list(self.drawStyles, drawstyle=drawstyle)\n        if self._drawstyle != drawstyle:\n            self.stale = True\n            # invalidate to trigger a recache of the path\n            self._invalidx = True\n        self._drawstyle = drawstyle",
        "begin_line": 1052,
        "end_line": 1085,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015698587127158557,
            "pseudo_dstar_susp": 0.0009652509652509653,
            "pseudo_tarantula_susp": 0.001282051282051282,
            "pseudo_op2_susp": 0.0009652509652509653,
            "pseudo_barinel_susp": 0.001282051282051282
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_linewidth#1087",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_linewidth(self, w)",
        "snippet": "    def set_linewidth(self, w):\n        \"\"\"\n        Set the line width in points.\n\n        Parameters\n        ----------\n        w : float\n            Line width, in points.\n        \"\"\"\n        w = float(w)\n\n        if self._linewidth != w:\n            self.stale = True\n        self._linewidth = w\n        # rescale the dashes + offset\n        self._dashOffset, self._dashSeq = _scale_dashes(\n            self._us_dashOffset, self._us_dashSeq, self._linewidth)",
        "begin_line": 1087,
        "end_line": 1103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012484394506866417,
            "pseudo_dstar_susp": 0.002277904328018223,
            "pseudo_tarantula_susp": 0.001282051282051282,
            "pseudo_op2_susp": 0.002277904328018223,
            "pseudo_barinel_susp": 0.001282051282051282
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D._split_drawstyle_linestyle#1105",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D._split_drawstyle_linestyle(self, ls)",
        "snippet": "    def _split_drawstyle_linestyle(self, ls):\n        \"\"\"\n        Split drawstyle from linestyle string.\n\n        If *ls* is only a drawstyle default to returning a linestyle\n        of '-'.\n\n        Parameters\n        ----------\n        ls : str\n            The linestyle to be processed\n\n        Returns\n        -------\n        ret_ds : str or None\n            If the linestyle string does not contain a drawstyle prefix\n            return None, otherwise return it.\n\n        ls : str\n            The linestyle with the drawstyle (if any) stripped.\n        \"\"\"\n        for ds in self.drawStyleKeys:  # long names are first in the list\n            if ls.startswith(ds):\n                cbook.warn_deprecated(\n                    \"3.1\", message=\"Passing the drawstyle with the linestyle \"\n                    \"as a single string is deprecated since Matplotlib \"\n                    \"%(since)s and support will be removed %(removal)s; \"\n                    \"please pass the drawstyle separately using the drawstyle \"\n                    \"keyword argument to Line2D or set_drawstyle() method (or \"\n                    \"ds/set_ds()).\")\n                return ds, ls[len(ds):] or '-'\n        return None, ls",
        "begin_line": 1105,
        "end_line": 1136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012484394506866417,
            "pseudo_dstar_susp": 0.002277904328018223,
            "pseudo_tarantula_susp": 0.0012610340479192938,
            "pseudo_op2_susp": 0.002277904328018223,
            "pseudo_barinel_susp": 0.0012626262626262627
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_linestyle#1138",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_linestyle(self, ls)",
        "snippet": "    def set_linestyle(self, ls):\n        \"\"\"\n        Set the linestyle of the line.\n\n        Parameters\n        ----------\n        ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n            Possible values:\n\n            - A string:\n\n              ===============================   =================\n              Linestyle                         Description\n              ===============================   =================\n              ``'-'`` or ``'solid'``            solid line\n              ``'--'`` or  ``'dashed'``         dashed line\n              ``'-.'`` or  ``'dashdot'``        dash-dotted line\n              ``':'`` or ``'dotted'``           dotted line\n              ``'None'`` or ``' '`` or ``''``   draw nothing\n              ===============================   =================\n\n            - Alternatively a dash tuple of the following form can be\n              provided::\n\n                  (offset, onoffseq)\n\n              where ``onoffseq`` is an even length tuple of on and off ink\n              in points. See also :meth:`set_dashes`.\n\n            For examples see :doc:`/gallery/lines_bars_and_markers/linestyles`.\n        \"\"\"\n        if isinstance(ls, str):\n            ds, ls = self._split_drawstyle_linestyle(ls)\n            if ds is not None:\n                self.set_drawstyle(ds)\n\n            if ls in [' ', '', 'none']:\n                ls = 'None'\n\n            cbook._check_in_list([*self._lineStyles, *ls_mapper_r], ls=ls)\n            if ls not in self._lineStyles:\n                ls = ls_mapper_r[ls]\n            self._linestyle = ls\n        else:\n            self._linestyle = '--'\n\n        # get the unscaled dashes\n        self._us_dashOffset, self._us_dashSeq = _get_dash_pattern(ls)\n        # compute the linewidth scaled dashes\n        self._dashOffset, self._dashSeq = _scale_dashes(\n            self._us_dashOffset, self._us_dashSeq, self._linewidth)",
        "begin_line": 1138,
        "end_line": 1188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012224938875305623,
            "pseudo_dstar_susp": 0.0021929824561403508,
            "pseudo_tarantula_susp": 0.0012610340479192938,
            "pseudo_op2_susp": 0.0021929824561403508,
            "pseudo_barinel_susp": 0.0012626262626262627
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_marker#1191",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_marker(self, marker)",
        "snippet": "    def set_marker(self, marker):\n        \"\"\"\n        Set the line marker.\n\n        Parameters\n        ----------\n        marker : marker style string, `~.path.Path` or `~.markers.MarkerStyle`\n            See `~matplotlib.markers` for full description of possible\n            arguments.\n        \"\"\"\n        self._marker.set_marker(marker)\n        self.stale = True",
        "begin_line": 1191,
        "end_line": 1202,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011376564277588168,
            "pseudo_dstar_susp": 0.001953125,
            "pseudo_tarantula_susp": 0.0005112474437627812,
            "pseudo_op2_susp": 0.001953125,
            "pseudo_barinel_susp": 0.0005112474437627812
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_markeredgecolor#1204",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_markeredgecolor(self, ec)",
        "snippet": "    def set_markeredgecolor(self, ec):\n        \"\"\"\n        Set the marker edge color.\n\n        Parameters\n        ----------\n        ec : color\n        \"\"\"\n        if ec is None:\n            ec = 'auto'\n        if (self._markeredgecolor is None\n                or np.any(self._markeredgecolor != ec)):\n            self.stale = True\n        self._markeredgecolor = ec",
        "begin_line": 1204,
        "end_line": 1217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010141987829614604,
            "pseudo_dstar_susp": 0.0016638935108153079,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.0016638935108153079,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_markeredgewidth#1219",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_markeredgewidth(self, ew)",
        "snippet": "    def set_markeredgewidth(self, ew):\n        \"\"\"\n        Set the marker edge width in points.\n\n        Parameters\n        ----------\n        ew : float\n             Marker edge width, in points.\n        \"\"\"\n        if ew is None:\n            ew = rcParams['lines.markeredgewidth']\n        if self._markeredgewidth != ew:\n            self.stale = True\n        self._markeredgewidth = ew",
        "begin_line": 1219,
        "end_line": 1232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010141987829614604,
            "pseudo_dstar_susp": 0.0016638935108153079,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0016638935108153079,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_markerfacecolor#1234",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_markerfacecolor(self, fc)",
        "snippet": "    def set_markerfacecolor(self, fc):\n        \"\"\"\n        Set the marker face color.\n\n        Parameters\n        ----------\n        fc : color\n        \"\"\"\n        if fc is None:\n            fc = 'auto'\n        if np.any(self._markerfacecolor != fc):\n            self.stale = True\n        self._markerfacecolor = fc",
        "begin_line": 1234,
        "end_line": 1246,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010695187165775401,
            "pseudo_dstar_susp": 0.0017889087656529517,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.0017889087656529517,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_markerfacecoloralt#1248",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_markerfacecoloralt(self, fc)",
        "snippet": "    def set_markerfacecoloralt(self, fc):\n        \"\"\"\n        Set the alternate marker face color.\n\n        Parameters\n        ----------\n        fc : color\n        \"\"\"\n        if fc is None:\n            fc = 'auto'\n        if np.any(self._markerfacecoloralt != fc):\n            self.stale = True\n        self._markerfacecoloralt = fc",
        "begin_line": 1248,
        "end_line": 1260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010940919037199124,
            "pseudo_dstar_susp": 0.001838235294117647,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.001838235294117647,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_markersize#1262",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_markersize(self, sz)",
        "snippet": "    def set_markersize(self, sz):\n        \"\"\"\n        Set the marker size in points.\n\n        Parameters\n        ----------\n        sz : float\n             Marker size, in points.\n        \"\"\"\n        sz = float(sz)\n        if self._markersize != sz:\n            self.stale = True\n        self._markersize = sz",
        "begin_line": 1262,
        "end_line": 1274,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010695187165775401,
            "pseudo_dstar_susp": 0.0017889087656529517,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0017889087656529517,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_xdata#1276",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_xdata(self, x)",
        "snippet": "    def set_xdata(self, x):\n        \"\"\"\n        Set the data array for x.\n\n        Parameters\n        ----------\n        x : 1D array\n        \"\"\"\n        self._xorig = x\n        self._invalidx = True\n        self.stale = True",
        "begin_line": 1276,
        "end_line": 1286,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010695187165775401,
            "pseudo_dstar_susp": 0.0017889087656529517,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.0017889087656529517,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_ydata#1288",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_ydata(self, y)",
        "snippet": "    def set_ydata(self, y):\n        \"\"\"\n        Set the data array for y.\n\n        Parameters\n        ----------\n        y : 1D array\n        \"\"\"\n        self._yorig = y\n        self._invalidy = True\n        self.stale = True",
        "begin_line": 1288,
        "end_line": 1298,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011086474501108647,
            "pseudo_dstar_susp": 0.0018726591760299626,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.0018726591760299626,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.update_from#1321",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.update_from(self, other)",
        "snippet": "    def update_from(self, other):\n        \"\"\"Copy properties from *other* to self.\"\"\"\n        Artist.update_from(self, other)\n        self._linestyle = other._linestyle\n        self._linewidth = other._linewidth\n        self._color = other._color\n        self._markersize = other._markersize\n        self._markerfacecolor = other._markerfacecolor\n        self._markerfacecoloralt = other._markerfacecoloralt\n        self._markeredgecolor = other._markeredgecolor\n        self._markeredgewidth = other._markeredgewidth\n        self._dashSeq = other._dashSeq\n        self._us_dashSeq = other._us_dashSeq\n        self._dashOffset = other._dashOffset\n        self._us_dashOffset = other._us_dashOffset\n        self._dashcapstyle = other._dashcapstyle\n        self._dashjoinstyle = other._dashjoinstyle\n        self._solidcapstyle = other._solidcapstyle\n        self._solidjoinstyle = other._solidjoinstyle\n\n        self._linestyle = other._linestyle\n        self._marker = MarkerStyle(other._marker.get_marker(),\n                                   other._marker.get_fillstyle())\n        self._drawstyle = other._drawstyle",
        "begin_line": 1321,
        "end_line": 1344,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00037778617302606723,
            "pseudo_dstar_susp": 0.00034916201117318437,
            "pseudo_tarantula_susp": 0.0007358351729212656,
            "pseudo_op2_susp": 0.00034916201117318437,
            "pseudo_barinel_susp": 0.0007358351729212656
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_dash_joinstyle#1346",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_dash_joinstyle(self, s)",
        "snippet": "    def set_dash_joinstyle(self, s):\n        \"\"\"\n        Set the join style for dashed lines.\n\n        Parameters\n        ----------\n        s : {'miter', 'round', 'bevel'}\n            For examples see :doc:`/gallery/lines_bars_and_markers/joinstyle`.\n        \"\"\"\n        s = mpl.rcsetup._deprecate_case_insensitive_join_cap(s)\n        cbook._check_in_list(self.validJoin, s=s)\n        if self._dashjoinstyle != s:\n            self.stale = True\n        self._dashjoinstyle = s",
        "begin_line": 1346,
        "end_line": 1359,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009099181073703367,
            "pseudo_dstar_susp": 0.0008613264427217916,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0008613264427217916,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_solid_joinstyle#1361",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_solid_joinstyle(self, s)",
        "snippet": "    def set_solid_joinstyle(self, s):\n        \"\"\"\n        Set the join style for solid lines.\n\n        Parameters\n        ----------\n        s : {'miter', 'round', 'bevel'}\n            For examples see :doc:`/gallery/lines_bars_and_markers/joinstyle`.\n        \"\"\"\n        s = mpl.rcsetup._deprecate_case_insensitive_join_cap(s)\n        cbook._check_in_list(self.validJoin, s=s)\n        if self._solidjoinstyle != s:\n            self.stale = True\n        self._solidjoinstyle = s",
        "begin_line": 1361,
        "end_line": 1374,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009066183136899365,
            "pseudo_dstar_susp": 0.0008583690987124463,
            "pseudo_tarantula_susp": 0.0007027406886858749,
            "pseudo_op2_susp": 0.0008583690987124463,
            "pseudo_barinel_susp": 0.0007027406886858749
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_dash_joinstyle#1376",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_dash_joinstyle(self)",
        "snippet": "    def get_dash_joinstyle(self):\n        \"\"\"\n        Return the join style for dashed lines.\n\n        See also `~.Line2D.set_dash_joinstyle`.\n        \"\"\"\n        return self._dashjoinstyle",
        "begin_line": 1376,
        "end_line": 1382,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_dash_capstyle#1392",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_dash_capstyle(self, s)",
        "snippet": "    def set_dash_capstyle(self, s):\n        \"\"\"\n        Set the cap style for dashed lines.\n\n        Parameters\n        ----------\n        s : {'butt', 'round', 'projecting'}\n            For examples see :doc:`/gallery/lines_bars_and_markers/joinstyle`.\n        \"\"\"\n        s = mpl.rcsetup._deprecate_case_insensitive_join_cap(s)\n        cbook._check_in_list(self.validCap, s=s)\n        if self._dashcapstyle != s:\n            self.stale = True\n        self._dashcapstyle = s",
        "begin_line": 1392,
        "end_line": 1405,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012953367875647669,
            "pseudo_dstar_susp": 0.0023752969121140144,
            "pseudo_tarantula_susp": 0.0007027406886858749,
            "pseudo_op2_susp": 0.0023752969121140144,
            "pseudo_barinel_susp": 0.0007027406886858749
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.set_solid_capstyle#1407",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.set_solid_capstyle(self, s)",
        "snippet": "    def set_solid_capstyle(self, s):\n        \"\"\"\n        Set the cap style for solid lines.\n\n        Parameters\n        ----------\n        s : {'butt', 'round', 'projecting'}\n            For examples see :doc:`/gallery/lines_bars_and_markers/joinstyle`.\n        \"\"\"\n        s = mpl.rcsetup._deprecate_case_insensitive_join_cap(s)\n        cbook._check_in_list(self.validCap, s=s)\n        if self._solidcapstyle != s:\n            self.stale = True\n        self._solidcapstyle = s",
        "begin_line": 1407,
        "end_line": 1420,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012224938875305623,
            "pseudo_dstar_susp": 0.0021929824561403508,
            "pseudo_tarantula_susp": 0.001282051282051282,
            "pseudo_op2_susp": 0.0021929824561403508,
            "pseudo_barinel_susp": 0.001282051282051282
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_dash_capstyle#1422",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_dash_capstyle(self)",
        "snippet": "    def get_dash_capstyle(self):\n        \"\"\"\n        Return the cap style for dashed lines.\n\n        See also `~.Line2D.set_dash_capstyle`.\n        \"\"\"\n        return self._dashcapstyle",
        "begin_line": 1422,
        "end_line": 1428,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.get_solid_capstyle#1430",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.get_solid_capstyle(self)",
        "snippet": "    def get_solid_capstyle(self):\n        \"\"\"\n        Return the cap style for solid lines.\n\n        See also `~.Line2D.set_solid_capstyle`.\n        \"\"\"\n        return self._solidcapstyle",
        "begin_line": 1430,
        "end_line": 1436,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.lines.Line2D.is_dashed#1438",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines.Line2D",
        "signature": "lib.matplotlib.lines.Line2D.is_dashed(self)",
        "snippet": "    def is_dashed(self):\n        \"\"\"\n        Return whether line has a dashed linestyle.\n\n        See also `~.Line2D.set_linestyle`.\n        \"\"\"\n        return self._linestyle in ('--', '-.', ':')",
        "begin_line": 1438,
        "end_line": 1444,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003036744609778318,
            "pseudo_dstar_susp": 0.0003020235578375113,
            "pseudo_tarantula_susp": 0.0003198976327575176,
            "pseudo_op2_susp": 0.0003020235578375113,
            "pseudo_barinel_susp": 0.0003198976327575176
        }
    },
    {
        "name": "lib.matplotlib.lines._AxLine.get_transform#1453",
        "src_path": "lib/matplotlib/lines.py",
        "class_name": "lib.matplotlib.lines._AxLine",
        "signature": "lib.matplotlib.lines._AxLine.get_transform(self)",
        "snippet": "    def get_transform(self):\n        ax = self.axes\n        (x1, y1), (x2, y2) = ax.transScale.transform([*zip(*self.get_data())])\n        dx = x2 - x1\n        dy = y2 - y1\n        if np.allclose(x1, x2):\n            if np.allclose(y1, y2):\n                raise ValueError(\n                    f\"Cannot draw a line through two identical points \"\n                    f\"(x={self.get_xdata()}, y={self.get_ydata()})\")\n            # First send y1 to 0 and y2 to 1.\n            return (Affine2D.from_values(1, 0, 0, 1 / dy, 0, -y1 / dy)\n                    + ax.get_xaxis_transform(which=\"grid\"))\n        if np.allclose(y1, y2):\n            # First send x1 to 0 and x2 to 1.\n            return (Affine2D.from_values(1 / dx, 0, 0, 1, -x1 / dx, 0)\n                    + ax.get_yaxis_transform(which=\"grid\"))\n        (vxlo, vylo), (vxhi, vyhi) = ax.transScale.transform(ax.viewLim)\n        # General case: find intersections with view limits in either\n        # direction, and draw between the middle two points.\n        _, start, stop, _ = sorted([\n            (vxlo, y1 + (vxlo - x1) * dy / dx),\n            (vxhi, y1 + (vxhi - x1) * dy / dx),\n            (x1 + (vylo - y1) * dx / dy, vylo),\n            (x1 + (vyhi - y1) * dx / dy, vyhi),\n        ])\n        return (BboxTransformFrom(Bbox([*zip(*self.get_data())]))\n                + BboxTransformTo(Bbox([start, stop]))\n                + ax.transLimits + ax.transAxes)",
        "begin_line": 1453,
        "end_line": 1481,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.__init__#42",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.__init__(self, edgecolor=None, facecolor=None, color=None, linewidth=None, linestyle=None, antialiased=None, hatch=None, fill=True, capstyle=None, joinstyle=None, **kwargs)",
        "snippet": "    def __init__(self,\n                 edgecolor=None,\n                 facecolor=None,\n                 color=None,\n                 linewidth=None,\n                 linestyle=None,\n                 antialiased=None,\n                 hatch=None,\n                 fill=True,\n                 capstyle=None,\n                 joinstyle=None,\n                 **kwargs):\n        \"\"\"\n        The following kwarg properties are supported\n\n        %(Patch)s\n        \"\"\"\n        artist.Artist.__init__(self)\n\n        if linewidth is None:\n            linewidth = mpl.rcParams['patch.linewidth']\n        if linestyle is None:\n            linestyle = \"solid\"\n        if capstyle is None:\n            capstyle = 'butt'\n        if joinstyle is None:\n            joinstyle = 'miter'\n        if antialiased is None:\n            antialiased = mpl.rcParams['patch.antialiased']\n\n        self._hatch_color = colors.to_rgba(mpl.rcParams['hatch.color'])\n        self._fill = True  # needed for set_facecolor call\n        if color is not None:\n            if edgecolor is not None or facecolor is not None:\n                cbook._warn_external(\n                    \"Setting the 'color' property will override \"\n                    \"the edgecolor or facecolor properties.\")\n            self.set_color(color)\n        else:\n            self.set_edgecolor(edgecolor)\n            self.set_facecolor(facecolor)\n        # unscaled dashes.  Needed to scale dash patterns by lw\n        self._us_dashes = None\n        self._linewidth = 0\n\n        self.set_fill(fill)\n        self.set_linestyle(linestyle)\n        self.set_linewidth(linewidth)\n        self.set_antialiased(antialiased)\n        self.set_hatch(hatch)\n        self.set_capstyle(capstyle)\n        self.set_joinstyle(joinstyle)\n\n        if len(kwargs):\n            self.update(kwargs)",
        "begin_line": 42,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.539709649871905e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch._process_radius#112",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch._process_radius(self, radius)",
        "snippet": "    def _process_radius(self, radius):\n        if radius is not None:\n            return radius\n        if isinstance(self._picker, Number):\n            _radius = self._picker\n        else:\n            if self.get_edgecolor()[3] == 0:\n                _radius = 0\n            else:\n                _radius = self.get_linewidth()\n        return _radius",
        "begin_line": 112,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.update_from#233",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.update_from(self, other)",
        "snippet": "    def update_from(self, other):\n        # docstring inherited.\n        artist.Artist.update_from(self, other)\n        # For some properties we don't need or don't want to go through the\n        # getters/setters, so we just copy them directly.\n        self._edgecolor = other._edgecolor\n        self._facecolor = other._facecolor\n        self._original_edgecolor = other._original_edgecolor\n        self._original_facecolor = other._original_facecolor\n        self._fill = other._fill\n        self._hatch = other._hatch\n        self._hatch_color = other._hatch_color\n        # copy the unscaled dash pattern\n        self._us_dashes = other._us_dashes\n        self.set_linewidth(other._linewidth)  # also sets dash properties\n        self.set_transform(other.get_data_transform())\n        # If the transform of other needs further initialization, then it will\n        # be the case for this artist too.\n        self._transformSet = other.is_transform_set()",
        "begin_line": 233,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.get_transform#259",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.get_transform(self)",
        "snippet": "    def get_transform(self):\n        \"\"\"Return the `~.transforms.Transform` applied to the `Patch`.\"\"\"\n        return self.get_patch_transform() + artist.Artist.get_transform(self)",
        "begin_line": 259,
        "end_line": 261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001851851851851852,
            "pseudo_dstar_susp": 0.0010131712259371835,
            "pseudo_tarantula_susp": 0.0007267441860465116,
            "pseudo_op2_susp": 0.0010131712259371835,
            "pseudo_barinel_susp": 0.0007267441860465116
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.get_data_transform#263",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.get_data_transform(self)",
        "snippet": "    def get_data_transform(self):\n        \"\"\"\n        Return the `~.transforms.Transform` mapping data coordinates to\n        physical coordinates.\n        \"\"\"\n        return artist.Artist.get_transform(self)",
        "begin_line": 263,
        "end_line": 268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.get_edgecolor#285",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.get_edgecolor(self)",
        "snippet": "    def get_edgecolor(self):\n        \"\"\"Return the edge color.\"\"\"\n        return self._edgecolor",
        "begin_line": 285,
        "end_line": 287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.get_facecolor#289",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.get_facecolor(self)",
        "snippet": "    def get_facecolor(self):\n        \"\"\"Return the face color.\"\"\"\n        return self._facecolor",
        "begin_line": 289,
        "end_line": 291,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_antialiased#301",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_antialiased(self, aa)",
        "snippet": "    def set_antialiased(self, aa):\n        \"\"\"\n        Set whether to use antialiased rendering.\n\n        Parameters\n        ----------\n        b : bool or None\n        \"\"\"\n        if aa is None:\n            aa = mpl.rcParams['patch.antialiased']\n        self._antialiased = aa\n        self.stale = True",
        "begin_line": 301,
        "end_line": 312,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch._set_edgecolor#314",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch._set_edgecolor(self, color)",
        "snippet": "    def _set_edgecolor(self, color):\n        set_hatch_color = True\n        if color is None:\n            if (mpl.rcParams['patch.force_edgecolor'] or\n                    not self._fill or self._edge_default):\n                color = mpl.rcParams['patch.edgecolor']\n            else:\n                color = 'none'\n                set_hatch_color = False\n\n        self._edgecolor = colors.to_rgba(color, self._alpha)\n        if set_hatch_color:\n            self._hatch_color = self._edgecolor\n        self.stale = True",
        "begin_line": 314,
        "end_line": 327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_edgecolor#329",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_edgecolor(self, color)",
        "snippet": "    def set_edgecolor(self, color):\n        \"\"\"\n        Set the patch edge color.\n\n        Parameters\n        ----------\n        color : color or None or 'auto'\n        \"\"\"\n        self._original_edgecolor = color\n        self._set_edgecolor(color)",
        "begin_line": 329,
        "end_line": 338,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_facecolor#347",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_facecolor(self, color)",
        "snippet": "    def set_facecolor(self, color):\n        \"\"\"\n        Set the patch face color.\n\n        Parameters\n        ----------\n        color : color or None\n        \"\"\"\n        self._original_facecolor = color\n        self._set_facecolor(color)",
        "begin_line": 347,
        "end_line": 356,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_alpha#374",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_alpha(self, alpha)",
        "snippet": "    def set_alpha(self, alpha):\n        # docstring inherited\n        super().set_alpha(alpha)\n        self._set_facecolor(self._original_facecolor)\n        self._set_edgecolor(self._original_edgecolor)",
        "begin_line": 374,
        "end_line": 378,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_linewidth#381",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_linewidth(self, w)",
        "snippet": "    def set_linewidth(self, w):\n        \"\"\"\n        Set the patch linewidth in points.\n\n        Parameters\n        ----------\n        w : float or None\n        \"\"\"\n        if w is None:\n            w = mpl.rcParams['patch.linewidth']\n            if w is None:\n                w = mpl.rcParams['axes.linewidth']\n\n        self._linewidth = float(w)\n        # scale the dash pattern by the linewidth\n        offset, ls = self._us_dashes\n        self._dashoffset, self._dashes = mlines._scale_dashes(\n            offset, ls, self._linewidth)\n        self.stale = True",
        "begin_line": 381,
        "end_line": 399,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_linestyle#401",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_linestyle(self, ls)",
        "snippet": "    def set_linestyle(self, ls):\n        \"\"\"\n        Set the patch linestyle.\n\n        ===========================   =================\n        linestyle                     description\n        ===========================   =================\n        ``'-'`` or ``'solid'``        solid line\n        ``'--'`` or  ``'dashed'``     dashed line\n        ``'-.'`` or  ``'dashdot'``    dash-dotted line\n        ``':'`` or ``'dotted'``       dotted line\n        ===========================   =================\n\n        Alternatively a dash tuple of the following form can be provided::\n\n            (offset, onoffseq)\n\n        where ``onoffseq`` is an even length tuple of on and off ink in points.\n\n        Parameters\n        ----------\n        ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n            The line style.\n        \"\"\"\n        if ls is None:\n            ls = \"solid\"\n        self._linestyle = ls\n        # get the unscaled dash pattern\n        offset, ls = self._us_dashes = mlines._get_dash_pattern(ls)\n        # scale the dash pattern by the linewidth\n        self._dashoffset, self._dashes = mlines._scale_dashes(\n            offset, ls, self._linewidth)\n        self.stale = True",
        "begin_line": 401,
        "end_line": 433,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.28332714444857e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_fill#435",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_fill(self, b)",
        "snippet": "    def set_fill(self, b):\n        \"\"\"\n        Set whether to fill the patch.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._fill = bool(b)\n        self._set_facecolor(self._original_facecolor)\n        self._set_edgecolor(self._original_edgecolor)\n        self.stale = True",
        "begin_line": 435,
        "end_line": 446,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_capstyle#457",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_capstyle(self, s)",
        "snippet": "    def set_capstyle(self, s):\n        \"\"\"\n        Set the capstyle.\n\n        Parameters\n        ----------\n        s : {'butt', 'round', 'projecting'}\n        \"\"\"\n        s = mpl.rcsetup._deprecate_case_insensitive_join_cap(s)\n        cbook._check_in_list(self.validCap, capstyle=s)\n        self._capstyle = s\n        self.stale = True",
        "begin_line": 457,
        "end_line": 468,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.28332714444857e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_joinstyle#474",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_joinstyle(self, s)",
        "snippet": "    def set_joinstyle(self, s):\n        \"\"\"Set the joinstyle.\n\n        Parameters\n        ----------\n        s : {'miter', 'round', 'bevel'}\n        \"\"\"\n        s = mpl.rcsetup._deprecate_case_insensitive_join_cap(s)\n        cbook._check_in_list(self.validJoin, joinstyle=s)\n        self._joinstyle = s\n        self.stale = True",
        "begin_line": 474,
        "end_line": 484,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.set_hatch#490",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.set_hatch(self, hatch)",
        "snippet": "    def set_hatch(self, hatch):\n        r\"\"\"\n        Set the hatching pattern.\n\n        *hatch* can be one of::\n\n          /   - diagonal hatching\n          \\   - back diagonal\n          |   - vertical\n          -   - horizontal\n          +   - crossed\n          x   - crossed diagonal\n          o   - small circle\n          O   - large circle\n          .   - dots\n          *   - stars\n\n        Letters can be combined, in which case all the specified\n        hatchings are done.  If same letter repeats, it increases the\n        density of hatching of that pattern.\n\n        Hatching is supported in the PostScript, PDF, SVG and Agg\n        backends only.\n\n        Parameters\n        ----------\n        hatch : {'/', '\\\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}\n        \"\"\"\n        self._hatch = hatch\n        self.stale = True",
        "begin_line": 490,
        "end_line": 519,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch._bind_draw_path_function#526",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch._bind_draw_path_function(self, renderer)",
        "snippet": "    def _bind_draw_path_function(self, renderer):\n        \"\"\"\n        ``draw()`` helper factored out for sharing with `FancyArrowPatch`.\n\n        Yields a callable ``dp`` such that calling ``dp(*args, **kwargs)`` is\n        equivalent to calling ``renderer1.draw_path(gc, *args, **kwargs)``\n        where ``renderer1`` and ``gc`` have been suitably set from ``renderer``\n        and the artist's properties.\n        \"\"\"\n\n        renderer.open_group('patch', self.get_gid())\n        gc = renderer.new_gc()\n\n        gc.set_foreground(self._edgecolor, isRGBA=True)\n\n        lw = self._linewidth\n        if self._edgecolor[3] == 0:\n            lw = 0\n        gc.set_linewidth(lw)\n        gc.set_dashes(self._dashoffset, self._dashes)\n        gc.set_capstyle(self._capstyle)\n        gc.set_joinstyle(self._joinstyle)\n\n        gc.set_antialiased(self._antialiased)\n        self._set_gc_clip(gc)\n        gc.set_url(self._url)\n        gc.set_snap(self.get_snap())\n\n        gc.set_alpha(self._alpha)\n\n        if self._hatch:\n            gc.set_hatch(self._hatch)\n            try:\n                gc.set_hatch_color(self._hatch_color)\n            except AttributeError:\n                # if we end up with a GC that does not have this method\n                cbook.warn_deprecated(\n                    \"3.1\", message=\"Your backend does not support setting the \"\n                    \"hatch color; such backends will become unsupported in \"\n                    \"Matplotlib 3.3.\")\n\n        if self.get_sketch_params() is not None:\n            gc.set_sketch_params(*self.get_sketch_params())\n\n        if self.get_path_effects():\n            from matplotlib.patheffects import PathEffectRenderer\n            renderer = PathEffectRenderer(self.get_path_effects(), renderer)\n\n        # In `with _bind_draw_path_function(renderer) as draw_path: ...`\n        # (in the implementations of `draw()` below), calls to `draw_path(...)`\n        # will occur as if they took place here with `gc` inserted as\n        # additional first argument.\n        yield functools.partial(renderer.draw_path, gc)\n\n        gc.restore()\n        renderer.close_group('patch')\n        self.stale = False",
        "begin_line": 526,
        "end_line": 582,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.draw#585",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        # docstring inherited\n        if not self.get_visible():\n            return\n        # Patch has traditionally ignored the dashoffset.\n        with cbook._setattr_cm(self, _dashoffset=0), \\\n                self._bind_draw_path_function(renderer) as draw_path:\n            path = self.get_path()\n            transform = self.get_transform()\n            tpath = transform.transform_path_non_affine(path)\n            affine = transform.get_affine()\n            draw_path(tpath, affine,\n                      # Work around a bug in the PDF and SVG renderers, which\n                      # do not draw the hatches if the facecolor is fully\n                      # transparent, but do if it is None.\n                      self._facecolor if self._facecolor[3] else None)",
        "begin_line": 585,
        "end_line": 600,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.925814377427281e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch.get_window_extent#606",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch.get_window_extent(self, renderer=None)",
        "snippet": "    def get_window_extent(self, renderer=None):\n        return self.get_path().get_extents(self.get_transform())",
        "begin_line": 606,
        "end_line": 607,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.61994655633135e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Patch._convert_xy_units#609",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Patch",
        "signature": "lib.matplotlib.patches.Patch._convert_xy_units(self, xy)",
        "snippet": "    def _convert_xy_units(self, xy):\n        \"\"\"Convert x and y units for a tuple (x, y).\"\"\"\n        x = self.convert_xunits(xy[0])\n        y = self.convert_yunits(xy[1])\n        return x, y",
        "begin_line": 609,
        "end_line": 613,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Rectangle.__init__#703",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Rectangle",
        "signature": "lib.matplotlib.patches.Rectangle.__init__(self, xy, width, height, angle=0.0, **kwargs)",
        "snippet": "    def __init__(self, xy, width, height, angle=0.0, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        xy : (float, float)\n            The bottom and left rectangle coordinates\n        width : float\n            Rectangle width\n        height : float\n            Rectangle height\n        angle : float, default: 0\n            Rotation in degrees anti-clockwise about *xy*.\n        fill : bool, default: True\n            Whether to fill the rectangle.\n\n        Notes\n        -----\n        Valid keyword arguments are:\n\n        %(Patch)s\n        \"\"\"\n\n        Patch.__init__(self, **kwargs)\n\n        self._x0 = xy[0]\n        self._y0 = xy[1]\n\n        self._width = width\n        self._height = height\n\n        self._x1 = self._x0 + self._width\n        self._y1 = self._y0 + self._height\n\n        self.angle = float(angle)\n        # Note: This cannot be calculated until this is added to an Axes\n        self._rect_transform = transforms.IdentityTransform()",
        "begin_line": 703,
        "end_line": 738,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.999000099990002e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Rectangle.get_path#740",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Rectangle",
        "signature": "lib.matplotlib.patches.Rectangle.get_path(self)",
        "snippet": "    def get_path(self):\n        \"\"\"Return the vertices of the rectangle.\"\"\"\n        return Path.unit_rectangle()",
        "begin_line": 740,
        "end_line": 742,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005243838489774515,
            "pseudo_dstar_susp": 0.000499001996007984,
            "pseudo_tarantula_susp": 0.002,
            "pseudo_op2_susp": 0.000499001996007984,
            "pseudo_barinel_susp": 0.002
        }
    },
    {
        "name": "lib.matplotlib.patches.Rectangle._update_patch_transform#744",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Rectangle",
        "signature": "lib.matplotlib.patches.Rectangle._update_patch_transform(self)",
        "snippet": "    def _update_patch_transform(self):\n        \"\"\"\n        Notes\n        -----\n        This cannot be called until after this has been added to an Axes,\n        otherwise unit conversion will fail. This makes it very important to\n        call the accessor method and not directly access the transformation\n        member variable.\n        \"\"\"\n        x0, y0, x1, y1 = self._convert_units()\n        bbox = transforms.Bbox.from_extents(x0, y0, x1, y1)\n        rot_trans = transforms.Affine2D()\n        rot_trans.rotate_deg_around(x0, y0, self.angle)\n        self._rect_transform = transforms.BboxTransformTo(bbox)\n        self._rect_transform += rot_trans",
        "begin_line": 744,
        "end_line": 758,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006361323155216285,
            "pseudo_dstar_susp": 0.0008136696501220504,
            "pseudo_tarantula_susp": 0.0003952569169960474,
            "pseudo_op2_susp": 0.0008136696501220504,
            "pseudo_barinel_susp": 0.0003952569169960474
        }
    },
    {
        "name": "lib.matplotlib.patches.Rectangle._convert_units#766",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Rectangle",
        "signature": "lib.matplotlib.patches.Rectangle._convert_units(self)",
        "snippet": "    def _convert_units(self):\n        \"\"\"Convert bounds of the rectangle.\"\"\"\n        x0 = self.convert_xunits(self._x0)\n        y0 = self.convert_yunits(self._y0)\n        x1 = self.convert_xunits(self._x1)\n        y1 = self.convert_yunits(self._y1)\n        return x0, y0, x1, y1",
        "begin_line": 766,
        "end_line": 772,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006934812760055479,
            "pseudo_dstar_susp": 0.0008230452674897119,
            "pseudo_tarantula_susp": 0.00040112314480545525,
            "pseudo_op2_susp": 0.0008230452674897119,
            "pseudo_barinel_susp": 0.00040112314480545525
        }
    },
    {
        "name": "lib.matplotlib.patches.Rectangle.get_patch_transform#774",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Rectangle",
        "signature": "lib.matplotlib.patches.Rectangle.get_patch_transform(self)",
        "snippet": "    def get_patch_transform(self):\n        self._update_patch_transform()\n        return self._rect_transform",
        "begin_line": 774,
        "end_line": 776,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Rectangle.get_y#782",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Rectangle",
        "signature": "lib.matplotlib.patches.Rectangle.get_y(self)",
        "snippet": "    def get_y(self):\n        \"\"\"Return the bottom coordinate of the rectangle.\"\"\"\n        return self._y0",
        "begin_line": 782,
        "end_line": 784,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Rectangle.get_width#790",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Rectangle",
        "signature": "lib.matplotlib.patches.Rectangle.get_width(self)",
        "snippet": "    def get_width(self):\n        \"\"\"Return the width of the rectangle.\"\"\"\n        return self._width",
        "begin_line": 790,
        "end_line": 792,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005243838489774515,
            "pseudo_dstar_susp": 0.00041203131437989287,
            "pseudo_tarantula_susp": 0.002,
            "pseudo_op2_susp": 0.00041203131437989287,
            "pseudo_barinel_susp": 0.002
        }
    },
    {
        "name": "lib.matplotlib.patches.Rectangle.set_x#798",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Rectangle",
        "signature": "lib.matplotlib.patches.Rectangle.set_x(self, x)",
        "snippet": "    def set_x(self, x):\n        \"\"\"Set the left coordinate of the rectangle.\"\"\"\n        self._x0 = x\n        self._update_x1()\n        self.stale = True",
        "begin_line": 798,
        "end_line": 802,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Rectangle.set_height#829",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Rectangle",
        "signature": "lib.matplotlib.patches.Rectangle.set_height(self, h)",
        "snippet": "    def set_height(self, h):\n        \"\"\"Set the height of the rectangle.\"\"\"\n        self._height = h\n        self._update_y1()\n        self.stale = True",
        "begin_line": 829,
        "end_line": 833,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.RegularPolygon.__init__#875",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.RegularPolygon",
        "signature": "lib.matplotlib.patches.RegularPolygon.__init__(self, xy, numVertices, radius=5, orientation=0, **kwargs)",
        "snippet": "    def __init__(self, xy, numVertices, radius=5, orientation=0,\n                 **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        xy : (float, float)\n            The center position.\n\n        numVertices : int\n            The number of vertices.\n\n        radius : float\n            The distance from the center to each of the vertices.\n\n        orientation : float\n            The polygon rotation angle (in radians).\n\n        **kwargs\n            `Patch` properties:\n\n            %(Patch)s\n        \"\"\"\n        self._xy = xy\n        self._numVertices = numVertices\n        self._orientation = orientation\n        self._radius = radius\n        self._path = Path.unit_regular_polygon(numVertices)\n        self._poly_transform = transforms.Affine2D()\n        self._update_transform()\n\n        Patch.__init__(self, **kwargs)",
        "begin_line": 875,
        "end_line": 905,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.RegularPolygon._update_transform#907",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.RegularPolygon",
        "signature": "lib.matplotlib.patches.RegularPolygon._update_transform(self)",
        "snippet": "    def _update_transform(self):\n        self._poly_transform.clear() \\\n            .scale(self.radius) \\\n            .rotate(self.orientation) \\\n            .translate(*self.xy)",
        "begin_line": 907,
        "end_line": 911,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.PathPatch.__init__#966",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.PathPatch",
        "signature": "lib.matplotlib.patches.PathPatch.__init__(self, path, **kwargs)",
        "snippet": "    def __init__(self, path, **kwargs):\n        \"\"\"\n        *path* is a `~.path.Path` object.\n\n        Valid keyword arguments are:\n\n        %(Patch)s\n        \"\"\"\n        Patch.__init__(self, **kwargs)\n        self._path = path",
        "begin_line": 966,
        "end_line": 975,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Polygon.__str__#987",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Polygon",
        "signature": "lib.matplotlib.patches.Polygon.__str__(self)",
        "snippet": "    def __str__(self):\n        s = \"Polygon%d((%g, %g) ...)\"\n        return s % (len(self._path.vertices), *tuple(self._path.vertices[0]))",
        "begin_line": 987,
        "end_line": 989,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Polygon.get_path#1007",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Polygon",
        "signature": "lib.matplotlib.patches.Polygon.get_path(self)",
        "snippet": "    def get_path(self):\n        \"\"\"\n        Get the path of the polygon\n\n        Returns\n        -------\n        path : Path\n           The `~.path.Path` object for the polygon.\n        \"\"\"\n        return self._path",
        "begin_line": 1007,
        "end_line": 1016,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge._recompute_path#1108",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge._recompute_path(self)",
        "snippet": "    def _recompute_path(self):\n        # Inner and outer rings are connected unless the annulus is complete\n        if abs((self.theta2 - self.theta1) - 360) <= 1e-12:\n            theta1, theta2 = 0, 360\n            connector = Path.MOVETO\n        else:\n            theta1, theta2 = self.theta1, self.theta2\n            connector = Path.LINETO\n\n        # Form the outer ring\n        arc = Path.arc(theta1, theta2)\n\n        if self.width is not None:\n            # Partial annulus needs to draw the outer ring\n            # followed by a reversed and scaled inner ring\n            v1 = arc.vertices\n            v2 = arc.vertices[::-1] * (self.r - self.width) / self.r\n            v = np.vstack([v1, v2, v1[0, :], (0, 0)])\n            c = np.hstack([arc.codes, arc.codes, connector, Path.CLOSEPOLY])\n            c[len(arc.codes)] = connector\n        else:\n            # Wedge doesn't need an inner ring\n            v = np.vstack([arc.vertices, [(0, 0), arc.vertices[0, :], (0, 0)]])\n            c = np.hstack([arc.codes, [connector, connector, Path.CLOSEPOLY]])\n\n        # Shift and scale the wedge to the final location.\n        v *= self.r\n        v += np.asarray(self.center)\n        self._path = Path(v, c)",
        "begin_line": 1108,
        "end_line": 1136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge.set_center#1138",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge.set_center(self, center)",
        "snippet": "    def set_center(self, center):\n        self._path = None\n        self.center = center\n        self.stale = True",
        "begin_line": 1138,
        "end_line": 1141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.104980424292088e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge.set_theta1#1148",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge.set_theta1(self, theta1)",
        "snippet": "    def set_theta1(self, theta1):\n        self._path = None\n        self.theta1 = theta1\n        self.stale = True",
        "begin_line": 1148,
        "end_line": 1151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge.set_width#1158",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge.set_width(self, width)",
        "snippet": "    def set_width(self, width):\n        self._path = None\n        self.width = width\n        self.stale = True",
        "begin_line": 1158,
        "end_line": 1161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.104980424292088e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge.get_path#1163",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge.get_path(self)",
        "snippet": "    def get_path(self):\n        if self._path is None:\n            self._recompute_path()\n        return self._path",
        "begin_line": 1163,
        "end_line": 1166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005988023952095808,
            "pseudo_dstar_susp": 0.0004233700254022015,
            "pseudo_tarantula_susp": 0.0024813895781637717,
            "pseudo_op2_susp": 0.0004233700254022015,
            "pseudo_barinel_susp": 0.0024813895781637717
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrow.__init__#1238",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrow",
        "signature": "lib.matplotlib.patches.FancyArrow.__init__(self, x, y, dx, dy, width=0.001, length_includes_head=False, head_width=None, head_length=None, shape='full', overhang=0, head_starts_at_zero=False, **kwargs)",
        "snippet": "    def __init__(self, x, y, dx, dy, width=0.001, length_includes_head=False,\n                 head_width=None, head_length=None, shape='full', overhang=0,\n                 head_starts_at_zero=False, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        width: float, default: 0.001\n            Width of full arrow tail.\n\n        length_includes_head: bool, default: False\n            True if head is to be counted in calculating the length.\n\n        head_width: float or None, default: 3*width\n            Total width of the full arrow head.\n\n        head_length: float or None, default: 1.5*head_width\n            Length of arrow head.\n\n        shape: ['full', 'left', 'right'], default: 'full'\n            Draw the left-half, right-half, or full arrow.\n\n        overhang: float, default: 0\n            Fraction that the arrow is swept back (0 overhang means\n            triangular shape). Can be negative or greater than one.\n\n        head_starts_at_zero: bool, default: False\n            If True, the head starts being drawn at coordinate 0\n            instead of ending at coordinate 0.\n\n        **kwargs\n            `.Patch` properties:\n\n            %(Patch)s\n        \"\"\"\n        if head_width is None:\n            head_width = 3 * width\n        if head_length is None:\n            head_length = 1.5 * head_width\n\n        distance = np.hypot(dx, dy)\n\n        if length_includes_head:\n            length = distance\n        else:\n            length = distance + head_length\n        if not length:\n            verts = np.empty([0, 2])  # display nothing if empty\n        else:\n            # start by drawing horizontal arrow, point at (0, 0)\n            hw, hl, hs, lw = head_width, head_length, overhang, width\n            left_half_arrow = np.array([\n                [0.0, 0.0],                 # tip\n                [-hl, -hw / 2],             # leftmost\n                [-hl * (1 - hs), -lw / 2],  # meets stem\n                [-length, -lw / 2],         # bottom left\n                [-length, 0],\n            ])\n            # if we're not including the head, shift up by head length\n            if not length_includes_head:\n                left_half_arrow += [head_length, 0]\n            # if the head starts at 0, shift up by another head length\n            if head_starts_at_zero:\n                left_half_arrow += [head_length / 2, 0]\n            # figure out the shape, and complete accordingly\n            if shape == 'left':\n                coords = left_half_arrow\n            else:\n                right_half_arrow = left_half_arrow * [1, -1]\n                if shape == 'right':\n                    coords = right_half_arrow\n                elif shape == 'full':\n                    # The half-arrows contain the midpoint of the stem,\n                    # which we can omit from the full arrow. Including it\n                    # twice caused a problem with xpdf.\n                    coords = np.concatenate([left_half_arrow[:-1],\n                                             right_half_arrow[-2::-1]])\n                else:\n                    raise ValueError(\"Got unknown shape: %s\" % shape)\n            if distance != 0:\n                cx = dx / distance\n                sx = dy / distance\n            else:\n                # Account for division by zero\n                cx, sx = 0, 1\n            M = [[cx, sx], [-sx, cx]]\n            verts = np.dot(coords, M) + (x + dx, y + dy)\n\n        super().__init__(verts, closed=True, **kwargs)",
        "begin_line": 1238,
        "end_line": 1325,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.CirclePolygon.__init__#1340",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.CirclePolygon",
        "signature": "lib.matplotlib.patches.CirclePolygon.__init__(self, xy, radius=5, resolution=20, **kwargs)",
        "snippet": "    def __init__(self, xy, radius=5,\n                 resolution=20,  # the number of vertices\n                 ** kwargs):\n        \"\"\"\n        Create a circle at *xy* = (*x*, *y*) with given *radius*.\n\n        This circle is approximated by a regular polygon with *resolution*\n        sides.  For a smoother circle drawn with splines, see `Circle`.\n\n        Valid keyword arguments are:\n\n        %(Patch)s\n        \"\"\"\n        RegularPolygon.__init__(self, xy,\n                                resolution,\n                                radius,\n                                orientation=0,\n                                **kwargs)",
        "begin_line": 1340,
        "end_line": 1357,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Ellipse.__str__#1363",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Ellipse",
        "signature": "lib.matplotlib.patches.Ellipse.__str__(self)",
        "snippet": "    def __str__(self):\n        pars = (self._center[0], self._center[1],\n                self.width, self.height, self.angle)\n        fmt = \"Ellipse(xy=(%s, %s), width=%s, height=%s, angle=%s)\"\n        return fmt % pars",
        "begin_line": 1363,
        "end_line": 1367,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Ellipse.__init__#1370",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Ellipse",
        "signature": "lib.matplotlib.patches.Ellipse.__init__(self, xy, width, height, angle=0, **kwargs)",
        "snippet": "    def __init__(self, xy, width, height, angle=0, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        xy : (float, float)\n            xy coordinates of ellipse centre.\n        width : float\n            Total length (diameter) of horizontal axis.\n        height : float\n            Total length (diameter) of vertical axis.\n        angle : scalar, optional\n            Rotation in degrees anti-clockwise.\n\n        Notes\n        -----\n        Valid keyword arguments are:\n\n        %(Patch)s\n        \"\"\"\n        Patch.__init__(self, **kwargs)\n\n        self._center = xy\n        self._width, self._height = width, height\n        self._angle = angle\n        self._path = Path.unit_circle()\n        # Note: This cannot be calculated until this is added to an Axes\n        self._patch_transform = transforms.IdentityTransform()",
        "begin_line": 1370,
        "end_line": 1396,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Ellipse._recompute_transform#1398",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Ellipse",
        "signature": "lib.matplotlib.patches.Ellipse._recompute_transform(self)",
        "snippet": "    def _recompute_transform(self):\n        \"\"\"\n        Notes\n        -----\n        This cannot be called until after this has been added to an Axes,\n        otherwise unit conversion will fail. This makes it very important to\n        call the accessor method and not directly access the transformation\n        member variable.\n        \"\"\"\n        center = (self.convert_xunits(self._center[0]),\n                  self.convert_yunits(self._center[1]))\n        width = self.convert_xunits(self._width)\n        height = self.convert_yunits(self._height)\n        self._patch_transform = transforms.Affine2D() \\\n            .scale(width * 0.5, height * 0.5) \\\n            .rotate_deg(self.angle) \\\n            .translate(*center)",
        "begin_line": 1398,
        "end_line": 1414,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Ellipse.get_patch_transform#1420",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Ellipse",
        "signature": "lib.matplotlib.patches.Ellipse.get_patch_transform(self)",
        "snippet": "    def get_patch_transform(self):\n        self._recompute_transform()\n        return self._patch_transform",
        "begin_line": 1420,
        "end_line": 1422,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Ellipse.set_center#1424",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Ellipse",
        "signature": "lib.matplotlib.patches.Ellipse.set_center(self, xy)",
        "snippet": "    def set_center(self, xy):\n        \"\"\"\n        Set the center of the ellipse.\n\n        Parameters\n        ----------\n        xy : (float, float)\n        \"\"\"\n        self._center = xy\n        self.stale = True",
        "begin_line": 1424,
        "end_line": 1433,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Ellipse.get_center#1435",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Ellipse",
        "signature": "lib.matplotlib.patches.Ellipse.get_center(self)",
        "snippet": "    def get_center(self):\n        \"\"\"Return the center of the ellipse.\"\"\"\n        return self._center",
        "begin_line": 1435,
        "end_line": 1437,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Ellipse.set_width#1441",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Ellipse",
        "signature": "lib.matplotlib.patches.Ellipse.set_width(self, width)",
        "snippet": "    def set_width(self, width):\n        \"\"\"\n        Set the width of the ellipse.\n\n        Parameters\n        ----------\n        width : float\n        \"\"\"\n        self._width = width\n        self.stale = True",
        "begin_line": 1441,
        "end_line": 1450,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Ellipse.get_width#1452",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Ellipse",
        "signature": "lib.matplotlib.patches.Ellipse.get_width(self)",
        "snippet": "    def get_width(self):\n        \"\"\"\n        Return the width of the ellipse.\n        \"\"\"\n        return self._width",
        "begin_line": 1452,
        "end_line": 1456,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Ellipse.set_height#1460",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Ellipse",
        "signature": "lib.matplotlib.patches.Ellipse.set_height(self, height)",
        "snippet": "    def set_height(self, height):\n        \"\"\"\n        Set the height of the ellipse.\n\n        Parameters\n        ----------\n        height : float\n        \"\"\"\n        self._height = height\n        self.stale = True",
        "begin_line": 1460,
        "end_line": 1469,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Ellipse.get_height#1471",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Ellipse",
        "signature": "lib.matplotlib.patches.Ellipse.get_height(self)",
        "snippet": "    def get_height(self):\n        \"\"\"Return the height of the ellipse.\"\"\"\n        return self._height",
        "begin_line": 1471,
        "end_line": 1473,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Ellipse.get_angle#1488",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Ellipse",
        "signature": "lib.matplotlib.patches.Ellipse.get_angle(self)",
        "snippet": "    def get_angle(self):\n        \"\"\"Return the angle of the ellipse.\"\"\"\n        return self._angle",
        "begin_line": 1488,
        "end_line": 1490,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Circle.__str__#1498",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Circle",
        "signature": "lib.matplotlib.patches.Circle.__str__(self)",
        "snippet": "    def __str__(self):\n        pars = self.center[0], self.center[1], self.radius\n        fmt = \"Circle(xy=(%g, %g), radius=%g)\"\n        return fmt % pars",
        "begin_line": 1498,
        "end_line": 1501,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Circle.__init__#1504",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Circle",
        "signature": "lib.matplotlib.patches.Circle.__init__(self, xy, radius=5, **kwargs)",
        "snippet": "    def __init__(self, xy, radius=5, **kwargs):\n        \"\"\"\n        Create a true circle at center *xy* = (*x*, *y*) with given *radius*.\n\n        Unlike `CirclePolygon` which is a polygonal approximation, this uses\n        Bezier splines and is much closer to a scale-free circle.\n\n        Valid keyword arguments are:\n\n        %(Patch)s\n        \"\"\"\n        Ellipse.__init__(self, xy, radius * 2, radius * 2, **kwargs)\n        self.radius = radius",
        "begin_line": 1504,
        "end_line": 1516,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Circle.set_radius#1518",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Circle",
        "signature": "lib.matplotlib.patches.Circle.set_radius(self, radius)",
        "snippet": "    def set_radius(self, radius):\n        \"\"\"\n        Set the radius of the circle.\n\n        Parameters\n        ----------\n        radius : float\n        \"\"\"\n        self.width = self.height = 2 * radius\n        self.stale = True",
        "begin_line": 1518,
        "end_line": 1527,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc.__str__#1548",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc",
        "signature": "lib.matplotlib.patches.Arc.__str__(self)",
        "snippet": "    def __str__(self):\n        pars = (self.center[0], self.center[1], self.width,\n                self.height, self.angle, self.theta1, self.theta2)\n        fmt = (\"Arc(xy=(%g, %g), width=%g, \"\n               \"height=%g, angle=%g, theta1=%g, theta2=%g)\")\n        return fmt % pars",
        "begin_line": 1548,
        "end_line": 1553,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc.__init__#1556",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc",
        "signature": "lib.matplotlib.patches.Arc.__init__(self, xy, width, height, angle=0.0, theta1=0.0, theta2=360.0, **kwargs)",
        "snippet": "    def __init__(self, xy, width, height, angle=0.0,\n                 theta1=0.0, theta2=360.0, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        xy : (float, float)\n            The center of the ellipse.\n\n        width : float\n            The length of the horizontal axis.\n\n        height : float\n            The length of the vertical axis.\n\n        angle : float\n            Rotation of the ellipse in degrees (counterclockwise).\n\n        theta1, theta2 : float, optional\n            Starting and ending angles of the arc in degrees. These values\n            are relative to *angle*, e.g. if *angle* = 45 and *theta1* = 90\n            the absolute starting angle is 135.\n            Default *theta1* = 0, *theta2* = 360, i.e. a complete ellipse.\n            The arc is drawn in the counterclockwise direction.\n            Angles greater than or equal to 360, or smaller than 0, are\n            represented by an equivalent angle in the range [0, 360), by\n            taking the input value mod 360.\n\n        Other Parameters\n        ----------------\n        **kwargs : `.Patch` properties\n            Most `.Patch` properties are supported as keyword arguments,\n            with the exception of *fill* and *facecolor* because filling is\n            not supported.\n\n        %(Patch)s\n        \"\"\"\n        fill = kwargs.setdefault('fill', False)\n        if fill:\n            raise ValueError(\"Arc objects can not be filled\")\n\n        Ellipse.__init__(self, xy, width, height, angle, **kwargs)\n\n        self.theta1 = theta1\n        self.theta2 = theta2",
        "begin_line": 1556,
        "end_line": 1599,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc.theta_stretch#1658",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc",
        "signature": "lib.matplotlib.patches.Arc.theta_stretch(theta, scale)",
        "snippet": "        def theta_stretch(theta, scale):\n            theta = np.deg2rad(theta)\n            x = np.cos(theta)\n            y = np.sin(theta)\n            return np.rad2deg(np.arctan2(scale * y, x))",
        "begin_line": 1658,
        "end_line": 1662,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc.line_circle_intersect#1673",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc",
        "signature": "lib.matplotlib.patches.Arc.line_circle_intersect(x0, y0, x1, y1)",
        "snippet": "        def line_circle_intersect(x0, y0, x1, y1):\n            dx = x1 - x0\n            dy = y1 - y0\n            dr2 = dx * dx + dy * dy\n            D = x0 * y1 - x1 * y0\n            D2 = D * D\n            discrim = dr2 - D2\n            if discrim >= 0.0:\n                sign_dy = np.copysign(1, dy)  # +/-1, never 0.\n                sqrt_discrim = np.sqrt(discrim)\n                return np.array(\n                    [[(D * dy + sign_dy * dx * sqrt_discrim) / dr2,\n                      (-D * dx + abs(dy) * sqrt_discrim) / dr2],\n                     [(D * dy - sign_dy * dx * sqrt_discrim) / dr2,\n                      (-D * dx - abs(dy) * sqrt_discrim) / dr2]])\n            else:\n                return np.empty((0, 2))",
        "begin_line": 1673,
        "end_line": 1689,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc.draw#1602",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc",
        "signature": "lib.matplotlib.patches.Arc.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        \"\"\"\n        Draw the arc to the given *renderer*.\n\n        Notes\n        -----\n        Ellipses are normally drawn using an approximation that uses\n        eight cubic Bezier splines.  The error of this approximation\n        is 1.89818e-6, according to this unverified source:\n\n          Lancaster, Don.  *Approximating a Circle or an Ellipse Using\n          Four Bezier Cubic Splines.*\n\n          http://www.tinaja.com/glib/ellipse4.pdf\n\n        There is a use case where very large ellipses must be drawn\n        with very high accuracy, and it is too expensive to render the\n        entire ellipse with enough segments (either splines or line\n        segments).  Therefore, in the case where either radius of the\n        ellipse is large enough that the error of the spline\n        approximation will be visible (greater than one pixel offset\n        from the ideal), a different technique is used.\n\n        In that case, only the visible parts of the ellipse are drawn,\n        with each visible arc using a fixed number of spline segments\n        (8).  The algorithm proceeds as follows:\n\n        1. The points where the ellipse intersects the axes bounding\n           box are located.  (This is done be performing an inverse\n           transformation on the axes bbox such that it is relative\n           to the unit circle -- this makes the intersection\n           calculation much easier than doing rotated ellipse\n           intersection directly).\n\n           This uses the \"line intersecting a circle\" algorithm from:\n\n               Vince, John.  *Geometry for Computer Graphics: Formulae,\n               Examples & Proofs.*  London: Springer-Verlag, 2005.\n\n        2. The angles of each of the intersection points are calculated.\n\n        3. Proceeding counterclockwise starting in the positive\n           x-direction, each of the visible arc-segments between the\n           pairs of vertices are drawn using the Bezier arc\n           approximation technique implemented in `.Path.arc`.\n        \"\"\"\n        if not hasattr(self, 'axes'):\n            raise RuntimeError('Arcs can only be used in Axes instances')\n\n        self._recompute_transform()\n\n        width = self.convert_xunits(self.width)\n        height = self.convert_yunits(self.height)\n\n        # If the width and height of ellipse are not equal, take into account\n        # stretching when calculating angles to draw between\n        def theta_stretch(theta, scale):\n            theta = np.deg2rad(theta)\n            x = np.cos(theta)\n            y = np.sin(theta)\n            return np.rad2deg(np.arctan2(scale * y, x))\n        theta1 = theta_stretch(self.theta1, width / height)\n        theta2 = theta_stretch(self.theta2, width / height)\n\n        # Get width and height in pixels\n        width, height = self.get_transform().transform((width, height))\n        inv_error = (1.0 / 1.89818e-6) * 0.5\n        if width < inv_error and height < inv_error:\n            self._path = Path.arc(theta1, theta2)\n            return Patch.draw(self, renderer)\n\n        def line_circle_intersect(x0, y0, x1, y1):\n            dx = x1 - x0\n            dy = y1 - y0\n            dr2 = dx * dx + dy * dy\n            D = x0 * y1 - x1 * y0\n            D2 = D * D\n            discrim = dr2 - D2\n            if discrim >= 0.0:\n                sign_dy = np.copysign(1, dy)  # +/-1, never 0.\n                sqrt_discrim = np.sqrt(discrim)\n                return np.array(\n                    [[(D * dy + sign_dy * dx * sqrt_discrim) / dr2,\n                      (-D * dx + abs(dy) * sqrt_discrim) / dr2],\n                     [(D * dy - sign_dy * dx * sqrt_discrim) / dr2,\n                      (-D * dx - abs(dy) * sqrt_discrim) / dr2]])\n            else:\n                return np.empty((0, 2))\n\n        def segment_circle_intersect(x0, y0, x1, y1):\n            epsilon = 1e-9\n            if x1 < x0:\n                x0e, x1e = x1, x0\n            else:\n                x0e, x1e = x0, x1\n            if y1 < y0:\n                y0e, y1e = y1, y0\n            else:\n                y0e, y1e = y0, y1\n            xys = line_circle_intersect(x0, y0, x1, y1)\n            xs, ys = xys.T\n            return xys[(x0e - epsilon < xs) & (xs < x1e + epsilon)\n                       & (y0e - epsilon < ys) & (ys < y1e + epsilon)]\n\n        # Transforms the axes box_path so that it is relative to the unit\n        # circle in the same way that it is relative to the desired ellipse.\n        box_path = Path.unit_rectangle()\n        box_path_transform = (transforms.BboxTransformTo(self.axes.bbox)\n                              + self.get_transform().inverted())\n        box_path = box_path.transformed(box_path_transform)\n\n        thetas = set()\n        # For each of the point pairs, there is a line segment\n        for p0, p1 in zip(box_path.vertices[:-1], box_path.vertices[1:]):\n            xy = segment_circle_intersect(*p0, *p1)\n            x, y = xy.T\n            theta = np.rad2deg(np.arctan2(y, x))\n            thetas.update(theta[(theta1 < theta) & (theta < theta2)])\n        thetas = sorted(thetas) + [theta2]\n\n        last_theta = theta1\n        theta1_rad = np.deg2rad(theta1)\n        inside = box_path.contains_point((np.cos(theta1_rad),\n                                          np.sin(theta1_rad)))\n\n        # save original path\n        path_original = self._path\n        for theta in thetas:\n            if inside:\n                self._path = Path.arc(last_theta, theta, 8)\n                Patch.draw(self, renderer)\n                inside = False\n            else:\n                inside = True\n            last_theta = theta\n\n        # restore original path\n        self._path = path_original",
        "begin_line": 1602,
        "end_line": 1739,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches._Style.__new__#1808",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Style",
        "signature": "lib.matplotlib.patches._Style.__new__(cls, stylename, **kw)",
        "snippet": "    def __new__(cls, stylename, **kw):\n        \"\"\"Return the instance of the subclass with the given style name.\"\"\"\n\n        # The \"class\" should have the _style_list attribute, which is a mapping\n        # of style names to style classes.\n\n        _list = stylename.replace(\" \", \"\").split(\",\")\n        _name = _list[0].lower()\n        try:\n            _cls = cls._style_list[_name]\n        except KeyError as err:\n            raise ValueError(\"Unknown style : %s\" % stylename) from err\n\n        try:\n            _args_pair = [cs.split(\"=\") for cs in _list[1:]]\n            _args = {k: float(v) for k, v in _args_pair}\n        except ValueError as err:\n            raise ValueError(\"Incorrect style argument : %s\" %\n                             stylename) from err\n        _args.update(kw)\n\n        return _cls(**_args)",
        "begin_line": 1808,
        "end_line": 1829,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003307972213033411,
            "pseudo_dstar_susp": 0.0003201024327784891,
            "pseudo_tarantula_susp": 0.0004201680672268908,
            "pseudo_op2_susp": 0.0003201024327784891,
            "pseudo_barinel_susp": 0.0004201680672268908
        }
    },
    {
        "name": "lib.matplotlib.patches.Square.__init__#1980",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Square",
        "signature": "lib.matplotlib.patches.Square.__init__(self, pad=0.3)",
        "snippet": "        def __init__(self, pad=0.3):\n            self.pad = pad\n            super().__init__()",
        "begin_line": 1980,
        "end_line": 1982,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004975124378109452,
            "pseudo_dstar_susp": 0.00040404040404040404,
            "pseudo_tarantula_susp": 0.0017921146953405018,
            "pseudo_op2_susp": 0.00040404040404040404,
            "pseudo_barinel_susp": 0.0017921146953405018
        }
    },
    {
        "name": "lib.matplotlib.patches.Square.transmute#1984",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Square",
        "signature": "lib.matplotlib.patches.Square.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n            pad = mutation_size * self.pad\n            # width and height with padding added.\n            width, height = width + 2 * pad, height + 2 * pad\n            # boundary of the padded box\n            x0, y0 = x0 - pad, y0 - pad\n            x1, y1 = x0 + width, y0 + height\n            return Path([(x0, y0), (x1, y0), (x1, y1), (x0, y1), (x0, y0)],\n                        closed=True)",
        "begin_line": 1984,
        "end_line": 1992,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041736227045075126,
            "pseudo_dstar_susp": 0.0003787878787878788,
            "pseudo_tarantula_susp": 0.0010638297872340426,
            "pseudo_op2_susp": 0.0003787878787878788,
            "pseudo_barinel_susp": 0.0010638297872340426
        }
    },
    {
        "name": "lib.matplotlib.patches.Circle.__init__#2004",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Circle",
        "signature": "lib.matplotlib.patches.Circle.__init__(self, pad=0.3)",
        "snippet": "        def __init__(self, pad=0.3):\n            self.pad = pad\n            super().__init__()",
        "begin_line": 2004,
        "end_line": 2006,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Circle.transmute#2008",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Circle",
        "signature": "lib.matplotlib.patches.Circle.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n            pad = mutation_size * self.pad\n            width, height = width + 2 * pad, height + 2 * pad\n            # boundary of the padded box\n            x0, y0 = x0 - pad, y0 - pad\n            return Path.circle((x0 + width / 2, y0 + height / 2),\n                               max(width, height) / 2)",
        "begin_line": 2008,
        "end_line": 2014,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.LArrow.__init__#2026",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.LArrow",
        "signature": "lib.matplotlib.patches.LArrow.__init__(self, pad=0.3)",
        "snippet": "        def __init__(self, pad=0.3):\n            self.pad = pad\n            super().__init__()",
        "begin_line": 2026,
        "end_line": 2028,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.LArrow.transmute#2030",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.LArrow",
        "signature": "lib.matplotlib.patches.LArrow.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n            # padding\n            pad = mutation_size * self.pad\n            # width and height with padding added.\n            width, height = width + 2 * pad, height + 2 * pad\n            # boundary of the padded box\n            x0, y0 = x0 - pad, y0 - pad,\n            x1, y1 = x0 + width, y0 + height\n\n            dx = (y1 - y0) / 2\n            dxx = dx / 2\n            x0 = x0 + pad / 1.4  # adjust by ~sqrt(2)\n\n            return Path([(x0 + dxx, y0), (x1, y0), (x1, y1), (x0 + dxx, y1),\n                         (x0 + dxx, y1 + dxx), (x0 - dx, y0 + dx),\n                         (x0 + dxx, y0 - dxx),  # arrow\n                         (x0 + dxx, y0), (x0 + dxx, y0)],\n                        closed=True)",
        "begin_line": 2030,
        "end_line": 2047,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.DArrow.__init__#2081",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.DArrow",
        "signature": "lib.matplotlib.patches.DArrow.__init__(self, pad=0.3)",
        "snippet": "        def __init__(self, pad=0.3):\n            self.pad = pad\n            super().__init__()",
        "begin_line": 2081,
        "end_line": 2083,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.DArrow.transmute#2085",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.DArrow",
        "signature": "lib.matplotlib.patches.DArrow.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n            # padding\n            pad = mutation_size * self.pad\n            # width and height with padding added.\n            # The width is padded by the arrows, so we don't need to pad it.\n            height = height + 2 * pad\n            # boundary of the padded box\n            x0, y0 = x0 - pad, y0 - pad\n            x1, y1 = x0 + width, y0 + height\n\n            dx = (y1 - y0) / 2\n            dxx = dx / 2\n            x0 = x0 + pad / 1.4  # adjust by ~sqrt(2)\n\n            return Path([(x0 + dxx, y0), (x1, y0),  # bot-segment\n                         (x1, y0 - dxx), (x1 + dx + dxx, y0 + dx),\n                         (x1, y1 + dxx),  # right-arrow\n                         (x1, y1), (x0 + dxx, y1),  # top-segment\n                         (x0 + dxx, y1 + dxx), (x0 - dx, y0 + dx),\n                         (x0 + dxx, y0 - dxx),  # left-arrow\n                         (x0 + dxx, y0), (x0 + dxx, y0)],  # close-poly\n                        closed=True)",
        "begin_line": 2085,
        "end_line": 2106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Round.__init__#2120",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Round",
        "signature": "lib.matplotlib.patches.Round.__init__(self, pad=0.3, rounding_size=None)",
        "snippet": "        def __init__(self, pad=0.3, rounding_size=None):\n            self.pad = pad\n            self.rounding_size = rounding_size\n            super().__init__()",
        "begin_line": 2120,
        "end_line": 2123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Round.transmute#2125",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Round",
        "signature": "lib.matplotlib.patches.Round.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n\n            # padding\n            pad = mutation_size * self.pad\n\n            # size of the rounding corner\n            if self.rounding_size:\n                dr = mutation_size * self.rounding_size\n            else:\n                dr = pad\n\n            width, height = width + 2 * pad, height + 2 * pad\n\n            x0, y0 = x0 - pad, y0 - pad,\n            x1, y1 = x0 + width, y0 + height\n\n            # Round corners are implemented as quadratic Bezier, e.g.,\n            # [(x0, y0-dr), (x0, y0), (x0+dr, y0)] for lower left corner.\n            cp = [(x0 + dr, y0),\n                  (x1 - dr, y0),\n                  (x1, y0), (x1, y0 + dr),\n                  (x1, y1 - dr),\n                  (x1, y1), (x1 - dr, y1),\n                  (x0 + dr, y1),\n                  (x0, y1), (x0, y1 - dr),\n                  (x0, y0 + dr),\n                  (x0, y0), (x0 + dr, y0),\n                  (x0 + dr, y0)]\n\n            com = [Path.MOVETO,\n                   Path.LINETO,\n                   Path.CURVE3, Path.CURVE3,\n                   Path.LINETO,\n                   Path.CURVE3, Path.CURVE3,\n                   Path.LINETO,\n                   Path.CURVE3, Path.CURVE3,\n                   Path.LINETO,\n                   Path.CURVE3, Path.CURVE3,\n                   Path.CLOSEPOLY]\n\n            path = Path(cp, com)\n\n            return path",
        "begin_line": 2125,
        "end_line": 2167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Round4.transmute#2186",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Round4",
        "signature": "lib.matplotlib.patches.Round4.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n\n            # padding\n            pad = mutation_size * self.pad\n\n            # Rounding size; defaults to half of the padding.\n            if self.rounding_size:\n                dr = mutation_size * self.rounding_size\n            else:\n                dr = pad / 2.\n\n            width = width + 2 * pad - 2 * dr\n            height = height + 2 * pad - 2 * dr\n\n            x0, y0 = x0 - pad + dr, y0 - pad + dr,\n            x1, y1 = x0 + width, y0 + height\n\n            cp = [(x0, y0),\n                  (x0 + dr, y0 - dr), (x1 - dr, y0 - dr), (x1, y0),\n                  (x1 + dr, y0 + dr), (x1 + dr, y1 - dr), (x1, y1),\n                  (x1 - dr, y1 + dr), (x0 + dr, y1 + dr), (x0, y1),\n                  (x0 - dr, y1 - dr), (x0 - dr, y0 + dr), (x0, y0),\n                  (x0, y0)]\n\n            com = [Path.MOVETO,\n                   Path.CURVE4, Path.CURVE4, Path.CURVE4,\n                   Path.CURVE4, Path.CURVE4, Path.CURVE4,\n                   Path.CURVE4, Path.CURVE4, Path.CURVE4,\n                   Path.CURVE4, Path.CURVE4, Path.CURVE4,\n                   Path.CLOSEPOLY]\n\n            path = Path(cp, com)\n\n            return path",
        "begin_line": 2186,
        "end_line": 2219,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Sawtooth._get_sawtooth_vertices#2238",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Sawtooth",
        "signature": "lib.matplotlib.patches.Sawtooth._get_sawtooth_vertices(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def _get_sawtooth_vertices(self, x0, y0, width, height, mutation_size):\n\n            # padding\n            pad = mutation_size * self.pad\n\n            # size of sawtooth\n            if self.tooth_size is None:\n                tooth_size = self.pad * .5 * mutation_size\n            else:\n                tooth_size = self.tooth_size * mutation_size\n\n            tooth_size2 = tooth_size / 2\n            width = width + 2 * pad - tooth_size\n            height = height + 2 * pad - tooth_size\n\n            # the sizes of the vertical and horizontal sawtooth are\n            # separately adjusted to fit the given box size.\n            dsx_n = int(round((width - tooth_size) / (tooth_size * 2))) * 2\n            dsx = (width - tooth_size) / dsx_n\n            dsy_n = int(round((height - tooth_size) / (tooth_size * 2))) * 2\n            dsy = (height - tooth_size) / dsy_n\n\n            x0, y0 = x0 - pad + tooth_size2, y0 - pad + tooth_size2\n            x1, y1 = x0 + width, y0 + height\n\n            bottom_saw_x = [\n                x0,\n                *(x0 + tooth_size2 + dsx * .5 * np.arange(dsx_n * 2)),\n                x1 - tooth_size2,\n            ]\n            bottom_saw_y = [\n                y0,\n                *([y0 - tooth_size2, y0, y0 + tooth_size2, y0] * dsx_n),\n                y0 - tooth_size2,\n            ]\n            right_saw_x = [\n                x1,\n                *([x1 + tooth_size2, x1, x1 - tooth_size2, x1] * dsx_n),\n                x1 + tooth_size2,\n            ]\n            right_saw_y = [\n                y0,\n                *(y0 + tooth_size2 + dsy * .5 * np.arange(dsy_n * 2)),\n                y1 - tooth_size2,\n            ]\n            top_saw_x = [\n                x1,\n                *(x1 - tooth_size2 - dsx * .5 * np.arange(dsx_n * 2)),\n                x0 + tooth_size2,\n            ]\n            top_saw_y = [\n                y1,\n                *([y1 + tooth_size2, y1, y1 - tooth_size2, y1] * dsx_n),\n                y1 + tooth_size2,\n            ]\n            left_saw_x = [\n                x0,\n                *([x0 - tooth_size2, x0, x0 + tooth_size2, x0] * dsy_n),\n                x0 - tooth_size2,\n            ]\n            left_saw_y = [\n                y1,\n                *(y1 - tooth_size2 - dsy * .5 * np.arange(dsy_n * 2)),\n                y0 + tooth_size2,\n            ]\n\n            saw_vertices = [*zip(bottom_saw_x, bottom_saw_y),\n                            *zip(right_saw_x, right_saw_y),\n                            *zip(top_saw_x, top_saw_y),\n                            *zip(left_saw_x, left_saw_y),\n                            (bottom_saw_x[0], bottom_saw_y[0])]\n\n            return saw_vertices",
        "begin_line": 2238,
        "end_line": 2310,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Sawtooth.transmute#2312",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Sawtooth",
        "signature": "lib.matplotlib.patches.Sawtooth.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n            saw_vertices = self._get_sawtooth_vertices(x0, y0, width,\n                                                       height, mutation_size)\n            path = Path(saw_vertices, closed=True)\n            return path",
        "begin_line": 2312,
        "end_line": 2316,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Roundtooth.__init__#2330",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Roundtooth",
        "signature": "lib.matplotlib.patches.Roundtooth.__init__(self, pad=0.3, tooth_size=None)",
        "snippet": "        def __init__(self, pad=0.3, tooth_size=None):\n            super().__init__(pad, tooth_size)",
        "begin_line": 2330,
        "end_line": 2331,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Roundtooth.transmute#2333",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Roundtooth",
        "signature": "lib.matplotlib.patches.Roundtooth.transmute(self, x0, y0, width, height, mutation_size)",
        "snippet": "        def transmute(self, x0, y0, width, height, mutation_size):\n            saw_vertices = self._get_sawtooth_vertices(x0, y0,\n                                                       width, height,\n                                                       mutation_size)\n            # Add a trailing vertex to allow us to close the polygon correctly\n            saw_vertices = np.concatenate([np.array(saw_vertices),\n                                           [saw_vertices[0]]], axis=0)\n            codes = ([Path.MOVETO] +\n                     [Path.CURVE3, Path.CURVE3] * ((len(saw_vertices)-1)//2) +\n                     [Path.CLOSEPOLY])\n            return Path(saw_vertices, codes)",
        "begin_line": 2333,
        "end_line": 2343,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.SimpleEvent.__init__#2399",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.SimpleEvent",
        "signature": "lib.matplotlib.patches.SimpleEvent.__init__(self, xy)",
        "snippet": "            def __init__(self, xy):\n                self.x, self.y = xy",
        "begin_line": 2399,
        "end_line": 2400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches._Base._clip#2402",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Base",
        "signature": "lib.matplotlib.patches._Base._clip(self, path, patchA, patchB)",
        "snippet": "        def _clip(self, path, patchA, patchB):\n            \"\"\"\n            Clip the path to the boundary of the patchA and patchB.\n            The starting point of the path needed to be inside of the\n            patchA and the end point inside the patch B. The *contains*\n            methods of each patch object is utilized to test if the point\n            is inside the path.\n            \"\"\"\n\n            if patchA:\n                def insideA(xy_display):\n                    xy_event = ConnectionStyle._Base.SimpleEvent(xy_display)\n                    return patchA.contains(xy_event)[0]\n\n                try:\n                    left, right = split_path_inout(path, insideA)\n                except ValueError:\n                    right = path\n\n                path = right\n\n            if patchB:\n                def insideB(xy_display):\n                    xy_event = ConnectionStyle._Base.SimpleEvent(xy_display)\n                    return patchB.contains(xy_event)[0]\n\n                try:\n                    left, right = split_path_inout(path, insideB)\n                except ValueError:\n                    left = path\n\n                path = left\n\n            return path",
        "begin_line": 2402,
        "end_line": 2435,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches._Base._shrink#2437",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Base",
        "signature": "lib.matplotlib.patches._Base._shrink(self, path, shrinkA, shrinkB)",
        "snippet": "        def _shrink(self, path, shrinkA, shrinkB):\n            \"\"\"\n            Shrink the path by fixed size (in points) with shrinkA and shrinkB.\n            \"\"\"\n            if shrinkA:\n                insideA = inside_circle(*path.vertices[0], shrinkA)\n                try:\n                    left, path = split_path_inout(path, insideA)\n                except ValueError:\n                    pass\n            if shrinkB:\n                insideB = inside_circle(*path.vertices[-1], shrinkB)\n                try:\n                    path, right = split_path_inout(path, insideB)\n                except ValueError:\n                    pass\n            return path",
        "begin_line": 2437,
        "end_line": 2453,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches._Base.__call__#2455",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Base",
        "signature": "lib.matplotlib.patches._Base.__call__(self, posA, posB, shrinkA=2.0, shrinkB=2.0, patchA=None, patchB=None)",
        "snippet": "        def __call__(self, posA, posB,\n                     shrinkA=2., shrinkB=2., patchA=None, patchB=None):\n            \"\"\"\n            Calls the *connect* method to create a path between *posA*\n             and *posB*. The path is clipped and shrunken.\n            \"\"\"\n\n            path = self.connect(posA, posB)\n\n            clipped_path = self._clip(path, patchA, patchB)\n            shrunk_path = self._shrink(clipped_path, shrinkA, shrinkB)\n\n            return shrunk_path",
        "begin_line": 2455,
        "end_line": 2467,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc3.__init__#2479",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc3",
        "signature": "lib.matplotlib.patches.Arc3.__init__(self, rad=0.0)",
        "snippet": "        def __init__(self, rad=0.):\n            \"\"\"\n            *rad*\n              curvature of the curve.\n            \"\"\"\n            self.rad = rad",
        "begin_line": 2479,
        "end_line": 2484,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc3.connect#2486",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc3",
        "signature": "lib.matplotlib.patches.Arc3.connect(self, posA, posB)",
        "snippet": "        def connect(self, posA, posB):\n            x1, y1 = posA\n            x2, y2 = posB\n            x12, y12 = (x1 + x2) / 2., (y1 + y2) / 2.\n            dx, dy = x2 - x1, y2 - y1\n\n            f = self.rad\n\n            cx, cy = x12 + f * dy, y12 - f * dx\n\n            vertices = [(x1, y1),\n                        (cx, cy),\n                        (x2, y2)]\n            codes = [Path.MOVETO,\n                     Path.CURVE3,\n                     Path.CURVE3]\n\n            return Path(vertices, codes)",
        "begin_line": 2486,
        "end_line": 2503,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Angle3.__init__#2514",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Angle3",
        "signature": "lib.matplotlib.patches.Angle3.__init__(self, angleA=90, angleB=0)",
        "snippet": "        def __init__(self, angleA=90, angleB=0):\n            \"\"\"\n            *angleA*\n              starting angle of the path\n\n            *angleB*\n              ending angle of the path\n            \"\"\"\n\n            self.angleA = angleA\n            self.angleB = angleB",
        "begin_line": 2514,
        "end_line": 2524,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Angle3.connect#2526",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Angle3",
        "signature": "lib.matplotlib.patches.Angle3.connect(self, posA, posB)",
        "snippet": "        def connect(self, posA, posB):\n            x1, y1 = posA\n            x2, y2 = posB\n\n            cosA = math.cos(math.radians(self.angleA))\n            sinA = math.sin(math.radians(self.angleA))\n            cosB = math.cos(math.radians(self.angleB))\n            sinB = math.sin(math.radians(self.angleB))\n\n            cx, cy = get_intersection(x1, y1, cosA, sinA,\n                                      x2, y2, cosB, sinB)\n\n            vertices = [(x1, y1), (cx, cy), (x2, y2)]\n            codes = [Path.MOVETO, Path.CURVE3, Path.CURVE3]\n\n            return Path(vertices, codes)",
        "begin_line": 2526,
        "end_line": 2541,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Angle.connect#2570",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Angle",
        "signature": "lib.matplotlib.patches.Angle.connect(self, posA, posB)",
        "snippet": "        def connect(self, posA, posB):\n            x1, y1 = posA\n            x2, y2 = posB\n\n            cosA = math.cos(math.radians(self.angleA))\n            sinA = math.sin(math.radians(self.angleA))\n            cosB = math.cos(math.radians(self.angleB))\n            sinB = math.sin(math.radians(self.angleB))\n\n            cx, cy = get_intersection(x1, y1, cosA, sinA,\n                                      x2, y2, cosB, sinB)\n\n            vertices = [(x1, y1)]\n            codes = [Path.MOVETO]\n\n            if self.rad == 0.:\n                vertices.append((cx, cy))\n                codes.append(Path.LINETO)\n            else:\n                dx1, dy1 = x1 - cx, y1 - cy\n                d1 = np.hypot(dx1, dy1)\n                f1 = self.rad / d1\n                dx2, dy2 = x2 - cx, y2 - cy\n                d2 = np.hypot(dx2, dy2)\n                f2 = self.rad / d2\n                vertices.extend([(cx + dx1 * f1, cy + dy1 * f1),\n                                 (cx, cy),\n                                 (cx + dx2 * f2, cy + dy2 * f2)])\n                codes.extend([Path.LINETO, Path.CURVE3, Path.CURVE3])\n\n            vertices.append((x2, y2))\n            codes.append(Path.LINETO)\n\n            return Path(vertices, codes)",
        "begin_line": 2570,
        "end_line": 2603,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Arc.connect#2640",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Arc",
        "signature": "lib.matplotlib.patches.Arc.connect(self, posA, posB)",
        "snippet": "        def connect(self, posA, posB):\n            x1, y1 = posA\n            x2, y2 = posB\n\n            vertices = [(x1, y1)]\n            rounded = []\n            codes = [Path.MOVETO]\n\n            if self.armA:\n                cosA = math.cos(math.radians(self.angleA))\n                sinA = math.sin(math.radians(self.angleA))\n                # x_armA, y_armB\n                d = self.armA - self.rad\n                rounded.append((x1 + d * cosA, y1 + d * sinA))\n                d = self.armA\n                rounded.append((x1 + d * cosA, y1 + d * sinA))\n\n            if self.armB:\n                cosB = math.cos(math.radians(self.angleB))\n                sinB = math.sin(math.radians(self.angleB))\n                x_armB, y_armB = x2 + self.armB * cosB, y2 + self.armB * sinB\n\n                if rounded:\n                    xp, yp = rounded[-1]\n                    dx, dy = x_armB - xp, y_armB - yp\n                    dd = (dx * dx + dy * dy) ** .5\n\n                    rounded.append((xp + self.rad * dx / dd,\n                                    yp + self.rad * dy / dd))\n                    vertices.extend(rounded)\n                    codes.extend([Path.LINETO,\n                                  Path.CURVE3,\n                                  Path.CURVE3])\n                else:\n                    xp, yp = vertices[-1]\n                    dx, dy = x_armB - xp, y_armB - yp\n                    dd = (dx * dx + dy * dy) ** .5\n\n                d = dd - self.rad\n                rounded = [(xp + d * dx / dd, yp + d * dy / dd),\n                           (x_armB, y_armB)]\n\n            if rounded:\n                xp, yp = rounded[-1]\n                dx, dy = x2 - xp, y2 - yp\n                dd = (dx * dx + dy * dy) ** .5\n\n                rounded.append((xp + self.rad * dx / dd,\n                                yp + self.rad * dy / dd))\n                vertices.extend(rounded)\n                codes.extend([Path.LINETO,\n                              Path.CURVE3,\n                              Path.CURVE3])\n\n            vertices.append((x2, y2))\n            codes.append(Path.LINETO)\n\n            return Path(vertices, codes)",
        "begin_line": 2640,
        "end_line": 2697,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Bar.__init__#2708",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Bar",
        "signature": "lib.matplotlib.patches.Bar.__init__(self, armA=0.0, armB=0.0, fraction=0.3, angle=None)",
        "snippet": "        def __init__(self, armA=0., armB=0., fraction=0.3, angle=None):\n            \"\"\"\n            Parameters\n            ----------\n            armA : float\n                minimum length of armA\n\n            armB : float\n                minimum length of armB\n\n            fraction : float\n                a fraction of the distance between two points that\n                will be added to armA and armB.\n\n            angle : float or None\n                angle of the connecting line (if None, parallel\n                to A and B)\n            \"\"\"\n            self.armA = armA\n            self.armB = armB\n            self.fraction = fraction\n            self.angle = angle",
        "begin_line": 2708,
        "end_line": 2729,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Bar.connect#2731",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Bar",
        "signature": "lib.matplotlib.patches.Bar.connect(self, posA, posB)",
        "snippet": "        def connect(self, posA, posB):\n            x1, y1 = posA\n            x20, y20 = x2, y2 = posB\n\n            theta1 = math.atan2(y2 - y1, x2 - x1)\n            dx, dy = x2 - x1, y2 - y1\n            dd = (dx * dx + dy * dy) ** .5\n            ddx, ddy = dx / dd, dy / dd\n\n            armA, armB = self.armA, self.armB\n\n            if self.angle is not None:\n                theta0 = np.deg2rad(self.angle)\n                dtheta = theta1 - theta0\n                dl = dd * math.sin(dtheta)\n                dL = dd * math.cos(dtheta)\n                x2, y2 = x1 + dL * math.cos(theta0), y1 + dL * math.sin(theta0)\n                armB = armB - dl\n\n                # update\n                dx, dy = x2 - x1, y2 - y1\n                dd2 = (dx * dx + dy * dy) ** .5\n                ddx, ddy = dx / dd2, dy / dd2\n\n            arm = max(armA, armB)\n            f = self.fraction * dd + arm\n\n            cx1, cy1 = x1 + f * ddy, y1 - f * ddx\n            cx2, cy2 = x2 + f * ddy, y2 - f * ddx\n\n            vertices = [(x1, y1),\n                        (cx1, cy1),\n                        (cx2, cy2),\n                        (x20, y20)]\n            codes = [Path.MOVETO,\n                     Path.LINETO,\n                     Path.LINETO,\n                     Path.LINETO]\n\n            return Path(vertices, codes)",
        "begin_line": 2731,
        "end_line": 2770,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches._point_along_a_line#2773",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches",
        "signature": "lib.matplotlib.patches._point_along_a_line(x0, y0, x1, y1, d)",
        "snippet": "def _point_along_a_line(x0, y0, x1, y1, d):\n    \"\"\"\n    Return the point on the line connecting (*x0*, *y0*) -- (*x1*, *y1*) whose\n    distance from (*x0*, *y0*) is *d*.\n    \"\"\"\n    dx, dy = x0 - x1, y0 - y1\n    ff = d / (dx * dx + dy * dy) ** .5\n    x2, y2 = x0 - ff * dx, y0 - ff * dy\n\n    return x2, y2",
        "begin_line": 2773,
        "end_line": 2782,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches._Base.ensure_quadratic_bezier#2841",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Base",
        "signature": "lib.matplotlib.patches._Base.ensure_quadratic_bezier(path)",
        "snippet": "        def ensure_quadratic_bezier(path):\n            \"\"\"\n            Some ArrowStyle class only works with a simple quadratic Bezier\n            curve (created with Arc3Connection or Angle3Connector). This static\n            method is to check if the provided path is a simple quadratic\n            Bezier curve and returns its control points if true.\n            \"\"\"\n            segments = list(path.iter_segments())\n            if (len(segments) != 2 or segments[0][1] != Path.MOVETO or\n                    segments[1][1] != Path.CURVE3):\n                raise ValueError(\n                    \"'path' is not a valid quadratic Bezier curve\")\n            return [*segments[0][0], *segments[1][0]]",
        "begin_line": 2841,
        "end_line": 2853,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches._Base.__call__#2869",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Base",
        "signature": "lib.matplotlib.patches._Base.__call__(self, path, mutation_size, linewidth, aspect_ratio=1.0)",
        "snippet": "        def __call__(self, path, mutation_size, linewidth,\n                     aspect_ratio=1.):\n            \"\"\"\n            The __call__ method is a thin wrapper around the transmute method\n            and takes care of the aspect ratio.\n            \"\"\"\n\n            path = make_path_regular(path)\n\n            if aspect_ratio is not None:\n                # Squeeze the given height by the aspect_ratio\n                vertices = path.vertices / [1, aspect_ratio]\n                path_shrunk = Path(vertices, path.codes)\n                # call transmute method with squeezed height.\n                path_mutated, fillable = self.transmute(path_shrunk,\n                                                        linewidth,\n                                                        mutation_size)\n                if np.iterable(fillable):\n                    path_list = []\n                    for p in zip(path_mutated):\n                        v, c = p.vertices, p.codes\n                        # Restore the height\n                        v[:, 1] = v[:, 1] * aspect_ratio\n                        path_list.append(Path(v, c))\n                    return path_list, fillable\n                else:\n                    return path_mutated, fillable\n            else:\n                return self.transmute(path, mutation_size, linewidth)",
        "begin_line": 2869,
        "end_line": 2897,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches._Curve.__init__#2907",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Curve",
        "signature": "lib.matplotlib.patches._Curve.__init__(self, beginarrow=None, endarrow=None, fillbegin=False, fillend=False, head_length=0.2, head_width=0.1)",
        "snippet": "        def __init__(self, beginarrow=None, endarrow=None,\n                     fillbegin=False, fillend=False,\n                     head_length=.2, head_width=.1):\n            \"\"\"\n            The arrows are drawn if *beginarrow* and/or *endarrow* are\n            true. *head_length* and *head_width* determines the size\n            of the arrow relative to the *mutation scale*.  The\n            arrowhead at the begin (or end) is closed if fillbegin (or\n            fillend) is True.\n            \"\"\"\n            self.beginarrow, self.endarrow = beginarrow, endarrow\n            self.head_length, self.head_width = head_length, head_width\n            self.fillbegin, self.fillend = fillbegin, fillend\n            super().__init__()",
        "begin_line": 2907,
        "end_line": 2920,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches._Curve._get_arrow_wedge#2922",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Curve",
        "signature": "lib.matplotlib.patches._Curve._get_arrow_wedge(self, x0, y0, x1, y1, head_dist, cos_t, sin_t, linewidth)",
        "snippet": "        def _get_arrow_wedge(self, x0, y0, x1, y1,\n                             head_dist, cos_t, sin_t, linewidth):\n            \"\"\"\n            Return the paths for arrow heads. Since arrow lines are\n            drawn with capstyle=projected, The arrow goes beyond the\n            desired point. This method also returns the amount of the path\n            to be shrunken so that it does not overshoot.\n            \"\"\"\n\n            # arrow from x0, y0 to x1, y1\n            dx, dy = x0 - x1, y0 - y1\n\n            cp_distance = np.hypot(dx, dy)\n\n            # pad_projected : amount of pad to account the\n            # overshooting of the projection of the wedge\n            pad_projected = (.5 * linewidth / sin_t)\n\n            # Account for division by zero\n            if cp_distance == 0:\n                cp_distance = 1\n\n            # apply pad for projected edge\n            ddx = pad_projected * dx / cp_distance\n            ddy = pad_projected * dy / cp_distance\n\n            # offset for arrow wedge\n            dx = dx / cp_distance * head_dist\n            dy = dy / cp_distance * head_dist\n\n            dx1, dy1 = cos_t * dx + sin_t * dy, -sin_t * dx + cos_t * dy\n            dx2, dy2 = cos_t * dx - sin_t * dy, sin_t * dx + cos_t * dy\n\n            vertices_arrow = [(x1 + ddx + dx1, y1 + ddy + dy1),\n                              (x1 + ddx, y1 + ddy),\n                              (x1 + ddx + dx2, y1 + ddy + dy2)]\n            codes_arrow = [Path.MOVETO,\n                           Path.LINETO,\n                           Path.LINETO]\n\n            return vertices_arrow, codes_arrow, ddx, ddy",
        "begin_line": 2922,
        "end_line": 2962,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches._Curve.transmute#2964",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Curve",
        "signature": "lib.matplotlib.patches._Curve.transmute(self, path, mutation_size, linewidth)",
        "snippet": "        def transmute(self, path, mutation_size, linewidth):\n\n            head_length = self.head_length * mutation_size\n            head_width = self.head_width * mutation_size\n            head_dist = np.hypot(head_length, head_width)\n            cos_t, sin_t = head_length / head_dist, head_width / head_dist\n\n            # begin arrow\n            x0, y0 = path.vertices[0]\n            x1, y1 = path.vertices[1]\n\n            # If there is no room for an arrow and a line, then skip the arrow\n            has_begin_arrow = self.beginarrow and (x0, y0) != (x1, y1)\n            verticesA, codesA, ddxA, ddyA = (\n                self._get_arrow_wedge(x1, y1, x0, y0,\n                                      head_dist, cos_t, sin_t, linewidth)\n                if has_begin_arrow\n                else ([], [], 0, 0)\n            )\n\n            # end arrow\n            x2, y2 = path.vertices[-2]\n            x3, y3 = path.vertices[-1]\n\n            # If there is no room for an arrow and a line, then skip the arrow\n            has_end_arrow = self.endarrow and (x2, y2) != (x3, y3)\n            verticesB, codesB, ddxB, ddyB = (\n                self._get_arrow_wedge(x2, y2, x3, y3,\n                                      head_dist, cos_t, sin_t, linewidth)\n                if has_end_arrow\n                else ([], [], 0, 0)\n            )\n\n            # This simple code will not work if ddx, ddy is greater than the\n            # separation between vertices.\n            _path = [Path(np.concatenate([[(x0 + ddxA, y0 + ddyA)],\n                                          path.vertices[1:-1],\n                                          [(x3 + ddxB, y3 + ddyB)]]),\n                          path.codes)]\n            _fillable = [False]\n\n            if has_begin_arrow:\n                if self.fillbegin:\n                    p = np.concatenate([verticesA, [verticesA[0],\n                                                    verticesA[0]], ])\n                    c = np.concatenate([codesA, [Path.LINETO, Path.CLOSEPOLY]])\n                    _path.append(Path(p, c))\n                    _fillable.append(True)\n                else:\n                    _path.append(Path(verticesA, codesA))\n                    _fillable.append(False)\n\n            if has_end_arrow:\n                if self.fillend:\n                    _fillable.append(True)\n                    p = np.concatenate([verticesB, [verticesB[0],\n                                                    verticesB[0]], ])\n                    c = np.concatenate([codesB, [Path.LINETO, Path.CLOSEPOLY]])\n                    _path.append(Path(p, c))\n                else:\n                    _fillable.append(False)\n                    _path.append(Path(verticesB, codesB))\n\n            return _path, _fillable",
        "begin_line": 2964,
        "end_line": 3027,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.CurveA.__init__#3040",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.CurveA",
        "signature": "lib.matplotlib.patches.CurveA.__init__(self, head_length=0.4, head_width=0.2)",
        "snippet": "        def __init__(self, head_length=.4, head_width=.2):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, default: 0.4\n                Length of the arrow head.\n\n            head_width : float, default: 0.2\n                Width of the arrow head.\n            \"\"\"\n            super().__init__(beginarrow=True, endarrow=False,\n                             head_length=head_length, head_width=head_width)",
        "begin_line": 3040,
        "end_line": 3051,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.CurveB.__init__#3057",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.CurveB",
        "signature": "lib.matplotlib.patches.CurveB.__init__(self, head_length=0.4, head_width=0.2)",
        "snippet": "        def __init__(self, head_length=.4, head_width=.2):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, default: 0.4\n                Length of the arrow head.\n\n            head_width : float, default: 0.2\n                Width of the arrow head.\n            \"\"\"\n            super().__init__(beginarrow=False, endarrow=True,\n                             head_length=head_length, head_width=head_width)",
        "begin_line": 3057,
        "end_line": 3068,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.CurveAB.__init__#3074",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.CurveAB",
        "signature": "lib.matplotlib.patches.CurveAB.__init__(self, head_length=0.4, head_width=0.2)",
        "snippet": "        def __init__(self, head_length=.4, head_width=.2):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, default: 0.4\n                Length of the arrow head.\n\n            head_width : float, default: 0.2\n                Width of the arrow head.\n            \"\"\"\n            super().__init__(beginarrow=True, endarrow=True,\n                             head_length=head_length, head_width=head_width)",
        "begin_line": 3074,
        "end_line": 3085,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.CurveFilledA.__init__#3091",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.CurveFilledA",
        "signature": "lib.matplotlib.patches.CurveFilledA.__init__(self, head_length=0.4, head_width=0.2)",
        "snippet": "        def __init__(self, head_length=.4, head_width=.2):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, default: 0.4\n                Length of the arrow head.\n\n            head_width : float, default: 0.2\n                Width of the arrow head.\n            \"\"\"\n            super().__init__(beginarrow=True, endarrow=False,\n                             fillbegin=True, fillend=False,\n                             head_length=head_length, head_width=head_width)",
        "begin_line": 3091,
        "end_line": 3103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.CurveFilledB.__init__#3109",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.CurveFilledB",
        "signature": "lib.matplotlib.patches.CurveFilledB.__init__(self, head_length=0.4, head_width=0.2)",
        "snippet": "        def __init__(self, head_length=.4, head_width=.2):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, default: 0.4\n                Length of the arrow head.\n\n            head_width : float, default: 0.2\n                Width of the arrow head.\n            \"\"\"\n            super().__init__(beginarrow=False, endarrow=True,\n                             fillbegin=False, fillend=True,\n                             head_length=head_length, head_width=head_width)",
        "begin_line": 3109,
        "end_line": 3121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.CurveFilledAB.__init__#3127",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.CurveFilledAB",
        "signature": "lib.matplotlib.patches.CurveFilledAB.__init__(self, head_length=0.4, head_width=0.2)",
        "snippet": "        def __init__(self, head_length=.4, head_width=.2):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, default: 0.4\n                Length of the arrow head.\n\n            head_width : float, default: 0.2\n                Width of the arrow head.\n            \"\"\"\n            super().__init__(beginarrow=True, endarrow=True,\n                             fillbegin=True, fillend=True,\n                             head_length=head_length, head_width=head_width)",
        "begin_line": 3127,
        "end_line": 3139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches._Bracket.__init__#3143",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Bracket",
        "signature": "lib.matplotlib.patches._Bracket.__init__(self, bracketA=None, bracketB=None, widthA=1.0, widthB=1.0, lengthA=0.2, lengthB=0.2, angleA=None, angleB=None, scaleA=None, scaleB=None)",
        "snippet": "        def __init__(self, bracketA=None, bracketB=None,\n                     widthA=1., widthB=1.,\n                     lengthA=0.2, lengthB=0.2,\n                     angleA=None, angleB=None,\n                     scaleA=None, scaleB=None):\n            self.bracketA, self.bracketB = bracketA, bracketB\n            self.widthA, self.widthB = widthA, widthB\n            self.lengthA, self.lengthB = lengthA, lengthB\n            self.angleA, self.angleB = angleA, angleB\n            self.scaleA, self.scaleB = scaleA, scaleB",
        "begin_line": 3143,
        "end_line": 3152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches._Bracket._get_bracket#3154",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Bracket",
        "signature": "lib.matplotlib.patches._Bracket._get_bracket(self, x0, y0, cos_t, sin_t, width, length)",
        "snippet": "        def _get_bracket(self, x0, y0,\n                         cos_t, sin_t, width, length):\n\n            # arrow from x0, y0 to x1, y1\n            from matplotlib.bezier import get_normal_points\n            x1, y1, x2, y2 = get_normal_points(x0, y0, cos_t, sin_t, width)\n\n            dx, dy = length * cos_t, length * sin_t\n\n            vertices_arrow = [(x1 + dx, y1 + dy),\n                              (x1, y1),\n                              (x2, y2),\n                              (x2 + dx, y2 + dy)]\n            codes_arrow = [Path.MOVETO,\n                           Path.LINETO,\n                           Path.LINETO,\n                           Path.LINETO]\n\n            return vertices_arrow, codes_arrow",
        "begin_line": 3154,
        "end_line": 3172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches._Bracket.transmute#3174",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches._Bracket",
        "signature": "lib.matplotlib.patches._Bracket.transmute(self, path, mutation_size, linewidth)",
        "snippet": "        def transmute(self, path, mutation_size, linewidth):\n\n            if self.scaleA is None:\n                scaleA = mutation_size\n            else:\n                scaleA = self.scaleA\n\n            if self.scaleB is None:\n                scaleB = mutation_size\n            else:\n                scaleB = self.scaleB\n\n            vertices_list, codes_list = [], []\n\n            if self.bracketA:\n                x0, y0 = path.vertices[0]\n                x1, y1 = path.vertices[1]\n                cos_t, sin_t = get_cos_sin(x1, y1, x0, y0)\n                verticesA, codesA = self._get_bracket(x0, y0, cos_t, sin_t,\n                                                      self.widthA * scaleA,\n                                                      self.lengthA * scaleA)\n                vertices_list.append(verticesA)\n                codes_list.append(codesA)\n\n            vertices_list.append(path.vertices)\n            codes_list.append(path.codes)\n\n            if self.bracketB:\n                x0, y0 = path.vertices[-1]\n                x1, y1 = path.vertices[-2]\n                cos_t, sin_t = get_cos_sin(x1, y1, x0, y0)\n                verticesB, codesB = self._get_bracket(x0, y0, cos_t, sin_t,\n                                                      self.widthB * scaleB,\n                                                      self.lengthB * scaleB)\n                vertices_list.append(verticesB)\n                codes_list.append(codesB)\n\n            vertices = np.concatenate(vertices_list)\n            codes = np.concatenate(codes_list)\n\n            p = Path(vertices, codes)\n\n            return p, False",
        "begin_line": 3174,
        "end_line": 3216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.BracketAB.__init__#3222",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.BracketAB",
        "signature": "lib.matplotlib.patches.BracketAB.__init__(self, widthA=1.0, lengthA=0.2, angleA=None, widthB=1.0, lengthB=0.2, angleB=None)",
        "snippet": "        def __init__(self,\n                     widthA=1., lengthA=0.2, angleA=None,\n                     widthB=1., lengthB=0.2, angleB=None):\n            \"\"\"\n            Parameters\n            ----------\n            widthA : float, default: 1.0\n                Width of the bracket.\n\n            lengthA : float, default: 0.2\n                Length of the bracket.\n\n            angleA : float, default: None\n                Angle between the bracket and the line.\n\n            widthB : float, default: 1.0\n                Width of the bracket.\n\n            lengthB : float, default: 0.2\n                Length of the bracket.\n\n            angleB : float, default: None\n                Angle between the bracket and the line.\n            \"\"\"\n            super().__init__(True, True,\n                             widthA=widthA, lengthA=lengthA, angleA=angleA,\n                             widthB=widthB, lengthB=lengthB, angleB=angleB)",
        "begin_line": 3222,
        "end_line": 3248,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.BracketA.__init__#3254",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.BracketA",
        "signature": "lib.matplotlib.patches.BracketA.__init__(self, widthA=1.0, lengthA=0.2, angleA=None)",
        "snippet": "        def __init__(self, widthA=1., lengthA=0.2, angleA=None):\n            \"\"\"\n            Parameters\n            ----------\n            widthA : float, default: 1.0\n                Width of the bracket.\n\n            lengthA : float, default: 0.2\n                Length of the bracket.\n\n            angleA : float, default: None\n                Angle between the bracket and the line.\n            \"\"\"\n            super().__init__(True, None,\n                             widthA=widthA, lengthA=lengthA, angleA=angleA)",
        "begin_line": 3254,
        "end_line": 3268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.BracketB.__init__#3274",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.BracketB",
        "signature": "lib.matplotlib.patches.BracketB.__init__(self, widthB=1.0, lengthB=0.2, angleB=None)",
        "snippet": "        def __init__(self, widthB=1., lengthB=0.2, angleB=None):\n            \"\"\"\n            Parameters\n            ----------\n            widthB : float, default: 1.0\n                Width of the bracket.\n\n            lengthB : float, default: 0.2\n                Length of the bracket.\n\n            angleB : float, default: None\n                Angle between the bracket and the line.\n            \"\"\"\n            super().__init__(None, True,\n                             widthB=widthB, lengthB=lengthB, angleB=angleB)",
        "begin_line": 3274,
        "end_line": 3288,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.BarAB.__init__#3294",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.BarAB",
        "signature": "lib.matplotlib.patches.BarAB.__init__(self, widthA=1.0, angleA=None, widthB=1.0, angleB=None)",
        "snippet": "        def __init__(self,\n                     widthA=1., angleA=None,\n                     widthB=1., angleB=None):\n            \"\"\"\n            Parameters\n            ----------\n            widthA : float, default: 1.0\n                Width of the bracket.\n\n            angleA : float, default: None\n                Angle between the bracket and the line.\n\n            widthB : float, default: 1.0\n                Width of the bracket.\n\n            angleB : float, default: None\n                Angle between the bracket and the line.\n            \"\"\"\n            super().__init__(True, True,\n                             widthA=widthA, lengthA=0, angleA=angleA,\n                             widthB=widthB, lengthB=0, angleB=angleB)",
        "begin_line": 3294,
        "end_line": 3314,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Simple.__init__#3320",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Simple",
        "signature": "lib.matplotlib.patches.Simple.__init__(self, head_length=0.5, head_width=0.5, tail_width=0.2)",
        "snippet": "        def __init__(self, head_length=.5, head_width=.5, tail_width=.2):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, default: 0.5\n                Length of the arrow head.\n\n            head_width : float, default: 0.5\n                Width of the arrow head.\n\n            tail_width : float, default: 0.2\n                Width of the arrow tail.\n            \"\"\"\n            self.head_length, self.head_width, self.tail_width = \\\n                head_length, head_width, tail_width\n            super().__init__()",
        "begin_line": 3320,
        "end_line": 3335,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Simple.transmute#3337",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Simple",
        "signature": "lib.matplotlib.patches.Simple.transmute(self, path, mutation_size, linewidth)",
        "snippet": "        def transmute(self, path, mutation_size, linewidth):\n\n            x0, y0, x1, y1, x2, y2 = self.ensure_quadratic_bezier(path)\n\n            # divide the path into a head and a tail\n            head_length = self.head_length * mutation_size\n            in_f = inside_circle(x2, y2, head_length)\n            arrow_path = [(x0, y0), (x1, y1), (x2, y2)]\n\n            try:\n                arrow_out, arrow_in = \\\n                    split_bezier_intersecting_with_closedpath(\n                        arrow_path, in_f, tolerance=0.01)\n            except NonIntersectingPathException:\n                # if this happens, make a straight line of the head_length\n                # long.\n                x0, y0 = _point_along_a_line(x2, y2, x1, y1, head_length)\n                x1n, y1n = 0.5 * (x0 + x2), 0.5 * (y0 + y2)\n                arrow_in = [(x0, y0), (x1n, y1n), (x2, y2)]\n                arrow_out = None\n\n            # head\n            head_width = self.head_width * mutation_size\n            head_left, head_right = make_wedged_bezier2(arrow_in,\n                                                        head_width / 2., wm=.5)\n\n            # tail\n            if arrow_out is not None:\n                tail_width = self.tail_width * mutation_size\n                tail_left, tail_right = get_parallels(arrow_out,\n                                                      tail_width / 2.)\n\n                patch_path = [(Path.MOVETO, tail_right[0]),\n                              (Path.CURVE3, tail_right[1]),\n                              (Path.CURVE3, tail_right[2]),\n                              (Path.LINETO, head_right[0]),\n                              (Path.CURVE3, head_right[1]),\n                              (Path.CURVE3, head_right[2]),\n                              (Path.CURVE3, head_left[1]),\n                              (Path.CURVE3, head_left[0]),\n                              (Path.LINETO, tail_left[2]),\n                              (Path.CURVE3, tail_left[1]),\n                              (Path.CURVE3, tail_left[0]),\n                              (Path.LINETO, tail_right[0]),\n                              (Path.CLOSEPOLY, tail_right[0]),\n                              ]\n            else:\n                patch_path = [(Path.MOVETO, head_right[0]),\n                              (Path.CURVE3, head_right[1]),\n                              (Path.CURVE3, head_right[2]),\n                              (Path.CURVE3, head_left[1]),\n                              (Path.CURVE3, head_left[0]),\n                              (Path.CLOSEPOLY, head_left[0]),\n                              ]\n\n            path = Path([p for c, p in patch_path], [c for c, p in patch_path])\n\n            return path, True",
        "begin_line": 3337,
        "end_line": 3394,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Fancy.__init__#3400",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Fancy",
        "signature": "lib.matplotlib.patches.Fancy.__init__(self, head_length=0.4, head_width=0.4, tail_width=0.4)",
        "snippet": "        def __init__(self, head_length=.4, head_width=.4, tail_width=.4):\n            \"\"\"\n            Parameters\n            ----------\n            head_length : float, default: 0.4\n                Length of the arrow head.\n\n            head_width : float, default: 0.4\n                Width of the arrow head.\n\n            tail_width : float, default: 0.4\n                Width of the arrow tail.\n            \"\"\"\n            self.head_length, self.head_width, self.tail_width = \\\n                head_length, head_width, tail_width\n            super().__init__()",
        "begin_line": 3400,
        "end_line": 3415,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Fancy.transmute#3417",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Fancy",
        "signature": "lib.matplotlib.patches.Fancy.transmute(self, path, mutation_size, linewidth)",
        "snippet": "        def transmute(self, path, mutation_size, linewidth):\n\n            x0, y0, x1, y1, x2, y2 = self.ensure_quadratic_bezier(path)\n\n            # divide the path into a head and a tail\n            head_length = self.head_length * mutation_size\n            arrow_path = [(x0, y0), (x1, y1), (x2, y2)]\n\n            # path for head\n            in_f = inside_circle(x2, y2, head_length)\n            try:\n                path_out, path_in = split_bezier_intersecting_with_closedpath(\n                    arrow_path, in_f, tolerance=0.01)\n            except NonIntersectingPathException:\n                # if this happens, make a straight line of the head_length\n                # long.\n                x0, y0 = _point_along_a_line(x2, y2, x1, y1, head_length)\n                x1n, y1n = 0.5 * (x0 + x2), 0.5 * (y0 + y2)\n                arrow_path = [(x0, y0), (x1n, y1n), (x2, y2)]\n                path_head = arrow_path\n            else:\n                path_head = path_in\n\n            # path for head\n            in_f = inside_circle(x2, y2, head_length * .8)\n            path_out, path_in = split_bezier_intersecting_with_closedpath(\n                arrow_path, in_f, tolerance=0.01)\n            path_tail = path_out\n\n            # head\n            head_width = self.head_width * mutation_size\n            head_l, head_r = make_wedged_bezier2(path_head,\n                                                 head_width / 2.,\n                                                 wm=.6)\n\n            # tail\n            tail_width = self.tail_width * mutation_size\n            tail_left, tail_right = make_wedged_bezier2(path_tail,\n                                                        tail_width * .5,\n                                                        w1=1., wm=0.6, w2=0.3)\n\n            # path for head\n            in_f = inside_circle(x0, y0, tail_width * .3)\n            path_in, path_out = split_bezier_intersecting_with_closedpath(\n                arrow_path, in_f, tolerance=0.01)\n            tail_start = path_in[-1]\n\n            head_right, head_left = head_r, head_l\n            patch_path = [(Path.MOVETO, tail_start),\n                          (Path.LINETO, tail_right[0]),\n                          (Path.CURVE3, tail_right[1]),\n                          (Path.CURVE3, tail_right[2]),\n                          (Path.LINETO, head_right[0]),\n                          (Path.CURVE3, head_right[1]),\n                          (Path.CURVE3, head_right[2]),\n                          (Path.CURVE3, head_left[1]),\n                          (Path.CURVE3, head_left[0]),\n                          (Path.LINETO, tail_left[2]),\n                          (Path.CURVE3, tail_left[1]),\n                          (Path.CURVE3, tail_left[0]),\n                          (Path.LINETO, tail_start),\n                          (Path.CLOSEPOLY, tail_start),\n                          ]\n            path = Path([p for c, p in patch_path], [c for c, p in patch_path])\n\n            return path, True",
        "begin_line": 3417,
        "end_line": 3482,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge.__init__#3492",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge.__init__(self, tail_width=0.3, shrink_factor=0.5)",
        "snippet": "        def __init__(self, tail_width=.3, shrink_factor=0.5):\n            \"\"\"\n            Parameters\n            ----------\n            tail_width : float, default: 0.3\n                Width of the tail.\n\n            shrink_factor : float, default: 0.5\n                Fraction of the arrow width at the middle point.\n            \"\"\"\n            self.tail_width = tail_width\n            self.shrink_factor = shrink_factor\n            super().__init__()",
        "begin_line": 3492,
        "end_line": 3504,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.Wedge.transmute#3506",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.Wedge",
        "signature": "lib.matplotlib.patches.Wedge.transmute(self, path, mutation_size, linewidth)",
        "snippet": "        def transmute(self, path, mutation_size, linewidth):\n\n            x0, y0, x1, y1, x2, y2 = self.ensure_quadratic_bezier(path)\n\n            arrow_path = [(x0, y0), (x1, y1), (x2, y2)]\n            b_plus, b_minus = make_wedged_bezier2(\n                                    arrow_path,\n                                    self.tail_width * mutation_size / 2.,\n                                    wm=self.shrink_factor)\n\n            patch_path = [(Path.MOVETO, b_plus[0]),\n                          (Path.CURVE3, b_plus[1]),\n                          (Path.CURVE3, b_plus[2]),\n                          (Path.LINETO, b_minus[2]),\n                          (Path.CURVE3, b_minus[1]),\n                          (Path.CURVE3, b_minus[0]),\n                          (Path.CLOSEPOLY, b_minus[0]),\n                          ]\n            path = Path([p for c, p in patch_path], [c for c, p in patch_path])\n\n            return path, True",
        "begin_line": 3506,
        "end_line": 3526,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.__str__#3552",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.__str__(self)",
        "snippet": "    def __str__(self):\n        s = self.__class__.__name__ + \"((%g, %g), width=%g, height=%g)\"\n        return s % (self._x, self._y, self._width, self._height)",
        "begin_line": 3552,
        "end_line": 3554,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.__init__#3557",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.__init__(self, xy, width, height, boxstyle='round', bbox_transmuter=None, mutation_scale=1.0, mutation_aspect=None, **kwargs)",
        "snippet": "    def __init__(self, xy, width, height,\n                 boxstyle=\"round\",\n                 bbox_transmuter=None,\n                 mutation_scale=1.,\n                 mutation_aspect=None,\n                 **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        xy : float, float\n          The lower left corner of the box.\n\n        width : float\n            The width of the box.\n\n        height : float\n            The height of the box.\n\n        boxstyle : str or `matplotlib.patches.BoxStyle`\n            The style of the fancy box. This can either be a `.BoxStyle`\n            instance or a string of the style name and optionally comma\n            seprarated attributes (e.g. \"Round, pad=0.2\"). This string is\n            passed to `.BoxStyle` to construct a `.BoxStyle` object. See\n            there for a full documentation.\n\n            The following box styles are available:\n\n            %(AvailableBoxstyles)s\n\n        mutation_scale : float, default: 1\n            Scaling factor applied to the attributes of the box style\n            (e.g. pad or rounding_size).\n\n        mutation_aspect : float, optional\n            The height of the rectangle will be squeezed by this value before\n            the mutation and the mutated box will be stretched by the inverse\n            of it. For example, this allows different horizontal and vertical\n            padding.\n\n        Other Parameters\n        ----------------\n        **kwargs : `.Patch` properties\n\n        %(Patch)s\n        \"\"\"\n\n        Patch.__init__(self, **kwargs)\n\n        self._x = xy[0]\n        self._y = xy[1]\n        self._width = width\n        self._height = height\n\n        if boxstyle == \"custom\":\n            if bbox_transmuter is None:\n                raise ValueError(\"bbox_transmuter argument is needed with \"\n                                 \"custom boxstyle\")\n            self._bbox_transmuter = bbox_transmuter\n        else:\n            self.set_boxstyle(boxstyle)\n\n        self._mutation_scale = mutation_scale\n        self._mutation_aspect = mutation_aspect\n\n        self.stale = True",
        "begin_line": 3557,
        "end_line": 3621,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00033967391304347825,
            "pseudo_dstar_susp": 0.0003223726627981947,
            "pseudo_tarantula_susp": 0.00043010752688172043,
            "pseudo_op2_susp": 0.0003223726627981947,
            "pseudo_barinel_susp": 0.00043010752688172043
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.set_boxstyle#3624",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.set_boxstyle(self, boxstyle=None, **kwargs)",
        "snippet": "    def set_boxstyle(self, boxstyle=None, **kwargs):\n        \"\"\"\n        Set the box style.\n\n        Most box styles can be further configured using attributes.\n        Attributes from the previous box style are not reused.\n\n        Without argument (or with ``boxstyle=None``), the available box styles\n        are returned as a human-readable string.\n\n        Parameters\n        ----------\n        boxstyle : str\n            The name of the box style. Optionally, followed by a comma and a\n            comma-separated list of attributes. The attributes may\n            alternatively be passed separately as keyword arguments.\n\n            The following box styles are available:\n\n            %(AvailableBoxstyles)s\n\n            .. ACCEPTS: %(ListBoxstyles)s\n\n        **kwargs\n            Additional attributes for the box style. See the table above for\n            supported parameters.\n\n        Examples\n        --------\n        ::\n\n            set_boxstyle(\"round,pad=0.2\")\n            set_boxstyle(\"round\", pad=0.2)\n\n        \"\"\"\n        if boxstyle is None:\n            return BoxStyle.pprint_styles()\n\n        if isinstance(boxstyle, BoxStyle._Base) or callable(boxstyle):\n            self._bbox_transmuter = boxstyle\n        else:\n            self._bbox_transmuter = BoxStyle(boxstyle, **kwargs)\n        self.stale = True",
        "begin_line": 3624,
        "end_line": 3666,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003471017007983339,
            "pseudo_dstar_susp": 0.0003243593902043464,
            "pseudo_tarantula_susp": 0.00043821209465381246,
            "pseudo_op2_susp": 0.0003243593902043464,
            "pseudo_barinel_susp": 0.00043821209465381246
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.set_mutation_scale#3668",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.set_mutation_scale(self, scale)",
        "snippet": "    def set_mutation_scale(self, scale):\n        \"\"\"\n        Set the mutation scale.\n\n        Parameters\n        ----------\n        scale : float\n        \"\"\"\n        self._mutation_scale = scale\n        self.stale = True",
        "begin_line": 3668,
        "end_line": 3677,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004752851711026616,
            "pseudo_dstar_susp": 0.00040241448692152917,
            "pseudo_tarantula_susp": 0.0017482517482517483,
            "pseudo_op2_susp": 0.00040241448692152917,
            "pseudo_barinel_susp": 0.0017482517482517483
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.get_mutation_scale#3679",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.get_mutation_scale(self)",
        "snippet": "    def get_mutation_scale(self):\n        \"\"\"Return the mutation scale.\"\"\"\n        return self._mutation_scale",
        "begin_line": 3679,
        "end_line": 3681,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004752851711026616,
            "pseudo_dstar_susp": 0.00040241448692152917,
            "pseudo_tarantula_susp": 0.0017482517482517483,
            "pseudo_op2_susp": 0.00040241448692152917,
            "pseudo_barinel_susp": 0.0017482517482517483
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.get_mutation_aspect#3694",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.get_mutation_aspect(self)",
        "snippet": "    def get_mutation_aspect(self):\n        \"\"\"Return the aspect ratio of the bbox mutation.\"\"\"\n        return self._mutation_aspect",
        "begin_line": 3694,
        "end_line": 3696,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000392156862745098,
            "pseudo_dstar_susp": 0.0003606202668589975,
            "pseudo_tarantula_susp": 0.0008561643835616438,
            "pseudo_op2_susp": 0.0003606202668589975,
            "pseudo_barinel_susp": 0.0008561643835616438
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.get_path#3702",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.get_path(self)",
        "snippet": "    def get_path(self):\n        \"\"\"Return the mutated path of the rectangle.\"\"\"\n        _path = self.get_boxstyle()(self._x, self._y,\n                                    self._width, self._height,\n                                    self.get_mutation_scale(),\n                                    self.get_mutation_aspect())\n        return _path",
        "begin_line": 3702,
        "end_line": 3708,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004975124378109452,
            "pseudo_dstar_susp": 0.00040404040404040404,
            "pseudo_tarantula_susp": 0.0017921146953405018,
            "pseudo_op2_susp": 0.00040404040404040404,
            "pseudo_barinel_susp": 0.0017921146953405018
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyBboxPatch.set_bounds#3772",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyBboxPatch",
        "signature": "lib.matplotlib.patches.FancyBboxPatch.set_bounds(self, *args)",
        "snippet": "    def set_bounds(self, *args):\n        \"\"\"\n        Set the bounds of the rectangle.\n\n        Call signatures::\n\n            set_bounds(left, bottom, width, height)\n            set_bounds((left, bottom, width, height))\n\n        Parameters\n        ----------\n        left, bottom : float\n            The coordinates of the bottom left corner of the rectangle.\n        width, height : float\n            The width/height of the rectangle.\n        \"\"\"\n        if len(args) == 1:\n            l, b, w, h = args[0]\n        else:\n            l, b, w, h = args\n        self._x = l\n        self._y = b\n        self._width = w\n        self._height = h\n        self.stale = True",
        "begin_line": 3772,
        "end_line": 3796,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00047214353163361664,
            "pseudo_dstar_susp": 0.00040064102564102563,
            "pseudo_tarantula_susp": 0.0017064846416382253,
            "pseudo_op2_susp": 0.00040064102564102563,
            "pseudo_barinel_susp": 0.0017064846416382253
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.__str__#3814",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.__str__(self)",
        "snippet": "    def __str__(self):\n        if self._posA_posB is not None:\n            (x1, y1), (x2, y2) = self._posA_posB\n            return f\"{type(self).__name__}(({x1:g}, {y1:g})->({x2:g}, {y2:g}))\"\n        else:\n            return f\"{type(self).__name__}({self._path_original})\"",
        "begin_line": 3814,
        "end_line": 3819,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.__init__#3822",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.__init__(self, posA=None, posB=None, path=None, arrowstyle='simple', arrow_transmuter=None, connectionstyle='arc3', connector=None, patchA=None, patchB=None, shrinkA=2, shrinkB=2, mutation_scale=1, mutation_aspect=None, dpi_cor=1, **kwargs)",
        "snippet": "    def __init__(self, posA=None, posB=None,\n                 path=None,\n                 arrowstyle=\"simple\",\n                 arrow_transmuter=None,\n                 connectionstyle=\"arc3\",\n                 connector=None,\n                 patchA=None,\n                 patchB=None,\n                 shrinkA=2,\n                 shrinkB=2,\n                 mutation_scale=1,\n                 mutation_aspect=None,\n                 dpi_cor=1,\n                 **kwargs):\n        \"\"\"\n        There are two ways for defining an arrow:\n\n        - If *posA* and *posB* are given, a path connecting two points is\n          created according to *connectionstyle*. The path will be\n          clipped with *patchA* and *patchB* and further shrunken by\n          *shrinkA* and *shrinkB*. An arrow is drawn along this\n          resulting path using the *arrowstyle* parameter.\n\n        - Alternatively if *path* is provided, an arrow is drawn along this\n          path and *patchA*, *patchB*, *shrinkA*, and *shrinkB* are ignored.\n\n        Parameters\n        ----------\n        posA, posB : (float, float), default: None\n            (x, y) coordinates of arrow tail and arrow head respectively.\n\n        path : `~matplotlib.path.Path`, default: None\n            If provided, an arrow is drawn along this path and *patchA*,\n            *patchB*, *shrinkA*, and *shrinkB* are ignored.\n\n        arrowstyle : str or `.ArrowStyle`, default: 'simple'\n            The `.ArrowStyle` with which the fancy arrow is drawn.  If a\n            string, it should be one of the available arrowstyle names, with\n            optional comma-separated attributes.  The optional attributes are\n            meant to be scaled with the *mutation_scale*.  The following arrow\n            styles are available:\n\n            %(AvailableArrowstyles)s\n\n        arrow_transmuter\n            Ignored.\n\n        connectionstyle : str or `.ConnectionStyle` or None, optional, \\\ndefault: 'arc3'\n            The `.ConnectionStyle` with which *posA* and *posB* are connected.\n            If a string, it should be one of the available connectionstyle\n            names, with optional comma-separated attributes.  The following\n            connection styles are available:\n\n            %(AvailableConnectorstyles)s\n\n        connector\n            Ignored.\n\n        patchA, patchB : `.Patch`, default: None\n            Head and tail patches, respectively.\n\n        shrinkA, shrinkB : float, default: 2\n            Shrinking factor of the tail and head of the arrow respectively.\n\n        mutation_scale : float, default: 1\n            Value with which attributes of *arrowstyle* (e.g., *head_length*)\n            will be scaled.\n\n        mutation_aspect : None or float, default: None\n            The height of the rectangle will be squeezed by this value before\n            the mutation and the mutated box will be stretched by the inverse\n            of it.\n\n        dpi_cor : float, default: 1\n            dpi_cor is currently used for linewidth-related things and shrink\n            factor. Mutation scale is affected by this.\n\n        Other Parameters\n        ----------------\n        **kwargs : `.Patch` properties, optional\n            Here is a list of available `.Patch` properties:\n\n        %(Patch)s\n\n            In contrast to other patches, the default ``capstyle`` and\n            ``joinstyle`` for `FancyArrowPatch` are set to ``\"round\"``.\n        \"\"\"\n        if arrow_transmuter is not None:\n            cbook.warn_deprecated(\n                3.0,\n                message=('The \"arrow_transmuter\" keyword argument is not used,'\n                         ' and will be removed in Matplotlib 3.1'),\n                name='arrow_transmuter',\n                obj_type='keyword argument')\n        if connector is not None:\n            cbook.warn_deprecated(\n                3.0,\n                message=('The \"connector\" keyword argument is not used,'\n                         ' and will be removed in Matplotlib 3.1'),\n                name='connector',\n                obj_type='keyword argument')\n        # Traditionally, the cap- and joinstyle for FancyArrowPatch are round\n        kwargs.setdefault(\"joinstyle\", \"round\")\n        kwargs.setdefault(\"capstyle\", \"round\")\n\n        Patch.__init__(self, **kwargs)\n\n        if posA is not None and posB is not None and path is None:\n            self._posA_posB = [posA, posB]\n\n            if connectionstyle is None:\n                connectionstyle = \"arc3\"\n            self.set_connectionstyle(connectionstyle)\n\n        elif posA is None and posB is None and path is not None:\n            self._posA_posB = None\n        else:\n            raise ValueError(\"Either posA and posB, or path need to provided\")\n\n        self.patchA = patchA\n        self.patchB = patchB\n        self.shrinkA = shrinkA\n        self.shrinkB = shrinkB\n\n        self._path_original = path\n\n        self.set_arrowstyle(arrowstyle)\n\n        self._mutation_scale = mutation_scale\n        self._mutation_aspect = mutation_aspect\n\n        self.set_dpi_cor(dpi_cor)",
        "begin_line": 3822,
        "end_line": 3954,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.set_dpi_cor#3956",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.set_dpi_cor(self, dpi_cor)",
        "snippet": "    def set_dpi_cor(self, dpi_cor):\n        \"\"\"\n        dpi_cor is currently used for linewidth-related things and\n        shrink factor. Mutation scale is affected by this.\n\n        Parameters\n        ----------\n        dpi_cor : scalar\n        \"\"\"\n        self._dpi_cor = dpi_cor\n        self.stale = True",
        "begin_line": 3956,
        "end_line": 3966,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.get_dpi_cor#3968",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.get_dpi_cor(self)",
        "snippet": "    def get_dpi_cor(self):\n        \"\"\"\n        dpi_cor is currently used for linewidth-related things and\n        shrink factor. Mutation scale is affected by this.\n\n        Returns\n        -------\n        dpi_cor : scalar\n        \"\"\"\n        return self._dpi_cor",
        "begin_line": 3968,
        "end_line": 3977,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.set_positions#3979",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.set_positions(self, posA, posB)",
        "snippet": "    def set_positions(self, posA, posB):\n        \"\"\"\n        Set the begin and end positions of the connecting path.\n\n        Parameters\n        ----------\n        posA, posB : None, tuple\n            (x, y) coordinates of arrow tail and arrow head respectively. If\n            `None` use current value.\n        \"\"\"\n        if posA is not None:\n            self._posA_posB[0] = posA\n        if posB is not None:\n            self._posA_posB[1] = posB\n        self.stale = True",
        "begin_line": 3979,
        "end_line": 3993,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.set_patchA#3995",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.set_patchA(self, patchA)",
        "snippet": "    def set_patchA(self, patchA):\n        \"\"\"\n        Set the tail patch.\n\n        Parameters\n        ----------\n        patchA : `.patches.Patch`\n        \"\"\"\n        self.patchA = patchA\n        self.stale = True",
        "begin_line": 3995,
        "end_line": 4004,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.set_connectionstyle#4017",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.set_connectionstyle(self, connectionstyle, **kw)",
        "snippet": "    def set_connectionstyle(self, connectionstyle, **kw):\n        \"\"\"\n        Set the connection style. Old attributes are forgotten.\n\n        Parameters\n        ----------\n        connectionstyle : str or `.ConnectionStyle` or None, optional\n            Can be a string with connectionstyle name with\n            optional comma-separated attributes, e.g.::\n\n                set_connectionstyle(\"arc,angleA=0,armA=30,rad=10\")\n\n            Alternatively, the attributes can be provided as keywords, e.g.::\n\n                set_connectionstyle(\"arc\", angleA=0,armA=30,rad=10)\n\n            Without any arguments (or with ``connectionstyle=None``), return\n            available styles as a list of strings.\n        \"\"\"\n\n        if connectionstyle is None:\n            return ConnectionStyle.pprint_styles()\n\n        if (isinstance(connectionstyle, ConnectionStyle._Base) or\n                callable(connectionstyle)):\n            self._connector = connectionstyle\n        else:\n            self._connector = ConnectionStyle(connectionstyle, **kw)\n        self.stale = True",
        "begin_line": 4017,
        "end_line": 4045,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.get_connectionstyle#4047",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.get_connectionstyle(self)",
        "snippet": "    def get_connectionstyle(self):\n        \"\"\"Return the `ConnectionStyle` used.\"\"\"\n        return self._connector",
        "begin_line": 4047,
        "end_line": 4049,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.set_arrowstyle#4051",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.set_arrowstyle(self, arrowstyle=None, **kw)",
        "snippet": "    def set_arrowstyle(self, arrowstyle=None, **kw):\n        \"\"\"\n        Set the arrow style. Old attributes are forgotten. Without arguments\n        (or with ``arrowstyle=None``) returns available box styles as a list of\n        strings.\n\n        Parameters\n        ----------\n        arrowstyle : None or ArrowStyle or str, default: None\n            Can be a string with arrowstyle name with optional comma-separated\n            attributes, e.g.::\n\n                set_arrowstyle(\"Fancy,head_length=0.2\")\n\n            Alternatively attributes can be provided as keywords, e.g.::\n\n                set_arrowstyle(\"fancy\", head_length=0.2)\n\n        \"\"\"\n\n        if arrowstyle is None:\n            return ArrowStyle.pprint_styles()\n\n        if isinstance(arrowstyle, ArrowStyle._Base):\n            self._arrow_transmuter = arrowstyle\n        else:\n            self._arrow_transmuter = ArrowStyle(arrowstyle, **kw)\n        self.stale = True",
        "begin_line": 4051,
        "end_line": 4078,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.get_arrowstyle#4080",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.get_arrowstyle(self)",
        "snippet": "    def get_arrowstyle(self):\n        \"\"\"Return the arrowstyle object.\"\"\"\n        return self._arrow_transmuter",
        "begin_line": 4080,
        "end_line": 4082,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.set_mutation_scale#4084",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.set_mutation_scale(self, scale)",
        "snippet": "    def set_mutation_scale(self, scale):\n        \"\"\"\n        Set the mutation scale.\n\n        Parameters\n        ----------\n        scale : scalar\n        \"\"\"\n        self._mutation_scale = scale\n        self.stale = True",
        "begin_line": 4084,
        "end_line": 4093,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.get_mutation_scale#4095",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.get_mutation_scale(self)",
        "snippet": "    def get_mutation_scale(self):\n        \"\"\"\n        Return the mutation scale.\n\n        Returns\n        -------\n        scale : scalar\n        \"\"\"\n        return self._mutation_scale",
        "begin_line": 4095,
        "end_line": 4103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.get_mutation_aspect#4116",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.get_mutation_aspect(self)",
        "snippet": "    def get_mutation_aspect(self):\n        \"\"\"Return the aspect ratio of the bbox mutation.\"\"\"\n        return self._mutation_aspect",
        "begin_line": 4116,
        "end_line": 4118,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.get_path#4120",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.get_path(self)",
        "snippet": "    def get_path(self):\n        \"\"\"\n        Return the path of the arrow in the data coordinates. Use\n        get_path_in_displaycoord() method to retrieve the arrow path\n        in display coordinates.\n        \"\"\"\n        _path, fillable = self.get_path_in_displaycoord()\n        if np.iterable(fillable):\n            _path = concatenate_paths(_path)\n        return self.get_transform().inverted().transform_path(_path)",
        "begin_line": 4120,
        "end_line": 4129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.get_path_in_displaycoord#4131",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.get_path_in_displaycoord(self)",
        "snippet": "    def get_path_in_displaycoord(self):\n        \"\"\"Return the mutated path of the arrow in display coordinates.\"\"\"\n        dpi_cor = self.get_dpi_cor()\n\n        if self._posA_posB is not None:\n            posA = self._convert_xy_units(self._posA_posB[0])\n            posB = self._convert_xy_units(self._posA_posB[1])\n            (posA, posB) = self.get_transform().transform((posA, posB))\n            _path = self.get_connectionstyle()(posA, posB,\n                                               patchA=self.patchA,\n                                               patchB=self.patchB,\n                                               shrinkA=self.shrinkA * dpi_cor,\n                                               shrinkB=self.shrinkB * dpi_cor\n                                               )\n        else:\n            _path = self.get_transform().transform_path(self._path_original)\n\n        _path, fillable = self.get_arrowstyle()(\n            _path,\n            self.get_mutation_scale() * dpi_cor,\n            self.get_linewidth() * dpi_cor,\n            self.get_mutation_aspect())\n\n        # if not fillable:\n        #    self._fill = False\n\n        return _path, fillable",
        "begin_line": 4131,
        "end_line": 4157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010421008753647353,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.FancyArrowPatch.draw#4159",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.FancyArrowPatch",
        "signature": "lib.matplotlib.patches.FancyArrowPatch.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            return\n\n        with self._bind_draw_path_function(renderer) as draw_path:\n\n            # FIXME : dpi_cor is for the dpi-dependency of the linewidth. There\n            # could be room for improvement.\n            self.set_dpi_cor(renderer.points_to_pixels(1.))\n            path, fillable = self.get_path_in_displaycoord()\n\n            if not np.iterable(fillable):\n                path = [path]\n                fillable = [fillable]\n\n            affine = transforms.IdentityTransform()\n\n            for p, f in zip(path, fillable):\n                draw_path(\n                    p, affine,\n                    self._facecolor if f and self._facecolor[3] else None)",
        "begin_line": 4159,
        "end_line": 4179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.ConnectionPatch.__str__#4185",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.ConnectionPatch",
        "signature": "lib.matplotlib.patches.ConnectionPatch.__str__(self)",
        "snippet": "    def __str__(self):\n        return \"ConnectionPatch((%g, %g), (%g, %g))\" % \\\n               (self.xy1[0], self.xy1[1], self.xy2[0], self.xy2[1])",
        "begin_line": 4185,
        "end_line": 4187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.ConnectionPatch.__init__#4190",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.ConnectionPatch",
        "signature": "lib.matplotlib.patches.ConnectionPatch.__init__(self, xyA, xyB, coordsA, coordsB=None, axesA=None, axesB=None, arrowstyle='-', arrow_transmuter=None, connectionstyle='arc3', connector=None, patchA=None, patchB=None, shrinkA=0.0, shrinkB=0.0, mutation_scale=10.0, mutation_aspect=None, clip_on=False, dpi_cor=1.0, **kwargs)",
        "snippet": "    def __init__(self, xyA, xyB, coordsA, coordsB=None,\n                 axesA=None, axesB=None,\n                 arrowstyle=\"-\",\n                 arrow_transmuter=None,\n                 connectionstyle=\"arc3\",\n                 connector=None,\n                 patchA=None,\n                 patchB=None,\n                 shrinkA=0.,\n                 shrinkB=0.,\n                 mutation_scale=10.,\n                 mutation_aspect=None,\n                 clip_on=False,\n                 dpi_cor=1.,\n                 **kwargs):\n        \"\"\"Connect point *xyA* in *coordsA* with point *xyB* in *coordsB*\n\n        Valid keys are\n\n        ===============  ======================================================\n        Key              Description\n        ===============  ======================================================\n        arrowstyle       the arrow style\n        connectionstyle  the connection style\n        relpos           default is (0.5, 0.5)\n        patchA           default is bounding box of the text\n        patchB           default is None\n        shrinkA          default is 2 points\n        shrinkB          default is 2 points\n        mutation_scale   default is text size (in points)\n        mutation_aspect  default is 1.\n        ?                any key for `matplotlib.patches.PathPatch`\n        ===============  ======================================================\n\n        *coordsA* and *coordsB* are strings that indicate the\n        coordinates of *xyA* and *xyB*.\n\n        =================  ===================================================\n        Property           Description\n        =================  ===================================================\n        'figure points'    points from the lower left corner of the figure\n        'figure pixels'    pixels from the lower left corner of the figure\n        'figure fraction'  0, 0 is lower left of figure and 1, 1 is upper right\n        'axes points'      points from lower left corner of axes\n        'axes pixels'      pixels from lower left corner of axes\n        'axes fraction'    0, 0 is lower left of axes and 1, 1 is upper right\n        'data'             use the coordinate system of the object being\n                           annotated (default)\n        'offset points'    offset (in points) from the *xy* value\n        'polar'            you can specify *theta*, *r* for the annotation,\n                           even in cartesian plots.  Note that if you are using\n                           a polar axes, you do not need to specify polar for\n                           the coordinate system since that is the native\n                           \"data\" coordinate system.\n        =================  ===================================================\n\n        Alternatively they can be set to any valid\n        `~matplotlib.transforms.Transform`.\n\n        .. note::\n\n           Using `ConnectionPatch` across two `~.axes.Axes` instances\n           is not directly compatible with :doc:`constrained layout\n           </tutorials/intermediate/constrainedlayout_guide>`. Add the artist\n           directly to the `.Figure` instead of adding it to a specific Axes.\n\n           .. code-block:: default\n\n              fig, ax = plt.subplots(1, 2, constrained_layout=True)\n              con = ConnectionPatch(..., axesA=ax[0], axesB=ax[1])\n              fig.add_artist(con)\n\n        \"\"\"\n        if coordsB is None:\n            coordsB = coordsA\n        # we'll draw ourself after the artist we annotate by default\n        self.xy1 = xyA\n        self.xy2 = xyB\n        self.coords1 = coordsA\n        self.coords2 = coordsB\n\n        self.axesA = axesA\n        self.axesB = axesB\n\n        FancyArrowPatch.__init__(self,\n                                 posA=(0, 0), posB=(1, 1),\n                                 arrowstyle=arrowstyle,\n                                 arrow_transmuter=arrow_transmuter,\n                                 connectionstyle=connectionstyle,\n                                 connector=connector,\n                                 patchA=patchA,\n                                 patchB=patchB,\n                                 shrinkA=shrinkA,\n                                 shrinkB=shrinkB,\n                                 mutation_scale=mutation_scale,\n                                 mutation_aspect=mutation_aspect,\n                                 clip_on=clip_on,\n                                 dpi_cor=dpi_cor,\n                                 **kwargs)\n\n        # if True, draw annotation only if self.xy is inside the axes\n        self._annotation_clip = None",
        "begin_line": 4190,
        "end_line": 4291,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.ConnectionPatch._get_xy#4293",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.ConnectionPatch",
        "signature": "lib.matplotlib.patches.ConnectionPatch._get_xy(self, x, y, s, axes=None)",
        "snippet": "    def _get_xy(self, x, y, s, axes=None):\n        \"\"\"Calculate the pixel position of given point.\"\"\"\n        if axes is None:\n            axes = self.axes\n\n        if s == 'data':\n            trans = axes.transData\n            x = float(self.convert_xunits(x))\n            y = float(self.convert_yunits(y))\n            return trans.transform((x, y))\n        elif s == 'offset points':\n            # convert the data point\n            dx, dy = self.xy\n\n            # prevent recursion\n            if self.xycoords == 'offset points':\n                return self._get_xy(dx, dy, 'data')\n\n            dx, dy = self._get_xy(dx, dy, self.xycoords)\n\n            # convert the offset\n            dpi = self.figure.get_dpi()\n            x *= dpi / 72.\n            y *= dpi / 72.\n\n            # add the offset to the data point\n            x += dx\n            y += dy\n\n            return x, y\n        elif s == 'polar':\n            theta, r = x, y\n            x = r * np.cos(theta)\n            y = r * np.sin(theta)\n            trans = axes.transData\n            return trans.transform((x, y))\n        elif s == 'figure points':\n            # points from the lower left corner of the figure\n            dpi = self.figure.dpi\n            l, b, w, h = self.figure.bbox.bounds\n            r = l + w\n            t = b + h\n\n            x *= dpi / 72.\n            y *= dpi / 72.\n            if x < 0:\n                x = r + x\n            if y < 0:\n                y = t + y\n            return x, y\n        elif s == 'figure pixels':\n            # pixels from the lower left corner of the figure\n            l, b, w, h = self.figure.bbox.bounds\n            r = l + w\n            t = b + h\n            if x < 0:\n                x = r + x\n            if y < 0:\n                y = t + y\n            return x, y\n        elif s == 'figure fraction':\n            # (0, 0) is lower left, (1, 1) is upper right of figure\n            trans = self.figure.transFigure\n            return trans.transform((x, y))\n        elif s == 'axes points':\n            # points from the lower left corner of the axes\n            dpi = self.figure.dpi\n            l, b, w, h = axes.bbox.bounds\n            r = l + w\n            t = b + h\n            if x < 0:\n                x = r + x * dpi / 72.\n            else:\n                x = l + x * dpi / 72.\n            if y < 0:\n                y = t + y * dpi / 72.\n            else:\n                y = b + y * dpi / 72.\n            return x, y\n        elif s == 'axes pixels':\n            # pixels from the lower left corner of the axes\n            l, b, w, h = axes.bbox.bounds\n            r = l + w\n            t = b + h\n            if x < 0:\n                x = r + x\n            else:\n                x = l + x\n            if y < 0:\n                y = t + y\n            else:\n                y = b + y\n            return x, y\n        elif s == 'axes fraction':\n            # (0, 0) is lower left, (1, 1) is upper right of axes\n            trans = axes.transAxes\n            return trans.transform((x, y))\n        elif isinstance(s, transforms.Transform):\n            return s.transform((x, y))\n        else:\n            raise ValueError(\"{} is not a valid coordinate \"\n                             \"transformation.\".format(s))",
        "begin_line": 4293,
        "end_line": 4394,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.ConnectionPatch.get_annotation_clip#4414",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.ConnectionPatch",
        "signature": "lib.matplotlib.patches.ConnectionPatch.get_annotation_clip(self)",
        "snippet": "    def get_annotation_clip(self):\n        \"\"\"\n        Return the clipping behavior.\n\n        See `.set_annotation_clip` for the meaning of the return value.\n        \"\"\"\n        return self._annotation_clip",
        "begin_line": 4414,
        "end_line": 4420,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.ConnectionPatch.get_path_in_displaycoord#4422",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.ConnectionPatch",
        "signature": "lib.matplotlib.patches.ConnectionPatch.get_path_in_displaycoord(self)",
        "snippet": "    def get_path_in_displaycoord(self):\n        \"\"\"Return the mutated path of the arrow in display coordinates.\"\"\"\n\n        dpi_cor = self.get_dpi_cor()\n\n        x, y = self.xy1\n        posA = self._get_xy(x, y, self.coords1, self.axesA)\n\n        x, y = self.xy2\n        posB = self._get_xy(x, y, self.coords2, self.axesB)\n\n        _path = self.get_connectionstyle()(posA, posB,\n                                           patchA=self.patchA,\n                                           patchB=self.patchB,\n                                           shrinkA=self.shrinkA * dpi_cor,\n                                           shrinkB=self.shrinkB * dpi_cor\n                                           )\n\n        _path, fillable = self.get_arrowstyle()(\n                                        _path,\n                                        self.get_mutation_scale() * dpi_cor,\n                                        self.get_linewidth() * dpi_cor,\n                                        self.get_mutation_aspect()\n                                        )\n\n        return _path, fillable",
        "begin_line": 4422,
        "end_line": 4447,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.ConnectionPatch._check_xy#4449",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.ConnectionPatch",
        "signature": "lib.matplotlib.patches.ConnectionPatch._check_xy(self, renderer)",
        "snippet": "    def _check_xy(self, renderer):\n        \"\"\"Check whether the annotation needs to be drawn.\"\"\"\n\n        b = self.get_annotation_clip()\n\n        if b or (b is None and self.coords1 == \"data\"):\n            x, y = self.xy1\n            xy_pixel = self._get_xy(x, y, self.coords1, self.axesA)\n            if self.axesA is None:\n                axes = self.axes\n            else:\n                axes = self.axesA\n            if not axes.contains_point(xy_pixel):\n                return False\n\n        if b or (b is None and self.coords2 == \"data\"):\n            x, y = self.xy2\n            xy_pixel = self._get_xy(x, y, self.coords2, self.axesB)\n            if self.axesB is None:\n                axes = self.axes\n            else:\n                axes = self.axesB\n            if not axes.contains_point(xy_pixel):\n                return False\n\n        return True",
        "begin_line": 4449,
        "end_line": 4474,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.patches.ConnectionPatch.draw#4476",
        "src_path": "lib/matplotlib/patches.py",
        "class_name": "lib.matplotlib.patches.ConnectionPatch",
        "signature": "lib.matplotlib.patches.ConnectionPatch.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        if renderer is not None:\n            self._renderer = renderer\n        if not self.get_visible() or not self._check_xy(renderer):\n            return\n        FancyArrowPatch.draw(self, renderer)",
        "begin_line": 4476,
        "end_line": 4481,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation._generate_deprecation_warning#24",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation._generate_deprecation_warning(since, message='', name='', alternative='', pending=False, obj_type='', addendum='', *, removal='')",
        "snippet": "def _generate_deprecation_warning(\n        since, message='', name='', alternative='', pending=False, obj_type='',\n        addendum='', *, removal=''):\n    if pending:\n        if removal:\n            raise ValueError(\n                \"A pending deprecation cannot have a scheduled removal\")\n    else:\n        if removal:\n            removal = \"in {}\".format(removal)\n        else:\n            removal = {\"2.2\": \"in 3.1\", \"3.0\": \"in 3.2\", \"3.1\": \"in 3.3\"}.get(\n                since, \"two minor releases later\")\n    if not message:\n        message = (\n            \"\\nThe %(name)s %(obj_type)s\"\n            + (\" will be deprecated in a future version\"\n               if pending else\n               (\" was deprecated in Matplotlib %(since)s\"\n                + (\" and will be removed %(removal)s\"\n                   if removal else\n                   \"\")))\n            + \".\"\n            + (\" Use %(alternative)s instead.\" if alternative else \"\")\n            + (\" %(addendum)s\" if addendum else \"\"))\n    warning_cls = (PendingDeprecationWarning if pending\n                   else MatplotlibDeprecationWarning)\n    return warning_cls(message % dict(\n        func=name, name=name, obj_type=obj_type, since=since, removal=removal,\n        alternative=alternative, addendum=addendum))",
        "begin_line": 24,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004016064257028112,
            "pseudo_dstar_susp": 0.1,
            "pseudo_tarantula_susp": 0.000357653791130186,
            "pseudo_op2_susp": 0.2,
            "pseudo_barinel_susp": 0.000357653791130186
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation.warn_deprecated#56",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation.warn_deprecated(since, *, message='', name='', alternative='', pending=False, obj_type='', addendum='', removal='')",
        "snippet": "def warn_deprecated(\n        since, *, message='', name='', alternative='', pending=False,\n        obj_type='', addendum='', removal=''):\n    \"\"\"\n    Display a standardized deprecation.\n\n    Parameters\n    ----------\n    since : str\n        The release at which this API became deprecated.\n\n    message : str, optional\n        Override the default deprecation message.  The ``%(since)s``,\n        ``%(name)s``, ``%(alternative)s``, ``%(obj_type)s``, ``%(addendum)s``,\n        and ``%(removal)s`` format specifiers will be replaced by the values\n        of the respective arguments passed to this function.\n\n    name : str, optional\n        The name of the deprecated object.\n\n    alternative : str, optional\n        An alternative API that the user may use in place of the deprecated\n        API.  The deprecation warning will tell the user about this alternative\n        if provided.\n\n    pending : bool, optional\n        If True, uses a PendingDeprecationWarning instead of a\n        DeprecationWarning.  Cannot be used together with *removal*.\n\n    obj_type : str, optional\n        The object type being deprecated.\n\n    addendum : str, optional\n        Additional text appended directly to the final message.\n\n    removal : str, optional\n        The expected removal version.  With the default (an empty string), a\n        removal version is automatically computed from *since*.  Set to other\n        Falsy values to not schedule a removal date.  Cannot be used together\n        with *pending*.\n\n    Examples\n    --------\n    Basic example::\n\n        # To warn of the deprecation of \"matplotlib.name_of_module\"\n        warn_deprecated('1.4.0', name='matplotlib.name_of_module',\n                        obj_type='module')\n    \"\"\"\n    warning = _generate_deprecation_warning(\n        since, message, name, alternative, pending, obj_type, addendum,\n        removal=removal)\n    from . import _warn_external\n    _warn_external(warning, category=MatplotlibDeprecationWarning)",
        "begin_line": 56,
        "end_line": 109,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0037174721189591076,
            "pseudo_dstar_susp": 0.041666666666666664,
            "pseudo_tarantula_susp": 0.0003527336860670194,
            "pseudo_op2_susp": 0.05263157894736842,
            "pseudo_barinel_susp": 0.0003527336860670194
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation.wrapper#231",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation.wrapper(*args, **kwargs)",
        "snippet": "        def wrapper(*args, **kwargs):\n            from . import _warn_external\n            _warn_external(warning)\n            return func(*args, **kwargs)",
        "begin_line": 231,
        "end_line": 234,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation._rename_parameter#254",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation._rename_parameter(since, old, new, func=None)",
        "snippet": "def _rename_parameter(since, old, new, func=None):\n    \"\"\"\n    Decorator indicating that parameter *old* of *func* is renamed to *new*.\n\n    The actual implementation of *func* should use *new*, not *old*.  If *old*\n    is passed to *func*, a DeprecationWarning is emitted, and its value is\n    used, even if *new* is also passed by keyword (this is to simplify pyplot\n    wrapper functions, which always pass *new* explicitly to the Axes method).\n    If *new* is also passed but positionally, a TypeError will be raised by the\n    underlying function during argument binding.\n\n    Examples\n    --------\n    ::\n\n        @_rename_parameter(\"3.1\", \"bad_name\", \"good_name\")\n        def func(good_name): ...\n    \"\"\"\n\n    if func is None:\n        return functools.partial(_rename_parameter, since, old, new)\n\n    signature = inspect.signature(func)\n    assert old not in signature.parameters, (\n        f\"Matplotlib internal error: {old!r} cannot be a parameter for \"\n        f\"{func.__name__}()\")\n    assert new in signature.parameters, (\n        f\"Matplotlib internal error: {new!r} must be a parameter for \"\n        f\"{func.__name__}()\")\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        if old in kwargs:\n            warn_deprecated(\n                since, message=f\"The {old!r} parameter of {func.__name__}() \"\n                f\"has been renamed {new!r} since Matplotlib {since}; support \"\n                f\"for the old name will be dropped %(removal)s.\")\n            kwargs[new] = kwargs.pop(old)\n        return func(*args, **kwargs)\n\n    # wrapper() must keep the same documented signature as func(): if we\n    # instead made both *old* and *new* appear in wrapper()'s signature, they\n    # would both show up in the pyplot function for an Axes method as well and\n    # pyplot would explicitly pass both arguments to the Axes method.\n\n    return wrapper",
        "begin_line": 254,
        "end_line": 299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation.wrapper#285",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation.wrapper(*args, **kwargs)",
        "snippet": "    def wrapper(*args, **kwargs):\n        if old in kwargs:\n            warn_deprecated(\n                since, message=f\"The {old!r} parameter of {func.__name__}() \"\n                f\"has been renamed {new!r} since Matplotlib {since}; support \"\n                f\"for the old name will be dropped %(removal)s.\")\n            kwargs[new] = kwargs.pop(old)\n        return func(*args, **kwargs)",
        "begin_line": 285,
        "end_line": 292,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation._delete_parameter#310",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation._delete_parameter(since, name, func=None, **kwargs)",
        "snippet": "def _delete_parameter(since, name, func=None, **kwargs):\n    \"\"\"\n    Decorator indicating that parameter *name* of *func* is being deprecated.\n\n    The actual implementation of *func* should keep the *name* parameter in its\n    signature, or accept a ``**kwargs`` argument (through which *name* would be\n    passed).\n\n    Parameters that come after the deprecated parameter effectively become\n    keyword-only (as they cannot be passed positionally without triggering the\n    DeprecationWarning on the deprecated parameter), and should be marked as\n    such after the deprecation period has passed and the deprecated parameter\n    is removed.\n\n    Parameters other than *since*, *name*, and *func* are keyword-only and\n    forwarded to `.warn_deprecated`.\n\n    Examples\n    --------\n    ::\n\n        @_delete_parameter(\"3.1\", \"unused\")\n        def func(used_arg, other_arg, unused, more_args): ...\n    \"\"\"\n\n    if func is None:\n        return functools.partial(_delete_parameter, since, name, **kwargs)\n\n    signature = inspect.signature(func)\n    # Name of `**kwargs` parameter of the decorated function, typically\n    # \"kwargs\" if such a parameter exists, or None if the decorated function\n    # doesn't accept `**kwargs`.\n    kwargs_name = next((param.name for param in signature.parameters.values()\n                        if param.kind == inspect.Parameter.VAR_KEYWORD), None)\n    if name in signature.parameters:\n        kind = signature.parameters[name].kind\n        is_varargs = kind is inspect.Parameter.VAR_POSITIONAL\n        is_varkwargs = kind is inspect.Parameter.VAR_KEYWORD\n        if not is_varargs and not is_varkwargs:\n            func.__signature__ = signature = signature.replace(parameters=[\n                param.replace(default=_deprecated_parameter)\n                if param.name == name else param\n                for param in signature.parameters.values()])\n    else:\n        is_varargs = is_varkwargs = False\n        assert kwargs_name, (\n            f\"Matplotlib internal error: {name!r} must be a parameter for \"\n            f\"{func.__name__}()\")\n\n    @functools.wraps(func)\n    def wrapper(*inner_args, **inner_kwargs):\n        arguments = signature.bind(*inner_args, **inner_kwargs).arguments\n        if is_varargs and arguments.get(name):\n            warn_deprecated(\n                since, message=f\"Additional positional arguments to \"\n                f\"{func.__name__}() are deprecated since %(since)s and \"\n                f\"support for them will be removed %(removal)s.\")\n        elif is_varkwargs and arguments.get(name):\n            warn_deprecated(\n                since, message=f\"Additional keyword arguments to \"\n                f\"{func.__name__}() are deprecated since %(since)s and \"\n                f\"support for them will be removed %(removal)s.\")\n        # We cannot just check `name not in arguments` because the pyplot\n        # wrappers always pass all arguments explicitly.\n        elif any(name in d and d[name] != _deprecated_parameter\n                 for d in [arguments, arguments.get(kwargs_name, {})]):\n            addendum = (f\"If any parameter follows {name!r}, they should be \"\n                        f\"passed as keyword, not positionally.\")\n            if kwargs.get(\"addendum\"):\n                kwargs[\"addendum\"] += \" \" + addendum\n            else:\n                kwargs[\"addendum\"] = addendum\n            warn_deprecated(\n                since,\n                name=repr(name),\n                obj_type=f\"parameter of {func.__name__}()\",\n                **kwargs)\n        return func(*inner_args, **inner_kwargs)\n\n    return wrapper",
        "begin_line": 310,
        "end_line": 389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048567265662943174,
            "pseudo_dstar_susp": 0.0005324813631522897,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0005324813631522897,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation.wrapper#360",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation.wrapper(*inner_args, **inner_kwargs)",
        "snippet": "    def wrapper(*inner_args, **inner_kwargs):\n        arguments = signature.bind(*inner_args, **inner_kwargs).arguments\n        if is_varargs and arguments.get(name):\n            warn_deprecated(\n                since, message=f\"Additional positional arguments to \"\n                f\"{func.__name__}() are deprecated since %(since)s and \"\n                f\"support for them will be removed %(removal)s.\")\n        elif is_varkwargs and arguments.get(name):\n            warn_deprecated(\n                since, message=f\"Additional keyword arguments to \"\n                f\"{func.__name__}() are deprecated since %(since)s and \"\n                f\"support for them will be removed %(removal)s.\")\n        # We cannot just check `name not in arguments` because the pyplot\n        # wrappers always pass all arguments explicitly.\n        elif any(name in d and d[name] != _deprecated_parameter\n                 for d in [arguments, arguments.get(kwargs_name, {})]):\n            addendum = (f\"If any parameter follows {name!r}, they should be \"\n                        f\"passed as keyword, not positionally.\")\n            if kwargs.get(\"addendum\"):\n                kwargs[\"addendum\"] += \" \" + addendum\n            else:\n                kwargs[\"addendum\"] = addendum\n            warn_deprecated(\n                since,\n                name=repr(name),\n                obj_type=f\"parameter of {func.__name__}()\",\n                **kwargs)\n        return func(*inner_args, **inner_kwargs)",
        "begin_line": 360,
        "end_line": 387,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001639344262295082,
            "pseudo_dstar_susp": 0.00273224043715847,
            "pseudo_tarantula_susp": 0.0012610340479192938,
            "pseudo_op2_susp": 0.00273224043715847,
            "pseudo_barinel_susp": 0.0012626262626262627
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation._make_keyword_only#392",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation._make_keyword_only(since, name, func=None)",
        "snippet": "def _make_keyword_only(since, name, func=None):\n    \"\"\"\n    Decorator indicating that passing parameter *name* (or any of the following\n    ones) positionally to *func* is being deprecated.\n\n    Note that this decorator **cannot** be applied to a function that has a\n    pyplot-level wrapper, as the wrapper always pass all arguments by keyword.\n    If it is used, users will see spurious DeprecationWarnings every time they\n    call the pyplot wrapper.\n    \"\"\"\n\n    if func is None:\n        return functools.partial(_make_keyword_only, since, name)\n\n    signature = inspect.signature(func)\n    POK = inspect.Parameter.POSITIONAL_OR_KEYWORD\n    KWO = inspect.Parameter.KEYWORD_ONLY\n    assert (name in signature.parameters\n            and signature.parameters[name].kind == POK), (\n        f\"Matplotlib internal error: {name!r} must be a positional-or-keyword \"\n        f\"parameter for {func.__name__}()\")\n    names = [*signature.parameters]\n    kwonly = [name for name in names[names.index(name):]\n              if signature.parameters[name].kind == POK]\n    func.__signature__ = signature.replace(parameters=[\n        param.replace(kind=KWO) if param.name in kwonly else param\n        for param in signature.parameters.values()])\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        bound = signature.bind(*args, **kwargs)\n        if name in bound.arguments and name not in kwargs:\n            warn_deprecated(\n                since, message=\"Passing the %(name)s %(obj_type)s \"\n                \"positionally is deprecated since Matplotlib %(since)s; the \"\n                \"parameter will become keyword-only %(removal)s.\",\n                name=name, obj_type=f\"parameter of {func.__name__}()\")\n        return func(*args, **kwargs)\n\n    return wrapper",
        "begin_line": 392,
        "end_line": 431,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation.wrapper#421",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation.wrapper(*args, **kwargs)",
        "snippet": "    def wrapper(*args, **kwargs):\n        bound = signature.bind(*args, **kwargs)\n        if name in bound.arguments and name not in kwargs:\n            warn_deprecated(\n                since, message=\"Passing the %(name)s %(obj_type)s \"\n                \"positionally is deprecated since Matplotlib %(since)s; the \"\n                \"parameter will become keyword-only %(removal)s.\",\n                name=name, obj_type=f\"parameter of {func.__name__}()\")\n        return func(*args, **kwargs)",
        "begin_line": 421,
        "end_line": 429,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.cbook.deprecation._suppress_matplotlib_deprecation_warning#435",
        "src_path": "lib/matplotlib/cbook/deprecation.py",
        "class_name": "lib.matplotlib.cbook.deprecation",
        "signature": "lib.matplotlib.cbook.deprecation._suppress_matplotlib_deprecation_warning()",
        "snippet": "def _suppress_matplotlib_deprecation_warning():\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", MatplotlibDeprecationWarning)\n        yield",
        "begin_line": 435,
        "end_line": 438,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005605381165919282,
            "pseudo_dstar_susp": 0.004219409282700422,
            "pseudo_tarantula_susp": 0.00032268473701193933,
            "pseudo_op2_susp": 0.00423728813559322,
            "pseudo_barinel_susp": 0.00032268473701193933
        }
    },
    {
        "name": "lib.matplotlib.afm._to_float#55",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm",
        "signature": "lib.matplotlib.afm._to_float(x)",
        "snippet": "def _to_float(x):\n    # Some AFM files use \",\" instead of \".\" as decimal separator -- this\n    # shouldn't be ambiguous (unless someone is wicked enough to use \",\" as\n    # thousands separator...).\n    if isinstance(x, bytes):\n        # Encoding doesn't really matter -- if we have codepoints >127 the call\n        # to float() will error anyways.\n        x = x.decode('latin-1')\n    return float(x.replace(',', '.'))",
        "begin_line": 55,
        "end_line": 63,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010978153474585575,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.afm._to_list_of_ints#70",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm",
        "signature": "lib.matplotlib.afm._to_list_of_ints(s)",
        "snippet": "def _to_list_of_ints(s):\n    s = s.replace(b',', b' ')\n    return [_to_int(val) for val in s.split()]",
        "begin_line": 70,
        "end_line": 72,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.afm._to_list_of_floats#75",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm",
        "signature": "lib.matplotlib.afm._to_list_of_floats(s)",
        "snippet": "def _to_list_of_floats(s):\n    return [_to_float(val) for val in s.split()]",
        "begin_line": 75,
        "end_line": 76,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.afm._to_bool#79",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm",
        "signature": "lib.matplotlib.afm._to_bool(s)",
        "snippet": "def _to_bool(s):\n    if s.lower().strip() in (b'false', b'0', b'no'):\n        return False\n    else:\n        return True",
        "begin_line": 79,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.afm._parse_header#86",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm",
        "signature": "lib.matplotlib.afm._parse_header(fh)",
        "snippet": "def _parse_header(fh):\n    \"\"\"\n    Reads the font metrics header (up to the char metrics) and returns\n    a dictionary mapping *key* to *val*.  *val* will be converted to the\n    appropriate python type as necessary; e.g.:\n\n        * 'False'->False\n        * '0'->0\n        * '-168 -218 1000 898'-> [-168, -218, 1000, 898]\n\n    Dictionary keys are\n\n      StartFontMetrics, FontName, FullName, FamilyName, Weight,\n      ItalicAngle, IsFixedPitch, FontBBox, UnderlinePosition,\n      UnderlineThickness, Version, Notice, EncodingScheme, CapHeight,\n      XHeight, Ascender, Descender, StartCharMetrics\n\n    \"\"\"\n    header_converters = {\n        b'StartFontMetrics': _to_float,\n        b'FontName': _to_str,\n        b'FullName': _to_str,\n        b'FamilyName': _to_str,\n        b'Weight': _to_str,\n        b'ItalicAngle': _to_float,\n        b'IsFixedPitch': _to_bool,\n        b'FontBBox': _to_list_of_ints,\n        b'UnderlinePosition': _to_float,\n        b'UnderlineThickness': _to_float,\n        b'Version': _to_str,\n        # Some AFM files have non-ASCII characters (which are not allowed by\n        # the spec).  Given that there is actually no public API to even access\n        # this field, just return it as straight bytes.\n        b'Notice': lambda x: x,\n        b'EncodingScheme': _to_str,\n        b'CapHeight': _to_float,  # Is the second version a mistake, or\n        b'Capheight': _to_float,  # do some AFM files contain 'Capheight'? -JKS\n        b'XHeight': _to_float,\n        b'Ascender': _to_float,\n        b'Descender': _to_float,\n        b'StdHW': _to_float,\n        b'StdVW': _to_float,\n        b'StartCharMetrics': _to_int,\n        b'CharacterSet': _to_str,\n        b'Characters': _to_int,\n        }\n\n    d = {}\n    first_line = True\n    for line in fh:\n        line = line.rstrip()\n        if line.startswith(b'Comment'):\n            continue\n        lst = line.split(b' ', 1)\n        key = lst[0]\n        if first_line:\n            # AFM spec, Section 4: The StartFontMetrics keyword\n            # [followed by a version number] must be the first line in\n            # the file, and the EndFontMetrics keyword must be the\n            # last non-empty line in the file.  We just check the\n            # first header entry.\n            if key != b'StartFontMetrics':\n                raise RuntimeError('Not an AFM file')\n            first_line = False\n        if len(lst) == 2:\n            val = lst[1]\n        else:\n            val = b''\n        try:\n            converter = header_converters[key]\n        except KeyError:\n            _log.error('Found an unknown keyword in AFM header (was %r)' % key)\n            continue\n        try:\n            d[key] = converter(val)\n        except ValueError:\n            _log.error('Value error parsing header in AFM: %s, %s', key, val)\n            continue\n        if key == b'StartCharMetrics':\n            break\n    else:\n        raise RuntimeError('Bad parse')\n    return d",
        "begin_line": 86,
        "end_line": 168,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.afm._parse_char_metrics#186",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm",
        "signature": "lib.matplotlib.afm._parse_char_metrics(fh)",
        "snippet": "def _parse_char_metrics(fh):\n    \"\"\"\n    Parse the given filehandle for character metrics information and return\n    the information as dicts.\n\n    It is assumed that the file cursor is on the line behind\n    'StartCharMetrics'.\n\n    Returns\n    -------\n    ascii_d : dict\n         A mapping \"ASCII num of the character\" to `.CharMetrics`.\n    name_d : dict\n         A mapping \"character name\" to `.CharMetrics`.\n\n    Notes\n    -----\n    This function is incomplete per the standard, but thus far parses\n    all the sample afm files tried.\n    \"\"\"\n    required_keys = {'C', 'WX', 'N', 'B'}\n\n    ascii_d = {}\n    name_d = {}\n    for line in fh:\n        # We are defensively letting values be utf8. The spec requires\n        # ascii, but there are non-compliant fonts in circulation\n        line = _to_str(line.rstrip())  # Convert from byte-literal\n        if line.startswith('EndCharMetrics'):\n            return ascii_d, name_d\n        # Split the metric line into a dictionary, keyed by metric identifiers\n        vals = dict(s.strip().split(' ', 1) for s in line.split(';') if s)\n        # There may be other metrics present, but only these are needed\n        if not required_keys.issubset(vals):\n            raise RuntimeError('Bad char metrics line: %s' % line)\n        num = _to_int(vals['C'])\n        wx = _to_float(vals['WX'])\n        name = vals['N']\n        bbox = _to_list_of_floats(vals['B'])\n        bbox = list(map(int, bbox))\n        metrics = CharMetrics(wx, name, bbox)\n        # Workaround: If the character name is 'Euro', give it the\n        # corresponding character code, according to WinAnsiEncoding (see PDF\n        # Reference).\n        if name == 'Euro':\n            num = 128\n        elif name == 'minus':\n            num = ord(\"\\N{MINUS SIGN}\")  # 0x2212\n        if num != -1:\n            ascii_d[num] = metrics\n        name_d[name] = metrics\n    raise RuntimeError('Bad parse')",
        "begin_line": 186,
        "end_line": 237,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.afm._parse_optional#326",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm",
        "signature": "lib.matplotlib.afm._parse_optional(fh)",
        "snippet": "def _parse_optional(fh):\n    \"\"\"\n    Parse the optional fields for kern pair data and composites.\n\n    Returns\n    -------\n    kern_data : dict\n        A dict containing kerning information. May be empty.\n        See `._parse_kern_pairs`.\n    composites : dict\n        A dict containing composite information. May be empty.\n        See `._parse_composites`.\n    \"\"\"\n    optional = {\n        b'StartKernData': _parse_kern_pairs,\n        b'StartComposites':  _parse_composites,\n        }\n\n    d = {b'StartKernData': {},\n         b'StartComposites': {}}\n    for line in fh:\n        line = line.rstrip()\n        if not line:\n            continue\n        key = line.split()[0]\n\n        if key in optional:\n            d[key] = optional[key](fh)\n\n    return d[b'StartKernData'], d[b'StartComposites']",
        "begin_line": 326,
        "end_line": 355,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.afm.AFM.__init__#360",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm.AFM",
        "signature": "lib.matplotlib.afm.AFM.__init__(self, fh)",
        "snippet": "    def __init__(self, fh):\n        \"\"\"Parse the AFM file in file object *fh*.\"\"\"\n        self._header = _parse_header(fh)\n        self._metrics, self._metrics_by_name = _parse_char_metrics(fh)\n        self._kern, self._composite = _parse_optional(fh)",
        "begin_line": 360,
        "end_line": 364,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.afm.AFM.get_str_bbox_and_descent#396",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm.AFM",
        "signature": "lib.matplotlib.afm.AFM.get_str_bbox_and_descent(self, s)",
        "snippet": "    def get_str_bbox_and_descent(self, s):\n        \"\"\"Return the string bounding box and the maximal descent.\"\"\"\n        if not len(s):\n            return 0, 0, 0, 0, 0\n        total_width = 0\n        namelast = None\n        miny = 1e9\n        maxy = 0\n        left = 0\n        if not isinstance(s, str):\n            s = _to_str(s)\n        for c in s:\n            if c == '\\n':\n                continue\n            name = uni2type1.get(ord(c), f\"uni{ord(c):04X}\")\n            try:\n                wx, _, bbox = self._metrics_by_name[name]\n            except KeyError:\n                name = 'question'\n                wx, _, bbox = self._metrics_by_name[name]\n            total_width += wx + self._kern.get((namelast, name), 0)\n            l, b, w, h = bbox\n            left = min(left, l)\n            miny = min(miny, b)\n            maxy = max(maxy, b + h)\n\n            namelast = name\n\n        return left, miny, total_width, maxy - miny, -miny",
        "begin_line": 396,
        "end_line": 424,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.afm.AFM.get_fullname#472",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm.AFM",
        "signature": "lib.matplotlib.afm.AFM.get_fullname(self)",
        "snippet": "    def get_fullname(self):\n        \"\"\"Return the font full name, e.g., 'Times-Roman'.\"\"\"\n        name = self._header.get(b'FullName')\n        if name is None:  # use FontName as a substitute\n            name = self._header[b'FontName']\n        return name",
        "begin_line": 472,
        "end_line": 477,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.afm.AFM.get_familyname#479",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm.AFM",
        "signature": "lib.matplotlib.afm.AFM.get_familyname(self)",
        "snippet": "    def get_familyname(self):\n        \"\"\"Return the font family name, e.g., 'Times'.\"\"\"\n        name = self._header.get(b'FamilyName')\n        if name is not None:\n            return name\n\n        # FamilyName not specified so we'll make a guess\n        name = self.get_fullname()\n        extras = (r'(?i)([ -](regular|plain|italic|oblique|bold|semibold|'\n                  r'light|ultralight|extra|condensed))+$')\n        return re.sub(extras, '', name)",
        "begin_line": 479,
        "end_line": 489,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.afm.AFM.get_weight#496",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm.AFM",
        "signature": "lib.matplotlib.afm.AFM.get_weight(self)",
        "snippet": "    def get_weight(self):\n        \"\"\"Return the font weight, e.g., 'Bold' or 'Roman'.\"\"\"\n        return self._header[b'Weight']",
        "begin_line": 496,
        "end_line": 498,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.afm.AFM.get_angle#500",
        "src_path": "lib/matplotlib/afm.py",
        "class_name": "lib.matplotlib.afm.AFM",
        "signature": "lib.matplotlib.afm.AFM.get_angle(self)",
        "snippet": "    def get_angle(self):\n        \"\"\"Return the fontangle as float.\"\"\"\n        return self._header[b'ItalicAngle']",
        "begin_line": 500,
        "end_line": 502,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.category.StrCategoryConverter.convert#28",
        "src_path": "lib/matplotlib/category.py",
        "class_name": "lib.matplotlib.category.StrCategoryConverter",
        "signature": "lib.matplotlib.category.StrCategoryConverter.convert(value, unit, axis)",
        "snippet": "    def convert(value, unit, axis):\n        \"\"\"\n        Convert strings in *value* to floats using mapping information stored\n        in the *unit* object.\n\n        Parameters\n        ----------\n        value : str or iterable\n            Value or list of values to be converted.\n        unit : `.UnitData`\n            An object mapping strings to integers.\n        axis : `~matplotlib.axis.Axis`\n            The axis on which the converted value is plotted.\n\n            .. note:: *axis* is unused.\n\n        Returns\n        -------\n        mapped_value : float or ndarray[float]\n        \"\"\"\n        if unit is None:\n            raise ValueError(\n                'Missing category information for StrCategoryConverter; '\n                'this might be caused by unintendedly mixing categorical and '\n                'numeric data')\n        # dtype = object preserves numerical pass throughs\n        values = np.atleast_1d(np.array(value, dtype=object))\n        # pass through sequence of non binary numbers\n        if all(units.ConversionInterface.is_numlike(v)\n               and not isinstance(v, (str, bytes))\n               for v in values):\n            return np.asarray(values, dtype=float)\n        # force an update so it also does type checking\n        unit.update(values)\n        return np.vectorize(unit._mapping.__getitem__, otypes=[float])(values)",
        "begin_line": 28,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.716644802839726e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.category.StrCategoryConverter.axisinfo#65",
        "src_path": "lib/matplotlib/category.py",
        "class_name": "lib.matplotlib.category.StrCategoryConverter",
        "signature": "lib.matplotlib.category.StrCategoryConverter.axisinfo(unit, axis)",
        "snippet": "    def axisinfo(unit, axis):\n        \"\"\"\n        Set the default axis ticks and labels.\n\n        Parameters\n        ----------\n        unit : `.UnitData`\n            object string unit information for value\n        axis : `~matplotlib.axis.Axis`\n            axis for which information is being set\n\n        Returns\n        -------\n        axisinfo : `~matplotlib.units.AxisInfo`\n            Information to support default tick labeling\n\n        .. note: axis is not used\n        \"\"\"\n        # locator and formatter take mapping dict because\n        # args need to be pass by reference for updates\n        majloc = StrCategoryLocator(unit._mapping)\n        majfmt = StrCategoryFormatter(unit._mapping)\n        return units.AxisInfo(majloc=majloc, majfmt=majfmt)",
        "begin_line": 65,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.59589821496392e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.category.StrCategoryConverter.default_units#90",
        "src_path": "lib/matplotlib/category.py",
        "class_name": "lib.matplotlib.category.StrCategoryConverter",
        "signature": "lib.matplotlib.category.StrCategoryConverter.default_units(data, axis)",
        "snippet": "    def default_units(data, axis):\n        \"\"\"\n        Set and update the `~matplotlib.axis.Axis` units.\n\n        Parameters\n        ----------\n        data : str or iterable of str\n        axis : `~matplotlib.axis.Axis`\n            axis on which the data is plotted\n\n        Returns\n        -------\n        class : `.UnitData`\n            object storing string to integer mapping\n        \"\"\"\n        # the conversion call stack is default_units -> axis_info -> convert\n        if axis.units is None:\n            axis.set_units(UnitData(data))\n        else:\n            axis.units.update(data)\n        return axis.units",
        "begin_line": 90,
        "end_line": 110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.659313725490196e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.category.StrCategoryLocator.__init__#115",
        "src_path": "lib/matplotlib/category.py",
        "class_name": "lib.matplotlib.category.StrCategoryLocator",
        "signature": "lib.matplotlib.category.StrCategoryLocator.__init__(self, units_mapping)",
        "snippet": "    def __init__(self, units_mapping):\n        \"\"\"\n        Parameters\n        -----------\n        units_mapping : dict\n            Mapping of category names (str) to indices (int).\n        \"\"\"\n        self._units = units_mapping",
        "begin_line": 115,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.737542556484061e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.category.StrCategoryLocator.tick_values#128",
        "src_path": "lib/matplotlib/category.py",
        "class_name": "lib.matplotlib.category.StrCategoryLocator",
        "signature": "lib.matplotlib.category.StrCategoryLocator.tick_values(self, vmin, vmax)",
        "snippet": "    def tick_values(self, vmin, vmax):\n        # docstring inherited\n        return self()",
        "begin_line": 128,
        "end_line": 130,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.71962328238382e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.category.StrCategoryFormatter.__init__#135",
        "src_path": "lib/matplotlib/category.py",
        "class_name": "lib.matplotlib.category.StrCategoryFormatter",
        "signature": "lib.matplotlib.category.StrCategoryFormatter.__init__(self, units_mapping)",
        "snippet": "    def __init__(self, units_mapping):\n        \"\"\"\n        Parameters\n        ----------\n        units_mapping : dict\n            Mapping of category names (str) to indices (int).\n        \"\"\"\n        self._units = units_mapping",
        "begin_line": 135,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.630675314765356e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.category.UnitData.__init__#164",
        "src_path": "lib/matplotlib/category.py",
        "class_name": "lib.matplotlib.category.UnitData",
        "signature": "lib.matplotlib.category.UnitData.__init__(self, data=None)",
        "snippet": "    def __init__(self, data=None):\n        \"\"\"\n        Create mapping between unique categorical values and integer ids.\n\n        Parameters\n        ----------\n        data : iterable\n            sequence of string values\n        \"\"\"\n        self._mapping = OrderedDict()\n        self._counter = itertools.count()\n        if data is not None:\n            self.update(data)",
        "begin_line": 164,
        "end_line": 176,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.550588945937783e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.category.UnitData._str_is_convertible#179",
        "src_path": "lib/matplotlib/category.py",
        "class_name": "lib.matplotlib.category.UnitData",
        "signature": "lib.matplotlib.category.UnitData._str_is_convertible(val)",
        "snippet": "    def _str_is_convertible(val):\n        \"\"\"\n        Helper method to check whether a string can be parsed as float or date.\n        \"\"\"\n        try:\n            float(val)\n        except ValueError:\n            try:\n                dateutil.parser.parse(val)\n            except (ValueError, TypeError):\n                # TypeError if dateutil >= 2.8.1 else ValueError\n                return False\n        return True",
        "begin_line": 179,
        "end_line": 191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.613247049866768e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.category.UnitData.update#193",
        "src_path": "lib/matplotlib/category.py",
        "class_name": "lib.matplotlib.category.UnitData",
        "signature": "lib.matplotlib.category.UnitData.update(self, data)",
        "snippet": "    def update(self, data):\n        \"\"\"\n        Map new values to integer identifiers.\n\n        Parameters\n        ----------\n        data : iterable of str or bytes\n\n        Raises\n        ------\n        TypeError\n            If elements in *data* are neither str nor bytes.\n        \"\"\"\n        data = np.atleast_1d(np.array(data, dtype=object))\n        # check if convertible to number:\n        convertible = True\n        for val in OrderedDict.fromkeys(data):\n            # OrderedDict just iterates over unique values in data.\n            cbook._check_isinstance((str, bytes), value=val)\n            if convertible:\n                # this will only be called so long as convertible is True.\n                convertible = self._str_is_convertible(val)\n            if val not in self._mapping:\n                self._mapping[val] = next(self._counter)\n        if convertible:\n            _log.info('Using categorical units to plot a list of strings '\n                      'that are all parsable as floats or dates. If these '\n                      'strings should be plotted as numbers, cast to the '\n                      'appropriate data type before plotting.')",
        "begin_line": 193,
        "end_line": 221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.633005114113426e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._pylab_helpers.Gcf.destroy#46",
        "src_path": "lib/matplotlib/_pylab_helpers.py",
        "class_name": "lib.matplotlib._pylab_helpers.Gcf",
        "signature": "lib.matplotlib._pylab_helpers.Gcf.destroy(cls, num)",
        "snippet": "    def destroy(cls, num):\n        \"\"\"\n        Destroy figure number *num*.\n\n        In the interactive backends, this is bound to the window \"destroy\" and\n        \"delete\" events.\n        \"\"\"\n        if not cls.has_fignum(num):\n            return\n        manager = cls.figs.pop(num)\n        manager.canvas.mpl_disconnect(manager._cidgcf)\n        manager.destroy()\n        gc.collect(1)",
        "begin_line": 46,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._pylab_helpers.Gcf.destroy_fig#61",
        "src_path": "lib/matplotlib/_pylab_helpers.py",
        "class_name": "lib.matplotlib._pylab_helpers.Gcf",
        "signature": "lib.matplotlib._pylab_helpers.Gcf.destroy_fig(cls, fig)",
        "snippet": "    def destroy_fig(cls, fig):\n        \"\"\"Destroy figure *fig*.\"\"\"\n        canvas = getattr(fig, \"canvas\", None)\n        manager = getattr(canvas, \"manager\", None)\n        num = getattr(manager, \"num\", None)\n        cls.destroy(num)",
        "begin_line": 61,
        "end_line": 66,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.3905531035778e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._pylab_helpers.Gcf.destroy_all#69",
        "src_path": "lib/matplotlib/_pylab_helpers.py",
        "class_name": "lib.matplotlib._pylab_helpers.Gcf",
        "signature": "lib.matplotlib._pylab_helpers.Gcf.destroy_all(cls)",
        "snippet": "    def destroy_all(cls):\n        \"\"\"Destroy all figures.\"\"\"\n        # Reimport gc in case the module globals have already been removed\n        # during interpreter shutdown.\n        import gc\n        for manager in list(cls.figs.values()):\n            manager.canvas.mpl_disconnect(manager._cidgcf)\n            manager.destroy()\n        cls.figs.clear()\n        gc.collect(1)",
        "begin_line": 69,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0070921985815602835,
            "pseudo_dstar_susp": 0.006329113924050633,
            "pseudo_tarantula_susp": 0.0006793478260869565,
            "pseudo_op2_susp": 0.005988023952095809,
            "pseudo_barinel_susp": 0.0006793478260869565
        }
    },
    {
        "name": "lib.matplotlib._pylab_helpers.Gcf.get_all_fig_managers#86",
        "src_path": "lib/matplotlib/_pylab_helpers.py",
        "class_name": "lib.matplotlib._pylab_helpers.Gcf",
        "signature": "lib.matplotlib._pylab_helpers.Gcf.get_all_fig_managers(cls)",
        "snippet": "    def get_all_fig_managers(cls):\n        \"\"\"Return a list of figure managers.\"\"\"\n        return list(cls.figs.values())",
        "begin_line": 86,
        "end_line": 88,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.240081088908195e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib._pylab_helpers.Gcf.set_active#101",
        "src_path": "lib/matplotlib/_pylab_helpers.py",
        "class_name": "lib.matplotlib._pylab_helpers.Gcf",
        "signature": "lib.matplotlib._pylab_helpers.Gcf.set_active(cls, manager)",
        "snippet": "    def set_active(cls, manager):\n        \"\"\"Make *manager* the active manager.\"\"\"\n        cls.figs[manager.num] = manager\n        cls.figs.move_to_end(manager.num)",
        "begin_line": 101,
        "end_line": 104,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01282051282051282,
            "pseudo_dstar_susp": 0.023255813953488372,
            "pseudo_tarantula_susp": 0.000546448087431694,
            "pseudo_op2_susp": 0.018518518518518517,
            "pseudo_barinel_susp": 0.000546448087431694
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformNode.__init__#107",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformNode",
        "signature": "lib.matplotlib.transforms.TransformNode.__init__(self, shorthand_name=None)",
        "snippet": "    def __init__(self, shorthand_name=None):\n        \"\"\"\n        Parameters\n        ----------\n        shorthand_name : str\n            A string representing the \"name\" of the transform. The name carries\n            no significance other than to improve the readability of\n            ``str(transform)`` when DEBUG=True.\n        \"\"\"\n        self._parents = {}\n\n        # TransformNodes start out as invalid until their values are\n        # computed for the first time.\n        self._invalid = 1\n        self._shorthand_name = shorthand_name or ''",
        "begin_line": 107,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008620689655172414,
            "pseudo_dstar_susp": 0.011363636363636364,
            "pseudo_tarantula_susp": 0.00043346337234503684,
            "pseudo_op2_susp": 0.010526315789473684,
            "pseudo_barinel_susp": 0.00043346337234503684
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformNode.__getstate__#128",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformNode",
        "signature": "lib.matplotlib.transforms.TransformNode.__getstate__(self)",
        "snippet": "    def __getstate__(self):\n        # turn the dictionary with weak values into a normal dictionary\n        return {**self.__dict__,\n                '_parents': {k: v() for k, v in self._parents.items()}}",
        "begin_line": 128,
        "end_line": 131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.872327211427557e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformNode.invalidate#148",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformNode",
        "signature": "lib.matplotlib.transforms.TransformNode.invalidate(self)",
        "snippet": "    def invalidate(self):\n        \"\"\"\n        Invalidate this `TransformNode` and triggers an invalidation of its\n        ancestors.  Should be called any time the transform changes.\n        \"\"\"\n        value = self.INVALID\n        if self.is_affine:\n            value = self.INVALID_AFFINE\n        return self._invalidate_internal(value, invalidating_node=self)",
        "begin_line": 148,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010638297872340425,
            "pseudo_dstar_susp": 0.008130081300813009,
            "pseudo_tarantula_susp": 0.0006944444444444445,
            "pseudo_op2_susp": 0.007633587786259542,
            "pseudo_barinel_susp": 0.0006944444444444445
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformNode._invalidate_internal#158",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformNode",
        "signature": "lib.matplotlib.transforms.TransformNode._invalidate_internal(self, value, invalidating_node)",
        "snippet": "    def _invalidate_internal(self, value, invalidating_node):\n        \"\"\"\n        Called by :meth:`invalidate` and subsequently ascends the transform\n        stack calling each TransformNode's _invalidate_internal method.\n        \"\"\"\n        # determine if this call will be an extension to the invalidation\n        # status. If not, then a shortcut means that we needn't invoke an\n        # invalidation up the transform stack as it will already have been\n        # invalidated.\n\n        # N.B This makes the invalidation sticky, once a transform has been\n        # invalidated as NON_AFFINE, then it will always be invalidated as\n        # NON_AFFINE even when triggered with a AFFINE_ONLY invalidation.\n        # In most cases this is not a problem (i.e. for interactive panning and\n        # zooming) and the only side effect will be on performance.\n        status_changed = self._invalid < value\n\n        if self.pass_through or status_changed:\n            self._invalid = value\n\n            for parent in list(self._parents.values()):\n                # Dereference the weak reference\n                parent = parent()\n                if parent is not None:\n                    parent._invalidate_internal(\n                        value=value, invalidating_node=self)",
        "begin_line": 158,
        "end_line": 183,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.104980424292088e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformNode.set_children#185",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformNode",
        "signature": "lib.matplotlib.transforms.TransformNode.set_children(self, *children)",
        "snippet": "    def set_children(self, *children):\n        \"\"\"\n        Set the children of the transform, to let the invalidation\n        system know which transforms can invalidate this transform.\n        Should be called from the constructor of any transforms that\n        depend on other transforms.\n        \"\"\"\n        # Parents are stored as weak references, so that if the\n        # parents are destroyed, references from the children won't\n        # keep them alive.\n        for child in children:\n            # Use weak references so this dictionary won't keep obsolete nodes\n            # alive; the callback deletes the dictionary entry. This is a\n            # performance improvement over using WeakValueDictionary.\n            ref = weakref.ref(\n                self, lambda _, pop=child._parents.pop, k=id(self): pop(k))\n            child._parents[id(self)] = ref",
        "begin_line": 185,
        "end_line": 201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.825346394845998e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.frozen#294",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.frozen(self)",
        "snippet": "    def frozen(self):\n        return Bbox(self.get_points().copy())",
        "begin_line": 294,
        "end_line": 295,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018315018315018315,
            "pseudo_dstar_susp": 0.0010090817356205853,
            "pseudo_tarantula_susp": 0.0007751937984496124,
            "pseudo_op2_susp": 0.0010090817356205853,
            "pseudo_barinel_susp": 0.0007757951900698216
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.xmin#367",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.xmin(self)",
        "snippet": "    def xmin(self):\n        \"\"\"The left edge of the bounding box.\"\"\"\n        return np.min(self.get_points()[:, 0])",
        "begin_line": 367,
        "end_line": 369,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002932551319648094,
            "pseudo_dstar_susp": 0.00029291154071470416,
            "pseudo_tarantula_susp": 0.0003046922608165753,
            "pseudo_op2_susp": 0.00029291154071470416,
            "pseudo_barinel_susp": 0.0003046922608165753
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.height#421",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.height(self)",
        "snippet": "    def height(self):\n        \"\"\"The (signed) height of the bounding box.\"\"\"\n        points = self.get_points()\n        return points[1, 1] - points[0, 1]",
        "begin_line": 421,
        "end_line": 424,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009267840593141798,
            "pseudo_dstar_susp": 0.0008680555555555555,
            "pseudo_tarantula_susp": 0.0005219206680584551,
            "pseudo_op2_susp": 0.0008680555555555555,
            "pseudo_barinel_susp": 0.0005219206680584551
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.bounds#433",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.bounds(self)",
        "snippet": "    def bounds(self):\n        \"\"\"Return (:attr:`x0`, :attr:`y0`, :attr:`width`, :attr:`height`).\"\"\"\n        (x0, y0), (x1, y1) = self.get_points()\n        return (x0, y0, x1 - x0, y1 - y0)",
        "begin_line": 433,
        "end_line": 436,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00029129041654529564,
            "pseudo_dstar_susp": 0.0004921259842519685,
            "pseudo_tarantula_susp": 0.0002799552071668533,
            "pseudo_op2_susp": 0.0004921259842519685,
            "pseudo_barinel_susp": 0.0002799552071668533
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.fully_overlaps#506",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.fully_overlaps(self, other)",
        "snippet": "    def fully_overlaps(self, other):\n        \"\"\"\n        Return whether this bounding box overlaps with the other bounding box,\n        not including the edges.\n\n        Parameters\n        ----------\n        other : `.BboxBase`\n        \"\"\"\n        ax1, ay1, ax2, ay2 = self.extents\n        bx1, by1, bx2, by2 = other.extents\n        if ax2 < ax1:\n            ax2, ax1 = ax1, ax2\n        if ay2 < ay1:\n            ay2, ay1 = ay1, ay2\n        if bx2 < bx1:\n            bx2, bx1 = bx1, bx2\n        if by2 < by1:\n            by2, by1 = by1, by2\n        return ax1 < bx2 and bx1 < ax2 and ay1 < by2 and by1 < ay2",
        "begin_line": 506,
        "end_line": 525,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.transformed#527",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.transformed(self, transform)",
        "snippet": "    def transformed(self, transform):\n        \"\"\"\n        Construct a `Bbox` by statically transforming this one by *transform*.\n        \"\"\"\n        pts = self.get_points()\n        ll, ul, lr = transform.transform(np.array(\n            [pts[0], [pts[0, 0], pts[1, 1]], [pts[1, 0], pts[0, 1]]]))\n        return Bbox([ll, [lr[0], ul[1]]])",
        "begin_line": 527,
        "end_line": 534,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004589261128958238,
            "pseudo_dstar_susp": 0.0003966679888932963,
            "pseudo_tarantula_susp": 0.0016181229773462784,
            "pseudo_op2_susp": 0.0003966679888932963,
            "pseudo_barinel_susp": 0.0016181229773462784
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.anchored#553",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.anchored(self, c, container=None)",
        "snippet": "    def anchored(self, c, container=None):\n        \"\"\"\n        Return a copy of the `Bbox` shifted to position *c* within *container*.\n\n        Parameters\n        ----------\n        c : (float, float) or str\n            May be either:\n\n            * A sequence (*cx*, *cy*) where *cx* and *cy* range from 0\n              to 1, where 0 is left or bottom and 1 is right or top\n\n            * a string:\n              - 'C' for centered\n              - 'S' for bottom-center\n              - 'SE' for bottom-left\n              - 'E' for left\n              - etc.\n\n        container : Bbox, optional\n            The box within which the :class:`Bbox` is positioned; it defaults\n            to the initial :class:`Bbox`.\n        \"\"\"\n        if container is None:\n            container = self\n        l, b, w, h = container.bounds\n        if isinstance(c, str):\n            cx, cy = self.coefs[c]\n        else:\n            cx, cy = c\n        L, B, W, H = self.bounds\n        return Bbox(self._points +\n                    [(l + cx * (w - W)) - L,\n                     (b + cy * (h - H)) - B])",
        "begin_line": 553,
        "end_line": 586,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003549875754348598,
            "pseudo_dstar_susp": 0.0003307972213033411,
            "pseudo_tarantula_susp": 0.0005037783375314861,
            "pseudo_op2_susp": 0.0003307972213033411,
            "pseudo_barinel_susp": 0.0005037783375314861
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.shrunk_to_aspect#599",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.shrunk_to_aspect(self, box_aspect, container=None, fig_aspect=1.0)",
        "snippet": "    def shrunk_to_aspect(self, box_aspect, container=None, fig_aspect=1.0):\n        \"\"\"\n        Return a copy of the :class:`Bbox`, shrunk so that it is as\n        large as it can be while having the desired aspect ratio,\n        *box_aspect*.  If the box coordinates are relative (i.e.\n        fractions of a larger box such as a figure) then the\n        physical aspect ratio of that figure is specified with\n        *fig_aspect*, so that *box_aspect* can also be given as a\n        ratio of the absolute dimensions, not the relative dimensions.\n        \"\"\"\n        if box_aspect <= 0 or fig_aspect <= 0:\n            raise ValueError(\"'box_aspect' and 'fig_aspect' must be positive\")\n        if container is None:\n            container = self\n        w, h = container.size\n        H = w * box_aspect / fig_aspect\n        if H <= h:\n            W = w\n        else:\n            W = h * fig_aspect / box_aspect\n            H = h\n        return Bbox([self._points[0],\n                     self._points[0] + (W, H)])",
        "begin_line": 599,
        "end_line": 621,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004246284501061571,
            "pseudo_dstar_susp": 0.00038255547054322876,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.00038255547054322876,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.padded#684",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.padded(self, p)",
        "snippet": "    def padded(self, p):\n        \"\"\"Construct a `Bbox` by padding this one on all four sides by *p*.\"\"\"\n        points = self.get_points()\n        return Bbox(points + [[-p, -p], [p, p]])",
        "begin_line": 684,
        "end_line": 687,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.union#716",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.union(bboxes)",
        "snippet": "    def union(bboxes):\n        \"\"\"Return a `Bbox` that contains all of the given *bboxes*.\"\"\"\n        if not len(bboxes):\n            raise ValueError(\"'bboxes' cannot be empty\")\n        # needed for 1.14.4 < numpy_version < 1.16\n        # can remove once we are at numpy >= 1.16\n        with np.errstate(invalid='ignore'):\n            x0 = np.min([bbox.xmin for bbox in bboxes])\n            x1 = np.max([bbox.xmax for bbox in bboxes])\n            y0 = np.min([bbox.ymin for bbox in bboxes])\n            y1 = np.max([bbox.ymax for bbox in bboxes])\n        return Bbox([[x0, y0], [x1, y1]])",
        "begin_line": 716,
        "end_line": 727,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003861003861003861,
            "pseudo_dstar_susp": 0.000355998576005696,
            "pseudo_tarantula_susp": 0.0008077544426494346,
            "pseudo_op2_susp": 0.000355998576005696,
            "pseudo_barinel_susp": 0.0008077544426494346
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxBase.intersection#730",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxBase",
        "signature": "lib.matplotlib.transforms.BboxBase.intersection(bbox1, bbox2)",
        "snippet": "    def intersection(bbox1, bbox2):\n        \"\"\"\n        Return the intersection of *bbox1* and *bbox2* if they intersect, or\n        None if they don't.\n        \"\"\"\n        x0 = np.maximum(bbox1.xmin, bbox2.xmin)\n        x1 = np.minimum(bbox1.xmax, bbox2.xmax)\n        y0 = np.maximum(bbox1.ymin, bbox2.ymin)\n        y1 = np.minimum(bbox1.ymax, bbox2.ymax)\n        return Bbox([[x0, y0], [x1, y1]]) if x0 <= x1 and y0 <= y1 else None",
        "begin_line": 730,
        "end_line": 739,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.895152376440866e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.__init__#747",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.__init__(self, points, **kwargs)",
        "snippet": "    def __init__(self, points, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        points : ndarray\n            A 2x2 numpy array of the form ``[[x0, y0], [x1, y1]]``.\n\n        Notes\n        -----\n        If you need to create a :class:`Bbox` object from another form\n        of data, consider the static methods :meth:`unit`,\n        :meth:`from_bounds` and :meth:`from_extents`.\n        \"\"\"\n        BboxBase.__init__(self, **kwargs)\n        points = np.asarray(points, float)\n        if points.shape != (2, 2):\n            raise ValueError('Bbox points must be of the form '\n                             '\"[[x0, y0], [x1, y1]]\".')\n        self._points = points\n        self._minpos = np.array([np.inf, np.inf])\n        self._ignore = True\n        # it is helpful in some contexts to know if the bbox is a\n        # default or has been mutated; we store the orig points to\n        # support the mutated methods\n        self._points_orig = self._points.copy()",
        "begin_line": 747,
        "end_line": 771,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002178649237472767,
            "pseudo_dstar_susp": 0.0010427528675703858,
            "pseudo_tarantula_susp": 0.0015337423312883436,
            "pseudo_op2_susp": 0.0010427528675703858,
            "pseudo_barinel_susp": 0.0015337423312883436
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.from_bounds#794",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.from_bounds(x0, y0, width, height)",
        "snippet": "    def from_bounds(x0, y0, width, height):\n        \"\"\"\n        Create a new `Bbox` from *x0*, *y0*, *width* and *height*.\n\n        *width* and *height* may be negative.\n        \"\"\"\n        return Bbox.from_extents(x0, y0, x0 + width, y0 + height)",
        "begin_line": 794,
        "end_line": 800,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019083969465648854,
            "pseudo_dstar_susp": 0.0010245901639344263,
            "pseudo_tarantula_susp": 0.0007485029940119761,
            "pseudo_op2_susp": 0.0010245901639344263,
            "pseudo_barinel_susp": 0.0007485029940119761
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.from_extents#803",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.from_extents(*args)",
        "snippet": "    def from_extents(*args):\n        \"\"\"\n        Create a new Bbox from *left*, *bottom*, *right* and *top*.\n\n        The *y*-axis increases upwards.\n        \"\"\"\n        return Bbox(np.reshape(args, (2, 2)))",
        "begin_line": 803,
        "end_line": 809,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.28332714444857e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.ignore#822",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.ignore(self, value)",
        "snippet": "    def ignore(self, value):\n        \"\"\"\n        Set whether the existing bounds of the box should be ignored\n        by subsequent calls to :meth:`update_from_data_xy`.\n\n        value : bool\n           - When ``True``, subsequent calls to :meth:`update_from_data_xy`\n             will ignore the existing bounds of the :class:`Bbox`.\n\n           - When ``False``, subsequent calls to :meth:`update_from_data_xy`\n             will include the existing bounds of the :class:`Bbox`.\n        \"\"\"\n        self._ignore = value",
        "begin_line": 822,
        "end_line": 834,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.204791598293403e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.update_from_path#836",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.update_from_path(self, path, ignore=None, updatex=True, updatey=True)",
        "snippet": "    def update_from_path(self, path, ignore=None, updatex=True, updatey=True):\n        \"\"\"\n        Update the bounds of the :class:`Bbox` based on the passed in\n        data.  After updating, the bounds will have positive *width*\n        and *height*; *x0* and *y0* will be the minimal values.\n\n        Parameters\n        ----------\n        path : :class:`~matplotlib.path.Path`\n\n        ignore : bool, optional\n           - when ``True``, ignore the existing bounds of the :class:`Bbox`.\n           - when ``False``, include the existing bounds of the :class:`Bbox`.\n           - when ``None``, use the last value passed to :meth:`ignore`.\n\n        updatex, updatey : bool, optional\n            When ``True``, update the x/y values.\n        \"\"\"\n        if ignore is None:\n            ignore = self._ignore\n\n        if path.vertices.size == 0:\n            return\n\n        points, minpos, changed = update_path_extents(\n            path, None, self._points, self._minpos, ignore)\n\n        if changed:\n            self.invalidate()\n            if updatex:\n                self._points[:, 0] = points[:, 0]\n                self._minpos[0] = minpos[0]\n            if updatey:\n                self._points[:, 1] = points[:, 1]\n                self._minpos[1] = minpos[1]",
        "begin_line": 836,
        "end_line": 870,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00047214353163361664,
            "pseudo_dstar_susp": 0.000578368999421631,
            "pseudo_tarantula_susp": 0.0017064846416382253,
            "pseudo_op2_susp": 0.000578368999421631,
            "pseudo_barinel_susp": 0.0017064846416382253
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.update_from_data_xy#872",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.update_from_data_xy(self, xy, ignore=None, updatex=True, updatey=True)",
        "snippet": "    def update_from_data_xy(self, xy, ignore=None, updatex=True, updatey=True):\n        \"\"\"\n        Update the bounds of the :class:`Bbox` based on the passed in\n        data.  After updating, the bounds will have positive *width*\n        and *height*; *x0* and *y0* will be the minimal values.\n\n        Parameters\n        ----------\n        xy : ndarray\n            A numpy array of 2D points.\n\n        ignore : bool, optional\n           - When ``True``, ignore the existing bounds of the :class:`Bbox`.\n           - When ``False``, include the existing bounds of the :class:`Bbox`.\n           - When ``None``, use the last value passed to :meth:`ignore`.\n\n        updatex, updatey : bool, optional\n            When ``True``, update the x/y values.\n        \"\"\"\n        if len(xy) == 0:\n            return\n\n        path = Path(xy)\n        self.update_from_path(path, ignore=ignore,\n                              updatex=updatex, updatey=updatey)",
        "begin_line": 872,
        "end_line": 896,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005194805194805195,
            "pseudo_dstar_susp": 0.0004972650422675286,
            "pseudo_tarantula_susp": 0.0019569471624266144,
            "pseudo_op2_susp": 0.0004972650422675286,
            "pseudo_barinel_susp": 0.0019569471624266144
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.y0#904",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.y0(self, val)",
        "snippet": "    def y0(self, val):\n        self._points[0, 1] = val\n        self.invalidate()",
        "begin_line": 904,
        "end_line": 906,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.252867871585376e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.x1#909",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.x1(self, val)",
        "snippet": "    def x1(self, val):\n        self._points[1, 0] = val\n        self.invalidate()",
        "begin_line": 909,
        "end_line": 911,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.375910880308233e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.y1#914",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.y1(self, val)",
        "snippet": "    def y1(self, val):\n        self._points[1, 1] = val\n        self.invalidate()",
        "begin_line": 914,
        "end_line": 916,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.375910880308233e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.intervaly#934",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.intervaly(self, interval)",
        "snippet": "    def intervaly(self, interval):\n        self._points[:, 1] = interval\n        self.invalidate()",
        "begin_line": 934,
        "end_line": 936,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0021691973969631237,
            "pseudo_dstar_susp": 0.001040582726326743,
            "pseudo_tarantula_susp": 0.0007704160246533128,
            "pseudo_op2_susp": 0.001040582726326743,
            "pseudo_barinel_susp": 0.0007704160246533128
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.minposx#951",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.minposx(self)",
        "snippet": "    def minposx(self):\n        return self._minpos[0]",
        "begin_line": 951,
        "end_line": 952,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002136752136752137,
            "pseudo_dstar_susp": 0.001034126163391934,
            "pseudo_tarantula_susp": 0.0007656967840735069,
            "pseudo_op2_susp": 0.001034126163391934,
            "pseudo_barinel_susp": 0.0007656967840735069
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.minposy#955",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.minposy(self)",
        "snippet": "    def minposy(self):\n        return self._minpos[1]",
        "begin_line": 955,
        "end_line": 956,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010548523206751054,
            "pseudo_dstar_susp": 0.001763668430335097,
            "pseudo_tarantula_susp": 0.0004885197850512946,
            "pseudo_op2_susp": 0.001763668430335097,
            "pseudo_barinel_susp": 0.0004885197850512946
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.set_points#966",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.set_points(self, points)",
        "snippet": "    def set_points(self, points):\n        \"\"\"\n        Set the points of the bounding box directly from a numpy array\n        of the form: ``[[x0, y0], [x1, y1]]``.  No error checking is\n        performed, as this method is mainly for internal use.\n        \"\"\"\n        if np.any(self._points != points):\n            self._points = points\n            self.invalidate()",
        "begin_line": 966,
        "end_line": 974,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.set#976",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.set(self, other)",
        "snippet": "    def set(self, other):\n        \"\"\"\n        Set this bounding box from the \"frozen\" bounds of another `Bbox`.\n        \"\"\"\n        if np.any(self._points != other.get_points()):\n            self._points = other.get_points()\n            self.invalidate()",
        "begin_line": 976,
        "end_line": 982,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00032808398950131233,
            "pseudo_dstar_susp": 0.0003183699458771092,
            "pseudo_tarantula_susp": 0.00041597337770382697,
            "pseudo_op2_susp": 0.0003183699458771092,
            "pseudo_barinel_susp": 0.00041597337770382697
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.mutatedx#988",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.mutatedx(self)",
        "snippet": "    def mutatedx(self):\n        \"\"\"Return whether the x-limits have changed since init.\"\"\"\n        return (self._points[0, 0] != self._points_orig[0, 0] or\n                self._points[1, 0] != self._points_orig[1, 0])",
        "begin_line": 988,
        "end_line": 991,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000708215297450425,
            "pseudo_dstar_susp": 0.0004268032437046522,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0004268032437046522,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "lib.matplotlib.transforms.Bbox.mutatedy#993",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Bbox",
        "signature": "lib.matplotlib.transforms.Bbox.mutatedy(self)",
        "snippet": "    def mutatedy(self):\n        \"\"\"Return whether the y-limits have changed since init.\"\"\"\n        return (self._points[0, 1] != self._points_orig[0, 1] or\n                self._points[1, 1] != self._points_orig[1, 1])",
        "begin_line": 993,
        "end_line": 996,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedBbox.__init__#1005",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedBbox",
        "signature": "lib.matplotlib.transforms.TransformedBbox.__init__(self, bbox, transform, **kwargs)",
        "snippet": "    def __init__(self, bbox, transform, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        bbox : :class:`Bbox`\n\n        transform : :class:`Transform`\n        \"\"\"\n        if not bbox.is_bbox:\n            raise ValueError(\"'bbox' is not a bbox\")\n        cbook._check_isinstance(Transform, transform=transform)\n        if transform.input_dims != 2 or transform.output_dims != 2:\n            raise ValueError(\n                \"The input and output dimensions of 'transform' must be 2\")\n\n        BboxBase.__init__(self, **kwargs)\n        self._bbox = bbox\n        self._transform = transform\n        self.set_children(bbox, transform)\n        self._points = None",
        "begin_line": 1005,
        "end_line": 1024,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001098901098901099,
            "pseudo_dstar_susp": 0.001851851851851852,
            "pseudo_tarantula_susp": 0.0008561643835616438,
            "pseudo_op2_susp": 0.001851851851851852,
            "pseudo_barinel_susp": 0.0008561643835616438
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedBbox.get_points#1028",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedBbox",
        "signature": "lib.matplotlib.transforms.TransformedBbox.get_points(self)",
        "snippet": "    def get_points(self):\n        # docstring inherited\n        if self._invalid:\n            p = self._bbox.get_points()\n            # Transform all four points, then make a new bounding box\n            # from the result, taking care to make the orientation the\n            # same.\n            points = self._transform.transform(\n                [[p[0, 0], p[0, 1]],\n                 [p[1, 0], p[0, 1]],\n                 [p[0, 0], p[1, 1]],\n                 [p[1, 0], p[1, 1]]])\n            points = np.ma.filled(points, 0.0)\n\n            xs = min(points[:, 0]), max(points[:, 0])\n            if p[0, 0] > p[1, 0]:\n                xs = xs[::-1]\n\n            ys = min(points[:, 1]), max(points[:, 1])\n            if p[0, 1] > p[1, 1]:\n                ys = ys[::-1]\n\n            self._points = np.array([\n                [xs[0], ys[0]],\n                [xs[1], ys[1]]\n            ])\n\n            self._invalid = 0\n        return self._points",
        "begin_line": 1028,
        "end_line": 1056,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005333333333333334,
            "pseudo_dstar_susp": 0.0005885815185403178,
            "pseudo_tarantula_susp": 0.001579778830963665,
            "pseudo_op2_susp": 0.0005885815185403178,
            "pseudo_barinel_susp": 0.001579778830963665
        }
    },
    {
        "name": "lib.matplotlib.transforms.LockableBbox.__init__#1074",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.LockableBbox",
        "signature": "lib.matplotlib.transforms.LockableBbox.__init__(self, bbox, x0=None, y0=None, x1=None, y1=None, **kwargs)",
        "snippet": "    def __init__(self, bbox, x0=None, y0=None, x1=None, y1=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        bbox : Bbox\n            The child bounding box to wrap.\n\n        x0 : float or None\n            The locked value for x0, or None to leave unlocked.\n\n        y0 : float or None\n            The locked value for y0, or None to leave unlocked.\n\n        x1 : float or None\n            The locked value for x1, or None to leave unlocked.\n\n        y1 : float or None\n            The locked value for y1, or None to leave unlocked.\n\n        \"\"\"\n        if not bbox.is_bbox:\n            raise ValueError(\"'bbox' is not a bbox\")\n\n        BboxBase.__init__(self, **kwargs)\n        self._bbox = bbox\n        self.set_children(bbox)\n        self._points = None\n        fp = [x0, y0, x1, y1]\n        mask = [val is None for val in fp]\n        self._locked_points = np.ma.array(fp, float, mask=mask).reshape((2, 2))",
        "begin_line": 1074,
        "end_line": 1103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.transforms.LockableBbox.get_points#1107",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.LockableBbox",
        "signature": "lib.matplotlib.transforms.LockableBbox.get_points(self)",
        "snippet": "    def get_points(self):\n        # docstring inherited\n        if self._invalid:\n            points = self._bbox.get_points()\n            self._points = np.where(self._locked_points.mask,\n                                    points,\n                                    self._locked_points)\n            self._invalid = 0\n        return self._points",
        "begin_line": 1107,
        "end_line": 1115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.transforms.LockableBbox.locked_x0#1136",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.LockableBbox",
        "signature": "lib.matplotlib.transforms.LockableBbox.locked_x0(self, x0)",
        "snippet": "    def locked_x0(self, x0):\n        self._locked_points.mask[0, 0] = x0 is None\n        self._locked_points.data[0, 0] = x0\n        self.invalidate()",
        "begin_line": 1136,
        "end_line": 1139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.LockableBbox.locked_y0#1142",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.LockableBbox",
        "signature": "lib.matplotlib.transforms.LockableBbox.locked_y0(self)",
        "snippet": "    def locked_y0(self):\n        \"\"\"\n        float or None: The value used for the locked y0.\n        \"\"\"\n        if self._locked_points.mask[0, 1]:\n            return None\n        else:\n            return self._locked_points[0, 1]",
        "begin_line": 1142,
        "end_line": 1149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.LockableBbox.locked_y0#1152",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.LockableBbox",
        "signature": "lib.matplotlib.transforms.LockableBbox.locked_y0(self, y0)",
        "snippet": "    def locked_y0(self, y0):\n        self._locked_points.mask[0, 1] = y0 is None\n        self._locked_points.data[0, 1] = y0\n        self.invalidate()",
        "begin_line": 1152,
        "end_line": 1155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.transforms.LockableBbox.locked_y1#1174",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.LockableBbox",
        "signature": "lib.matplotlib.transforms.LockableBbox.locked_y1(self)",
        "snippet": "    def locked_y1(self):\n        \"\"\"\n        float or None: The value used for the locked y1.\n        \"\"\"\n        if self._locked_points.mask[1, 1]:\n            return None\n        else:\n            return self._locked_points[1, 1]",
        "begin_line": 1174,
        "end_line": 1181,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.__init_subclass__#1238",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.__init_subclass__(cls)",
        "snippet": "    def __init_subclass__(cls):\n        # 1d transforms are always separable; we assume higher-dimensional ones\n        # are not but subclasses can also directly set is_separable -- this is\n        # verified by checking whether \"is_separable\" appears more than once in\n        # the class's MRO (it appears once in Transform).\n        if (sum(\"is_separable\" in vars(parent) for parent in cls.__mro__) == 1\n                and cls.input_dims == cls.output_dims == 1):\n            cls.is_separable = True\n        # Transform.inverted raises NotImplementedError; we assume that if this\n        # is overridden then the transform is invertible but subclass can also\n        # directly set has_inverse.\n        if (sum(\"has_inverse\" in vars(parent) for parent in cls.__mro__) == 1\n                and hasattr(cls, \"inverted\")\n                and cls.inverted is not Transform.inverted):\n            cls.has_inverse = True",
        "begin_line": 1238,
        "end_line": 1252,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.__add__#1254",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.__add__(self, other)",
        "snippet": "    def __add__(self, other):\n        \"\"\"\n        Compose two transforms together so that *self* is followed by *other*.\n        \"\"\"\n        return (composite_transform_factory(self, other)\n                if isinstance(other, Transform) else\n                NotImplemented)",
        "begin_line": 1254,
        "end_line": 1260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004923682914820286,
            "pseudo_dstar_susp": 0.0005402485143165856,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.0005402485143165856,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform._iter_break_from_left_to_right#1266",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform._iter_break_from_left_to_right(self)",
        "snippet": "    def _iter_break_from_left_to_right(self):\n        \"\"\"\n        Returns an iterator breaking down this transform stack from left to\n        right recursively. If self == ((A, N), A) then the result will be an\n        iterator which yields I : ((A, N), A), followed by A : (N, A),\n        followed by (A, N) : (A), but not ((A, N), A) : I.\n\n        This is equivalent to flattening the stack then yielding\n        ``flat_stack[:i], flat_stack[i:]`` where i=0..(n-1).\n\n        \"\"\"\n        yield IdentityTransform(), self",
        "begin_line": 1266,
        "end_line": 1277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005730659025787965,
            "pseudo_dstar_susp": 0.0005847953216374269,
            "pseudo_tarantula_susp": 0.0016863406408094434,
            "pseudo_op2_susp": 0.0005847953216374269,
            "pseudo_barinel_susp": 0.0016863406408094434
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.depth#1280",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.depth(self)",
        "snippet": "    def depth(self):\n        \"\"\"\n        Returns the number of transforms which have been chained\n        together to form this Transform instance.\n\n        .. note::\n\n            For the special case of a Composite transform, the maximum depth\n            of the two is returned.\n\n        \"\"\"\n        return 1",
        "begin_line": 1280,
        "end_line": 1291,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00033647375504710633,
            "pseudo_dstar_susp": 0.0005861664712778429,
            "pseudo_tarantula_susp": 0.00032299741602067185,
            "pseudo_op2_susp": 0.0005861664712778429,
            "pseudo_barinel_susp": 0.00032299741602067185
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.contains_branch#1293",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.contains_branch(self, other)",
        "snippet": "    def contains_branch(self, other):\n        \"\"\"\n        Return whether the given transform is a sub-tree of this transform.\n\n        This routine uses transform equality to identify sub-trees, therefore\n        in many situations it is object id which will be used.\n\n        For the case where the given transform represents the whole\n        of this transform, returns True.\n\n        \"\"\"\n        if self.depth < other.depth:\n            return False\n\n        # check that a subtree is equal to other (starting from self)\n        for _, sub_tree in self._iter_break_from_left_to_right():\n            if sub_tree == other:\n                return True\n        return False",
        "begin_line": 1293,
        "end_line": 1311,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005165289256198347,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.001392757660167131,
            "pseudo_op2_susp": 0.0005906674542232723,
            "pseudo_barinel_susp": 0.001392757660167131
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.contains_branch_seperately#1313",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.contains_branch_seperately(self, other_transform)",
        "snippet": "    def contains_branch_seperately(self, other_transform):\n        \"\"\"\n        Returns whether the given branch is a sub-tree of this transform on\n        each separate dimension.\n\n        A common use for this method is to identify if a transform is a blended\n        transform containing an axes' data transform. e.g.::\n\n            x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)\n\n        \"\"\"\n        if self.output_dims != 2:\n            raise ValueError('contains_branch_seperately only supports '\n                             'transforms with 2 output dimensions')\n        # for a non-blended transform each separate dimension is the same, so\n        # just return the appropriate shape.\n        return [self.contains_branch(other_transform)] * 2",
        "begin_line": 1313,
        "end_line": 1329,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005913660555884093,
            "pseudo_dstar_susp": 0.0005599104143337066,
            "pseudo_tarantula_susp": 0.0017482517482517483,
            "pseudo_op2_susp": 0.0005599104143337066,
            "pseudo_barinel_susp": 0.0017482517482517483
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.__sub__#1331",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.__sub__(self, other)",
        "snippet": "    def __sub__(self, other):\n        \"\"\"\n        Returns a transform stack which goes all the way down self's transform\n        stack, and then ascends back up other's stack. If it can, this is\n        optimised::\n\n            # normally\n            A - B == a + b.inverted()\n\n            # sometimes, when A contains the tree B there is no need to\n            # descend all the way down to the base of A (via B), instead we\n            # can just stop at B.\n\n            (A + B) - (B)^-1 == A\n\n            # similarly, when B contains tree A, we can avoid descending A at\n            # all, basically:\n            A - (A + B) == ((B + A) - A).inverted() or B^-1\n\n        For clarity, the result of ``(A + B) - B + B == (A + B)``.\n\n        \"\"\"\n        # we only know how to do this operation if other is a Transform.\n        if not isinstance(other, Transform):\n            return NotImplemented\n\n        for remainder, sub_tree in self._iter_break_from_left_to_right():\n            if sub_tree == other:\n                return remainder\n\n        for remainder, sub_tree in other._iter_break_from_left_to_right():\n            if sub_tree == self:\n                if not remainder.has_inverse:\n                    raise ValueError(\n                        \"The shortcut cannot be computed since 'other' \"\n                        \"includes a non-invertible component\")\n                return remainder.inverted()\n\n        # if we have got this far, then there was no shortcut possible\n        if other.has_inverse:\n            return self + other.inverted()\n        else:\n            raise ValueError('It is not possible to compute transA - transB '\n                             'since transB cannot be inverted and there is no '\n                             'shortcut possible.')",
        "begin_line": 1331,
        "end_line": 1375,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.__array__#1377",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.__array__(self, *args, **kwargs)",
        "snippet": "    def __array__(self, *args, **kwargs):\n        \"\"\"\n        Array interface to get at this Transform's affine matrix.\n        \"\"\"\n        return self.get_affine().get_matrix()",
        "begin_line": 1377,
        "end_line": 1381,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004752851711026616,
            "pseudo_dstar_susp": 0.00040241448692152917,
            "pseudo_tarantula_susp": 0.0017482517482517483,
            "pseudo_op2_susp": 0.00040241448692152917,
            "pseudo_barinel_susp": 0.0017482517482517483
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.transform#1383",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.transform(self, values)",
        "snippet": "    def transform(self, values):\n        \"\"\"\n        Performs the transformation on the given array of values.\n\n        Accepts a numpy array of shape (N x :attr:`input_dims`) and\n        returns a numpy array of shape (N x :attr:`output_dims`).\n\n        Alternatively, accepts a numpy array of length :attr:`input_dims`\n        and returns a numpy array of length :attr:`output_dims`.\n        \"\"\"\n        # Ensure that values is a 2d array (but remember whether\n        # we started with a 1d or 2d array).\n        values = np.asanyarray(values)\n        ndim = values.ndim\n        values = values.reshape((-1, self.input_dims))\n\n        # Transform the values\n        res = self.transform_affine(self.transform_non_affine(values))\n\n        # Convert the result back to the shape of the input values.\n        if ndim == 0:\n            assert not np.ma.is_masked(res)  # just to be on the safe side\n            return res[0, 0]\n        if ndim == 1:\n            return res.reshape(-1)\n        elif ndim == 2:\n            return res\n        raise ValueError(\n            \"Input values must have shape (N x {dims}) \"\n            \"or ({dims}).\".format(dims=self.input_dims))",
        "begin_line": 1383,
        "end_line": 1412,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00035536602700781805,
            "pseudo_dstar_susp": 0.000591715976331361,
            "pseudo_tarantula_susp": 0.0003436426116838488,
            "pseudo_op2_susp": 0.000591715976331361,
            "pseudo_barinel_susp": 0.0003436426116838488
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.transform_affine#1414",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.transform_affine(self, values)",
        "snippet": "    def transform_affine(self, values):\n        \"\"\"\n        Performs only the affine part of this transformation on the\n        given array of values.\n\n        ``transform(values)`` is always equivalent to\n        ``transform_affine(transform_non_affine(values))``.\n\n        In non-affine transformations, this is generally a no-op.  In\n        affine transformations, this is equivalent to\n        ``transform(values)``.\n\n        Parameters\n        ----------\n        values : array\n            The input values as NumPy array of length :attr:`input_dims` or\n            shape (N x :attr:`input_dims`).\n\n        Returns\n        -------\n        values : array\n            The output values as NumPy array of length :attr:`input_dims` or\n            shape (N x :attr:`output_dims`), depending on the input.\n        \"\"\"\n        return self.get_affine().transform(values)",
        "begin_line": 1414,
        "end_line": 1438,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.transform_bbox#1465",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.transform_bbox(self, bbox)",
        "snippet": "    def transform_bbox(self, bbox):\n        \"\"\"\n        Transform the given bounding box.\n\n        Note, for smarter transforms including caching (a common\n        requirement for matplotlib figures), see :class:`TransformedBbox`.\n        \"\"\"\n        return Bbox(self.transform(bbox.get_points()))",
        "begin_line": 1465,
        "end_line": 1472,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.get_affine#1474",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.get_affine(self)",
        "snippet": "    def get_affine(self):\n        \"\"\"\n        Get the affine part of this transform.\n        \"\"\"\n        return IdentityTransform()",
        "begin_line": 1474,
        "end_line": 1478,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004975124378109452,
            "pseudo_dstar_susp": 0.00040404040404040404,
            "pseudo_tarantula_susp": 0.0017921146953405018,
            "pseudo_op2_susp": 0.00040404040404040404,
            "pseudo_barinel_susp": 0.0017921146953405018
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.get_matrix#1480",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        \"\"\"\n        Get the Affine transformation array for the affine part\n        of this transform.\n\n        \"\"\"\n        return self.get_affine().get_matrix()",
        "begin_line": 1480,
        "end_line": 1486,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040290088638195,
            "pseudo_dstar_susp": 0.00036859565057132326,
            "pseudo_tarantula_susp": 0.000942507068803016,
            "pseudo_op2_susp": 0.00036859565057132326,
            "pseudo_barinel_susp": 0.000942507068803016
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.transform_path#1504",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.transform_path(self, path)",
        "snippet": "    def transform_path(self, path):\n        \"\"\"\n        Returns a transformed path.\n\n        *path*: a :class:`~matplotlib.path.Path` instance.\n\n        In some cases, this transform may insert curves into the path\n        that began as line segments.\n        \"\"\"\n        return self.transform_path_affine(self.transform_path_non_affine(path))",
        "begin_line": 1504,
        "end_line": 1513,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00039761431411530816,
            "pseudo_dstar_susp": 0.0003650967506389193,
            "pseudo_tarantula_susp": 0.0009115770282588879,
            "pseudo_op2_susp": 0.0003650967506389193,
            "pseudo_barinel_susp": 0.0009115770282588879
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.transform_path_affine#1515",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.transform_path_affine(self, path)",
        "snippet": "    def transform_path_affine(self, path):\n        \"\"\"\n        Returns a path, transformed only by the affine part of\n        this transform.\n\n        *path*: a :class:`~matplotlib.path.Path` instance.\n\n        ``transform_path(path)`` is equivalent to\n        ``transform_path_affine(transform_path_non_affine(values))``.\n        \"\"\"\n        return self.get_affine().transform_path_affine(path)",
        "begin_line": 1515,
        "end_line": 1525,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000392156862745098,
            "pseudo_dstar_susp": 0.0003606202668589975,
            "pseudo_tarantula_susp": 0.0008561643835616438,
            "pseudo_op2_susp": 0.0003606202668589975,
            "pseudo_barinel_susp": 0.0008561643835616438
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.transform_path_non_affine#1527",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.transform_path_non_affine(self, path)",
        "snippet": "    def transform_path_non_affine(self, path):\n        \"\"\"\n        Returns a path, transformed only by the non-affine\n        part of this transform.\n\n        *path*: a :class:`~matplotlib.path.Path` instance.\n\n        ``transform_path(path)`` is equivalent to\n        ``transform_path_affine(transform_path_non_affine(values))``.\n        \"\"\"\n        x = self.transform_non_affine(path.vertices)\n        return Path._fast_from_codes_and_verts(x, path.codes, path)",
        "begin_line": 1527,
        "end_line": 1538,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003812428516965307,
            "pseudo_dstar_susp": 0.00035198873636043646,
            "pseudo_tarantula_susp": 0.0007564296520423601,
            "pseudo_op2_susp": 0.00035198873636043646,
            "pseudo_barinel_susp": 0.0007564296520423601
        }
    },
    {
        "name": "lib.matplotlib.transforms.Transform.transform_angles#1540",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Transform",
        "signature": "lib.matplotlib.transforms.Transform.transform_angles(self, angles, pts, radians=False, pushoff=1e-05)",
        "snippet": "    def transform_angles(self, angles, pts, radians=False, pushoff=1e-5):\n        \"\"\"\n        Transforms a set of angles anchored at specific locations.\n\n        Parameters\n        ----------\n        angles : (N,) array-like\n            The angles to transform.\n        pts : (N, 2) array-like\n            The points where the angles are anchored.\n        radians : bool, default: False\n            Whether *angles* are radians or degrees.\n        pushoff : float\n            For each point in *pts* and angle in *angles*, the transformed\n            angle is computed by transforming a segment of length *pushoff*\n            starting at that point and making that angle relative to the\n            horizontal axis, and measuring the angle between the horizontal\n            axis and the transformed segment.\n\n        Returns\n        -------\n        transformed_angles : (N,) array\n        \"\"\"\n        # Must be 2D\n        if self.input_dims != 2 or self.output_dims != 2:\n            raise NotImplementedError('Only defined in 2D')\n        angles = np.asarray(angles)\n        pts = np.asarray(pts)\n        if angles.ndim != 1 or angles.shape[0] != pts.shape[0]:\n            raise ValueError(\"'angles' must be a column vector and have same \"\n                             \"number of rows as 'pts'\")\n        if pts.shape[1] != 2:\n            raise ValueError(\"'pts' must be array with 2 columns for x, y\")\n        # Convert to radians if desired\n        if not radians:\n            angles = np.deg2rad(angles)\n        # Move a short distance away\n        pts2 = pts + pushoff * np.column_stack([np.cos(angles),\n                                                np.sin(angles)])\n        # Transform both sets of points\n        tpts = self.transform(pts)\n        tpts2 = self.transform(pts2)\n        # Calculate transformed angles\n        d = tpts2 - tpts\n        a = np.arctan2(d[:, 1], d[:, 0])\n        # Convert back to degrees if desired\n        if not radians:\n            a = np.rad2deg(a)\n        return a",
        "begin_line": 1540,
        "end_line": 1588,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformWrapper.__init__#1619",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformWrapper",
        "signature": "lib.matplotlib.transforms.TransformWrapper.__init__(self, child)",
        "snippet": "    def __init__(self, child):\n        \"\"\"\n        *child*: A class:`Transform` instance.  This child may later\n        be replaced with :meth:`set`.\n        \"\"\"\n        cbook._check_isinstance(Transform, child=child)\n        self._init(child)\n        self.set_children(child)",
        "begin_line": 1619,
        "end_line": 1626,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001443001443001443,
            "pseudo_dstar_susp": 0.002638522427440633,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.002638522427440633,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformWrapper._init#1628",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformWrapper",
        "signature": "lib.matplotlib.transforms.TransformWrapper._init(self, child)",
        "snippet": "    def _init(self, child):\n        Transform.__init__(self)\n        self.input_dims = child.input_dims\n        self.output_dims = child.output_dims\n        self._set(child)\n        self._invalid = 0",
        "begin_line": 1628,
        "end_line": 1633,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002197802197802198,
            "pseudo_dstar_susp": 0.002638522427440633,
            "pseudo_tarantula_susp": 0.001392757660167131,
            "pseudo_op2_susp": 0.002638522427440633,
            "pseudo_barinel_susp": 0.001392757660167131
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformWrapper.__eq__#1635",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformWrapper",
        "signature": "lib.matplotlib.transforms.TransformWrapper.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        return self._child.__eq__(other)",
        "begin_line": 1635,
        "end_line": 1636,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005107252298263534,
            "pseudo_dstar_susp": 0.0005858230814294083,
            "pseudo_tarantula_susp": 0.0013605442176870747,
            "pseudo_op2_susp": 0.0005858230814294083,
            "pseudo_barinel_susp": 0.0013531799729364006
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformWrapper.frozen#1640",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformWrapper",
        "signature": "lib.matplotlib.transforms.TransformWrapper.frozen(self)",
        "snippet": "    def frozen(self):\n        # docstring inherited\n        return self._child.frozen()",
        "begin_line": 1640,
        "end_line": 1642,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000429553264604811,
            "pseudo_dstar_susp": 0.00038446751249519417,
            "pseudo_tarantula_susp": 0.0013605442176870747,
            "pseudo_op2_susp": 0.00038446751249519417,
            "pseudo_barinel_susp": 0.0013531799729364006
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformWrapper._set#1644",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformWrapper",
        "signature": "lib.matplotlib.transforms.TransformWrapper._set(self, child)",
        "snippet": "    def _set(self, child):\n        self._child = child\n\n        self.transform = child.transform\n        self.transform_affine = child.transform_affine\n        self.transform_non_affine = child.transform_non_affine\n        self.transform_path = child.transform_path\n        self.transform_path_affine = child.transform_path_affine\n        self.transform_path_non_affine = child.transform_path_non_affine\n        self.get_affine = child.get_affine\n        self.inverted = child.inverted\n        self.get_matrix = child.get_matrix",
        "begin_line": 1644,
        "end_line": 1655,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002197802197802198,
            "pseudo_dstar_susp": 0.002531645569620253,
            "pseudo_tarantula_susp": 0.0009115770282588879,
            "pseudo_op2_susp": 0.002531645569620253,
            "pseudo_barinel_susp": 0.0009115770282588879
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformWrapper.set#1661",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformWrapper",
        "signature": "lib.matplotlib.transforms.TransformWrapper.set(self, child)",
        "snippet": "    def set(self, child):\n        \"\"\"\n        Replace the current child of this transform with another one.\n\n        The new child must have the same number of input and output\n        dimensions as the current child.\n        \"\"\"\n        if (child.input_dims != self.input_dims or\n                child.output_dims != self.output_dims):\n            raise ValueError(\n                \"The new child must have the same number of input and output \"\n                \"dimensions as the current child\")\n\n        self.set_children(child)\n        self._set(child)\n\n        self._invalid = 0\n        self.invalidate()\n        self._invalid = 0",
        "begin_line": 1661,
        "end_line": 1679,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001519756838905775,
            "pseudo_dstar_susp": 0.002336448598130841,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.002336448598130841,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.__init__#1693",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        Transform.__init__(self, *args, **kwargs)\n        self._inverted = None",
        "begin_line": 1693,
        "end_line": 1695,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008628127696289905,
            "pseudo_dstar_susp": 0.0014285714285714286,
            "pseudo_tarantula_susp": 0.001282051282051282,
            "pseudo_op2_susp": 0.0014285714285714286,
            "pseudo_barinel_susp": 0.001282051282051282
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.__array__#1697",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.__array__(self, *args, **kwargs)",
        "snippet": "    def __array__(self, *args, **kwargs):\n        # optimises the access of the transform matrix vs. the superclass\n        return self.get_matrix()",
        "begin_line": 1697,
        "end_line": 1699,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003861003861003861,
            "pseudo_dstar_susp": 0.000355998576005696,
            "pseudo_tarantula_susp": 0.0008077544426494346,
            "pseudo_op2_susp": 0.000355998576005696,
            "pseudo_barinel_susp": 0.0008077544426494346
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.__eq__#1701",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        if getattr(other, \"is_affine\", False):\n            return np.all(self.get_matrix() == other.get_matrix())\n        return NotImplemented",
        "begin_line": 1701,
        "end_line": 1704,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005107252298263534,
            "pseudo_dstar_susp": 0.0005777007510109763,
            "pseudo_tarantula_susp": 0.0013605442176870747,
            "pseudo_op2_susp": 0.0005777007510109763,
            "pseudo_barinel_susp": 0.0013531799729364006
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.transform#1706",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.transform(self, values)",
        "snippet": "    def transform(self, values):\n        # docstring inherited\n        return self.transform_affine(values)",
        "begin_line": 1706,
        "end_line": 1708,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005157297576070139,
            "pseudo_dstar_susp": 0.0005787037037037037,
            "pseudo_tarantula_susp": 0.0013736263736263737,
            "pseudo_op2_susp": 0.0005787037037037037,
            "pseudo_barinel_susp": 0.0013736263736263737
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.transform_non_affine#1715",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.transform_non_affine(self, points)",
        "snippet": "    def transform_non_affine(self, points):\n        # docstring inherited\n        return points",
        "begin_line": 1715,
        "end_line": 1717,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000708215297450425,
            "pseudo_dstar_susp": 0.0004268032437046522,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0004268032437046522,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.transform_path#1719",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.transform_path(self, path)",
        "snippet": "    def transform_path(self, path):\n        # docstring inherited\n        return self.transform_path_affine(path)",
        "begin_line": 1719,
        "end_line": 1721,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.transform_path_affine#1723",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.transform_path_affine(self, path)",
        "snippet": "    def transform_path_affine(self, path):\n        # docstring inherited\n        return Path(self.transform_affine(path.vertices),\n                    path.codes, path._interpolation_steps)",
        "begin_line": 1723,
        "end_line": 1726,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003952569169960474,
            "pseudo_dstar_susp": 0.00036310820624546115,
            "pseudo_tarantula_susp": 0.00089126559714795,
            "pseudo_op2_susp": 0.00036310820624546115,
            "pseudo_barinel_susp": 0.00089126559714795
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.transform_path_non_affine#1728",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.transform_path_non_affine(self, path)",
        "snippet": "    def transform_path_non_affine(self, path):\n        # docstring inherited\n        return path",
        "begin_line": 1728,
        "end_line": 1730,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.transforms.AffineBase.get_affine#1732",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.AffineBase",
        "signature": "lib.matplotlib.transforms.AffineBase.get_affine(self)",
        "snippet": "    def get_affine(self):\n        # docstring inherited\n        return self",
        "begin_line": 1732,
        "end_line": 1734,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005047955577990914,
            "pseudo_dstar_susp": 0.0005704506560182544,
            "pseudo_tarantula_susp": 0.0013157894736842105,
            "pseudo_op2_susp": 0.0005704506560182544,
            "pseudo_barinel_susp": 0.0013157894736842105
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2DBase.is_separable#1761",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2DBase",
        "signature": "lib.matplotlib.transforms.Affine2DBase.is_separable(self)",
        "snippet": "    def is_separable(self):\n        mtx = self.get_matrix()\n        return mtx[0, 1] == mtx[1, 0] == 0.0",
        "begin_line": 1761,
        "end_line": 1763,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010976948408342481,
            "pseudo_dstar_susp": 0.0018484288354898336,
            "pseudo_tarantula_susp": 0.000502008032128514,
            "pseudo_op2_susp": 0.0018484288354898336,
            "pseudo_barinel_susp": 0.000502008032128514
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2DBase.transform_affine#1785",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2DBase",
        "signature": "lib.matplotlib.transforms.Affine2DBase.transform_affine(self, points)",
        "snippet": "    def transform_affine(self, points):\n        mtx = self.get_matrix()\n        if isinstance(points, np.ma.MaskedArray):\n            tpoints = affine_transform(points.data, mtx)\n            return np.ma.MaskedArray(tpoints, mask=np.ma.getmask(points))\n        return affine_transform(points, mtx)",
        "begin_line": 1785,
        "end_line": 1790,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003026634382566586,
            "pseudo_dstar_susp": 0.0005685048322910744,
            "pseudo_tarantula_susp": 0.0002826455624646693,
            "pseudo_op2_susp": 0.0005685048322910744,
            "pseudo_barinel_susp": 0.0002826455624646693
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2DBase.inverted#1806",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2DBase",
        "signature": "lib.matplotlib.transforms.Affine2DBase.inverted(self)",
        "snippet": "    def inverted(self):\n        # docstring inherited\n        if self._inverted is None or self._invalid:\n            mtx = self.get_matrix()\n            shorthand_name = None\n            if self._shorthand_name:\n                shorthand_name = '(%s)-1' % self._shorthand_name\n            self._inverted = Affine2D(inv(mtx), shorthand_name=shorthand_name)\n            self._invalid = 0\n        return self._inverted",
        "begin_line": 1806,
        "end_line": 1815,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003114294612270321,
            "pseudo_dstar_susp": 0.00030674846625766873,
            "pseudo_tarantula_susp": 0.0003466204506065858,
            "pseudo_op2_susp": 0.00030674846625766873,
            "pseudo_barinel_susp": 0.0003466204506065858
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.__init__#1823",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.__init__(self, matrix=None, **kwargs)",
        "snippet": "    def __init__(self, matrix=None, **kwargs):\n        \"\"\"\n        Initialize an Affine transform from a 3x3 numpy float array::\n\n          a c e\n          b d f\n          0 0 1\n\n        If *matrix* is None, initialize with the identity transform.\n        \"\"\"\n        Affine2DBase.__init__(self, **kwargs)\n        if matrix is None:\n            # A bit faster than np.identity(3).\n            matrix = IdentityTransform._mtx.copy()\n        self._mtx = matrix\n        self._invalid = 0",
        "begin_line": 1823,
        "end_line": 1838,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006184291898577613,
            "pseudo_dstar_susp": 0.001183431952662722,
            "pseudo_tarantula_susp": 0.001128668171557562,
            "pseudo_op2_susp": 0.001183431952662722,
            "pseudo_barinel_susp": 0.001128668171557562
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.from_values#1843",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.from_values(a, b, c, d, e, f)",
        "snippet": "    def from_values(a, b, c, d, e, f):\n        \"\"\"\n        Create a new Affine2D instance from the given values::\n\n          a c e\n          b d f\n          0 0 1\n\n        .\n        \"\"\"\n        return Affine2D(\n            np.array([a, c, e, b, d, f, 0.0, 0.0, 1.0], float).reshape((3, 3)))",
        "begin_line": 1843,
        "end_line": 1854,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.get_matrix#1856",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        \"\"\"\n        Get the underlying transformation matrix as a 3x3 numpy array::\n\n          a c e\n          b d f\n          0 0 1\n\n        .\n        \"\"\"\n        if self._invalid:\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx",
        "begin_line": 1856,
        "end_line": 1869,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000500751126690035,
            "pseudo_dstar_susp": 0.0005681818181818182,
            "pseudo_tarantula_susp": 0.001282051282051282,
            "pseudo_op2_susp": 0.0005681818181818182,
            "pseudo_barinel_susp": 0.001282051282051282
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.clear#1903",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.clear(self)",
        "snippet": "    def clear(self):\n        \"\"\"\n        Reset the underlying matrix to the identity transform.\n        \"\"\"\n        # A bit faster than np.identity(3).\n        self._mtx = IdentityTransform._mtx.copy()\n        self.invalidate()\n        return self",
        "begin_line": 1903,
        "end_line": 1910,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038880248833592535,
            "pseudo_dstar_susp": 0.00035816618911174784,
            "pseudo_tarantula_susp": 0.0008305647840531562,
            "pseudo_op2_susp": 0.00035816618911174784,
            "pseudo_barinel_susp": 0.0008305647840531562
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.rotate#1912",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.rotate(self, theta)",
        "snippet": "    def rotate(self, theta):\n        \"\"\"\n        Add a rotation (in radians) to this transform in place.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        a = np.cos(theta)\n        b = np.sin(theta)\n        rotate_mtx = np.array([[a, -b, 0.0], [b, a, 0.0], [0.0, 0.0, 1.0]],\n                              float)\n        self._mtx = np.dot(rotate_mtx, self._mtx)\n        self.invalidate()\n        return self",
        "begin_line": 1912,
        "end_line": 1926,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006402048655569782,
            "pseudo_dstar_susp": 0.0012360939431396785,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0012360939431396785,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.rotate_deg#1928",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.rotate_deg(self, degrees)",
        "snippet": "    def rotate_deg(self, degrees):\n        \"\"\"\n        Add a rotation (in degrees) to this transform in place.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        return self.rotate(np.deg2rad(degrees))",
        "begin_line": 1928,
        "end_line": 1936,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006849315068493151,
            "pseudo_dstar_susp": 0.0013850415512465374,
            "pseudo_tarantula_susp": 0.001128668171557562,
            "pseudo_op2_susp": 0.0013850415512465374,
            "pseudo_barinel_susp": 0.001128668171557562
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.rotate_deg_around#1948",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.rotate_deg_around(self, x, y, degrees)",
        "snippet": "    def rotate_deg_around(self, x, y, degrees):\n        \"\"\"\n        Add a rotation (in degrees) around the point (x, y) in place.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        # Cast to float to avoid wraparound issues with uint8's\n        x, y = float(x), float(y)\n        return self.translate(-x, -y).rotate_deg(degrees).translate(x, y)",
        "begin_line": 1948,
        "end_line": 1958,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006353240152477764,
            "pseudo_dstar_susp": 0.0012254901960784314,
            "pseudo_tarantula_susp": 0.0012610340479192938,
            "pseudo_op2_susp": 0.0012254901960784314,
            "pseudo_barinel_susp": 0.0012626262626262627
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.translate#1960",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.translate(self, tx, ty)",
        "snippet": "    def translate(self, tx, ty):\n        \"\"\"\n        Adds a translation in place.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        translate_mtx = np.array(\n            [[1.0, 0.0, tx], [0.0, 1.0, ty], [0.0, 0.0, 1.0]], float)\n        self._mtx = np.dot(translate_mtx, self._mtx)\n        self.invalidate()\n        return self",
        "begin_line": 1960,
        "end_line": 1972,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006293266205160479,
            "pseudo_dstar_susp": 0.0012033694344163659,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0012033694344163659,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.scale#1974",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.scale(self, sx, sy=None)",
        "snippet": "    def scale(self, sx, sy=None):\n        \"\"\"\n        Adds a scale in place.\n\n        If *sy* is None, the same scale is applied in both the *x*- and\n        *y*-directions.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        if sy is None:\n            sy = sx\n        scale_mtx = np.array(\n            [[sx, 0.0, 0.0], [0.0, sy, 0.0], [0.0, 0.0, 1.0]], float)\n        self._mtx = np.dot(scale_mtx, self._mtx)\n        self.invalidate()\n        return self",
        "begin_line": 1974,
        "end_line": 1991,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006373486297004461,
            "pseudo_dstar_susp": 0.0012285012285012285,
            "pseudo_tarantula_susp": 0.001128668171557562,
            "pseudo_op2_susp": 0.0012285012285012285,
            "pseudo_barinel_susp": 0.001128668171557562
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.skew#1993",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.skew(self, xShear, yShear)",
        "snippet": "    def skew(self, xShear, yShear):\n        \"\"\"\n        Adds a skew in place.\n\n        *xShear* and *yShear* are the shear angles along the *x*- and\n        *y*-axes, respectively, in radians.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        rotX = np.tan(xShear)\n        rotY = np.tan(yShear)\n        skew_mtx = np.array(\n            [[1.0, rotX, 0.0], [rotY, 1.0, 0.0], [0.0, 0.0, 1.0]], float)\n        self._mtx = np.dot(skew_mtx, self._mtx)\n        self.invalidate()\n        return self",
        "begin_line": 1993,
        "end_line": 2010,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.Affine2D.skew_deg#2012",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.Affine2D",
        "signature": "lib.matplotlib.transforms.Affine2D.skew_deg(self, xShear, yShear)",
        "snippet": "    def skew_deg(self, xShear, yShear):\n        \"\"\"\n        Adds a skew in place.\n\n        *xShear* and *yShear* are the shear angles along the *x*- and\n        *y*-axes, respectively, in degrees.\n\n        Returns *self*, so this method can easily be chained with more\n        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`\n        and :meth:`scale`.\n        \"\"\"\n        return self.skew(np.deg2rad(xShear), np.deg2rad(yShear))",
        "begin_line": 2012,
        "end_line": 2023,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.frozen#2033",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.frozen(self)",
        "snippet": "    def frozen(self):\n        # docstring inherited\n        return self",
        "begin_line": 2033,
        "end_line": 2035,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005988023952095808,
            "pseudo_dstar_susp": 0.0004233700254022015,
            "pseudo_tarantula_susp": 0.0024813895781637717,
            "pseudo_op2_susp": 0.0004233700254022015,
            "pseudo_barinel_susp": 0.0024813895781637717
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.get_matrix#2039",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        # docstring inherited\n        return self._mtx",
        "begin_line": 2039,
        "end_line": 2041,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017452006980802793,
            "pseudo_dstar_susp": 0.0009910802775024777,
            "pseudo_tarantula_susp": 0.0013605442176870747,
            "pseudo_op2_susp": 0.0009910802775024777,
            "pseudo_barinel_susp": 0.0013531799729364006
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.transform#2043",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.transform(self, points)",
        "snippet": "    def transform(self, points):\n        # docstring inherited\n        return np.asanyarray(points)",
        "begin_line": 2043,
        "end_line": 2045,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002777777777777778,
            "pseudo_dstar_susp": 0.0002777777777777778,
            "pseudo_tarantula_susp": 0.0002808199943836001,
            "pseudo_op2_susp": 0.0002777777777777778,
            "pseudo_barinel_susp": 0.0002808199943836001
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.transform_non_affine#2051",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.transform_non_affine(self, points)",
        "snippet": "    def transform_non_affine(self, points):\n        # docstring inherited\n        return np.asanyarray(points)",
        "begin_line": 2051,
        "end_line": 2053,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.transform_path_affine#2059",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.transform_path_affine(self, path)",
        "snippet": "    def transform_path_affine(self, path):\n        # docstring inherited\n        return path",
        "begin_line": 2059,
        "end_line": 2061,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.transform_path_non_affine#2063",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.transform_path_non_affine(self, path)",
        "snippet": "    def transform_path_non_affine(self, path):\n        # docstring inherited\n        return path",
        "begin_line": 2063,
        "end_line": 2065,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.get_affine#2067",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.get_affine(self)",
        "snippet": "    def get_affine(self):\n        # docstring inherited\n        return self",
        "begin_line": 2067,
        "end_line": 2069,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041736227045075126,
            "pseudo_dstar_susp": 0.0003787878787878788,
            "pseudo_tarantula_susp": 0.0010638297872340426,
            "pseudo_op2_susp": 0.0003787878787878788,
            "pseudo_barinel_susp": 0.0010638297872340426
        }
    },
    {
        "name": "lib.matplotlib.transforms.IdentityTransform.inverted#2071",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.IdentityTransform",
        "signature": "lib.matplotlib.transforms.IdentityTransform.inverted(self)",
        "snippet": "    def inverted(self):\n        # docstring inherited\n        return self",
        "begin_line": 2071,
        "end_line": 2073,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043271311120726956,
            "pseudo_dstar_susp": 0.00038580246913580245,
            "pseudo_tarantula_susp": 0.001392757660167131,
            "pseudo_op2_susp": 0.00038580246913580245,
            "pseudo_barinel_susp": 0.001392757660167131
        }
    },
    {
        "name": "lib.matplotlib.transforms._BlendedMixin.__eq__#2079",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms._BlendedMixin",
        "signature": "lib.matplotlib.transforms._BlendedMixin.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        if isinstance(other, (BlendedAffine2D, BlendedGenericTransform)):\n            return (self._x == other._x) and (self._y == other._y)\n        elif self._x == self._y:\n            return self._x == other\n        else:\n            return NotImplemented",
        "begin_line": 2079,
        "end_line": 2085,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005431830526887561,
            "pseudo_dstar_susp": 0.0005899705014749262,
            "pseudo_tarantula_susp": 0.0016181229773462784,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0016181229773462784
        }
    },
    {
        "name": "lib.matplotlib.transforms._BlendedMixin.contains_branch_seperately#2087",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms._BlendedMixin",
        "signature": "lib.matplotlib.transforms._BlendedMixin.contains_branch_seperately(self, transform)",
        "snippet": "    def contains_branch_seperately(self, transform):\n        return (self._x.contains_branch(transform),\n                self._y.contains_branch(transform))",
        "begin_line": 2087,
        "end_line": 2089,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.BlendedGenericTransform.__init__#2107",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BlendedGenericTransform",
        "signature": "lib.matplotlib.transforms.BlendedGenericTransform.__init__(self, x_transform, y_transform, **kwargs)",
        "snippet": "    def __init__(self, x_transform, y_transform, **kwargs):\n        \"\"\"\n        Create a new \"blended\" transform using *x_transform* to transform the\n        *x*-axis and *y_transform* to transform the *y*-axis.\n\n        You will generally not call this constructor directly but use the\n        `blended_transform_factory` function instead, which can determine\n        automatically which kind of blended transform to create.\n        \"\"\"\n        Transform.__init__(self, **kwargs)\n        self._x = x_transform\n        self._y = y_transform\n        self.set_children(x_transform, y_transform)\n        self._affine = None",
        "begin_line": 2107,
        "end_line": 2120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015408320493066256,
            "pseudo_dstar_susp": 0.00267379679144385,
            "pseudo_tarantula_susp": 0.0006172839506172839,
            "pseudo_op2_susp": 0.00267379679144385,
            "pseudo_barinel_susp": 0.0006172839506172839
        }
    },
    {
        "name": "lib.matplotlib.transforms.BlendedGenericTransform.frozen#2135",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BlendedGenericTransform",
        "signature": "lib.matplotlib.transforms.BlendedGenericTransform.frozen(self)",
        "snippet": "    def frozen(self):\n        # docstring inherited\n        return blended_transform_factory(self._x.frozen(), self._y.frozen())",
        "begin_line": 2135,
        "end_line": 2137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.BlendedGenericTransform.transform_non_affine#2139",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BlendedGenericTransform",
        "signature": "lib.matplotlib.transforms.BlendedGenericTransform.transform_non_affine(self, points)",
        "snippet": "    def transform_non_affine(self, points):\n        # docstring inherited\n        if self._x.is_affine and self._y.is_affine:\n            return points\n        x = self._x\n        y = self._y\n\n        if x == y and x.input_dims == 2:\n            return x.transform_non_affine(points)\n\n        if x.input_dims == 2:\n            x_points = x.transform_non_affine(points)[:, 0:1]\n        else:\n            x_points = x.transform_non_affine(points[:, 0])\n            x_points = x_points.reshape((len(x_points), 1))\n\n        if y.input_dims == 2:\n            y_points = y.transform_non_affine(points)[:, 1:]\n        else:\n            y_points = y.transform_non_affine(points[:, 1])\n            y_points = y_points.reshape((len(y_points), 1))\n\n        if (isinstance(x_points, np.ma.MaskedArray) or\n                isinstance(y_points, np.ma.MaskedArray)):\n            return np.ma.concatenate((x_points, y_points), 1)\n        else:\n            return np.concatenate((x_points, y_points), 1)",
        "begin_line": 2139,
        "end_line": 2165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004152823920265781,
            "pseudo_dstar_susp": 0.00037764350453172205,
            "pseudo_tarantula_susp": 0.0010526315789473684,
            "pseudo_op2_susp": 0.00037764350453172205,
            "pseudo_barinel_susp": 0.0010526315789473684
        }
    },
    {
        "name": "lib.matplotlib.transforms.BlendedGenericTransform.inverted#2167",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BlendedGenericTransform",
        "signature": "lib.matplotlib.transforms.BlendedGenericTransform.inverted(self)",
        "snippet": "    def inverted(self):\n        # docstring inherited\n        return BlendedGenericTransform(self._x.inverted(), self._y.inverted())",
        "begin_line": 2167,
        "end_line": 2169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.BlendedGenericTransform.get_affine#2171",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BlendedGenericTransform",
        "signature": "lib.matplotlib.transforms.BlendedGenericTransform.get_affine(self)",
        "snippet": "    def get_affine(self):\n        # docstring inherited\n        if self._invalid or self._affine is None:\n            if self._x == self._y:\n                self._affine = self._x.get_affine()\n            else:\n                x_mtx = self._x.get_affine().get_matrix()\n                y_mtx = self._y.get_affine().get_matrix()\n                # We already know the transforms are separable, so we can skip\n                # setting b and c to zero.\n                mtx = np.array([x_mtx[0], y_mtx[1], [0.0, 0.0, 1.0]])\n                self._affine = Affine2D(mtx)\n            self._invalid = 0\n        return self._affine",
        "begin_line": 2171,
        "end_line": 2184,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041050903119868636,
            "pseudo_dstar_susp": 0.00037425149700598805,
            "pseudo_tarantula_susp": 0.001004016064257028,
            "pseudo_op2_susp": 0.00037425149700598805,
            "pseudo_barinel_susp": 0.0010030090270812437
        }
    },
    {
        "name": "lib.matplotlib.transforms.BlendedAffine2D.__init__#2197",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BlendedAffine2D",
        "signature": "lib.matplotlib.transforms.BlendedAffine2D.__init__(self, x_transform, y_transform, **kwargs)",
        "snippet": "    def __init__(self, x_transform, y_transform, **kwargs):\n        \"\"\"\n        Create a new \"blended\" transform using *x_transform* to transform the\n        *x*-axis and *y_transform* to transform the *y*-axis.\n\n        Both *x_transform* and *y_transform* must be 2D affine transforms.\n\n        You will generally not call this constructor directly but use the\n        `blended_transform_factory` function instead, which can determine\n        automatically which kind of blended transform to create.\n        \"\"\"\n        is_affine = x_transform.is_affine and y_transform.is_affine\n        is_separable = x_transform.is_separable and y_transform.is_separable\n        is_correct = is_affine and is_separable\n        if not is_correct:\n            raise ValueError(\"Both *x_transform* and *y_transform* must be 2D \"\n                             \"affine transforms\")\n\n        Transform.__init__(self, **kwargs)\n        self._x = x_transform\n        self._y = y_transform\n        self.set_children(x_transform, y_transform)\n\n        Affine2DBase.__init__(self)\n        self._mtx = None",
        "begin_line": 2197,
        "end_line": 2221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011376564277588168,
            "pseudo_dstar_susp": 0.001953125,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.001953125,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.transforms.BlendedAffine2D.get_matrix#2223",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BlendedAffine2D",
        "signature": "lib.matplotlib.transforms.BlendedAffine2D.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            if self._x == self._y:\n                self._mtx = self._x.get_matrix()\n            else:\n                x_mtx = self._x.get_matrix()\n                y_mtx = self._y.get_matrix()\n                # We already know the transforms are separable, so we can skip\n                # setting b and c to zero.\n                self._mtx = np.array([x_mtx[0], y_mtx[1], [0.0, 0.0, 1.0]])\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx",
        "begin_line": 2223,
        "end_line": 2236,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000500751126690035,
            "pseudo_dstar_susp": 0.0005773672055427252,
            "pseudo_tarantula_susp": 0.001282051282051282,
            "pseudo_op2_susp": 0.0005773672055427252,
            "pseudo_barinel_susp": 0.001282051282051282
        }
    },
    {
        "name": "lib.matplotlib.transforms.blended_transform_factory#2239",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms",
        "signature": "lib.matplotlib.transforms.blended_transform_factory(x_transform, y_transform)",
        "snippet": "def blended_transform_factory(x_transform, y_transform):\n    \"\"\"\n    Create a new \"blended\" transform using *x_transform* to transform\n    the *x*-axis and *y_transform* to transform the *y*-axis.\n\n    A faster version of the blended transform is returned for the case\n    where both child transforms are affine.\n    \"\"\"\n    if (isinstance(x_transform, Affine2DBase)\n        and isinstance(y_transform, Affine2DBase)):\n        return BlendedAffine2D(x_transform, y_transform)\n    return BlendedGenericTransform(x_transform, y_transform)",
        "begin_line": 2239,
        "end_line": 2250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048567265662943174,
            "pseudo_dstar_susp": 0.0005324813631522897,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0005324813631522897,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.__init__#2263",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.__init__(self, a, b, **kwargs)",
        "snippet": "    def __init__(self, a, b, **kwargs):\n        \"\"\"\n        Create a new composite transform that is the result of\n        applying transform *a* then transform *b*.\n\n        You will generally not call this constructor directly but write ``a +\n        b`` instead, which will automatically choose the best kind of composite\n        transform instance to create.\n        \"\"\"\n        if a.output_dims != b.input_dims:\n            raise ValueError(\"The output dimension of 'a' must be equal to \"\n                             \"the input dimensions of 'b'\")\n        self.input_dims = a.input_dims\n        self.output_dims = b.output_dims\n\n        Transform.__init__(self, **kwargs)\n        self._a = a\n        self._b = b\n        self.set_children(a, b)",
        "begin_line": 2263,
        "end_line": 2281,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006317119393556538,
            "pseudo_dstar_susp": 0.0012121212121212121,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0012121212121212121,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.frozen#2283",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.frozen(self)",
        "snippet": "    def frozen(self):\n        # docstring inherited\n        self._invalid = 0\n        frozen = composite_transform_factory(\n            self._a.frozen(), self._b.frozen())\n        if not isinstance(frozen, CompositeGenericTransform):\n            return frozen.frozen()\n        return frozen",
        "begin_line": 2283,
        "end_line": 2290,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041186161449752884,
            "pseudo_dstar_susp": 0.00037537537537537537,
            "pseudo_tarantula_susp": 0.0010204081632653062,
            "pseudo_op2_susp": 0.00037537537537537537,
            "pseudo_barinel_susp": 0.0010204081632653062
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform._invalidate_internal#2292",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform._invalidate_internal(self, value, invalidating_node)",
        "snippet": "    def _invalidate_internal(self, value, invalidating_node):\n        # In some cases for a composite transform, an invalidating call to\n        # AFFINE_ONLY needs to be extended to invalidate the NON_AFFINE part\n        # too. These cases are when the right hand transform is non-affine and\n        # either:\n        # (a) the left hand transform is non affine\n        # (b) it is the left hand node which has triggered the invalidation\n        if value == Transform.INVALID_AFFINE \\\n            and not self._b.is_affine \\\n            and (not self._a.is_affine or invalidating_node is self._a):\n\n            value = Transform.INVALID\n\n        Transform._invalidate_internal(self, value=value,\n                                       invalidating_node=invalidating_node)",
        "begin_line": 2292,
        "end_line": 2306,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015151515151515152,
            "pseudo_dstar_susp": 0.0020491803278688526,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0020491803278688526,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.__eq__#2308",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        if isinstance(other, (CompositeGenericTransform, CompositeAffine2D)):\n            return self is other or (self._a == other._a\n                                     and self._b == other._b)\n        else:\n            return False",
        "begin_line": 2308,
        "end_line": 2313,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005025125628140704,
            "pseudo_dstar_susp": 0.000585480093676815,
            "pseudo_tarantula_susp": 0.0012987012987012987,
            "pseudo_op2_susp": 0.000585480093676815,
            "pseudo_barinel_susp": 0.0012987012987012987
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform._iter_break_from_left_to_right#2315",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform._iter_break_from_left_to_right(self)",
        "snippet": "    def _iter_break_from_left_to_right(self):\n        for left, right in self._a._iter_break_from_left_to_right():\n            yield left, right + self._b\n        for left, right in self._b._iter_break_from_left_to_right():\n            yield self._a + left, right",
        "begin_line": 2315,
        "end_line": 2319,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005213764337851929,
            "pseudo_dstar_susp": 0.0005931198102016608,
            "pseudo_tarantula_susp": 0.001443001443001443,
            "pseudo_op2_susp": 0.0005931198102016608,
            "pseudo_barinel_susp": 0.001443001443001443
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.transform_affine#2330",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.transform_affine(self, points)",
        "snippet": "    def transform_affine(self, points):\n        # docstring inherited\n        return self.get_affine().transform(points)",
        "begin_line": 2330,
        "end_line": 2332,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005047955577990914,
            "pseudo_dstar_susp": 0.0005830903790087463,
            "pseudo_tarantula_susp": 0.0013157894736842105,
            "pseudo_op2_susp": 0.0005830903790087463,
            "pseudo_barinel_susp": 0.0013157894736842105
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.transform_non_affine#2334",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.transform_non_affine(self, points)",
        "snippet": "    def transform_non_affine(self, points):\n        # docstring inherited\n        if self._a.is_affine and self._b.is_affine:\n            return points\n        elif not self._a.is_affine and self._b.is_affine:\n            return self._a.transform_non_affine(points)\n        else:\n            return self._b.transform_non_affine(\n                                self._a.transform(points))",
        "begin_line": 2334,
        "end_line": 2342,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005988023952095808,
            "pseudo_dstar_susp": 0.0005834305717619603,
            "pseudo_tarantula_susp": 0.0024813895781637717,
            "pseudo_op2_susp": 0.0005834305717619603,
            "pseudo_barinel_susp": 0.0024813895781637717
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.transform_path_non_affine#2344",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.transform_path_non_affine(self, path)",
        "snippet": "    def transform_path_non_affine(self, path):\n        # docstring inherited\n        if self._a.is_affine and self._b.is_affine:\n            return path\n        elif not self._a.is_affine and self._b.is_affine:\n            return self._a.transform_path_non_affine(path)\n        else:\n            return self._b.transform_path_non_affine(\n                                    self._a.transform_path(path))",
        "begin_line": 2344,
        "end_line": 2352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.get_affine#2354",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.get_affine(self)",
        "snippet": "    def get_affine(self):\n        # docstring inherited\n        if not self._b.is_affine:\n            return self._b.get_affine()\n        else:\n            return Affine2D(np.dot(self._b.get_affine().get_matrix(),\n                                   self._a.get_affine().get_matrix()))",
        "begin_line": 2354,
        "end_line": 2360,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005243838489774515,
            "pseudo_dstar_susp": 0.0005714285714285715,
            "pseudo_tarantula_susp": 0.002,
            "pseudo_op2_susp": 0.0005714285714285715,
            "pseudo_barinel_susp": 0.002
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeGenericTransform.inverted#2362",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeGenericTransform",
        "signature": "lib.matplotlib.transforms.CompositeGenericTransform.inverted(self)",
        "snippet": "    def inverted(self):\n        # docstring inherited\n        return CompositeGenericTransform(\n            self._b.inverted(), self._a.inverted())",
        "begin_line": 2362,
        "end_line": 2365,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042607584149978694,
            "pseudo_dstar_susp": 0.0003831417624521073,
            "pseudo_tarantula_susp": 0.0012610340479192938,
            "pseudo_op2_susp": 0.0003831417624521073,
            "pseudo_barinel_susp": 0.0012626262626262627
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeAffine2D.__init__#2375",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeAffine2D",
        "signature": "lib.matplotlib.transforms.CompositeAffine2D.__init__(self, a, b, **kwargs)",
        "snippet": "    def __init__(self, a, b, **kwargs):\n        \"\"\"\n        Create a new composite transform that is the result of\n        applying `Affine2DBase` *a* then `Affine2DBase` *b*.\n\n        You will generally not call this constructor directly but write ``a +\n        b`` instead, which will automatically choose the best kind of composite\n        transform instance to create.\n        \"\"\"\n        if not a.is_affine or not b.is_affine:\n            raise ValueError(\"'a' and 'b' must be affine transforms\")\n        if a.output_dims != b.input_dims:\n            raise ValueError(\"The output dimension of 'a' must be equal to \"\n                             \"the input dimensions of 'b'\")\n        self.input_dims = a.input_dims\n        self.output_dims = b.output_dims\n\n        Affine2DBase.__init__(self, **kwargs)\n        self._a = a\n        self._b = b\n        self.set_children(a, b)\n        self._mtx = None",
        "begin_line": 2375,
        "end_line": 2396,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041050903119868636,
            "pseudo_dstar_susp": 0.00037425149700598805,
            "pseudo_tarantula_susp": 0.001004016064257028,
            "pseudo_op2_susp": 0.00037425149700598805,
            "pseudo_barinel_susp": 0.0010030090270812437
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeAffine2D.depth#2399",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeAffine2D",
        "signature": "lib.matplotlib.transforms.CompositeAffine2D.depth(self)",
        "snippet": "    def depth(self):\n        return self._a.depth + self._b.depth",
        "begin_line": 2399,
        "end_line": 2400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeAffine2D._iter_break_from_left_to_right#2402",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeAffine2D",
        "signature": "lib.matplotlib.transforms.CompositeAffine2D._iter_break_from_left_to_right(self)",
        "snippet": "    def _iter_break_from_left_to_right(self):\n        for left, right in self._a._iter_break_from_left_to_right():\n            yield left, right + self._b\n        for left, right in self._b._iter_break_from_left_to_right():\n            yield self._a + left, right",
        "begin_line": 2402,
        "end_line": 2406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.transforms.CompositeAffine2D.get_matrix#2410",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.CompositeAffine2D",
        "signature": "lib.matplotlib.transforms.CompositeAffine2D.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            self._mtx = np.dot(\n                self._b.get_matrix(),\n                self._a.get_matrix())\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx",
        "begin_line": 2410,
        "end_line": 2418,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041356492969396195,
            "pseudo_dstar_susp": 0.00037650602409638556,
            "pseudo_tarantula_susp": 0.001037344398340249,
            "pseudo_op2_susp": 0.00037650602409638556,
            "pseudo_barinel_susp": 0.001037344398340249
        }
    },
    {
        "name": "lib.matplotlib.transforms.composite_transform_factory#2421",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms",
        "signature": "lib.matplotlib.transforms.composite_transform_factory(a, b)",
        "snippet": "def composite_transform_factory(a, b):\n    \"\"\"\n    Create a new composite transform that is the result of applying\n    transform a then transform b.\n\n    Shortcut versions of the blended transform are provided for the\n    case where both child transforms are affine, or one or the other\n    is the identity transform.\n\n    Composite transforms may also be created using the '+' operator,\n    e.g.::\n\n      c = a + b\n    \"\"\"\n    # check to see if any of a or b are IdentityTransforms. We use\n    # isinstance here to guarantee that the transforms will *always*\n    # be IdentityTransforms. Since TransformWrappers are mutable,\n    # use of equality here would be wrong.\n    if isinstance(a, IdentityTransform):\n        return b\n    elif isinstance(b, IdentityTransform):\n        return a\n    elif isinstance(a, Affine2D) and isinstance(b, Affine2D):\n        return CompositeAffine2D(a, b)\n    return CompositeGenericTransform(a, b)",
        "begin_line": 2421,
        "end_line": 2445,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006309148264984228,
            "pseudo_dstar_susp": 0.0012091898428053204,
            "pseudo_tarantula_susp": 0.001128668171557562,
            "pseudo_op2_susp": 0.0012091898428053204,
            "pseudo_barinel_susp": 0.001128668171557562
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxTransform.__init__#2454",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxTransform",
        "signature": "lib.matplotlib.transforms.BboxTransform.__init__(self, boxin, boxout, **kwargs)",
        "snippet": "    def __init__(self, boxin, boxout, **kwargs):\n        \"\"\"\n        Create a new :class:`BboxTransform` that linearly transforms\n        points from *boxin* to *boxout*.\n        \"\"\"\n        if not boxin.is_bbox or not boxout.is_bbox:\n            raise ValueError(\"'boxin' and 'boxout' must be bbox\")\n\n        Affine2DBase.__init__(self, **kwargs)\n        self._boxin = boxin\n        self._boxout = boxout\n        self.set_children(boxin, boxout)\n        self._mtx = None\n        self._inverted = None",
        "begin_line": 2454,
        "end_line": 2467,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.28332714444857e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxTransform.get_matrix#2471",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxTransform",
        "signature": "lib.matplotlib.transforms.BboxTransform.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            inl, inb, inw, inh = self._boxin.bounds\n            outl, outb, outw, outh = self._boxout.bounds\n            x_scale = outw / inw\n            y_scale = outh / inh\n            if DEBUG and (x_scale == 0 or y_scale == 0):\n                raise ValueError(\n                    \"Transforming from or to a singular bounding box\")\n            self._mtx = np.array([[x_scale, 0.0    , (-inl*x_scale+outl)],\n                                  [0.0    , y_scale, (-inb*y_scale+outb)],\n                                  [0.0    , 0.0    , 1.0        ]],\n                                 float)\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx",
        "begin_line": 2471,
        "end_line": 2487,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxTransformTo.__init__#2497",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxTransformTo",
        "signature": "lib.matplotlib.transforms.BboxTransformTo.__init__(self, boxout, **kwargs)",
        "snippet": "    def __init__(self, boxout, **kwargs):\n        \"\"\"\n        Create a new :class:`BboxTransformTo` that linearly transforms\n        points from the unit bounding box to *boxout*.\n        \"\"\"\n        if not boxout.is_bbox:\n            raise ValueError(\"'boxout' must be bbox\")\n\n        Affine2DBase.__init__(self, **kwargs)\n        self._boxout = boxout\n        self.set_children(boxout)\n        self._mtx = None\n        self._inverted = None",
        "begin_line": 2497,
        "end_line": 2509,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006257822277847309,
            "pseudo_dstar_susp": 0.0011961722488038277,
            "pseudo_tarantula_susp": 0.001128668171557562,
            "pseudo_op2_susp": 0.0011961722488038277,
            "pseudo_barinel_susp": 0.001128668171557562
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxTransformTo.get_matrix#2513",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxTransformTo",
        "signature": "lib.matplotlib.transforms.BboxTransformTo.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            outl, outb, outw, outh = self._boxout.bounds\n            if DEBUG and (outw == 0 or outh == 0):\n                raise ValueError(\"Transforming to a singular bounding box.\")\n            self._mtx = np.array([[outw,  0.0, outl],\n                                  [ 0.0, outh, outb],\n                                  [ 0.0,  0.0,  1.0]],\n                                 float)\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx",
        "begin_line": 2513,
        "end_line": 2525,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005157297576070139,
            "pseudo_dstar_susp": 0.000574052812858783,
            "pseudo_tarantula_susp": 0.0013736263736263737,
            "pseudo_op2_susp": 0.000574052812858783,
            "pseudo_barinel_susp": 0.0013736263736263737
        }
    },
    {
        "name": "lib.matplotlib.transforms.BboxTransformFrom.get_matrix#2567",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.BboxTransformFrom",
        "signature": "lib.matplotlib.transforms.BboxTransformFrom.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            inl, inb, inw, inh = self._boxin.bounds\n            if DEBUG and (inw == 0 or inh == 0):\n                raise ValueError(\"Transforming from a singular bounding box.\")\n            x_scale = 1.0 / inw\n            y_scale = 1.0 / inh\n            self._mtx = np.array([[x_scale, 0.0    , (-inl*x_scale)],\n                                  [0.0    , y_scale, (-inb*y_scale)],\n                                  [0.0    , 0.0    , 1.0        ]],\n                                 float)\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx",
        "begin_line": 2567,
        "end_line": 2581,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005025125628140704,
            "pseudo_dstar_susp": 0.0005830903790087463,
            "pseudo_tarantula_susp": 0.0012987012987012987,
            "pseudo_op2_susp": 0.0005830903790087463,
            "pseudo_barinel_susp": 0.0012987012987012987
        }
    },
    {
        "name": "lib.matplotlib.transforms.ScaledTranslation.__init__#2589",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.ScaledTranslation",
        "signature": "lib.matplotlib.transforms.ScaledTranslation.__init__(self, xt, yt, scale_trans, **kwargs)",
        "snippet": "    def __init__(self, xt, yt, scale_trans, **kwargs):\n        Affine2DBase.__init__(self, **kwargs)\n        self._t = (xt, yt)\n        self._scale_trans = scale_trans\n        self.set_children(scale_trans)\n        self._mtx = None\n        self._inverted = None",
        "begin_line": 2589,
        "end_line": 2595,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011376564277588168,
            "pseudo_dstar_susp": 0.001953125,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.001953125,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.transforms.ScaledTranslation.get_matrix#2599",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.ScaledTranslation",
        "signature": "lib.matplotlib.transforms.ScaledTranslation.get_matrix(self)",
        "snippet": "    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            # A bit faster than np.identity(3).\n            self._mtx = IdentityTransform._mtx.copy()\n            self._mtx[:2, 2] = self._scale_trans.transform(self._t)\n            self._invalid = 0\n            self._inverted = None\n        return self._mtx",
        "begin_line": 2599,
        "end_line": 2607,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00037778617302606723,
            "pseudo_dstar_susp": 0.00034916201117318437,
            "pseudo_tarantula_susp": 0.0007358351729212656,
            "pseudo_op2_susp": 0.00034916201117318437,
            "pseudo_barinel_susp": 0.0007358351729212656
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPath.__init__#2622",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPath",
        "signature": "lib.matplotlib.transforms.TransformedPath.__init__(self, path, transform)",
        "snippet": "    def __init__(self, path, transform):\n        \"\"\"\n        Parameters\n        ----------\n        path : `~.path.Path`\n        transform : `Transform`\n        \"\"\"\n        cbook._check_isinstance(Transform, transform=transform)\n        TransformNode.__init__(self)\n        self._path = path\n        self._transform = transform\n        self.set_children(transform)\n        self._transformed_path = None\n        self._transformed_points = None",
        "begin_line": 2622,
        "end_line": 2635,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00039761431411530816,
            "pseudo_dstar_susp": 0.0003650967506389193,
            "pseudo_tarantula_susp": 0.0009115770282588879,
            "pseudo_op2_susp": 0.0003650967506389193,
            "pseudo_barinel_susp": 0.0009115770282588879
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPath._revalidate#2637",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPath",
        "signature": "lib.matplotlib.transforms.TransformedPath._revalidate(self)",
        "snippet": "    def _revalidate(self):\n        # only recompute if the invalidation includes the non_affine part of\n        # the transform\n        if (self._invalid & self.INVALID_NON_AFFINE == self.INVALID_NON_AFFINE\n            or self._transformed_path is None):\n            self._transformed_path = \\\n                self._transform.transform_path_non_affine(self._path)\n            self._transformed_points = \\\n                Path._fast_from_codes_and_verts(\n                    self._transform.transform_non_affine(self._path.vertices),\n                    None, self._path)\n        self._invalid = 0",
        "begin_line": 2637,
        "end_line": 2648,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003952569169960474,
            "pseudo_dstar_susp": 0.00036310820624546115,
            "pseudo_tarantula_susp": 0.00089126559714795,
            "pseudo_op2_susp": 0.00036310820624546115,
            "pseudo_barinel_susp": 0.00089126559714795
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPath.get_transformed_points_and_affine#2650",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPath",
        "signature": "lib.matplotlib.transforms.TransformedPath.get_transformed_points_and_affine(self)",
        "snippet": "    def get_transformed_points_and_affine(self):\n        \"\"\"\n        Return a copy of the child path, with the non-affine part of\n        the transform already applied, along with the affine part of\n        the path necessary to complete the transformation.  Unlike\n        :meth:`get_transformed_path_and_affine`, no interpolation will\n        be performed.\n        \"\"\"\n        self._revalidate()\n        return self._transformed_points, self.get_affine()",
        "begin_line": 2650,
        "end_line": 2659,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00037778617302606723,
            "pseudo_dstar_susp": 0.00034916201117318437,
            "pseudo_tarantula_susp": 0.0007358351729212656,
            "pseudo_op2_susp": 0.00034916201117318437,
            "pseudo_barinel_susp": 0.0007358351729212656
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPath.get_transformed_path_and_affine#2661",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPath",
        "signature": "lib.matplotlib.transforms.TransformedPath.get_transformed_path_and_affine(self)",
        "snippet": "    def get_transformed_path_and_affine(self):\n        \"\"\"\n        Return a copy of the child path, with the non-affine part of\n        the transform already applied, along with the affine part of\n        the path necessary to complete the transformation.\n        \"\"\"\n        self._revalidate()\n        return self._transformed_path, self.get_affine()",
        "begin_line": 2661,
        "end_line": 2668,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042607584149978694,
            "pseudo_dstar_susp": 0.0003831417624521073,
            "pseudo_tarantula_susp": 0.0012610340479192938,
            "pseudo_op2_susp": 0.0003831417624521073,
            "pseudo_barinel_susp": 0.0012626262626262627
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPath.get_fully_transformed_path#2670",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPath",
        "signature": "lib.matplotlib.transforms.TransformedPath.get_fully_transformed_path(self)",
        "snippet": "    def get_fully_transformed_path(self):\n        \"\"\"\n        Return a fully-transformed copy of the child path.\n        \"\"\"\n        self._revalidate()\n        return self._transform.transform_path_affine(self._transformed_path)",
        "begin_line": 2670,
        "end_line": 2675,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00013700506918755994,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPath.get_affine#2677",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPath",
        "signature": "lib.matplotlib.transforms.TransformedPath.get_affine(self)",
        "snippet": "    def get_affine(self):\n        return self._transform.get_affine()",
        "begin_line": 2677,
        "end_line": 2678,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003952569169960474,
            "pseudo_dstar_susp": 0.00036310820624546115,
            "pseudo_tarantula_susp": 0.00089126559714795,
            "pseudo_op2_susp": 0.00036310820624546115,
            "pseudo_barinel_susp": 0.00089126559714795
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPatchPath.__init__#2687",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPatchPath",
        "signature": "lib.matplotlib.transforms.TransformedPatchPath.__init__(self, patch)",
        "snippet": "    def __init__(self, patch):\n        \"\"\"\n        Parameters\n        ----------\n        patch : `~.patches.Patch`\n        \"\"\"\n        TransformNode.__init__(self)\n\n        transform = patch.get_transform()\n        self._patch = patch\n        self._transform = transform\n        self.set_children(transform)\n        self._path = patch.get_path()\n        self._transformed_path = None\n        self._transformed_points = None",
        "begin_line": 2687,
        "end_line": 2701,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008116883116883117,
            "pseudo_dstar_susp": 0.000449034575662326,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.transforms.TransformedPatchPath._revalidate#2703",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms.TransformedPatchPath",
        "signature": "lib.matplotlib.transforms.TransformedPatchPath._revalidate(self)",
        "snippet": "    def _revalidate(self):\n        patch_path = self._patch.get_path()\n        # Only recompute if the invalidation includes the non_affine part of\n        # the transform, or the Patch's Path has changed.\n        if (self._transformed_path is None or self._path != patch_path or\n                (self._invalid & self.INVALID_NON_AFFINE ==\n                    self.INVALID_NON_AFFINE)):\n            self._path = patch_path\n            self._transformed_path = \\\n                self._transform.transform_path_non_affine(patch_path)\n            self._transformed_points = \\\n                Path._fast_from_codes_and_verts(\n                    self._transform.transform_non_affine(patch_path.vertices),\n                    None, patch_path)\n        self._invalid = 0",
        "begin_line": 2703,
        "end_line": 2717,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.0004805382027871216,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.0004805382027871216,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "lib.matplotlib.transforms.nonsingular#2720",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms",
        "signature": "lib.matplotlib.transforms.nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True)",
        "snippet": "def nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True):\n    \"\"\"\n    Modify the endpoints of a range as needed to avoid singularities.\n\n    Parameters\n    ----------\n    vmin, vmax : float\n        The initial endpoints.\n    expander : float, default: 0.001\n        Fractional amount by which *vmin* and *vmax* are expanded if\n        the original interval is too small, based on *tiny*.\n    tiny : float, default: 1e-15\n        Threshold for the ratio of the interval to the maximum absolute\n        value of its endpoints.  If the interval is smaller than\n        this, it will be expanded.  This value should be around\n        1e-15 or larger; otherwise the interval will be approaching\n        the double precision resolution limit.\n    increasing : bool, default: True\n        If True, swap *vmin*, *vmax* if *vmin* > *vmax*.\n\n    Returns\n    -------\n    vmin, vmax : float\n        Endpoints, expanded and/or swapped if necessary.\n        If either input is inf or NaN, or if both inputs are 0 or very\n        close to zero, it returns -*expander*, *expander*.\n    \"\"\"\n\n    if (not np.isfinite(vmin)) or (not np.isfinite(vmax)):\n        return -expander, expander\n\n    swapped = False\n    if vmax < vmin:\n        vmin, vmax = vmax, vmin\n        swapped = True\n\n    # Expand vmin, vmax to float: if they were integer types, they can wrap\n    # around in abs (abs(np.int8(-128)) == -128) and vmax - vmin can overflow.\n    vmin, vmax = map(float, [vmin, vmax])\n\n    maxabsvalue = max(abs(vmin), abs(vmax))\n    if maxabsvalue < (1e6 / tiny) * np.finfo(float).tiny:\n        vmin = -expander\n        vmax = expander\n\n    elif vmax - vmin <= maxabsvalue * tiny:\n        if vmax == 0 and vmin == 0:\n            vmin = -expander\n            vmax = expander\n        else:\n            vmin -= expander*abs(vmin)\n            vmax += expander*abs(vmax)\n\n    if swapped and not increasing:\n        vmin, vmax = vmax, vmin\n    return vmin, vmax",
        "begin_line": 2720,
        "end_line": 2775,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009950248756218905,
            "pseudo_dstar_susp": 0.0016233766233766235,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.0016233766233766235,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.transforms.interval_contains#2778",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms",
        "signature": "lib.matplotlib.transforms.interval_contains(interval, val)",
        "snippet": "def interval_contains(interval, val):\n    \"\"\"\n    Check, inclusively, whether an interval includes a given value.\n\n    Parameters\n    ----------\n    interval : sequence of scalar\n        A 2-length sequence, endpoints that define the interval.\n    val : scalar\n        Value to check is within interval.\n\n    Returns\n    -------\n    bool\n        Returns *True* if given *val* is within the *interval*.\n    \"\"\"\n    a, b = interval\n    if a > b:\n        a, b = b, a\n    return a <= val <= b",
        "begin_line": 2778,
        "end_line": 2797,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.transforms._interval_contains_close#2800",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms",
        "signature": "lib.matplotlib.transforms._interval_contains_close(interval, val, rtol=1e-10)",
        "snippet": "def _interval_contains_close(interval, val, rtol=1e-10):\n    \"\"\"\n    Check, inclusively, whether an interval includes a given value, with the\n    interval expanded by a small tolerance to admit floating point errors.\n\n    Parameters\n    ----------\n    interval : sequence of scalar\n        A 2-length sequence, endpoints that define the interval.\n    val : scalar\n        Value to check is within interval.\n    rtol : scalar\n        Tolerance slippage allowed outside of this interval.  Default\n        1e-10 * (b - a).\n\n    Returns\n    -------\n    bool\n        Returns *True* if given *val* is within the *interval* (with tolerance)\n    \"\"\"\n    a, b = interval\n    if a > b:\n        a, b = b, a\n    rtol = (b - a) * rtol\n    return a - rtol <= val <= b + rtol",
        "begin_line": 2800,
        "end_line": 2824,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003812428516965307,
            "pseudo_dstar_susp": 0.00035198873636043646,
            "pseudo_tarantula_susp": 0.0007564296520423601,
            "pseudo_op2_susp": 0.00035198873636043646,
            "pseudo_barinel_susp": 0.0007564296520423601
        }
    },
    {
        "name": "lib.matplotlib.transforms.offset_copy#2847",
        "src_path": "lib/matplotlib/transforms.py",
        "class_name": "lib.matplotlib.transforms",
        "signature": "lib.matplotlib.transforms.offset_copy(trans, fig=None, x=0.0, y=0.0, units='inches')",
        "snippet": "def offset_copy(trans, fig=None, x=0.0, y=0.0, units='inches'):\n    \"\"\"\n    Return a new transform with an added offset.\n\n    Parameters\n    ----------\n    trans : `Transform` subclass\n        Any transform, to which offset will be applied.\n    fig : :class:`~matplotlib.figure.Figure`, default: None\n        Current figure. It can be None if *units* are 'dots'.\n    x, y : float, default: 0.0\n        The offset to apply.\n    units : {'inches', 'points', 'dots'}, default: 'inches'\n        Units of the offset.\n\n    Returns\n    -------\n    trans : `Transform` subclass\n        Transform with applied offset.\n    \"\"\"\n    if units == 'dots':\n        return trans + Affine2D().translate(x, y)\n    if fig is None:\n        raise ValueError('For units of inches or points a fig kwarg is needed')\n    if units == 'points':\n        x /= 72.0\n        y /= 72.0\n    elif units == 'inches':\n        pass\n    else:\n        cbook._check_in_list(['dots', 'points', 'inches'], units=units)\n    return trans + ScaledTranslation(x, y, fig.dpi_scale_trans)",
        "begin_line": 2847,
        "end_line": 2878,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.sankey.Sankey.__init__#42",
        "src_path": "lib/matplotlib/sankey.py",
        "class_name": "lib.matplotlib.sankey.Sankey",
        "signature": "lib.matplotlib.sankey.Sankey.__init__(self, ax=None, scale=1.0, unit='', format='%G', gap=0.25, radius=0.1, shoulder=0.03, offset=0.15, head_angle=100, margin=0.4, tolerance=1e-06, **kwargs)",
        "snippet": "    def __init__(self, ax=None, scale=1.0, unit='', format='%G', gap=0.25,\n                 radius=0.1, shoulder=0.03, offset=0.15, head_angle=100,\n                 margin=0.4, tolerance=1e-6, **kwargs):\n        \"\"\"\n        Create a new Sankey instance.\n\n        Optional keyword arguments:\n\n          ===============   ===================================================\n          Field             Description\n          ===============   ===================================================\n          *ax*              axes onto which the data should be plotted\n                            If *ax* isn't provided, new axes will be created.\n          *scale*           scaling factor for the flows\n                            *scale* sizes the width of the paths in order to\n                            maintain proper layout.  The same scale is applied\n                            to all subdiagrams.  The value should be chosen\n                            such that the product of the scale and the sum of\n                            the inputs is approximately 1.0 (and the product of\n                            the scale and the sum of the outputs is\n                            approximately -1.0).\n          *unit*            string representing the physical unit associated\n                            with the flow quantities\n                            If *unit* is None, then none of the quantities are\n                            labeled.\n          *format*          a Python number formatting string to be used in\n                            labeling the flow as a quantity (i.e., a number\n                            times a unit, where the unit is given)\n          *gap*             space between paths that break in/break away\n                            to/from the top or bottom\n          *radius*          inner radius of the vertical paths\n          *shoulder*        size of the shoulders of output arrowS\n          *offset*          text offset (from the dip or tip of the arrow)\n          *head_angle*      angle of the arrow heads (and negative of the angle\n                            of the tails) [deg]\n          *margin*          minimum space between Sankey outlines and the edge\n                            of the plot area\n          *tolerance*       acceptable maximum of the magnitude of the sum of\n                            flows\n                            The magnitude of the sum of connected flows cannot\n                            be greater than *tolerance*.\n          ===============   ===================================================\n\n        The optional arguments listed above are applied to all subdiagrams so\n        that there is consistent alignment and formatting.\n\n        If :class:`Sankey` is instantiated with any keyword arguments other\n        than those explicitly listed above (``**kwargs``), they will be passed\n        to :meth:`add`, which will create the first subdiagram.\n\n        In order to draw a complex Sankey diagram, create an instance of\n        :class:`Sankey` by calling it without any kwargs::\n\n            sankey = Sankey()\n\n        Then add simple Sankey sub-diagrams::\n\n            sankey.add() # 1\n            sankey.add() # 2\n            #...\n            sankey.add() # n\n\n        Finally, create the full diagram::\n\n            sankey.finish()\n\n        Or, instead, simply daisy-chain those calls::\n\n            Sankey().add().add...  .add().finish()\n\n        See Also\n        --------\n        Sankey.add\n        Sankey.finish\n\n        Examples\n        --------\n        .. plot:: gallery/specialty_plots/sankey_basics.py\n        \"\"\"\n        # Check the arguments.\n        if gap < 0:\n            raise ValueError(\n                \"'gap' is negative, which is not allowed because it would \"\n                \"cause the paths to overlap\")\n        if radius > gap:\n            raise ValueError(\n                \"'radius' is greater than 'gap', which is not allowed because \"\n                \"it would cause the paths to overlap\")\n        if head_angle < 0:\n            raise ValueError(\n                \"'head_angle' is negative, which is not allowed because it \"\n                \"would cause inputs to look like outputs and vice versa\")\n        if tolerance < 0:\n            raise ValueError(\n                \"'tolerance' is negative, but it must be a magnitude\")\n\n        # Create axes if necessary.\n        if ax is None:\n            import matplotlib.pyplot as plt\n            fig = plt.figure()\n            ax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[])\n\n        self.diagrams = []\n\n        # Store the inputs.\n        self.ax = ax\n        self.unit = unit\n        self.format = format\n        self.scale = scale\n        self.gap = gap\n        self.radius = radius\n        self.shoulder = shoulder\n        self.offset = offset\n        self.margin = margin\n        self.pitch = np.tan(np.pi * (1 - head_angle / 180.0) / 2.0)\n        self.tolerance = tolerance\n\n        # Initialize the vertices of tight box around the diagram(s).\n        self.extent = np.array((np.inf, -np.inf, np.inf, -np.inf))\n\n        # If there are any kwargs, create the first subdiagram.\n        if len(kwargs):\n            self.add(**kwargs)",
        "begin_line": 42,
        "end_line": 164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.sankey.Sankey._add_input#221",
        "src_path": "lib/matplotlib/sankey.py",
        "class_name": "lib.matplotlib.sankey.Sankey",
        "signature": "lib.matplotlib.sankey.Sankey._add_input(self, path, angle, flow, length)",
        "snippet": "    def _add_input(self, path, angle, flow, length):\n        \"\"\"\n        Add an input to a path and return its tip and label locations.\n        \"\"\"\n        if angle is None:\n            return [0, 0], [0, 0]\n        else:\n            x, y = path[-1][1]  # Use the last point as a reference.\n            dipdepth = (flow / 2) * self.pitch\n            if angle == RIGHT:\n                x -= length\n                dip = [x + dipdepth, y + flow / 2.0]\n                path.extend([(Path.LINETO, [x, y]),\n                             (Path.LINETO, dip),\n                             (Path.LINETO, [x, y + flow]),\n                             (Path.LINETO, [x + self.gap, y + flow])])\n                label_location = [dip[0] - self.offset, dip[1]]\n            else:  # Vertical\n                x -= self.gap\n                if angle == UP:\n                    sign = 1\n                else:\n                    sign = -1\n\n                dip = [x - flow / 2, y - sign * (length - dipdepth)]\n                if angle == DOWN:\n                    quadrant = 2\n                else:\n                    quadrant = 1\n\n                # Inner arc isn't needed if inner radius is zero\n                if self.radius:\n                    path.extend(self._arc(quadrant=quadrant,\n                                          cw=angle == UP,\n                                          radius=self.radius,\n                                          center=(x + self.radius,\n                                                  y - sign * self.radius)))\n                else:\n                    path.append((Path.LINETO, [x, y]))\n                path.extend([(Path.LINETO, [x, y - sign * length]),\n                             (Path.LINETO, dip),\n                             (Path.LINETO, [x - flow, y - sign * length])])\n                path.extend(self._arc(quadrant=quadrant,\n                                      cw=angle == DOWN,\n                                      radius=flow + self.radius,\n                                      center=(x + self.radius,\n                                              y - sign * self.radius)))\n                path.append((Path.LINETO, [x - flow, y + sign * flow]))\n                label_location = [dip[0], dip[1] - sign * self.offset]\n\n            return dip, label_location",
        "begin_line": 221,
        "end_line": 271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.sankey.Sankey._add_output#273",
        "src_path": "lib/matplotlib/sankey.py",
        "class_name": "lib.matplotlib.sankey.Sankey",
        "signature": "lib.matplotlib.sankey.Sankey._add_output(self, path, angle, flow, length)",
        "snippet": "    def _add_output(self, path, angle, flow, length):\n        \"\"\"\n        Append an output to a path and return its tip and label locations.\n\n        .. note:: *flow* is negative for an output.\n        \"\"\"\n        if angle is None:\n            return [0, 0], [0, 0]\n        else:\n            x, y = path[-1][1]  # Use the last point as a reference.\n            tipheight = (self.shoulder - flow / 2) * self.pitch\n            if angle == RIGHT:\n                x += length\n                tip = [x + tipheight, y + flow / 2.0]\n                path.extend([(Path.LINETO, [x, y]),\n                             (Path.LINETO, [x, y + self.shoulder]),\n                             (Path.LINETO, tip),\n                             (Path.LINETO, [x, y - self.shoulder + flow]),\n                             (Path.LINETO, [x, y + flow]),\n                             (Path.LINETO, [x - self.gap, y + flow])])\n                label_location = [tip[0] + self.offset, tip[1]]\n            else:  # Vertical\n                x += self.gap\n                if angle == UP:\n                    sign = 1\n                else:\n                    sign = -1\n\n                tip = [x - flow / 2.0, y + sign * (length + tipheight)]\n                if angle == UP:\n                    quadrant = 3\n                else:\n                    quadrant = 0\n                # Inner arc isn't needed if inner radius is zero\n                if self.radius:\n                    path.extend(self._arc(quadrant=quadrant,\n                                          cw=angle == UP,\n                                          radius=self.radius,\n                                          center=(x - self.radius,\n                                                  y + sign * self.radius)))\n                else:\n                    path.append((Path.LINETO, [x, y]))\n                path.extend([(Path.LINETO, [x, y + sign * length]),\n                             (Path.LINETO, [x - self.shoulder,\n                                            y + sign * length]),\n                             (Path.LINETO, tip),\n                             (Path.LINETO, [x + self.shoulder - flow,\n                                            y + sign * length]),\n                             (Path.LINETO, [x - flow, y + sign * length])])\n                path.extend(self._arc(quadrant=quadrant,\n                                      cw=angle == DOWN,\n                                      radius=self.radius - flow,\n                                      center=(x - self.radius,\n                                              y + sign * self.radius)))\n                path.append((Path.LINETO, [x - flow, y + sign * flow]))\n                label_location = [tip[0], tip[1] + sign * self.offset]\n            return tip, label_location",
        "begin_line": 273,
        "end_line": 329,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.sankey.Sankey.add#350",
        "src_path": "lib/matplotlib/sankey.py",
        "class_name": "lib.matplotlib.sankey.Sankey",
        "signature": "lib.matplotlib.sankey.Sankey.add(self, patchlabel='', flows=None, orientations=None, labels='', trunklength=1.0, pathlengths=0.25, prior=None, connect=(0, 0), rotation=0, **kwargs)",
        "snippet": "    def add(self, patchlabel='', flows=None, orientations=None, labels='',\n            trunklength=1.0, pathlengths=0.25, prior=None, connect=(0, 0),\n            rotation=0, **kwargs):\n        \"\"\"\n        Add a simple Sankey diagram with flows at the same hierarchical level.\n\n        Parameters\n        ----------\n        patchlabel : str\n            Label to be placed at the center of the diagram.\n            Note that *label* (not *patchlabel*) can be passed as keyword\n            argument to create an entry in the legend.\n\n        flows : list of float\n            Array of flow values.  By convention, inputs are positive and\n            outputs are negative.\n\n            Flows are placed along the top of the diagram from the inside out\n            in order of their index within *flows*.  They are placed along the\n            sides of the diagram from the top down and along the bottom from\n            the outside in.\n\n            If the sum of the inputs and outputs is\n            nonzero, the discrepancy will appear as a cubic Bezier curve along\n            the top and bottom edges of the trunk.\n\n        orientations : list of {-1, 0, 1}\n            List of orientations of the flows (or a single orientation to be\n            used for all flows).  Valid values are 0 (inputs from\n            the left, outputs to the right), 1 (from and to the top) or -1\n            (from and to the bottom).\n\n        labels : list of (str or None)\n            List of labels for the flows (or a single label to be used for all\n            flows).  Each label may be *None* (no label), or a labeling string.\n            If an entry is a (possibly empty) string, then the quantity for the\n            corresponding flow will be shown below the string.  However, if\n            the *unit* of the main diagram is None, then quantities are never\n            shown, regardless of the value of this argument.\n\n        trunklength : float\n            Length between the bases of the input and output groups (in\n            data-space units).\n\n        pathlengths : list of float\n            List of lengths of the vertical arrows before break-in or after\n            break-away.  If a single value is given, then it will be applied to\n            the first (inside) paths on the top and bottom, and the length of\n            all other arrows will be justified accordingly.  The *pathlengths*\n            are not applied to the horizontal inputs and outputs.\n\n        prior : int\n            Index of the prior diagram to which this diagram should be\n            connected.\n\n        connect : (int, int)\n            A (prior, this) tuple indexing the flow of the prior diagram and\n            the flow of this diagram which should be connected.  If this is the\n            first diagram or *prior* is *None*, *connect* will be ignored.\n\n        rotation : float\n            Angle of rotation of the diagram in degrees.  The interpretation of\n            the *orientations* argument will be rotated accordingly (e.g., if\n            *rotation* == 90, an *orientations* entry of 1 means to/from the\n            left).  *rotation* is ignored if this diagram is connected to an\n            existing one (using *prior* and *connect*).\n\n        Returns\n        -------\n        Sankey\n            The current `.Sankey` instance.\n\n        Other Parameters\n        ----------------\n        **kwargs\n           Additional keyword arguments set `matplotlib.patches.PathPatch`\n           properties, listed below.  For example, one may want to use\n           ``fill=False`` or ``label=\"A legend entry\"``.\n\n        %(Patch)s\n\n        See Also\n        --------\n        Sankey.finish\n        \"\"\"\n        # Check and preprocess the arguments.\n        if flows is None:\n            flows = np.array([1.0, -1.0])\n        else:\n            flows = np.array(flows)\n        n = flows.shape[0]  # Number of flows\n        if rotation is None:\n            rotation = 0\n        else:\n            # In the code below, angles are expressed in deg/90.\n            rotation /= 90.0\n        if orientations is None:\n            orientations = 0\n        try:\n            orientations = np.broadcast_to(orientations, n)\n        except ValueError:\n            raise ValueError(\n                f\"The shapes of 'flows' {np.shape(flows)} and 'orientations' \"\n                f\"{np.shape(orientations)} are incompatible\"\n            ) from None\n        try:\n            labels = np.broadcast_to(labels, n)\n        except ValueError:\n            raise ValueError(\n                f\"The shapes of 'flows' {np.shape(flows)} and 'labels' \"\n                f\"{np.shape(labels)} are incompatible\"\n            ) from None\n        if trunklength < 0:\n            raise ValueError(\n                \"'trunklength' is negative, which is not allowed because it \"\n                \"would cause poor layout\")\n        if abs(np.sum(flows)) > self.tolerance:\n            _log.info(\"The sum of the flows is nonzero (%f; patchlabel=%r); \"\n                      \"is the system not at steady state?\",\n                      np.sum(flows), patchlabel)\n        scaled_flows = self.scale * flows\n        gain = sum(max(flow, 0) for flow in scaled_flows)\n        loss = sum(min(flow, 0) for flow in scaled_flows)\n        if prior is not None:\n            if prior < 0:\n                raise ValueError(\"The index of the prior diagram is negative\")\n            if min(connect) < 0:\n                raise ValueError(\n                    \"At least one of the connection indices is negative\")\n            if prior >= len(self.diagrams):\n                raise ValueError(\n                    f\"The index of the prior diagram is {prior}, but there \"\n                    f\"are only {len(self.diagrams)} other diagrams\")\n            if connect[0] >= len(self.diagrams[prior].flows):\n                raise ValueError(\n                    \"The connection index to the source diagram is {}, but \"\n                    \"that diagram has only {} flows\".format(\n                        connect[0], len(self.diagrams[prior].flows)))\n            if connect[1] >= n:\n                raise ValueError(\n                    f\"The connection index to this diagram is {connect[1]}, \"\n                    f\"but this diagram has only {n} flows\")\n            if self.diagrams[prior].angles[connect[0]] is None:\n                raise ValueError(\n                    f\"The connection cannot be made, which may occur if the \"\n                    f\"magnitude of flow {connect[0]} of diagram {prior} is \"\n                    f\"less than the specified tolerance\")\n            flow_error = (self.diagrams[prior].flows[connect[0]] +\n                          flows[connect[1]])\n            if abs(flow_error) >= self.tolerance:\n                raise ValueError(\n                    f\"The scaled sum of the connected flows is {flow_error}, \"\n                    f\"which is not within the tolerance ({self.tolerance})\")\n\n        # Determine if the flows are inputs.\n        are_inputs = [None] * n\n        for i, flow in enumerate(flows):\n            if flow >= self.tolerance:\n                are_inputs[i] = True\n            elif flow <= -self.tolerance:\n                are_inputs[i] = False\n            else:\n                _log.info(\n                    \"The magnitude of flow %d (%f) is below the tolerance \"\n                    \"(%f).\\nIt will not be shown, and it cannot be used in a \"\n                    \"connection.\", i, flow, self.tolerance)\n\n        # Determine the angles of the arrows (before rotation).\n        angles = [None] * n\n        for i, (orient, is_input) in enumerate(zip(orientations, are_inputs)):\n            if orient == 1:\n                if is_input:\n                    angles[i] = DOWN\n                elif not is_input:\n                    # Be specific since is_input can be None.\n                    angles[i] = UP\n            elif orient == 0:\n                if is_input is not None:\n                    angles[i] = RIGHT\n            else:\n                if orient != -1:\n                    raise ValueError(\n                        f\"The value of orientations[{i}] is {orient}, \"\n                        f\"but it must be -1, 0, or 1\")\n                if is_input:\n                    angles[i] = UP\n                elif not is_input:\n                    angles[i] = DOWN\n\n        # Justify the lengths of the paths.\n        if np.iterable(pathlengths):\n            if len(pathlengths) != n:\n                raise ValueError(\n                    f\"The lengths of 'flows' ({n}) and 'pathlengths' \"\n                    f\"({len(pathlengths)}) are incompatible\")\n        else:  # Make pathlengths into a list.\n            urlength = pathlengths\n            ullength = pathlengths\n            lrlength = pathlengths\n            lllength = pathlengths\n            d = dict(RIGHT=pathlengths)\n            pathlengths = [d.get(angle, 0) for angle in angles]\n            # Determine the lengths of the top-side arrows\n            # from the middle outwards.\n            for i, (angle, is_input, flow) in enumerate(zip(angles, are_inputs,\n                                                            scaled_flows)):\n                if angle == DOWN and is_input:\n                    pathlengths[i] = ullength\n                    ullength += flow\n                elif angle == UP and not is_input:\n                    pathlengths[i] = urlength\n                    urlength -= flow  # Flow is negative for outputs.\n            # Determine the lengths of the bottom-side arrows\n            # from the middle outwards.\n            for i, (angle, is_input, flow) in enumerate(reversed(list(zip(\n                  angles, are_inputs, scaled_flows)))):\n                if angle == UP and is_input:\n                    pathlengths[n - i - 1] = lllength\n                    lllength += flow\n                elif angle == DOWN and not is_input:\n                    pathlengths[n - i - 1] = lrlength\n                    lrlength -= flow\n            # Determine the lengths of the left-side arrows\n            # from the bottom upwards.\n            has_left_input = False\n            for i, (angle, is_input, spec) in enumerate(reversed(list(zip(\n                  angles, are_inputs, zip(scaled_flows, pathlengths))))):\n                if angle == RIGHT:\n                    if is_input:\n                        if has_left_input:\n                            pathlengths[n - i - 1] = 0\n                        else:\n                            has_left_input = True\n            # Determine the lengths of the right-side arrows\n            # from the top downwards.\n            has_right_output = False\n            for i, (angle, is_input, spec) in enumerate(zip(\n                  angles, are_inputs, list(zip(scaled_flows, pathlengths)))):\n                if angle == RIGHT:\n                    if not is_input:\n                        if has_right_output:\n                            pathlengths[i] = 0\n                        else:\n                            has_right_output = True\n\n        # Begin the subpaths, and smooth the transition if the sum of the flows\n        # is nonzero.\n        urpath = [(Path.MOVETO, [(self.gap - trunklength / 2.0),  # Upper right\n                                 gain / 2.0]),\n                  (Path.LINETO, [(self.gap - trunklength / 2.0) / 2.0,\n                                 gain / 2.0]),\n                  (Path.CURVE4, [(self.gap - trunklength / 2.0) / 8.0,\n                                 gain / 2.0]),\n                  (Path.CURVE4, [(trunklength / 2.0 - self.gap) / 8.0,\n                                 -loss / 2.0]),\n                  (Path.LINETO, [(trunklength / 2.0 - self.gap) / 2.0,\n                                 -loss / 2.0]),\n                  (Path.LINETO, [(trunklength / 2.0 - self.gap),\n                                 -loss / 2.0])]\n        llpath = [(Path.LINETO, [(trunklength / 2.0 - self.gap),  # Lower left\n                                 loss / 2.0]),\n                  (Path.LINETO, [(trunklength / 2.0 - self.gap) / 2.0,\n                                 loss / 2.0]),\n                  (Path.CURVE4, [(trunklength / 2.0 - self.gap) / 8.0,\n                                 loss / 2.0]),\n                  (Path.CURVE4, [(self.gap - trunklength / 2.0) / 8.0,\n                                 -gain / 2.0]),\n                  (Path.LINETO, [(self.gap - trunklength / 2.0) / 2.0,\n                                 -gain / 2.0]),\n                  (Path.LINETO, [(self.gap - trunklength / 2.0),\n                                 -gain / 2.0])]\n        lrpath = [(Path.LINETO, [(trunklength / 2.0 - self.gap),  # Lower right\n                                 loss / 2.0])]\n        ulpath = [(Path.LINETO, [self.gap - trunklength / 2.0,  # Upper left\n                                 gain / 2.0])]\n\n        # Add the subpaths and assign the locations of the tips and labels.\n        tips = np.zeros((n, 2))\n        label_locations = np.zeros((n, 2))\n        # Add the top-side inputs and outputs from the middle outwards.\n        for i, (angle, is_input, spec) in enumerate(zip(\n              angles, are_inputs, list(zip(scaled_flows, pathlengths)))):\n            if angle == DOWN and is_input:\n                tips[i, :], label_locations[i, :] = self._add_input(\n                    ulpath, angle, *spec)\n            elif angle == UP and not is_input:\n                tips[i, :], label_locations[i, :] = self._add_output(\n                    urpath, angle, *spec)\n        # Add the bottom-side inputs and outputs from the middle outwards.\n        for i, (angle, is_input, spec) in enumerate(reversed(list(zip(\n              angles, are_inputs, list(zip(scaled_flows, pathlengths)))))):\n            if angle == UP and is_input:\n                tip, label_location = self._add_input(llpath, angle, *spec)\n                tips[n - i - 1, :] = tip\n                label_locations[n - i - 1, :] = label_location\n            elif angle == DOWN and not is_input:\n                tip, label_location = self._add_output(lrpath, angle, *spec)\n                tips[n - i - 1, :] = tip\n                label_locations[n - i - 1, :] = label_location\n        # Add the left-side inputs from the bottom upwards.\n        has_left_input = False\n        for i, (angle, is_input, spec) in enumerate(reversed(list(zip(\n              angles, are_inputs, list(zip(scaled_flows, pathlengths)))))):\n            if angle == RIGHT and is_input:\n                if not has_left_input:\n                    # Make sure the lower path extends\n                    # at least as far as the upper one.\n                    if llpath[-1][1][0] > ulpath[-1][1][0]:\n                        llpath.append((Path.LINETO, [ulpath[-1][1][0],\n                                                     llpath[-1][1][1]]))\n                    has_left_input = True\n                tip, label_location = self._add_input(llpath, angle, *spec)\n                tips[n - i - 1, :] = tip\n                label_locations[n - i - 1, :] = label_location\n        # Add the right-side outputs from the top downwards.\n        has_right_output = False\n        for i, (angle, is_input, spec) in enumerate(zip(\n              angles, are_inputs, list(zip(scaled_flows, pathlengths)))):\n            if angle == RIGHT and not is_input:\n                if not has_right_output:\n                    # Make sure the upper path extends\n                    # at least as far as the lower one.\n                    if urpath[-1][1][0] < lrpath[-1][1][0]:\n                        urpath.append((Path.LINETO, [lrpath[-1][1][0],\n                                                     urpath[-1][1][1]]))\n                    has_right_output = True\n                tips[i, :], label_locations[i, :] = self._add_output(\n                    urpath, angle, *spec)\n        # Trim any hanging vertices.\n        if not has_left_input:\n            ulpath.pop()\n            llpath.pop()\n        if not has_right_output:\n            lrpath.pop()\n            urpath.pop()\n\n        # Concatenate the subpaths in the correct order (clockwise from top).\n        path = (urpath + self._revert(lrpath) + llpath + self._revert(ulpath) +\n                [(Path.CLOSEPOLY, urpath[0][1])])\n\n        # Create a patch with the Sankey outline.\n        codes, vertices = zip(*path)\n        vertices = np.array(vertices)\n\n        def _get_angle(a, r):\n            if a is None:\n                return None\n            else:\n                return a + r\n\n        if prior is None:\n            if rotation != 0:  # By default, none of this is needed.\n                angles = [_get_angle(angle, rotation) for angle in angles]\n                rotate = Affine2D().rotate_deg(rotation * 90).transform_affine\n                tips = rotate(tips)\n                label_locations = rotate(label_locations)\n                vertices = rotate(vertices)\n            text = self.ax.text(0, 0, s=patchlabel, ha='center', va='center')\n        else:\n            rotation = (self.diagrams[prior].angles[connect[0]] -\n                        angles[connect[1]])\n            angles = [_get_angle(angle, rotation) for angle in angles]\n            rotate = Affine2D().rotate_deg(rotation * 90).transform_affine\n            tips = rotate(tips)\n            offset = self.diagrams[prior].tips[connect[0]] - tips[connect[1]]\n            translate = Affine2D().translate(*offset).transform_affine\n            tips = translate(tips)\n            label_locations = translate(rotate(label_locations))\n            vertices = translate(rotate(vertices))\n            kwds = dict(s=patchlabel, ha='center', va='center')\n            text = self.ax.text(*offset, **kwds)\n        if mpl.rcParams['_internal.classic_mode']:\n            fc = kwargs.pop('fc', kwargs.pop('facecolor', '#bfd1d4'))\n            lw = kwargs.pop('lw', kwargs.pop('linewidth', 0.5))\n        else:\n            fc = kwargs.pop('fc', kwargs.pop('facecolor', None))\n            lw = kwargs.pop('lw', kwargs.pop('linewidth', None))\n        if fc is None:\n            fc = next(self.ax._get_patches_for_fill.prop_cycler)['color']\n        patch = PathPatch(Path(vertices, codes), fc=fc, lw=lw, **kwargs)\n        self.ax.add_patch(patch)\n\n        # Add the path labels.\n        texts = []\n        for number, angle, label, location in zip(flows, angles, labels,\n                                                  label_locations):\n            if label is None or angle is None:\n                label = ''\n            elif self.unit is not None:\n                quantity = self.format % abs(number) + self.unit\n                if label != '':\n                    label += \"\\n\"\n                label += quantity\n            texts.append(self.ax.text(x=location[0], y=location[1],\n                                      s=label,\n                                      ha='center', va='center'))\n        # Text objects are placed even they are empty (as long as the magnitude\n        # of the corresponding flow is larger than the tolerance) in case the\n        # user wants to provide labels later.\n\n        # Expand the size of the diagram if necessary.\n        self.extent = (min(np.min(vertices[:, 0]),\n                           np.min(label_locations[:, 0]),\n                           self.extent[0]),\n                       max(np.max(vertices[:, 0]),\n                           np.max(label_locations[:, 0]),\n                           self.extent[1]),\n                       min(np.min(vertices[:, 1]),\n                           np.min(label_locations[:, 1]),\n                           self.extent[2]),\n                       max(np.max(vertices[:, 1]),\n                           np.max(label_locations[:, 1]),\n                           self.extent[3]))\n        # Include both vertices _and_ label locations in the extents; there are\n        # where either could determine the margins (e.g., arrow shoulders).\n\n        # Add this diagram as a subdiagram.\n        self.diagrams.append(\n            SimpleNamespace(patch=patch, flows=flows, angles=angles, tips=tips,\n                            text=text, texts=texts))\n\n        # Allow a daisy-chained call structure (see docstring for the class).\n        return self",
        "begin_line": 350,
        "end_line": 772,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element.get_d2Sidksij2#805",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element",
        "signature": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element.get_d2Sidksij2(self, alpha, ecc)",
        "snippet": "    def get_d2Sidksij2(self, alpha, ecc):\n        \"\"\"\n        Parameters\n        ----------\n        *alpha* is a (N x 3 x 1) array (array of column-matrices) of\n        barycentric coordinates\n        *ecc* is a (N x 3 x 1) array (array of column-matrices) of triangle\n        eccentricities\n\n        Returns\n        -------\n        Returns the arrays d2sdksi2 (N x 3 x 1) Hessian of shape functions\n        expressed in covariant coordinates in first apex basis.\n        \"\"\"\n        subtri = np.argmin(alpha, axis=1)[:, 0]\n        ksi = _roll_vectorized(alpha, -subtri, axis=0)\n        E = _roll_vectorized(ecc, -subtri, axis=0)\n        x = ksi[:, 0, 0]\n        y = ksi[:, 1, 0]\n        z = ksi[:, 2, 0]\n        d2V = _to_matrix_vectorized([\n            [     6.*x,      6.*x,      6.*x],\n            [     6.*y,        0.,        0.],\n            [       0.,      6.*z,        0.],\n            [     2.*z, 2.*z-4.*x, 2.*z-2.*x],\n            [2.*y-4.*x,      2.*y, 2.*y-2.*x],\n            [2.*x-4.*y,        0.,     -2.*y],\n            [     2.*z,        0.,      2.*y],\n            [       0.,      2.*y,      2.*z],\n            [       0., 2.*x-4.*z,     -2.*z],\n            [    -2.*z,     -2.*y,     x-y-z]])\n        # Puts back d2V in first apex basis\n        d2V = _prod_vectorized(d2V, _extract_submatrices(\n            self.rotate_d2V, subtri, block_size=3, axis=0))\n        prod = _prod_vectorized(self.M, d2V)\n        prod += _scalar_vectorized(E[:, 0, 0],\n                                   _prod_vectorized(self.M0, d2V))\n        prod += _scalar_vectorized(E[:, 1, 0],\n                                   _prod_vectorized(self.M1, d2V))\n        prod += _scalar_vectorized(E[:, 2, 0],\n                                   _prod_vectorized(self.M2, d2V))\n        d2sdksi2 = _roll_vectorized(prod, 3*subtri, axis=0)\n        return d2sdksi2",
        "begin_line": 805,
        "end_line": 847,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element.get_bending_matrices#849",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element",
        "signature": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element.get_bending_matrices(self, J, ecc)",
        "snippet": "    def get_bending_matrices(self, J, ecc):\n        \"\"\"\n        Parameters\n        ----------\n        *J* is a (N x 2 x 2) array of jacobian matrices (jacobian matrix at\n        triangle first apex)\n        *ecc* is a (N x 3 x 1) array (array of column-matrices) of triangle\n        eccentricities\n\n        Returns\n        -------\n        Returns the element K matrices for bending energy expressed in\n        GLOBAL nodal coordinates.\n        K_ij = integral [ (d2zi/dx2 + d2zi/dy2) * (d2zj/dx2 + d2zj/dy2) dA]\n        tri_J is needed to rotate dofs from local basis to global basis\n        \"\"\"\n        n = np.size(ecc, 0)\n\n        # 1) matrix to rotate dofs in global coordinates\n        J1 = _prod_vectorized(self.J0_to_J1, J)\n        J2 = _prod_vectorized(self.J0_to_J2, J)\n        DOF_rot = np.zeros([n, 9, 9], dtype=np.float64)\n        DOF_rot[:, 0, 0] = 1\n        DOF_rot[:, 3, 3] = 1\n        DOF_rot[:, 6, 6] = 1\n        DOF_rot[:, 1:3, 1:3] = J\n        DOF_rot[:, 4:6, 4:6] = J1\n        DOF_rot[:, 7:9, 7:9] = J2\n\n        # 2) matrix to rotate Hessian in global coordinates.\n        H_rot, area = self.get_Hrot_from_J(J, return_area=True)\n\n        # 3) Computes stiffness matrix\n        # Gauss quadrature.\n        K = np.zeros([n, 9, 9], dtype=np.float64)\n        weights = self.gauss_w\n        pts = self.gauss_pts\n        for igauss in range(self.n_gauss):\n            alpha = np.tile(pts[igauss, :], n).reshape(n, 3)\n            alpha = np.expand_dims(alpha, 2)\n            weight = weights[igauss]\n            d2Skdksi2 = self.get_d2Sidksij2(alpha, ecc)\n            d2Skdx2 = _prod_vectorized(d2Skdksi2, H_rot)\n            K += weight * _prod_vectorized(_prod_vectorized(d2Skdx2, self.E),\n                                           _transpose_vectorized(d2Skdx2))\n\n        # 4) With nodal (not elem) dofs\n        K = _prod_vectorized(_prod_vectorized(_transpose_vectorized(DOF_rot),\n                                              K), DOF_rot)\n\n        # 5) Need the area to compute total element energy\n        return _scalar_vectorized(area, K)",
        "begin_line": 849,
        "end_line": 900,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element.get_Hrot_from_J#902",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element",
        "signature": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element.get_Hrot_from_J(self, J, return_area=False)",
        "snippet": "    def get_Hrot_from_J(self, J, return_area=False):\n        \"\"\"\n        Parameters\n        ----------\n        *J* is a (N x 2 x 2) array of jacobian matrices (jacobian matrix at\n        triangle first apex)\n\n        Returns\n        -------\n        Returns H_rot used to rotate Hessian from local basis of first apex,\n        to global coordinates.\n        if *return_area* is True, returns also the triangle area (0.5*det(J))\n        \"\"\"\n        # Here we try to deal with the simplest colinear cases; a null\n        # energy and area is imposed.\n        J_inv = _safe_inv22_vectorized(J)\n        Ji00 = J_inv[:, 0, 0]\n        Ji11 = J_inv[:, 1, 1]\n        Ji10 = J_inv[:, 1, 0]\n        Ji01 = J_inv[:, 0, 1]\n        H_rot = _to_matrix_vectorized([\n            [Ji00*Ji00, Ji10*Ji10, Ji00*Ji10],\n            [Ji01*Ji01, Ji11*Ji11, Ji01*Ji11],\n            [2*Ji00*Ji01, 2*Ji11*Ji10, Ji00*Ji11+Ji10*Ji01]])\n        if not return_area:\n            return H_rot\n        else:\n            area = 0.5 * (J[:, 0, 0]*J[:, 1, 1] - J[:, 0, 1]*J[:, 1, 0])\n            return H_rot, area",
        "begin_line": 902,
        "end_line": 930,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element.get_Kff_and_Ff#932",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element",
        "signature": "lib.matplotlib.tri.triinterpolate._ReducedHCT_Element.get_Kff_and_Ff(self, J, ecc, triangles, Uc)",
        "snippet": "    def get_Kff_and_Ff(self, J, ecc, triangles, Uc):\n        \"\"\"\n        Builds K and F for the following elliptic formulation:\n        minimization of curvature energy with value of function at node\n        imposed and derivatives 'free'.\n        Builds the global Kff matrix in cco format.\n        Builds the full Ff vec Ff = - Kfc x Uc\n\n        Parameters\n        ----------\n        *J* is a (N x 2 x 2) array of jacobian matrices (jacobian matrix at\n        triangle first apex)\n        *ecc* is a (N x 3 x 1) array (array of column-matrices) of triangle\n        eccentricities\n        *triangles* is a (N x 3) array of nodes indexes.\n        *Uc* is (N x 3) array of imposed displacements at nodes\n\n        Returns\n        -------\n        (Kff_rows, Kff_cols, Kff_vals) Kff matrix in coo format - Duplicate\n        (row, col) entries must be summed.\n        Ff: force vector - dim npts * 3\n        \"\"\"\n        ntri = np.size(ecc, 0)\n        vec_range = np.arange(ntri, dtype=np.int32)\n        c_indices = np.full(ntri, -1, dtype=np.int32)  # for unused dofs, -1\n        f_dof = [1, 2, 4, 5, 7, 8]\n        c_dof = [0, 3, 6]\n\n        # vals, rows and cols indices in global dof numbering\n        f_dof_indices = _to_matrix_vectorized([[\n            c_indices, triangles[:, 0]*2, triangles[:, 0]*2+1,\n            c_indices, triangles[:, 1]*2, triangles[:, 1]*2+1,\n            c_indices, triangles[:, 2]*2, triangles[:, 2]*2+1]])\n\n        expand_indices = np.ones([ntri, 9, 1], dtype=np.int32)\n        f_row_indices = _prod_vectorized(_transpose_vectorized(f_dof_indices),\n                                         _transpose_vectorized(expand_indices))\n        f_col_indices = _prod_vectorized(expand_indices, f_dof_indices)\n        K_elem = self.get_bending_matrices(J, ecc)\n\n        # Extracting sub-matrices\n        # Explanation & notations:\n        # * Subscript f denotes 'free' degrees of freedom (i.e. dz/dx, dz/dx)\n        # * Subscript c denotes 'condensated' (imposed) degrees of freedom\n        #    (i.e. z at all nodes)\n        # * F = [Ff, Fc] is the force vector\n        # * U = [Uf, Uc] is the imposed dof vector\n        #        [ Kff Kfc ]\n        # * K =  [         ]  is the laplacian stiffness matrix\n        #        [ Kcf Kff ]\n        # * As F = K x U one gets straightforwardly: Ff = - Kfc x Uc\n\n        # Computing Kff stiffness matrix in sparse coo format\n        Kff_vals = np.ravel(K_elem[np.ix_(vec_range, f_dof, f_dof)])\n        Kff_rows = np.ravel(f_row_indices[np.ix_(vec_range, f_dof, f_dof)])\n        Kff_cols = np.ravel(f_col_indices[np.ix_(vec_range, f_dof, f_dof)])\n\n        # Computing Ff force vector in sparse coo format\n        Kfc_elem = K_elem[np.ix_(vec_range, f_dof, c_dof)]\n        Uc_elem = np.expand_dims(Uc, axis=2)\n        Ff_elem = - _prod_vectorized(Kfc_elem, Uc_elem)[:, :, 0]\n        Ff_indices = f_dof_indices[np.ix_(vec_range, [0], f_dof)][:, 0, :]\n\n        # Extracting Ff force vector in dense format\n        # We have to sum duplicate indices -  using bincount\n        Ff = np.bincount(np.ravel(Ff_indices), weights=np.ravel(Ff_elem))\n        return Kff_rows, Kff_cols, Kff_vals, Ff",
        "begin_line": 932,
        "end_line": 999,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom.compute_dz#1087",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom",
        "signature": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom.compute_dz(self)",
        "snippet": "    def compute_dz(self):\n        \"\"\"\n        self.df is computed as weighted average of _triangles sharing a common\n        node. On each triangle itri f is first assumed linear (= ~f), which\n        allows to compute d~f[itri]\n        Then the following approximation of df nodal values is then proposed:\n            f[ipt] = SUM ( w[itri] x d~f[itri] , for itri sharing apex ipt)\n        The weighted coeff. w[itri] are proportional to the angle of the\n        triangle itri at apex ipt\n        \"\"\"\n        el_geom_w = self.compute_geom_weights()\n        el_geom_grad = self.compute_geom_grads()\n\n        # Sum of weights coeffs\n        w_node_sum = np.bincount(np.ravel(self._triangles),\n                                 weights=np.ravel(el_geom_w))\n\n        # Sum of weighted df = (dfx, dfy)\n        dfx_el_w = np.empty_like(el_geom_w)\n        dfy_el_w = np.empty_like(el_geom_w)\n        for iapex in range(3):\n            dfx_el_w[:, iapex] = el_geom_w[:, iapex]*el_geom_grad[:, 0]\n            dfy_el_w[:, iapex] = el_geom_w[:, iapex]*el_geom_grad[:, 1]\n        dfx_node_sum = np.bincount(np.ravel(self._triangles),\n                                   weights=np.ravel(dfx_el_w))\n        dfy_node_sum = np.bincount(np.ravel(self._triangles),\n                                   weights=np.ravel(dfy_el_w))\n\n        # Estimation of df\n        dfx_estim = dfx_node_sum/w_node_sum\n        dfy_estim = dfy_node_sum/w_node_sum\n        return np.vstack([dfx_estim, dfy_estim]).T",
        "begin_line": 1087,
        "end_line": 1118,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom.compute_geom_weights#1120",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom",
        "signature": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom.compute_geom_weights(self)",
        "snippet": "    def compute_geom_weights(self):\n        \"\"\"\n        Builds the (nelems x 3) weights coeffs of _triangles angles,\n        renormalized so that np.sum(weights, axis=1) == np.ones(nelems)\n        \"\"\"\n        weights = np.zeros([np.size(self._triangles, 0), 3])\n        tris_pts = self._tris_pts\n        for ipt in range(3):\n            p0 = tris_pts[:, ipt % 3, :]\n            p1 = tris_pts[:, (ipt+1) % 3, :]\n            p2 = tris_pts[:, (ipt-1) % 3, :]\n            alpha1 = np.arctan2(p1[:, 1]-p0[:, 1], p1[:, 0]-p0[:, 0])\n            alpha2 = np.arctan2(p2[:, 1]-p0[:, 1], p2[:, 0]-p0[:, 0])\n            # In the below formula we could take modulo 2. but\n            # modulo 1. is safer regarding round-off errors (flat triangles).\n            angle = np.abs(((alpha2-alpha1) / np.pi) % 1)\n            # Weight proportional to angle up np.pi/2; null weight for\n            # degenerated cases 0 and np.pi (note that *angle* is normalized\n            # by np.pi).\n            weights[:, ipt] = 0.5 - np.abs(angle-0.5)\n        return weights",
        "begin_line": 1120,
        "end_line": 1140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom.compute_geom_grads#1142",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom",
        "signature": "lib.matplotlib.tri.triinterpolate._DOF_estimator_geom.compute_geom_grads(self)",
        "snippet": "    def compute_geom_grads(self):\n        \"\"\"\n        Compute the (global) gradient component of f assumed linear (~f).\n        returns array df of shape (nelems, 2)\n        df[ielem].dM[ielem] = dz[ielem] i.e. df = dz x dM = dM.T^-1 x dz\n        \"\"\"\n        tris_pts = self._tris_pts\n        tris_f = self.z[self._triangles]\n\n        dM1 = tris_pts[:, 1, :] - tris_pts[:, 0, :]\n        dM2 = tris_pts[:, 2, :] - tris_pts[:, 0, :]\n        dM = np.dstack([dM1, dM2])\n        # Here we try to deal with the simplest colinear cases: a null\n        # gradient is assumed in this case.\n        dM_inv = _safe_inv22_vectorized(dM)\n\n        dZ1 = tris_f[:, 1] - tris_f[:, 0]\n        dZ2 = tris_f[:, 2] - tris_f[:, 0]\n        dZ = np.vstack([dZ1, dZ2]).T\n        df = np.empty_like(dZ)\n\n        # With np.einsum: could be ej,eji -> ej\n        df[:, 0] = dZ[:, 0]*dM_inv[:, 0, 0] + dZ[:, 1]*dM_inv[:, 1, 0]\n        df[:, 1] = dZ[:, 0]*dM_inv[:, 0, 1] + dZ[:, 1]*dM_inv[:, 1, 1]\n        return df",
        "begin_line": 1142,
        "end_line": 1166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_min_E.__init__#1175",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_min_E",
        "signature": "lib.matplotlib.tri.triinterpolate._DOF_estimator_min_E.__init__(self, Interpolator)",
        "snippet": "    def __init__(self, Interpolator):\n        self._eccs = Interpolator._eccs\n        _DOF_estimator_geom.__init__(self, Interpolator)",
        "begin_line": 1175,
        "end_line": 1177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010649627263045793,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_min_E.compute_dz#1179",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._DOF_estimator_min_E",
        "signature": "lib.matplotlib.tri.triinterpolate._DOF_estimator_min_E.compute_dz(self)",
        "snippet": "    def compute_dz(self):\n        \"\"\"\n        Elliptic solver for bending energy minimization.\n        Uses a dedicated 'toy' sparse Jacobi PCG solver.\n        \"\"\"\n        # Initial guess for iterative PCG solver.\n        dz_init = _DOF_estimator_geom.compute_dz(self)\n        Uf0 = np.ravel(dz_init)\n\n        reference_element = _ReducedHCT_Element()\n        J = CubicTriInterpolator._get_jacobian(self._tris_pts)\n        eccs = self._eccs\n        triangles = self._triangles\n        Uc = self.z[self._triangles]\n\n        # Building stiffness matrix and force vector in coo format\n        Kff_rows, Kff_cols, Kff_vals, Ff = reference_element.get_Kff_and_Ff(\n            J, eccs, triangles, Uc)\n\n        # Building sparse matrix and solving minimization problem\n        # We could use scipy.sparse direct solver; however to avoid this\n        # external dependency an implementation of a simple PCG solver with\n        # a simple diagonal Jacobi preconditioner is implemented.\n        tol = 1.e-10\n        n_dof = Ff.shape[0]\n        Kff_coo = _Sparse_Matrix_coo(Kff_vals, Kff_rows, Kff_cols,\n                                     shape=(n_dof, n_dof))\n        Kff_coo.compress_csc()\n        Uf, err = _cg(A=Kff_coo, b=Ff, x0=Uf0, tol=tol)\n        # If the PCG did not converge, we return the best guess between Uf0\n        # and Uf.\n        err0 = np.linalg.norm(Kff_coo.dot(Uf0) - Ff)\n        if err0 < err:\n            # Maybe a good occasion to raise a warning here ?\n            cbook._warn_external(\"In TriCubicInterpolator initialization, \"\n                                 \"PCG sparse solver did not converge after \"\n                                 \"1000 iterations. `geom` approximation is \"\n                                 \"used instead of `min_E`\")\n            Uf = Uf0\n\n        # Building dz from Uf\n        dz = np.empty([self._pts.shape[0], 2], dtype=np.float64)\n        dz[:, 0] = Uf[::2]\n        dz[:, 1] = Uf[1::2]\n        return dz",
        "begin_line": 1179,
        "end_line": 1223,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.__init__#1229",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo",
        "signature": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.__init__(self, vals, rows, cols, shape)",
        "snippet": "    def __init__(self, vals, rows, cols, shape):\n        \"\"\"\n        Creates a sparse matrix in coo format\n        *vals*: arrays of values of non-null entries of the matrix\n        *rows*: int arrays of rows of non-null entries of the matrix\n        *cols*: int arrays of cols of non-null entries of the matrix\n        *shape*: 2-tuple (n, m) of matrix shape\n\n        \"\"\"\n        self.n, self.m = shape\n        self.vals = np.asarray(vals, dtype=np.float64)\n        self.rows = np.asarray(rows, dtype=np.int32)\n        self.cols = np.asarray(cols, dtype=np.int32)",
        "begin_line": 1229,
        "end_line": 1241,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.dot#1243",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo",
        "signature": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.dot(self, V)",
        "snippet": "    def dot(self, V):\n        \"\"\"\n        Dot product of self by a vector *V* in sparse-dense to dense format\n        *V* dense vector of shape (self.m,).\n        \"\"\"\n        assert V.shape == (self.m,)\n        return np.bincount(self.rows,\n                           weights=self.vals*V[self.cols],\n                           minlength=self.m)",
        "begin_line": 1243,
        "end_line": 1251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.compress_csc#1253",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo",
        "signature": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.compress_csc(self)",
        "snippet": "    def compress_csc(self):\n        \"\"\"\n        Compress rows, cols, vals / summing duplicates. Sort for csc format.\n        \"\"\"\n        _, unique, indices = np.unique(\n            self.rows + self.n*self.cols,\n            return_index=True, return_inverse=True)\n        self.rows = self.rows[unique]\n        self.cols = self.cols[unique]\n        self.vals = np.bincount(indices, weights=self.vals)",
        "begin_line": 1253,
        "end_line": 1262,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.to_dense#1275",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo",
        "signature": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.to_dense(self)",
        "snippet": "    def to_dense(self):\n        \"\"\"\n        Returns a dense matrix representing self.\n        Mainly for debugging purposes.\n        \"\"\"\n        ret = np.zeros([self.n, self.m], dtype=np.float64)\n        nvals = self.vals.size\n        for i in range(nvals):\n            ret[self.rows[i], self.cols[i]] += self.vals[i]\n        return ret",
        "begin_line": 1275,
        "end_line": 1284,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.diag#1290",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo",
        "signature": "lib.matplotlib.tri.triinterpolate._Sparse_Matrix_coo.diag(self)",
        "snippet": "    def diag(self):\n        \"\"\"\n        Returns the (dense) vector of the diagonal elements.\n        \"\"\"\n        in_diag = (self.rows == self.cols)\n        diag = np.zeros(min(self.n, self.n), dtype=np.float64)  # default 0.\n        diag[self.rows[in_diag]] = self.vals[in_diag]\n        return diag",
        "begin_line": 1290,
        "end_line": 1297,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._cg#1300",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._cg(A, b, x0=None, tol=1e-10, maxiter=1000)",
        "snippet": "def _cg(A, b, x0=None, tol=1.e-10, maxiter=1000):\n    \"\"\"\n    Use Preconditioned Conjugate Gradient iteration to solve A x = b\n    A simple Jacobi (diagonal) preconditionner is used.\n\n    Parameters\n    ----------\n    A : _Sparse_Matrix_coo\n        *A* must have been compressed before by compress_csc or\n        compress_csr method.\n\n    b : array\n        Right hand side of the linear system.\n\n    Returns\n    -------\n    x : array\n        The converged solution.\n    err : float\n        The absolute error np.linalg.norm(A.dot(x) - b)\n\n    Other parameters\n    ----------------\n    x0 : array\n        Starting guess for the solution.\n    tol : float\n        Tolerance to achieve. The algorithm terminates when the relative\n        residual is below tol.\n    maxiter : int\n        Maximum number of iterations.  Iteration will stop after *maxiter*\n        steps even if the specified tolerance has not been achieved.\n    \"\"\"\n    n = b.size\n    assert A.n == n\n    assert A.m == n\n    b_norm = np.linalg.norm(b)\n\n    # Jacobi pre-conditioner\n    kvec = A.diag\n    # For diag elem < 1e-6 we keep 1e-6.\n    kvec = np.maximum(kvec, 1e-6)\n\n    # Initial guess\n    if x0 is None:\n        x = np.zeros(n)\n    else:\n        x = x0\n\n    r = b - A.dot(x)\n    w = r/kvec\n\n    p = np.zeros(n)\n    beta = 0.0\n    rho = np.dot(r, w)\n    k = 0\n\n    # Following C. T. Kelley\n    while (np.sqrt(abs(rho)) > tol*b_norm) and (k < maxiter):\n        p = w + beta*p\n        z = A.dot(p)\n        alpha = rho/np.dot(p, z)\n        r = r - alpha*z\n        w = r/kvec\n        rhoold = rho\n        rho = np.dot(r, w)\n        x = x + alpha*p\n        beta = rho/rhoold\n        #err = np.linalg.norm(A.dot(x) - b) # absolute accuracy - not used\n        k += 1\n    err = np.linalg.norm(A.dot(x) - b)\n    return x, err",
        "begin_line": 1300,
        "end_line": 1370,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._safe_inv22_vectorized#1420",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._safe_inv22_vectorized(M)",
        "snippet": "def _safe_inv22_vectorized(M):\n    \"\"\"\n    Inversion of arrays of (2, 2) matrices, returns 0 for rank-deficient\n    matrices.\n\n    *M* : array of (2, 2) matrices to inverse, shape (n, 2, 2)\n    \"\"\"\n    assert M.ndim == 3\n    assert M.shape[-2:] == (2, 2)\n    M_inv = np.empty_like(M)\n    prod1 = M[:, 0, 0]*M[:, 1, 1]\n    delta = prod1 - M[:, 0, 1]*M[:, 1, 0]\n\n    # We set delta_inv to 0. in case of a rank deficient matrix; a\n    # rank-deficient input matrix *M* will lead to a null matrix in output\n    rank2 = (np.abs(delta) > 1e-8*np.abs(prod1))\n    if np.all(rank2):\n        # Normal 'optimized' flow.\n        delta_inv = 1./delta\n    else:\n        # 'Pathologic' flow.\n        delta_inv = np.zeros(M.shape[0])\n        delta_inv[rank2] = 1./delta[rank2]\n\n    M_inv[:, 0, 0] = M[:, 1, 1]*delta_inv\n    M_inv[:, 0, 1] = -M[:, 0, 1]*delta_inv\n    M_inv[:, 1, 0] = -M[:, 1, 0]*delta_inv\n    M_inv[:, 1, 1] = M[:, 0, 0]*delta_inv\n    return M_inv",
        "begin_line": 1420,
        "end_line": 1448,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._pseudo_inv22sym_vectorized#1451",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._pseudo_inv22sym_vectorized(M)",
        "snippet": "def _pseudo_inv22sym_vectorized(M):\n    \"\"\"\n    Inversion of arrays of (2, 2) SYMMETRIC matrices; returns the\n    (Moore-Penrose) pseudo-inverse for rank-deficient matrices.\n\n    In case M is of rank 1, we have M = trace(M) x P where P is the orthogonal\n    projection on Im(M), and we return trace(M)^-1 x P == M / trace(M)**2\n    In case M is of rank 0, we return the null matrix.\n\n    *M* : array of (2, 2) matrices to inverse, shape (n, 2, 2)\n    \"\"\"\n    assert M.ndim == 3\n    assert M.shape[-2:] == (2, 2)\n    M_inv = np.empty_like(M)\n    prod1 = M[:, 0, 0]*M[:, 1, 1]\n    delta = prod1 - M[:, 0, 1]*M[:, 1, 0]\n    rank2 = (np.abs(delta) > 1e-8*np.abs(prod1))\n\n    if np.all(rank2):\n        # Normal 'optimized' flow.\n        M_inv[:, 0, 0] = M[:, 1, 1] / delta\n        M_inv[:, 0, 1] = -M[:, 0, 1] / delta\n        M_inv[:, 1, 0] = -M[:, 1, 0] / delta\n        M_inv[:, 1, 1] = M[:, 0, 0] / delta\n    else:\n        # 'Pathologic' flow.\n        # Here we have to deal with 2 sub-cases\n        # 1) First sub-case: matrices of rank 2:\n        delta = delta[rank2]\n        M_inv[rank2, 0, 0] = M[rank2, 1, 1] / delta\n        M_inv[rank2, 0, 1] = -M[rank2, 0, 1] / delta\n        M_inv[rank2, 1, 0] = -M[rank2, 1, 0] / delta\n        M_inv[rank2, 1, 1] = M[rank2, 0, 0] / delta\n        # 2) Second sub-case: rank-deficient matrices of rank 0 and 1:\n        rank01 = ~rank2\n        tr = M[rank01, 0, 0] + M[rank01, 1, 1]\n        tr_zeros = (np.abs(tr) < 1.e-8)\n        sq_tr_inv = (1.-tr_zeros) / (tr**2+tr_zeros)\n        #sq_tr_inv = 1. / tr**2\n        M_inv[rank01, 0, 0] = M[rank01, 0, 0] * sq_tr_inv\n        M_inv[rank01, 0, 1] = M[rank01, 0, 1] * sq_tr_inv\n        M_inv[rank01, 1, 0] = M[rank01, 1, 0] * sq_tr_inv\n        M_inv[rank01, 1, 1] = M[rank01, 1, 1] * sq_tr_inv\n\n    return M_inv",
        "begin_line": 1451,
        "end_line": 1495,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._prod_vectorized#1498",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._prod_vectorized(M1, M2)",
        "snippet": "def _prod_vectorized(M1, M2):\n    \"\"\"\n    Matrix product between arrays of matrices, or a matrix and an array of\n    matrices (*M1* and *M2*)\n    \"\"\"\n    sh1 = M1.shape\n    sh2 = M2.shape\n    assert len(sh1) >= 2\n    assert len(sh2) >= 2\n    assert sh1[-1] == sh2[-2]\n\n    ndim1 = len(sh1)\n    t1_index = [*range(ndim1-2), ndim1-1, ndim1-2]\n    return np.sum(np.transpose(M1, t1_index)[..., np.newaxis] *\n                  M2[..., np.newaxis, :], -3)",
        "begin_line": 1498,
        "end_line": 1512,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._scalar_vectorized#1515",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._scalar_vectorized(scalar, M)",
        "snippet": "def _scalar_vectorized(scalar, M):\n    \"\"\"\n    Scalar product between scalars and matrices.\n    \"\"\"\n    return scalar[:, np.newaxis, np.newaxis]*M",
        "begin_line": 1515,
        "end_line": 1519,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._transpose_vectorized#1522",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._transpose_vectorized(M)",
        "snippet": "def _transpose_vectorized(M):\n    \"\"\"\n    Transposition of an array of matrices *M*.\n    \"\"\"\n    return np.transpose(M, [0, 2, 1])",
        "begin_line": 1522,
        "end_line": 1526,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._roll_vectorized#1529",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._roll_vectorized(M, roll_indices, axis)",
        "snippet": "def _roll_vectorized(M, roll_indices, axis):\n    \"\"\"\n    Rolls an array of matrices along an axis according to an array of indices\n    *roll_indices*\n    *axis* can be either 0 (rolls rows) or 1 (rolls columns).\n    \"\"\"\n    assert axis in [0, 1]\n    ndim = M.ndim\n    assert ndim == 3\n    ndim_roll = roll_indices.ndim\n    assert ndim_roll == 1\n    sh = M.shape\n    r, c = sh[-2:]\n    assert sh[0] == roll_indices.shape[0]\n    vec_indices = np.arange(sh[0], dtype=np.int32)\n\n    # Builds the rolled matrix\n    M_roll = np.empty_like(M)\n    if axis == 0:\n        for ir in range(r):\n            for ic in range(c):\n                M_roll[:, ir, ic] = M[vec_indices, (-roll_indices+ir) % r, ic]\n    elif axis == 1:\n        for ir in range(r):\n            for ic in range(c):\n                M_roll[:, ir, ic] = M[vec_indices, ir, (-roll_indices+ic) % c]\n    return M_roll",
        "begin_line": 1529,
        "end_line": 1555,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._to_matrix_vectorized#1558",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._to_matrix_vectorized(M)",
        "snippet": "def _to_matrix_vectorized(M):\n    \"\"\"\n    Builds an array of matrices from individuals np.arrays of identical\n    shapes.\n    *M*: ncols-list of nrows-lists of shape sh.\n\n    Returns M_res np.array of shape (sh, nrow, ncols) so that:\n        M_res[..., i, j] = M[i][j]\n    \"\"\"\n    assert isinstance(M, (tuple, list))\n    assert all(isinstance(item, (tuple, list)) for item in M)\n    c_vec = np.asarray([len(item) for item in M])\n    assert np.all(c_vec-c_vec[0] == 0)\n    r = len(M)\n    c = c_vec[0]\n    M00 = np.asarray(M[0][0])\n    dt = M00.dtype\n    sh = [M00.shape[0], r, c]\n    M_ret = np.empty(sh, dtype=dt)\n    for irow in range(r):\n        for icol in range(c):\n            M_ret[:, irow, icol] = np.asarray(M[irow][icol])\n    return M_ret",
        "begin_line": 1558,
        "end_line": 1580,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tri.triinterpolate._extract_submatrices#1583",
        "src_path": "lib/matplotlib/tri/triinterpolate.py",
        "class_name": "lib.matplotlib.tri.triinterpolate",
        "signature": "lib.matplotlib.tri.triinterpolate._extract_submatrices(M, block_indices, block_size, axis)",
        "snippet": "def _extract_submatrices(M, block_indices, block_size, axis):\n    \"\"\"\n    Extracts selected blocks of a matrices *M* depending on parameters\n    *block_indices* and *block_size*.\n\n    Returns the array of extracted matrices *Mres* so that ::\n\n        M_res[..., ir, :] = M[(block_indices*block_size+ir), :]\n    \"\"\"\n    assert block_indices.ndim == 1\n    assert axis in [0, 1]\n\n    r, c = M.shape\n    if axis == 0:\n        sh = [block_indices.shape[0], block_size, c]\n    elif axis == 1:\n        sh = [block_indices.shape[0], r, block_size]\n\n    dt = M.dtype\n    M_res = np.empty(sh, dtype=dt)\n    if axis == 0:\n        for ir in range(block_size):\n            M_res[:, ir, :] = M[(block_indices*block_size+ir), :]\n    elif axis == 1:\n        for ic in range(block_size):\n            M_res[:, :, ic] = M[:, (block_indices*block_size+ic)]\n\n    return M_res",
        "begin_line": 1583,
        "end_line": 1610,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._subplots.SubplotBase.__init__#18",
        "src_path": "lib/matplotlib/axes/_subplots.py",
        "class_name": "lib.matplotlib.axes._subplots.SubplotBase",
        "signature": "lib.matplotlib.axes._subplots.SubplotBase.__init__(self, fig, *args, **kwargs)",
        "snippet": "    def __init__(self, fig, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        fig : `matplotlib.figure.Figure`\n\n        *args : tuple (*nrows*, *ncols*, *index*) or int\n            The array of subplots in the figure has dimensions ``(nrows,\n            ncols)``, and *index* is the index of the subplot being created.\n            *index* starts at 1 in the upper left corner and increases to the\n            right.\n\n            If *nrows*, *ncols*, and *index* are all single digit numbers, then\n            *args* can be passed as a single 3-digit number (e.g. 234 for\n            (2, 3, 4)).\n        \"\"\"\n\n        self.figure = fig\n        self._subplotspec = SubplotSpec._from_subplot_args(fig, args)\n        self.update_params()\n        # _axes_class is set in the subplot_class_factory\n        self._axes_class.__init__(self, fig, self.figbox, **kwargs)\n        # add a layout box to this, for both the full axis, and the poss\n        # of the axis.  We need both because the axes may become smaller\n        # due to parasitic axes and hence no longer fill the subplotspec.\n        if self._subplotspec._layoutbox is None:\n            self._layoutbox = None\n            self._poslayoutbox = None\n        else:\n            name = self._subplotspec._layoutbox.name + '.ax'\n            name = name + layoutbox.seq_id()\n            self._layoutbox = layoutbox.LayoutBox(\n                    parent=self._subplotspec._layoutbox,\n                    name=name,\n                    artist=self)\n            self._poslayoutbox = layoutbox.LayoutBox(\n                    parent=self._layoutbox,\n                    name=self._layoutbox.name+'.pos',\n                    pos=True, subplot=True, artist=self)",
        "begin_line": 18,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036900369003690036,
            "pseudo_dstar_susp": 0.005405405405405406,
            "pseudo_tarantula_susp": 0.0005797101449275362,
            "pseudo_op2_susp": 0.005405405405405406,
            "pseudo_barinel_susp": 0.0005797101449275362
        }
    },
    {
        "name": "lib.matplotlib.axes._subplots.SubplotBase.update_params#92",
        "src_path": "lib/matplotlib/axes/_subplots.py",
        "class_name": "lib.matplotlib.axes._subplots.SubplotBase",
        "signature": "lib.matplotlib.axes._subplots.SubplotBase.update_params(self)",
        "snippet": "    def update_params(self):\n        \"\"\"update the subplot position from fig.subplotpars\"\"\"\n        self.figbox, _, _, self.numRows, self.numCols = \\\n            self.get_subplotspec().get_position(self.figure,\n                                                return_all=True)",
        "begin_line": 92,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.029411764705882353,
            "pseudo_dstar_susp": 0.03125,
            "pseudo_tarantula_susp": 0.0006090133982947625,
            "pseudo_op2_susp": 0.02631578947368421,
            "pseudo_barinel_susp": 0.0006090133982947625
        }
    },
    {
        "name": "lib.matplotlib.axes._subplots.SubplotBase.is_last_row#111",
        "src_path": "lib/matplotlib/axes/_subplots.py",
        "class_name": "lib.matplotlib.axes._subplots.SubplotBase",
        "signature": "lib.matplotlib.axes._subplots.SubplotBase.is_last_row(self)",
        "snippet": "    def is_last_row(self):\n        return self.get_subplotspec().rowspan.stop == self.get_gridspec().nrows",
        "begin_line": 111,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.19793966151582e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._subplots.SubplotBase.label_outer#120",
        "src_path": "lib/matplotlib/axes/_subplots.py",
        "class_name": "lib.matplotlib.axes._subplots.SubplotBase",
        "signature": "lib.matplotlib.axes._subplots.SubplotBase.label_outer(self)",
        "snippet": "    def label_outer(self):\n        \"\"\"\n        Only show \"outer\" labels and tick labels.\n\n        x-labels are only kept for subplots on the last row; y-labels only for\n        subplots on the first column.\n        \"\"\"\n        lastrow = self.is_last_row()\n        firstcol = self.is_first_col()\n        if not lastrow:\n            for label in self.get_xticklabels(which=\"both\"):\n                label.set_visible(False)\n            self.get_xaxis().get_offset_text().set_visible(False)\n            self.set_xlabel(\"\")\n        if not firstcol:\n            for label in self.get_yticklabels(which=\"both\"):\n                label.set_visible(False)\n            self.get_yaxis().get_offset_text().set_visible(False)\n            self.set_ylabel(\"\")",
        "begin_line": 120,
        "end_line": 138,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.999000099990002e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axes._subplots.SubplotBase._make_twin_axes#140",
        "src_path": "lib/matplotlib/axes/_subplots.py",
        "class_name": "lib.matplotlib.axes._subplots.SubplotBase",
        "signature": "lib.matplotlib.axes._subplots.SubplotBase._make_twin_axes(self, *args, **kwargs)",
        "snippet": "    def _make_twin_axes(self, *args, **kwargs):\n        \"\"\"Make a twinx axes of self. This is used for twinx and twiny.\"\"\"\n        if 'sharex' in kwargs and 'sharey' in kwargs:\n            # The following line is added in v2.2 to avoid breaking Seaborn,\n            # which currently uses this internal API.\n            if kwargs[\"sharex\"] is not self and kwargs[\"sharey\"] is not self:\n                raise ValueError(\"Twinned Axes may share only one axis\")\n        # The dance here with label is to force add_subplot() to create a new\n        # Axes (by passing in a label never seen before).  Note that this does\n        # not affect plot reactivation by subplot() as twin axes can never be\n        # reactivated by subplot().\n        sentinel = str(uuid.uuid4())\n        real_label = kwargs.pop(\"label\", sentinel)\n        twin = self.figure.add_subplot(\n            self.get_subplotspec(), *args, label=sentinel, **kwargs)\n        if real_label is not sentinel:\n            twin.set_label(real_label)\n        self.set_adjustable('datalim')\n        twin.set_adjustable('datalim')\n        if self._layoutbox is not None and twin._layoutbox is not None:\n            # make the layout boxes be explicitly the same\n            twin._layoutbox.constrain_same(self._layoutbox)\n            twin._poslayoutbox.constrain_same(self._poslayoutbox)\n        self._twinned_axes.join(self, twin)\n        return twin",
        "begin_line": 140,
        "end_line": 164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009708737864077669,
            "pseudo_dstar_susp": 0.0006285355122564425,
            "pseudo_tarantula_susp": 0.004629629629629629,
            "pseudo_op2_susp": 0.0006285355122564425,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "lib.matplotlib.axes._subplots.subplot_class_factory#180",
        "src_path": "lib/matplotlib/axes/_subplots.py",
        "class_name": "lib.matplotlib.axes._subplots",
        "signature": "lib.matplotlib.axes._subplots.subplot_class_factory(axes_class=None)",
        "snippet": "def subplot_class_factory(axes_class=None):\n    \"\"\"\n    This makes a new class that inherits from `.SubplotBase` and the\n    given axes_class (which is assumed to be a subclass of `.axes.Axes`).\n    This is perhaps a little bit roundabout to make a new class on\n    the fly like this, but it means that a new Subplot class does\n    not have to be created for every type of Axes.\n    \"\"\"\n    if axes_class is None:\n        cbook.warn_deprecated(\n            \"3.3\", message=\"Support for passing None to subplot_class_factory \"\n            \"is deprecated; explicitly pass the default Axes class instead.\")\n        axes_class = Axes\n    try:\n        # Avoid creating two different instances of GeoAxesSubplot...\n        # Only a temporary backcompat fix.  This should be removed in\n        # 3.4\n        return next(cls for cls in SubplotBase.__subclasses__()\n                    if cls.__bases__ == (SubplotBase, axes_class))\n    except StopIteration:\n        return type(\"%sSubplot\" % axes_class.__name__,\n                    (SubplotBase, axes_class),\n                    {'_axes_class': axes_class})",
        "begin_line": 180,
        "end_line": 202,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.texmanager.TexManager._reinit#105",
        "src_path": "lib/matplotlib/texmanager.py",
        "class_name": "lib.matplotlib.texmanager.TexManager",
        "signature": "lib.matplotlib.texmanager.TexManager._reinit(self)",
        "snippet": "    def _reinit(self):\n        Path(self.texcache).mkdir(parents=True, exist_ok=True)\n        ff = rcParams['font.family']\n        if len(ff) == 1 and ff[0].lower() in self.font_families:\n            self.font_family = ff[0].lower()\n        else:\n            _log.info('font.family must be one of (%s) when text.usetex is '\n                      'True. serif will be used by default.',\n                      ', '.join(self.font_families))\n            self.font_family = 'serif'\n\n        fontconfig = [self.font_family]\n        for font_family in self.font_families:\n            font_family_attr = font_family.replace('-', '_')\n            for font in rcParams['font.' + font_family]:\n                if font.lower() in self.font_info:\n                    setattr(self, font_family_attr,\n                            self.font_info[font.lower()])\n                    _log.debug('family: %s, font: %s, info: %s',\n                               font_family, font, self.font_info[font.lower()])\n                    break\n                else:\n                    _log.debug('%s font is not compatible with usetex.',\n                               font_family)\n            else:\n                _log.info('No LaTeX-compatible font found for the %s font '\n                          'family in rcParams. Using default.', font_family)\n                setattr(self, font_family_attr, self.font_info[font_family])\n            fontconfig.append(getattr(self, font_family_attr)[0])\n        # Add a hash of the latex preamble to self._fontconfig so that the\n        # correct png is selected for strings rendered with same font and dpi\n        # even if the latex preamble changes within the session\n        preamble_bytes = self.get_custom_preamble().encode('utf-8')\n        fontconfig.append(hashlib.md5(preamble_bytes).hexdigest())\n        self._fontconfig = ''.join(fontconfig)\n\n        # The following packages and commands need to be included in the latex\n        # file's preamble:\n        cmd = [self.serif[1], self.sans_serif[1], self.monospace[1]]\n        if self.font_family == 'cursive':\n            cmd.append(self.cursive[1])\n        self._font_preamble = '\\n'.join(\n            [r'\\usepackage{type1cm}'] + cmd + [r'\\usepackage{textcomp}'])",
        "begin_line": 105,
        "end_line": 147,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.texmanager.TexManager.get_font_config#158",
        "src_path": "lib/matplotlib/texmanager.py",
        "class_name": "lib.matplotlib.texmanager.TexManager",
        "signature": "lib.matplotlib.texmanager.TexManager.get_font_config(self)",
        "snippet": "    def get_font_config(self):\n        \"\"\"Reinitializes self if relevant rcParams on have changed.\"\"\"\n        if self._rc_cache is None:\n            self._rc_cache = dict.fromkeys(self._rc_cache_keys)\n        changed = [par for par in self._rc_cache_keys\n                   if rcParams[par] != self._rc_cache[par]]\n        if changed:\n            _log.debug('following keys changed: %s', changed)\n            for k in changed:\n                _log.debug('%-20s: %-10s -> %-10s',\n                           k, self._rc_cache[k], rcParams[k])\n                # deepcopy may not be necessary, but feels more future-proof\n                self._rc_cache[k] = copy.deepcopy(rcParams[k])\n            _log.debug('RE-INIT\\nold fontconfig: %s', self._fontconfig)\n            self._reinit()\n        _log.debug('fontconfig: %s', self._fontconfig)\n        return self._fontconfig",
        "begin_line": 158,
        "end_line": 174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.tight_bbox.adjust_bbox#8",
        "src_path": "lib/matplotlib/tight_bbox.py",
        "class_name": "lib.matplotlib.tight_bbox",
        "signature": "lib.matplotlib.tight_bbox.adjust_bbox(fig, bbox_inches, fixed_dpi=None)",
        "snippet": "def adjust_bbox(fig, bbox_inches, fixed_dpi=None):\n    \"\"\"\n    Temporarily adjust the figure so that only the specified area\n    (bbox_inches) is saved.\n\n    It modifies fig.bbox, fig.bbox_inches,\n    fig.transFigure._boxout, and fig.patch.  While the figure size\n    changes, the scale of the original figure is conserved.  A\n    function which restores the original values are returned.\n    \"\"\"\n\n    origBbox = fig.bbox\n    origBboxInches = fig.bbox_inches\n    orig_tight_layout = fig.get_tight_layout()\n    _boxout = fig.transFigure._boxout\n\n    fig.set_tight_layout(False)\n\n    asp_list = []\n    locator_list = []\n    for ax in fig.axes:\n        pos = ax.get_position(original=False).frozen()\n        locator_list.append(ax.get_axes_locator())\n        asp_list.append(ax.get_aspect())\n\n        def _l(a, r, pos=pos):\n            return pos\n        ax.set_axes_locator(_l)\n        ax.set_aspect(\"auto\")\n\n    def restore_bbox():\n        for ax, asp, loc in zip(fig.axes, asp_list, locator_list):\n            ax.set_aspect(asp)\n            ax.set_axes_locator(loc)\n\n        fig.bbox = origBbox\n        fig.bbox_inches = origBboxInches\n        fig.set_tight_layout(orig_tight_layout)\n        fig.transFigure._boxout = _boxout\n        fig.transFigure.invalidate()\n        fig.patch.set_bounds(0, 0, 1, 1)\n\n    if fixed_dpi is not None:\n        tr = Affine2D().scale(fixed_dpi)\n        dpi_scale = fixed_dpi / fig.dpi\n    else:\n        tr = Affine2D().scale(fig.dpi)\n        dpi_scale = 1.\n\n    _bbox = TransformedBbox(bbox_inches, tr)\n\n    fig.bbox_inches = Bbox.from_bounds(0, 0,\n                                       bbox_inches.width, bbox_inches.height)\n    x0, y0 = _bbox.x0, _bbox.y0\n    w1, h1 = fig.bbox.width * dpi_scale, fig.bbox.height * dpi_scale\n    fig.transFigure._boxout = Bbox.from_bounds(-x0, -y0, w1, h1)\n    fig.transFigure.invalidate()\n\n    fig.bbox = TransformedBbox(fig.bbox_inches, tr)\n\n    fig.patch.set_bounds(x0 / w1, y0 / h1,\n                         fig.bbox.width / w1, fig.bbox.height / h1)\n\n    return restore_bbox",
        "begin_line": 8,
        "end_line": 71,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick.__init__#56",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick.__init__(self, axes, loc, label=None, size=None, width=None, color=None, tickdir=None, pad=None, labelsize=None, labelcolor=None, zorder=None, gridOn=None, tick1On=True, tick2On=True, label1On=True, label2On=False, major=True, labelrotation=0, grid_color=None, grid_linestyle=None, grid_linewidth=None, grid_alpha=None, **kw)",
        "snippet": "    def __init__(self, axes, loc, label=None,\n                 size=None,  # points\n                 width=None,\n                 color=None,\n                 tickdir=None,\n                 pad=None,\n                 labelsize=None,\n                 labelcolor=None,\n                 zorder=None,\n                 gridOn=None,  # defaults to axes.grid depending on\n                               # axes.grid.which\n                 tick1On=True,\n                 tick2On=True,\n                 label1On=True,\n                 label2On=False,\n                 major=True,\n                 labelrotation=0,\n                 grid_color=None,\n                 grid_linestyle=None,\n                 grid_linewidth=None,\n                 grid_alpha=None,\n                 **kw  # Other Line2D kwargs applied to gridlines.\n                 ):\n        \"\"\"\n        bbox is the Bound2D bounding box in display coords of the Axes\n        loc is the tick location in data coords\n        size is the tick size in points\n        \"\"\"\n        martist.Artist.__init__(self)\n\n        if gridOn is None:\n            if major and (mpl.rcParams['axes.grid.which']\n                          in ('both', 'major')):\n                gridOn = mpl.rcParams['axes.grid']\n            elif (not major) and (mpl.rcParams['axes.grid.which']\n                                  in ('both', 'minor')):\n                gridOn = mpl.rcParams['axes.grid']\n            else:\n                gridOn = False\n\n        self.set_figure(axes.figure)\n        self.axes = axes\n\n        name = self.__name__.lower()\n\n        self._loc = loc\n\n        major_minor = \"major\" if major else \"minor\"\n\n        if size is None:\n            size = mpl.rcParams[f\"{name}.{major_minor}.size\"]\n        self._size = size\n\n        if width is None:\n            width = mpl.rcParams[f\"{name}.{major_minor}.width\"]\n        self._width = width\n\n        if color is None:\n            color = mpl.rcParams[f\"{name}.color\"]\n\n        if pad is None:\n            pad = mpl.rcParams[f\"{name}.{major_minor}.pad\"]\n        self._base_pad = pad\n\n        if labelcolor is None:\n            labelcolor = mpl.rcParams[f\"{name}.color\"]\n\n        if labelsize is None:\n            labelsize = mpl.rcParams[f\"{name}.labelsize\"]\n\n        self._set_labelrotation(labelrotation)\n\n        if zorder is None:\n            if major:\n                zorder = mlines.Line2D.zorder + 0.01\n            else:\n                zorder = mlines.Line2D.zorder\n        self._zorder = zorder\n\n        if grid_color is None:\n            grid_color = mpl.rcParams[\"grid.color\"]\n        if grid_linestyle is None:\n            grid_linestyle = mpl.rcParams[\"grid.linestyle\"]\n        if grid_linewidth is None:\n            grid_linewidth = mpl.rcParams[\"grid.linewidth\"]\n        if grid_alpha is None:\n            grid_alpha = mpl.rcParams[\"grid.alpha\"]\n        grid_kw = {k[5:]: v for k, v in kw.items()}\n\n        self.apply_tickdir(tickdir)\n\n        self.tick1line = mlines.Line2D(\n            [], [],\n            color=color, linestyle=\"none\", zorder=zorder, visible=tick1On,\n            markersize=size, markeredgewidth=width,\n        )\n        self.tick2line = mlines.Line2D(\n            [], [],\n            color=color, linestyle=\"none\", zorder=zorder, visible=tick2On,\n            markersize=size, markeredgewidth=width,\n        )\n        self.gridline = mlines.Line2D(\n            [], [],\n            color=grid_color, alpha=grid_alpha, visible=gridOn,\n            linestyle=grid_linestyle, linewidth=grid_linewidth, marker=\"\",\n            **grid_kw,\n        )\n        self.gridline.get_path()._interpolation_steps = \\\n            GRIDLINE_INTERPOLATION_STEPS\n        self.label1 = mtext.Text(\n            np.nan, np.nan,\n            fontsize=labelsize, color=labelcolor, visible=label1On)\n        self.label2 = mtext.Text(\n            np.nan, np.nan,\n            fontsize=labelsize, color=labelcolor, visible=label2On)\n        for meth, attr in [(\"_get_tick1line\", \"tick1line\"),\n                           (\"_get_tick2line\", \"tick2line\"),\n                           (\"_get_gridline\", \"gridline\"),\n                           (\"_get_text1\", \"label1\"),\n                           (\"_get_text2\", \"label2\")]:\n            if getattr(self, meth) != getattr(Tick, meth).__get__(self):\n                cbook.warn_deprecated(\n                    \"3.3\", message=f\"Relying on {meth} to initialize \"\n                    f\"Tick.{attr} is deprecated since %(since)s and will not \"\n                    f\"work %(removal)s; please directly set the attribute in \"\n                    \"the subclass' __init__ instead.\")\n                setattr(self, attr, getattr(self, meth)())\n        for artist in [self.tick1line, self.tick2line, self.gridline,\n                       self.label1, self.label2]:\n            self._set_artist_props(artist)\n\n        self.update_position(loc)",
        "begin_line": 56,
        "end_line": 187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024875621890547263,
            "pseudo_dstar_susp": 0.003937007874015748,
            "pseudo_tarantula_susp": 0.000591016548463357,
            "pseudo_op2_susp": 0.003215434083601286,
            "pseudo_barinel_susp": 0.000591016548463357
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick.get_tick_padding#233",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick.get_tick_padding(self)",
        "snippet": "    def get_tick_padding(self):\n        \"\"\"Get the length of the tick outside of the axes.\"\"\"\n        padding = {\n            'in': 0.0,\n            'inout': 0.5,\n            'out': 1.0\n        }\n        return self._size * padding[self._tickdir]",
        "begin_line": 233,
        "end_line": 240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007727975270479134,
            "pseudo_dstar_susp": 0.0008244023083264633,
            "pseudo_tarantula_susp": 0.0004344048653344917,
            "pseudo_op2_susp": 0.0008244023083264633,
            "pseudo_barinel_susp": 0.0004344048653344917
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick.set_clip_path#247",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick.set_clip_path(self, clippath, transform=None)",
        "snippet": "    def set_clip_path(self, clippath, transform=None):\n        # docstring inherited\n        martist.Artist.set_clip_path(self, clippath, transform)\n        self.gridline.set_clip_path(clippath, transform)\n        self.stale = True",
        "begin_line": 247,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.53465943339361e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick.draw#303",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick.draw(self, renderer)",
        "snippet": "    def draw(self, renderer):\n        if not self.get_visible():\n            self.stale = False\n            return\n        renderer.open_group(self.__name__, gid=self.get_gid())\n        for artist in [self.gridline, self.tick1line, self.tick2line,\n                       self.label1, self.label2]:\n            artist.draw(renderer)\n        renderer.close_group(self.__name__)\n        self.stale = False",
        "begin_line": 303,
        "end_line": 312,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.19793966151582e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Tick._apply_params#347",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Tick",
        "signature": "lib.matplotlib.axis.Tick._apply_params(self, **kw)",
        "snippet": "    def _apply_params(self, **kw):\n        for name, target in [(\"gridOn\", self.gridline),\n                             (\"tick1On\", self.tick1line),\n                             (\"tick2On\", self.tick2line),\n                             (\"label1On\", self.label1),\n                             (\"label2On\", self.label2)]:\n            if name in kw:\n                target.set_visible(kw.pop(name))\n        if any(k in kw for k in ['size', 'width', 'pad', 'tickdir']):\n            self._size = kw.pop('size', self._size)\n            # Width could be handled outside this block, but it is\n            # convenient to leave it here.\n            self._width = kw.pop('width', self._width)\n            self._base_pad = kw.pop('pad', self._base_pad)\n            # apply_tickdir uses _size and _base_pad to make _pad,\n            # and also makes _tickmarkers.\n            self.apply_tickdir(kw.pop('tickdir', self._tickdir))\n            self.tick1line.set_marker(self._tickmarkers[0])\n            self.tick2line.set_marker(self._tickmarkers[1])\n            for line in (self.tick1line, self.tick2line):\n                line.set_markersize(self._size)\n                line.set_markeredgewidth(self._width)\n            # _get_text1_transform uses _pad from apply_tickdir.\n            trans = self._get_text1_transform()[0]\n            self.label1.set_transform(trans)\n            trans = self._get_text2_transform()[0]\n            self.label2.set_transform(trans)\n        tick_kw = {k: v for k, v in kw.items() if k in ['color', 'zorder']}\n        self.tick1line.set(**tick_kw)\n        self.tick2line.set(**tick_kw)\n        for k, v in tick_kw.items():\n            setattr(self, '_' + k, v)\n\n        if 'labelrotation' in kw:\n            self._set_labelrotation(kw.pop('labelrotation'))\n            self.label1.set(rotation=self._labelrotation[1])\n            self.label2.set(rotation=self._labelrotation[1])\n\n        label_kw = {k[5:]: v for k, v in kw.items()\n                    if k in ['labelsize', 'labelcolor']}\n        self.label1.set(**label_kw)\n        self.label2.set(**label_kw)\n        for k, v in label_kw.items():\n            # for labelsize the text objects covert str ('small')\n            # -> points. grab the integer from the `Text` object\n            # instead of saving the string representation\n            v = getattr(self.label1, 'get_' + k)()\n            setattr(self, '_label' + k, v)\n\n        grid_kw = {k[5:]: v for k, v in kw.items()\n                   if k in _gridline_param_names}\n        self.gridline.set(**grid_kw)\n        for k, v in grid_kw.items():\n            setattr(self, '_grid_' + k, v)",
        "begin_line": 347,
        "end_line": 400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0027100271002710027,
            "pseudo_dstar_susp": 0.0011312217194570137,
            "pseudo_tarantula_susp": 0.0017064846416382253,
            "pseudo_op2_susp": 0.0011312217194570137,
            "pseudo_barinel_susp": 0.0017064846416382253
        }
    },
    {
        "name": "lib.matplotlib.axis.XTick.__init__#420",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XTick",
        "signature": "lib.matplotlib.axis.XTick.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # x in data coords, y in axes coords\n        self.tick1line.set(\n            xdata=[0], ydata=[0],\n            transform=self.axes.get_xaxis_transform(which=\"tick1\"),\n            marker=self._tickmarkers[0],\n        )\n        self.tick2line.set(\n            xdata=[0], ydata=[1],\n            transform=self.axes.get_xaxis_transform(which=\"tick2\"),\n            marker=self._tickmarkers[1],\n        )\n        self.gridline.set(\n            xdata=[0, 0], ydata=[0, 1],\n            transform=self.axes.get_xaxis_transform(which=\"grid\"),\n        )\n        # the y loc is 3 points below the min of y axis\n        trans, va, ha = self._get_text1_transform()\n        self.label1.set(\n            x=0, y=0,\n            verticalalignment=va, horizontalalignment=ha, transform=trans,\n        )\n        trans, va, ha = self._get_text2_transform()\n        self.label2.set(\n            x=0, y=1,\n            verticalalignment=va, horizontalalignment=ha, transform=trans,\n        )",
        "begin_line": 420,
        "end_line": 447,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024509803921568627,
            "pseudo_dstar_susp": 0.0010976948408342481,
            "pseudo_tarantula_susp": 0.0008305647840531562,
            "pseudo_op2_susp": 0.0010976948408342481,
            "pseudo_barinel_susp": 0.0008305647840531562
        }
    },
    {
        "name": "lib.matplotlib.axis.XTick._get_text1_transform#449",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XTick",
        "signature": "lib.matplotlib.axis.XTick._get_text1_transform(self)",
        "snippet": "    def _get_text1_transform(self):\n        return self.axes.get_xaxis_text1_transform(self._pad)",
        "begin_line": 449,
        "end_line": 450,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001392757660167131,
            "pseudo_dstar_susp": 0.0009199632014719411,
            "pseudo_tarantula_susp": 0.0006086427267194157,
            "pseudo_op2_susp": 0.0009199632014719411,
            "pseudo_barinel_susp": 0.0006086427267194157
        }
    },
    {
        "name": "lib.matplotlib.axis.XTick._get_text2_transform#452",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XTick",
        "signature": "lib.matplotlib.axis.XTick._get_text2_transform(self)",
        "snippet": "    def _get_text2_transform(self):\n        return self.axes.get_xaxis_text2_transform(self._pad)",
        "begin_line": 452,
        "end_line": 453,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0027100271002710027,
            "pseudo_dstar_susp": 0.0011312217194570137,
            "pseudo_tarantula_susp": 0.001037344398340249,
            "pseudo_op2_susp": 0.0011312217194570137,
            "pseudo_barinel_susp": 0.001037344398340249
        }
    },
    {
        "name": "lib.matplotlib.axis.XTick.apply_tickdir#455",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XTick",
        "signature": "lib.matplotlib.axis.XTick.apply_tickdir(self, tickdir)",
        "snippet": "    def apply_tickdir(self, tickdir):\n        if tickdir is None:\n            tickdir = mpl.rcParams['%s.direction' % self.__name__.lower()]\n        self._tickdir = tickdir\n\n        if self._tickdir == 'in':\n            self._tickmarkers = (mlines.TICKUP, mlines.TICKDOWN)\n        elif self._tickdir == 'inout':\n            self._tickmarkers = ('|', '|')\n        else:\n            self._tickmarkers = (mlines.TICKDOWN, mlines.TICKUP)\n        self._pad = self._base_pad + self.get_tick_padding()\n        self.stale = True",
        "begin_line": 455,
        "end_line": 467,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015290519877675841,
            "pseudo_dstar_susp": 0.0009560229445506692,
            "pseudo_tarantula_susp": 0.0006459948320413437,
            "pseudo_op2_susp": 0.0009560229445506692,
            "pseudo_barinel_susp": 0.0006459948320413437
        }
    },
    {
        "name": "lib.matplotlib.axis.XTick.update_position#469",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XTick",
        "signature": "lib.matplotlib.axis.XTick.update_position(self, loc)",
        "snippet": "    def update_position(self, loc):\n        \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n        self.tick1line.set_xdata((loc,))\n        self.tick2line.set_xdata((loc,))\n        self.gridline.set_xdata((loc,))\n        self.label1.set_x(loc)\n        self.label2.set_x(loc)\n        self._loc = loc\n        self.stale = True",
        "begin_line": 469,
        "end_line": 477,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015527950310559005,
            "pseudo_dstar_susp": 0.0026954177897574125,
            "pseudo_tarantula_susp": 0.0006211180124223603,
            "pseudo_op2_susp": 0.0026954177897574125,
            "pseudo_barinel_susp": 0.0006211180124223603
        }
    },
    {
        "name": "lib.matplotlib.axis.YTick._get_text2_transform#523",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YTick",
        "signature": "lib.matplotlib.axis.YTick._get_text2_transform(self)",
        "snippet": "    def _get_text2_transform(self):\n        return self.axes.get_yaxis_text2_transform(self._pad)",
        "begin_line": 523,
        "end_line": 524,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014684287812041115,
            "pseudo_dstar_susp": 0.0009380863039399625,
            "pseudo_tarantula_susp": 0.0006242197253433209,
            "pseudo_op2_susp": 0.0009380863039399625,
            "pseudo_barinel_susp": 0.0006242197253433209
        }
    },
    {
        "name": "lib.matplotlib.axis.YTick.apply_tickdir#526",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YTick",
        "signature": "lib.matplotlib.axis.YTick.apply_tickdir(self, tickdir)",
        "snippet": "    def apply_tickdir(self, tickdir):\n        if tickdir is None:\n            tickdir = mpl.rcParams['%s.direction' % self.__name__.lower()]\n        self._tickdir = tickdir\n\n        if self._tickdir == 'in':\n            self._tickmarkers = (mlines.TICKRIGHT, mlines.TICKLEFT)\n        elif self._tickdir == 'inout':\n            self._tickmarkers = ('_', '_')\n        else:\n            self._tickmarkers = (mlines.TICKLEFT, mlines.TICKRIGHT)\n        self._pad = self._base_pad + self.get_tick_padding()\n        self.stale = True",
        "begin_line": 526,
        "end_line": 538,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.490075649764063e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.YTick.update_position#540",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YTick",
        "signature": "lib.matplotlib.axis.YTick.update_position(self, loc)",
        "snippet": "    def update_position(self, loc):\n        \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n        self.tick1line.set_ydata((loc,))\n        self.tick2line.set_ydata((loc,))\n        self.gridline.set_ydata((loc,))\n        self.label1.set_y(loc)\n        self.label2.set_y(loc)\n        self._loc = loc\n        self.stale = True",
        "begin_line": 540,
        "end_line": 548,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002824858757062147,
            "pseudo_dstar_susp": 0.0011441647597254005,
            "pseudo_tarantula_susp": 0.0009000900090009,
            "pseudo_op2_susp": 0.0011441647597254005,
            "pseudo_barinel_susp": 0.0009000900090009
        }
    },
    {
        "name": "lib.matplotlib.axis.Ticker.__init__#567",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Ticker",
        "signature": "lib.matplotlib.axis.Ticker.__init__(self)",
        "snippet": "    def __init__(self):\n        self._locator = None\n        self._formatter = None",
        "begin_line": 567,
        "end_line": 569,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis._LazyTickList.__get__#609",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis._LazyTickList",
        "signature": "lib.matplotlib.axis._LazyTickList.__get__(self, instance, cls)",
        "snippet": "    def __get__(self, instance, cls):\n        if instance is None:\n            return self\n        else:\n            # instance._get_tick() can itself try to access the majorTicks\n            # attribute (e.g. in certain projection classes which override\n            # e.g. get_xaxis_text1_transform).  In order to avoid infinite\n            # recursion, first set the majorTicks on the instance to an empty\n            # list, then create the tick and append it.\n            if self._major:\n                instance.majorTicks = []\n                tick = instance._get_tick(major=True)\n                instance.majorTicks.append(tick)\n                return instance.majorTicks\n            else:\n                instance.minorTicks = []\n                tick = instance._get_tick(major=False)\n                instance.minorTicks.append(tick)\n                return instance.minorTicks",
        "begin_line": 609,
        "end_line": 627,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014814814814814814,
            "pseudo_dstar_susp": 0.000942507068803016,
            "pseudo_tarantula_susp": 0.0006273525721455458,
            "pseudo_op2_susp": 0.000942507068803016,
            "pseudo_barinel_susp": 0.0006273525721455458
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.__init__#666",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.__init__(self, axes, pickradius=15)",
        "snippet": "    def __init__(self, axes, pickradius=15):\n        \"\"\"\n        Parameters\n        ----------\n        axes : `matplotlib.axes.Axes`\n            The `~.axes.Axes` to which the created Axis belongs.\n        pickradius : float\n            The acceptance radius for containment tests. See also\n            `.Axis.contains`.\n        \"\"\"\n        martist.Artist.__init__(self)\n        self._remove_overlapping_locs = True\n\n        self.set_figure(axes.figure)\n\n        self.isDefault_label = True\n\n        self.axes = axes\n        self.major = Ticker()\n        self.minor = Ticker()\n        self.callbacks = cbook.CallbackRegistry()\n\n        self._autolabelpos = True\n        self._smart_bounds = False  # Deprecated in 3.2\n\n        self.label = mtext.Text(\n            np.nan, np.nan,\n            fontsize=mpl.rcParams['axes.labelsize'],\n            fontweight=mpl.rcParams['axes.labelweight'],\n            color=mpl.rcParams['axes.labelcolor'],\n        )\n        self._set_artist_props(self.label)\n        self.offsetText = mtext.Text(np.nan, np.nan)\n        self._set_artist_props(self.offsetText)\n\n        self.labelpad = mpl.rcParams['axes.labelpad']\n\n        self.pickradius = pickradius\n\n        # Initialize here for testing; later add API\n        self._major_tick_kw = dict()\n        self._minor_tick_kw = dict()\n\n        self.cla()\n        self._set_scale('linear')",
        "begin_line": 666,
        "end_line": 710,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0027624309392265192,
            "pseudo_dstar_susp": 0.0011376564277588168,
            "pseudo_tarantula_susp": 0.0008841732979664014,
            "pseudo_op2_susp": 0.0011376564277588168,
            "pseudo_barinel_susp": 0.0008841732979664014
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.cla#771",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.cla(self)",
        "snippet": "    def cla(self):\n        \"\"\"Clear this axis.\"\"\"\n\n        self.label.set_text('')  # self.set_label_text would change isDefault_\n\n        self._set_scale('linear')\n\n        # Clear the callback registry for this axis, or it may \"leak\"\n        self.callbacks = cbook.CallbackRegistry()\n\n        # whether the grids are on\n        self._gridOnMajor = (\n                mpl.rcParams['axes.grid'] and\n                mpl.rcParams['axes.grid.which'] in ('both', 'major'))\n        self._gridOnMinor = (\n                mpl.rcParams['axes.grid'] and\n                mpl.rcParams['axes.grid.which'] in ('both', 'minor'))\n\n        self.reset_ticks()\n\n        self.converter = None\n        self.units = None\n        self.set_units(None)\n        self.stale = True",
        "begin_line": 771,
        "end_line": 794,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017574692442882249,
            "pseudo_dstar_susp": 0.000992063492063492,
            "pseudo_tarantula_susp": 0.0006958942240779402,
            "pseudo_op2_susp": 0.000992063492063492,
            "pseudo_barinel_susp": 0.0006958942240779402
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.reset_ticks#796",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.reset_ticks(self)",
        "snippet": "    def reset_ticks(self):\n        \"\"\"\n        Re-initialize the major and minor Tick lists.\n\n        Each list starts with a single fresh Tick.\n        \"\"\"\n        # Restore the lazy tick lists.\n        try:\n            del self.majorTicks\n        except AttributeError:\n            pass\n        try:\n            del self.minorTicks\n        except AttributeError:\n            pass\n        try:\n            self.set_clip_path(self.axes.patch)\n        except AttributeError:\n            pass",
        "begin_line": 796,
        "end_line": 814,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009514747859181732,
            "pseudo_dstar_susp": 0.0008741258741258741,
            "pseudo_tarantula_susp": 0.0005321979776476849,
            "pseudo_op2_susp": 0.0008741258741258741,
            "pseudo_barinel_susp": 0.0005321979776476849
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_tick_params#816",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_tick_params(self, which='major', reset=False, **kw)",
        "snippet": "    def set_tick_params(self, which='major', reset=False, **kw):\n        \"\"\"\n        Set appearance parameters for ticks, ticklabels, and gridlines.\n\n        For documentation of keyword arguments, see\n        :meth:`matplotlib.axes.Axes.tick_params`.\n        \"\"\"\n        cbook._check_in_list(['major', 'minor', 'both'], which=which)\n        kwtrans = self._translate_tick_kw(kw)\n\n        # the kwargs are stored in self._major/minor_tick_kw so that any\n        # future new ticks will automatically get them\n        if reset:\n            if which in ['major', 'both']:\n                self._major_tick_kw.clear()\n                self._major_tick_kw.update(kwtrans)\n            if which in ['minor', 'both']:\n                self._minor_tick_kw.clear()\n                self._minor_tick_kw.update(kwtrans)\n            self.reset_ticks()\n        else:\n            if which in ['major', 'both']:\n                self._major_tick_kw.update(kwtrans)\n                for tick in self.majorTicks:\n                    tick._apply_params(**kwtrans)\n            if which in ['minor', 'both']:\n                self._minor_tick_kw.update(kwtrans)\n                for tick in self.minorTicks:\n                    tick._apply_params(**kwtrans)\n            # special-case label color to also apply to the offset text\n            if 'labelcolor' in kwtrans:\n                self.offsetText.set_color(kwtrans['labelcolor'])\n\n        self.stale = True",
        "begin_line": 816,
        "end_line": 849,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0027247956403269754,
            "pseudo_dstar_susp": 0.0011337868480725624,
            "pseudo_tarantula_susp": 0.00089126559714795,
            "pseudo_op2_susp": 0.0011337868480725624,
            "pseudo_barinel_susp": 0.00089126559714795
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis._translate_tick_kw#852",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis._translate_tick_kw(kw)",
        "snippet": "    def _translate_tick_kw(kw):\n        # The following lists may be moved to a more accessible location.\n        kwkeys = ['size', 'width', 'color', 'tickdir', 'pad',\n                  'labelsize', 'labelcolor', 'zorder', 'gridOn',\n                  'tick1On', 'tick2On', 'label1On', 'label2On',\n                  'length', 'direction', 'left', 'bottom', 'right', 'top',\n                  'labelleft', 'labelbottom', 'labelright', 'labeltop',\n                  'labelrotation'] + _gridline_param_names\n        kwtrans = {}\n        if 'length' in kw:\n            kwtrans['size'] = kw.pop('length')\n        if 'direction' in kw:\n            kwtrans['tickdir'] = kw.pop('direction')\n        if 'rotation' in kw:\n            kwtrans['labelrotation'] = kw.pop('rotation')\n        if 'left' in kw:\n            kwtrans['tick1On'] = kw.pop('left')\n        if 'bottom' in kw:\n            kwtrans['tick1On'] = kw.pop('bottom')\n        if 'right' in kw:\n            kwtrans['tick2On'] = kw.pop('right')\n        if 'top' in kw:\n            kwtrans['tick2On'] = kw.pop('top')\n        if 'labelleft' in kw:\n            kwtrans['label1On'] = kw.pop('labelleft')\n        if 'labelbottom' in kw:\n            kwtrans['label1On'] = kw.pop('labelbottom')\n        if 'labelright' in kw:\n            kwtrans['label2On'] = kw.pop('labelright')\n        if 'labeltop' in kw:\n            kwtrans['label2On'] = kw.pop('labeltop')\n        if 'colors' in kw:\n            c = kw.pop('colors')\n            kwtrans['color'] = c\n            kwtrans['labelcolor'] = c\n        # Maybe move the checking up to the caller of this method.\n        for key in kw:\n            if key not in kwkeys:\n                raise ValueError(\n                    \"keyword %s is not recognized; valid keywords are %s\"\n                    % (key, kwkeys))\n            kwtrans.update(kw)\n        return kwtrans",
        "begin_line": 852,
        "end_line": 894,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002824858757062147,
            "pseudo_dstar_susp": 0.0011441647597254005,
            "pseudo_tarantula_susp": 0.0009000900090009,
            "pseudo_op2_susp": 0.0011441647597254005,
            "pseudo_barinel_susp": 0.0009000900090009
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_clip_path#896",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_clip_path(self, clippath, transform=None)",
        "snippet": "    def set_clip_path(self, clippath, transform=None):\n        martist.Artist.set_clip_path(self, clippath, transform)\n        for child in self.majorTicks + self.minorTicks:\n            child.set_clip_path(clippath, transform)\n        self.stale = True",
        "begin_line": 896,
        "end_line": 900,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024752475247524753,
            "pseudo_dstar_susp": 0.0011025358324145535,
            "pseudo_tarantula_susp": 0.0008382229673093043,
            "pseudo_op2_susp": 0.0011025358324145535,
            "pseudo_barinel_susp": 0.0008382229673093043
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_inverted#939",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_inverted(self)",
        "snippet": "    def get_inverted(self):\n        \"\"\"\n        Return whether the axis is oriented in the \"inverse\" direction.\n\n        The \"normal\" direction is increasing to the right for the x-axis and to\n        the top for the y-axis; the \"inverse\" direction is increasing to the\n        left for the x-axis and to the bottom for the y-axis.\n        \"\"\"\n        low, high = self.get_view_interval()\n        return high < low",
        "begin_line": 939,
        "end_line": 948,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.807010695604653e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis._set_artist_props#977",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis._set_artist_props(self, a)",
        "snippet": "    def _set_artist_props(self, a):\n        if a is None:\n            return\n        a.set_figure(self.figure)",
        "begin_line": 977,
        "end_line": 980,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009165902841429881,
            "pseudo_dstar_susp": 0.000864304235090752,
            "pseudo_tarantula_susp": 0.0005165289256198347,
            "pseudo_op2_susp": 0.000864304235090752,
            "pseudo_barinel_susp": 0.0005165289256198347
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis._update_ticks#1013",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis._update_ticks(self)",
        "snippet": "    def _update_ticks(self):\n        \"\"\"\n        Update ticks (position and labels) using the current data interval of\n        the axes.  Return the list of ticks that will be drawn.\n        \"\"\"\n        major_locs = self.get_majorticklocs()\n        major_labels = self.major.formatter.format_ticks(major_locs)\n        major_ticks = self.get_major_ticks(len(major_locs))\n        self.major.formatter.set_locs(major_locs)\n        for tick, loc, label in zip(major_ticks, major_locs, major_labels):\n            tick.update_position(loc)\n            tick.set_label1(label)\n            tick.set_label2(label)\n        minor_locs = self.get_minorticklocs()\n        minor_labels = self.minor.formatter.format_ticks(minor_locs)\n        minor_ticks = self.get_minor_ticks(len(minor_locs))\n        self.minor.formatter.set_locs(minor_locs)\n        for tick, loc, label in zip(minor_ticks, minor_locs, minor_labels):\n            tick.update_position(loc)\n            tick.set_label1(label)\n            tick.set_label2(label)\n        ticks = [*major_ticks, *minor_ticks]\n\n        view_low, view_high = self.get_view_interval()\n        if view_low > view_high:\n            view_low, view_high = view_high, view_low\n\n        if self._smart_bounds and ticks:  # _smart_bounds is deprecated in 3.2\n            # handle inverted limits\n            data_low, data_high = sorted(self.get_data_interval())\n            locs = np.sort([tick.get_loc() for tick in ticks])\n            if data_low <= view_low:\n                # data extends beyond view, take view as limit\n                ilow = view_low\n            else:\n                # data stops within view, take best tick\n                good_locs = locs[locs <= data_low]\n                if len(good_locs):\n                    # last tick prior or equal to first data point\n                    ilow = good_locs[-1]\n                else:\n                    # No ticks (why not?), take first tick\n                    ilow = locs[0]\n            if data_high >= view_high:\n                # data extends beyond view, take view as limit\n                ihigh = view_high\n            else:\n                # data stops within view, take best tick\n                good_locs = locs[locs >= data_high]\n                if len(good_locs):\n                    # first tick after or equal to last data point\n                    ihigh = good_locs[0]\n                else:\n                    # No ticks (why not?), take last tick\n                    ihigh = locs[-1]\n            ticks = [tick for tick in ticks if ilow <= tick.get_loc() <= ihigh]\n\n        interval_t = self.get_transform().transform([view_low, view_high])\n\n        ticks_to_draw = []\n        for tick in ticks:\n            try:\n                loc_t = self.get_transform().transform(tick.get_loc())\n            except AssertionError:\n                # transforms.transform doesn't allow masked values but\n                # some scales might make them, so we need this try/except.\n                pass\n            else:\n                if mtransforms._interval_contains_close(interval_t, loc_t):\n                    ticks_to_draw.append(tick)\n\n        return ticks_to_draw",
        "begin_line": 1013,
        "end_line": 1084,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.495128166691651e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis._get_tick_bboxes#1086",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis._get_tick_bboxes(self, ticks, renderer)",
        "snippet": "    def _get_tick_bboxes(self, ticks, renderer):\n        \"\"\"Return lists of bboxes for ticks' label1's and label2's.\"\"\"\n        return ([tick.label1.get_window_extent(renderer)\n                 for tick in ticks if tick.label1.get_visible()],\n                [tick.label2.get_window_extent(renderer)\n                 for tick in ticks if tick.label2.get_visible()])",
        "begin_line": 1086,
        "end_line": 1091,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.769622029290537e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_tightbbox#1093",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_tightbbox(self, renderer)",
        "snippet": "    def get_tightbbox(self, renderer):\n        \"\"\"\n        Return a bounding box that encloses the axis. It only accounts\n        tick labels, axis label, and offsetText.\n        \"\"\"\n        if not self.get_visible():\n            return\n\n        ticks_to_draw = self._update_ticks()\n\n        self._update_label_position(renderer)\n\n        # go back to just this axis's tick labels\n        ticklabelBoxes, ticklabelBoxes2 = self._get_tick_bboxes(\n                    ticks_to_draw, renderer)\n\n        self._update_offset_text_position(ticklabelBoxes, ticklabelBoxes2)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n\n        bboxes = [\n            *(a.get_window_extent(renderer)\n              for a in [self.label, self.offsetText]\n              if a.get_visible()),\n            *ticklabelBoxes,\n            *ticklabelBoxes2,\n        ]\n        bboxes = [b for b in bboxes\n                  if 0 < b.width < np.inf and 0 < b.height < np.inf]\n        if bboxes:\n            return mtransforms.Bbox.union(bboxes)\n        else:\n            return None",
        "begin_line": 1093,
        "end_line": 1124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.999000099990002e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.draw#1135",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.draw(self, renderer, *args, **kwargs)",
        "snippet": "    def draw(self, renderer, *args, **kwargs):\n        # docstring inherited\n\n        if not self.get_visible():\n            return\n        renderer.open_group(__name__, gid=self.get_gid())\n\n        ticks_to_draw = self._update_ticks()\n        ticklabelBoxes, ticklabelBoxes2 = self._get_tick_bboxes(ticks_to_draw,\n                                                                renderer)\n\n        for tick in ticks_to_draw:\n            tick.draw(renderer)\n\n        # scale up the axis label box to also find the neighbors, not\n        # just the tick labels that actually overlap note we need a\n        # *copy* of the axis label box because we don't wan't to scale\n        # the actual bbox\n\n        self._update_label_position(renderer)\n\n        self.label.draw(renderer)\n\n        self._update_offset_text_position(ticklabelBoxes, ticklabelBoxes2)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n        self.offsetText.draw(renderer)\n\n        renderer.close_group(__name__)\n        self.stale = False",
        "begin_line": 1135,
        "end_line": 1163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00028686173264486515,
            "pseudo_dstar_susp": 0.00028686173264486515,
            "pseudo_tarantula_susp": 0.00029568302779420464,
            "pseudo_op2_susp": 0.00028686173264486515,
            "pseudo_barinel_susp": 0.00029568302779420464
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_majorticklabels#1183",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_majorticklabels(self)",
        "snippet": "    def get_majorticklabels(self):\n        \"\"\"Return a list of Text instances for the major ticklabels.\"\"\"\n        ticks = self.get_major_ticks()\n        labels1 = [tick.label1 for tick in ticks if tick.label1.get_visible()]\n        labels2 = [tick.label2 for tick in ticks if tick.label2.get_visible()]\n        return cbook.silent_list('Text major ticklabel', labels1 + labels2)",
        "begin_line": 1183,
        "end_line": 1188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00011461318051575932,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_minorticklabels#1190",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_minorticklabels(self)",
        "snippet": "    def get_minorticklabels(self):\n        \"\"\"Return a list of Text instances for the minor ticklabels.\"\"\"\n        ticks = self.get_minor_ticks()\n        labels1 = [tick.label1 for tick in ticks if tick.label1.get_visible()]\n        labels2 = [tick.label2 for tick in ticks if tick.label2.get_visible()]\n        return cbook.silent_list('Text minor ticklabel', labels1 + labels2)",
        "begin_line": 1190,
        "end_line": 1195,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_ticklabels#1197",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_ticklabels(self, minor=False, which=None)",
        "snippet": "    def get_ticklabels(self, minor=False, which=None):\n        \"\"\"\n        Get the tick labels as a list of `~matplotlib.text.Text` instances.\n\n        Parameters\n        ----------\n        minor : bool\n           If True return the minor ticklabels,\n           else return the major ticklabels\n\n        which : None, ('minor', 'major', 'both')\n           Overrides *minor*.\n\n           Selects which ticklabels to return\n\n        Returns\n        -------\n        ret : list\n           List of `~matplotlib.text.Text` instances.\n        \"\"\"\n\n        if which is not None:\n            if which == 'minor':\n                return self.get_minorticklabels()\n            elif which == 'major':\n                return self.get_majorticklabels()\n            elif which == 'both':\n                return self.get_majorticklabels() + self.get_minorticklabels()\n            else:\n                cbook._check_in_list(['major', 'minor', 'both'], which=which)\n        if minor:\n            return self.get_minorticklabels()\n        return self.get_majorticklabels()",
        "begin_line": 1197,
        "end_line": 1229,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_majorticklocs#1255",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_majorticklocs(self)",
        "snippet": "    def get_majorticklocs(self):\n        \"\"\"Get the array of major tick locations in data coordinates.\"\"\"\n        return self.major.locator()",
        "begin_line": 1255,
        "end_line": 1257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00038880248833592535,
            "pseudo_dstar_susp": 0.00035816618911174784,
            "pseudo_tarantula_susp": 0.0008305647840531562,
            "pseudo_op2_susp": 0.00035816618911174784,
            "pseudo_barinel_susp": 0.0008305647840531562
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_minorticklocs#1259",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_minorticklocs(self)",
        "snippet": "    def get_minorticklocs(self):\n        \"\"\"Get the array of minor tick locations in data coordinates.\"\"\"\n        # Remove minor ticks duplicating major ticks.\n        major_locs = self.major.locator()\n        minor_locs = self.minor.locator()\n        transform = self._scale.get_transform()\n        tr_minor_locs = transform.transform(minor_locs)\n        tr_major_locs = transform.transform(major_locs)\n        lo, hi = sorted(transform.transform(self.get_view_interval()))\n        # Use the transformed view limits as scale.  1e-5 is the default rtol\n        # for np.isclose.\n        tol = (hi - lo) * 1e-5\n        if self.remove_overlapping_locs:\n            minor_locs = [\n                loc for loc, tr_loc in zip(minor_locs, tr_minor_locs)\n                if ~np.isclose(tr_loc, tr_major_locs, atol=tol, rtol=0).any()]\n        return minor_locs",
        "begin_line": 1259,
        "end_line": 1275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000280662363177098,
            "pseudo_dstar_susp": 0.000280662363177098,
            "pseudo_tarantula_susp": 0.0002876042565429968,
            "pseudo_op2_susp": 0.000280662363177098,
            "pseudo_barinel_susp": 0.0002876042565429968
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_ticklocs#1277",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_ticklocs(self, minor=False)",
        "snippet": "    def get_ticklocs(self, minor=False):\n        \"\"\"Get the array of tick locations in data coordinates.\"\"\"\n        return self.get_minorticklocs() if minor else self.get_majorticklocs()",
        "begin_line": 1277,
        "end_line": 1279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis._copy_tick_props#1306",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis._copy_tick_props(self, src, dest)",
        "snippet": "    def _copy_tick_props(self, src, dest):\n        \"\"\"Copy the properties from *src* tick to *dest* tick.\"\"\"\n        if src is None or dest is None:\n            return\n        dest.label1.update_from(src.label1)\n        dest.label2.update_from(src.label2)\n        dest.tick1line.update_from(src.tick1line)\n        dest.tick2line.update_from(src.tick2line)\n        dest.gridline.update_from(src.gridline)",
        "begin_line": 1306,
        "end_line": 1314,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003861003861003861,
            "pseudo_dstar_susp": 0.000355998576005696,
            "pseudo_tarantula_susp": 0.0008077544426494346,
            "pseudo_op2_susp": 0.000355998576005696,
            "pseudo_barinel_susp": 0.0008077544426494346
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_major_locator#1320",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_major_locator(self)",
        "snippet": "    def get_major_locator(self):\n        \"\"\"Get the locator of the major ticker.\"\"\"\n        return self.major.locator",
        "begin_line": 1320,
        "end_line": 1322,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009615384615384616,
            "pseudo_dstar_susp": 0.0015503875968992248,
            "pseudo_tarantula_susp": 0.0012610340479192938,
            "pseudo_op2_susp": 0.0015503875968992248,
            "pseudo_barinel_susp": 0.0012626262626262627
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_major_formatter#1328",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_major_formatter(self)",
        "snippet": "    def get_major_formatter(self):\n        \"\"\"Get the formatter of the major ticker.\"\"\"\n        return self.major.formatter",
        "begin_line": 1328,
        "end_line": 1330,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_major_ticks#1336",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_major_ticks(self, numticks=None)",
        "snippet": "    def get_major_ticks(self, numticks=None):\n        \"\"\"Get the tick instances; grow as necessary.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_majorticklocs())\n\n        while len(self.majorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=True)\n            self.majorTicks.append(tick)\n            tick.gridline.set_visible(self._gridOnMajor)\n            self._copy_tick_props(self.majorTicks[0], tick)\n\n        return self.majorTicks[:numticks]",
        "begin_line": 1336,
        "end_line": 1348,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00015725743041358704,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_minor_ticks#1350",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_minor_ticks(self, numticks=None)",
        "snippet": "    def get_minor_ticks(self, numticks=None):\n        \"\"\"Get the minor tick instances; grow as necessary.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_minorticklocs())\n\n        while len(self.minorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=False)\n            self.minorTicks.append(tick)\n            tick.gridline.set_visible(self._gridOnMinor)\n            self._copy_tick_props(self.minorTicks[0], tick)\n\n        return self.minorTicks[:numticks]",
        "begin_line": 1350,
        "end_line": 1362,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002805836139169473,
            "pseudo_dstar_susp": 0.0002805836139169473,
            "pseudo_tarantula_susp": 0.0002875215641173088,
            "pseudo_op2_susp": 0.0002805836139169473,
            "pseudo_barinel_susp": 0.0002875215641173088
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.grid#1364",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.grid(self, b=None, which='major', **kwargs)",
        "snippet": "    def grid(self, b=None, which='major', **kwargs):\n        \"\"\"\n        Configure the grid lines.\n\n        Parameters\n        ----------\n        b : bool or None\n            Whether to show the grid lines. If any *kwargs* are supplied,\n            it is assumed you want the grid on and *b* will be set to True.\n\n            If *b* is *None* and there are no *kwargs*, this toggles the\n            visibility of the lines.\n\n        which : {'major', 'minor', 'both'}\n            The grid lines to apply the changes on.\n\n        **kwargs : `.Line2D` properties\n            Define the line properties of the grid, e.g.::\n\n                grid(color='r', linestyle='-', linewidth=2)\n\n        \"\"\"\n        if len(kwargs):\n            if not b and b is not None:  # something false-like but not None\n                cbook._warn_external('First parameter to grid() is false, '\n                                     'but line properties are supplied. The '\n                                     'grid will be enabled.')\n            b = True\n        which = which.lower()\n        cbook._check_in_list(['major', 'minor', 'both'], which=which)\n        gridkw = {'grid_' + item[0]: item[1] for item in kwargs.items()}\n\n        if which in ['minor', 'both']:\n            if b is None:\n                self._gridOnMinor = not self._gridOnMinor\n            else:\n                self._gridOnMinor = b\n            self.set_tick_params(which='minor', gridOn=self._gridOnMinor,\n                                 **gridkw)\n        if which in ['major', 'both']:\n            if b is None:\n                self._gridOnMajor = not self._gridOnMajor\n            else:\n                self._gridOnMajor = b\n            self.set_tick_params(which='major', gridOn=self._gridOnMajor,\n                                 **gridkw)\n        self.stale = True",
        "begin_line": 1364,
        "end_line": 1410,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011695906432748538,
            "pseudo_dstar_susp": 0.0020491803278688526,
            "pseudo_tarantula_susp": 0.0006887052341597796,
            "pseudo_op2_susp": 0.0020491803278688526,
            "pseudo_barinel_susp": 0.0006887052341597796
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.update_units#1412",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.update_units(self, data)",
        "snippet": "    def update_units(self, data):\n        \"\"\"\n        Introspect *data* for units converter and update the\n        axis.converter instance if necessary. Return *True*\n        if *data* is registered for unit conversion.\n        \"\"\"\n        converter = munits.registry.get_converter(data)\n        if converter is None:\n            return False\n\n        neednew = self.converter != converter\n        self.converter = converter\n        default = self.converter.default_units(data, self)\n        if default is not None and self.units is None:\n            self.set_units(default)\n\n        if neednew:\n            self._update_axisinfo()\n        self.stale = True\n        return True",
        "begin_line": 1412,
        "end_line": 1431,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003204101249599487,
            "pseudo_dstar_susp": 0.00031338138514572234,
            "pseudo_tarantula_susp": 0.0003990422984836393,
            "pseudo_op2_susp": 0.00031338138514572234,
            "pseudo_barinel_susp": 0.0003992015968063872
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis._update_axisinfo#1433",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis._update_axisinfo(self)",
        "snippet": "    def _update_axisinfo(self):\n        \"\"\"\n        Check the axis converter for the stored units to see if the\n        axis info needs to be updated.\n        \"\"\"\n        if self.converter is None:\n            return\n\n        info = self.converter.axisinfo(self.units, self)\n\n        if info is None:\n            return\n        if info.majloc is not None and \\\n           self.major.locator != info.majloc and self.isDefault_majloc:\n            self.set_major_locator(info.majloc)\n            self.isDefault_majloc = True\n        if info.minloc is not None and \\\n           self.minor.locator != info.minloc and self.isDefault_minloc:\n            self.set_minor_locator(info.minloc)\n            self.isDefault_minloc = True\n        if info.majfmt is not None and \\\n           self.major.formatter != info.majfmt and self.isDefault_majfmt:\n            self.set_major_formatter(info.majfmt)\n            self.isDefault_majfmt = True\n        if info.minfmt is not None and \\\n           self.minor.formatter != info.minfmt and self.isDefault_minfmt:\n            self.set_minor_formatter(info.minfmt)\n            self.isDefault_minfmt = True\n        if info.label is not None and self.isDefault_label:\n            self.set_label_text(info.label)\n            self.isDefault_label = True\n\n        self.set_default_intervals()",
        "begin_line": 1433,
        "end_line": 1465,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003621876131836291,
            "pseudo_dstar_susp": 0.0003365870077415012,
            "pseudo_tarantula_susp": 0.0006064281382656155,
            "pseudo_op2_susp": 0.0003365870077415012,
            "pseudo_barinel_susp": 0.0006060606060606061
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.have_units#1467",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.have_units(self)",
        "snippet": "    def have_units(self):\n        return self.converter is not None or self.units is not None",
        "begin_line": 1467,
        "end_line": 1468,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012836970474967907,
            "pseudo_dstar_susp": 0.002369668246445498,
            "pseudo_tarantula_susp": 0.0007358351729212656,
            "pseudo_op2_susp": 0.002369668246445498,
            "pseudo_barinel_susp": 0.0007358351729212656
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.convert_units#1470",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.convert_units(self, x)",
        "snippet": "    def convert_units(self, x):\n        # If x is natively supported by Matplotlib, doesn't need converting\n        if munits._is_natively_supported(x):\n            return x\n\n        if self.converter is None:\n            self.converter = munits.registry.get_converter(x)\n\n        if self.converter is None:\n            return x\n        try:\n            ret = self.converter.convert(x, self.units, self)\n        except Exception as e:\n            raise munits.ConversionError('Failed to convert value(s) to axis '\n                                         f'units: {x!r}') from e\n        return ret",
        "begin_line": 1470,
        "end_line": 1485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001177856301531213,
            "pseudo_dstar_susp": 0.002074688796680498,
            "pseudo_tarantula_susp": 0.0011750881316098707,
            "pseudo_op2_susp": 0.002074688796680498,
            "pseudo_barinel_susp": 0.0011750881316098707
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_units#1487",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_units(self, u)",
        "snippet": "    def set_units(self, u):\n        \"\"\"\n        Set the units for axis.\n\n        Parameters\n        ----------\n        u : units tag\n        \"\"\"\n        if u == self.units:\n            return\n        self.units = u\n        self._update_axisinfo()\n        self.callbacks.process('units')\n        self.callbacks.process('units finalize')\n        self.stale = True",
        "begin_line": 1487,
        "end_line": 1501,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013531799729364006,
            "pseudo_dstar_susp": 0.002457002457002457,
            "pseudo_tarantula_susp": 0.0012987012987012987,
            "pseudo_op2_susp": 0.002457002457002457,
            "pseudo_barinel_susp": 0.0012987012987012987
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_label_text#1507",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_label_text(self, label, fontdict=None, **kwargs)",
        "snippet": "    def set_label_text(self, label, fontdict=None, **kwargs):\n        \"\"\"\n        Set the text value of the axis label.\n\n        Parameters\n        ----------\n        label : str\n            Text string.\n        fontdict : dict\n            Text properties.\n        **kwargs\n            Merged into fontdict.\n        \"\"\"\n        self.isDefault_label = False\n        self.label.set_text(label)\n        if fontdict is not None:\n            self.label.update(fontdict)\n        self.label.update(kwargs)\n        self.stale = True\n        return self.label",
        "begin_line": 1507,
        "end_line": 1526,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00045187528242205153,
            "pseudo_dstar_susp": 0.00039277297721916735,
            "pseudo_tarantula_susp": 0.0015337423312883436,
            "pseudo_op2_susp": 0.00039277297721916735,
            "pseudo_barinel_susp": 0.0015337423312883436
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_major_formatter#1528",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_major_formatter(self, formatter)",
        "snippet": "    def set_major_formatter(self, formatter):\n        \"\"\"\n        Set the formatter of the major ticker.\n\n        Parameters\n        ----------\n        formatter : `~matplotlib.ticker.Formatter`\n        \"\"\"\n        cbook._check_isinstance(mticker.Formatter, formatter=formatter)\n        if (isinstance(formatter, mticker.FixedFormatter)\n                and len(formatter.seq) > 0\n                and not isinstance(self.major.locator, mticker.FixedLocator)):\n            cbook._warn_external('FixedFormatter should only be used together '\n                                 'with FixedLocator')\n        self.isDefault_majfmt = False\n        self.major.formatter = formatter\n        formatter.set_axis(self)\n        self.stale = True",
        "begin_line": 1528,
        "end_line": 1545,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009514747859181732,
            "pseudo_dstar_susp": 0.0008741258741258741,
            "pseudo_tarantula_susp": 0.001392757660167131,
            "pseudo_op2_susp": 0.0008741258741258741,
            "pseudo_barinel_susp": 0.001392757660167131
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_minor_formatter#1547",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_minor_formatter(self, formatter)",
        "snippet": "    def set_minor_formatter(self, formatter):\n        \"\"\"\n        Set the formatter of the minor ticker.\n\n        Parameters\n        ----------\n        formatter : `~matplotlib.ticker.Formatter`\n        \"\"\"\n        cbook._check_isinstance(mticker.Formatter, formatter=formatter)\n        if (isinstance(formatter, mticker.FixedFormatter)\n                and len(formatter.seq) > 0\n                and not isinstance(self.minor.locator, mticker.FixedLocator)):\n            cbook._warn_external('FixedFormatter should only be used together '\n                                 'with FixedLocator')\n        self.isDefault_minfmt = False\n        self.minor.formatter = formatter\n        formatter.set_axis(self)\n        self.stale = True",
        "begin_line": 1547,
        "end_line": 1564,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004923682914820286,
            "pseudo_dstar_susp": 0.0005402485143165856,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.0005402485143165856,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_major_locator#1566",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_major_locator(self, locator)",
        "snippet": "    def set_major_locator(self, locator):\n        \"\"\"\n        Set the locator of the major ticker.\n\n        Parameters\n        ----------\n        locator : `~matplotlib.ticker.Locator`\n        \"\"\"\n        cbook._check_isinstance(mticker.Locator, locator=locator)\n        self.isDefault_majloc = False\n        self.major.locator = locator\n        if self.major.formatter:\n            self.major.formatter._set_locator(locator)\n        locator.set_axis(self)\n        self.stale = True",
        "begin_line": 1566,
        "end_line": 1580,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000998003992015968,
            "pseudo_dstar_susp": 0.0016286644951140066,
            "pseudo_tarantula_susp": 0.001422475106685633,
            "pseudo_op2_susp": 0.0016286644951140066,
            "pseudo_barinel_susp": 0.001422475106685633
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_ticklabels#1608",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_ticklabels(self, ticklabels, *args, minor=False, **kwargs)",
        "snippet": "    def set_ticklabels(self, ticklabels, *args, minor=False, **kwargs):\n        r\"\"\"\n        Set the text values of the tick labels.\n\n        .. warning::\n            This method should only be used after fixing the tick positions\n            using `.Axis.set_ticks`. Otherwise, the labels may end up in\n            unexpected positions.\n\n        Parameters\n        ----------\n        ticklabels : sequence of str or of `.Text`\\s\n            List of texts for tick labels; must include values for non-visible\n            labels.\n        minor : bool\n            If True, set minor ticks instead of major ticks.\n        **kwargs\n            Text properties.\n\n        Returns\n        -------\n        labels : list of `.Text`\\s\n            For each tick, includes ``tick.label1`` if it is visible, then\n            ``tick.label2`` if it is visible, in that order.\n        \"\"\"\n        if args:\n            cbook.warn_deprecated(\n                \"3.1\", message=\"Additional positional arguments to \"\n                \"set_ticklabels are ignored, and deprecated since Matplotlib \"\n                \"3.1; passing them will raise a TypeError in Matplotlib 3.3.\")\n        ticklabels = [t.get_text() if hasattr(t, 'get_text') else t\n                      for t in ticklabels]\n        if minor:\n            self.set_minor_formatter(mticker.FixedFormatter(ticklabels))\n            ticks = self.get_minor_ticks()\n        else:\n            self.set_major_formatter(mticker.FixedFormatter(ticklabels))\n            ticks = self.get_major_ticks()\n        ret = []\n        for tick_label, tick in zip(ticklabels, ticks):\n            # deal with label1\n            tick.label1.set_text(tick_label)\n            tick.label1.update(kwargs)\n            # deal with label2\n            tick.label2.set_text(tick_label)\n            tick.label2.update(kwargs)\n            # only return visible tick labels\n            if tick.label1.get_visible():\n                ret.append(tick.label1)\n            if tick.label2.get_visible():\n                ret.append(tick.label2)\n\n        self.stale = True\n        return ret",
        "begin_line": 1608,
        "end_line": 1661,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00012753475322025253,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.set_ticks#1664",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.set_ticks(self, ticks, minor=False)",
        "snippet": "    def set_ticks(self, ticks, minor=False):\n        \"\"\"\n        Set the locations of the tick marks from sequence ticks\n\n        Parameters\n        ----------\n        ticks : sequence of floats\n        minor : bool\n        \"\"\"\n        # XXX if the user changes units, the information will be lost here\n        ticks = self.convert_units(ticks)\n        if len(ticks) > 1:\n            xleft, xright = self.get_view_interval()\n            if xright > xleft:\n                self.set_view_interval(min(ticks), max(ticks))\n            else:\n                self.set_view_interval(max(ticks), min(ticks))\n        if minor:\n            self.set_minor_locator(mticker.FixedLocator(ticks))\n            return self.get_minor_ticks(len(ticks))\n        else:\n            self.set_major_locator(mticker.FixedLocator(ticks))\n            return self.get_major_ticks(len(ticks))",
        "begin_line": 1664,
        "end_line": 1686,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.axis_date#1721",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.axis_date(self, tz=None)",
        "snippet": "    def axis_date(self, tz=None):\n        \"\"\"\n        Sets up axis ticks and labels treating data along this axis as dates.\n\n        Parameters\n        ----------\n        tz : tzinfo or str or None\n            The timezone used to create date labels.\n        \"\"\"\n        # By providing a sample datetime instance with the desired timezone,\n        # the registered converter can be selected, and the \"units\" attribute,\n        # which is the timezone, can be set.\n        if isinstance(tz, str):\n            import dateutil.tz\n            tz = dateutil.tz.gettz(tz)\n        self.update_units(datetime.datetime(2009, 1, 1, 0, 0, 0, 0, tz))",
        "begin_line": 1721,
        "end_line": 1736,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis._get_ticks_position#1743",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis._get_ticks_position(self)",
        "snippet": "    def _get_ticks_position(self):\n        \"\"\"\n        Helper for `XAxis.get_ticks_position` and `YAxis.get_ticks_position`.\n\n        Check the visibility of tick1line, label1, tick2line, and label2 on\n        the first major and the first minor ticks, and return\n\n        - 1 if only tick1line and label1 are visible (which corresponds to\n          \"bottom\" for the x-axis and \"left\" for the y-axis);\n        - 2 if only tick2line and label2 are visible (which corresponds to\n          \"top\" for the x-axis and \"right\" for the y-axis);\n        - \"default\" if only tick1line, tick2line and label1 are visible;\n        - \"unknown\" otherwise.\n        \"\"\"\n        major = self.majorTicks[0]\n        minor = self.minorTicks[0]\n        if all(tick.tick1line.get_visible()\n               and not tick.tick2line.get_visible()\n               and tick.label1.get_visible()\n               and not tick.label2.get_visible()\n               for tick in [major, minor]):\n            return 1\n        elif all(tick.tick2line.get_visible()\n                 and not tick.tick1line.get_visible()\n                 and tick.label2.get_visible()\n                 and not tick.label1.get_visible()\n                 for tick in [major, minor]):\n            return 2\n        elif all(tick.tick1line.get_visible()\n                 and tick.tick2line.get_visible()\n                 and tick.label1.get_visible()\n                 and not tick.label2.get_visible()\n                 for tick in [major, minor]):\n            return \"default\"\n        else:\n            return \"unknown\"",
        "begin_line": 1743,
        "end_line": 1778,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00039761431411530816,
            "pseudo_dstar_susp": 0.0003650967506389193,
            "pseudo_tarantula_susp": 0.0009115770282588879,
            "pseudo_op2_susp": 0.0003650967506389193,
            "pseudo_barinel_susp": 0.0009115770282588879
        }
    },
    {
        "name": "lib.matplotlib.axis.Axis.get_label_position#1780",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.Axis",
        "signature": "lib.matplotlib.axis.Axis.get_label_position(self)",
        "snippet": "    def get_label_position(self):\n        \"\"\"\n        Return the label position (top or bottom)\n        \"\"\"\n        return self.label_position",
        "begin_line": 1780,
        "end_line": 1784,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00037778617302606723,
            "pseudo_dstar_susp": 0.00034916201117318437,
            "pseudo_tarantula_susp": 0.0007358351729212656,
            "pseudo_op2_susp": 0.00034916201117318437,
            "pseudo_barinel_susp": 0.0007358351729212656
        }
    },
    {
        "name": "lib.matplotlib.axis.getter#1806",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis",
        "signature": "lib.matplotlib.axis.getter(self)",
        "snippet": "    def getter(self):\n        # docstring inherited.\n        return getattr(getattr(self.axes, lim_name), attr_name)",
        "begin_line": 1806,
        "end_line": 1808,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 7.496813854112003e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.setter#1810",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis",
        "signature": "lib.matplotlib.axis.setter(self, vmin, vmax, ignore=False)",
        "snippet": "    def setter(self, vmin, vmax, ignore=False):\n        # docstring inherited.\n        if ignore:\n            setattr(getattr(self.axes, lim_name), attr_name, (vmin, vmax))\n        else:\n            oldmin, oldmax = getter(self)\n            if oldmin < oldmax:\n                setter(self, min(vmin, vmax, oldmin), max(vmin, vmax, oldmax),\n                       ignore=True)\n            else:\n                setter(self, max(vmin, vmax, oldmin), min(vmin, vmax, oldmax),\n                       ignore=True)\n        self.stale = True",
        "begin_line": 1810,
        "end_line": 1822,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003837298541826554,
            "pseudo_dstar_susp": 0.00035398230088495576,
            "pseudo_tarantula_susp": 0.0007751937984496124,
            "pseudo_op2_susp": 0.00035398230088495576,
            "pseudo_barinel_susp": 0.0007757951900698216
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis.__init__#1834",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # x in axes coords, y in display coords (to be updated at draw time by\n        # _update_label_positions and _update_offset_text_position).\n        self.label.set(\n            x=0.5, y=0,\n            verticalalignment='top', horizontalalignment='center',\n            transform=mtransforms.blended_transform_factory(\n                self.axes.transAxes, mtransforms.IdentityTransform()),\n        )\n        self.label_position = 'bottom'\n        self.offsetText.set(\n            x=1, y=0,\n            verticalalignment='top', horizontalalignment='right',\n            transform=mtransforms.blended_transform_factory(\n                self.axes.transAxes, mtransforms.IdentityTransform()),\n            fontsize=mpl.rcParams['xtick.labelsize'],\n            color=mpl.rcParams['xtick.color'],\n        )\n        self.offset_text_position = 'bottom'",
        "begin_line": 1834,
        "end_line": 1853,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001422475106685633,
            "pseudo_dstar_susp": 0.0025906735751295338,
            "pseudo_tarantula_susp": 0.0005913660555884093,
            "pseudo_op2_susp": 0.0025906735751295338,
            "pseudo_barinel_susp": 0.0005913660555884093
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis._get_tick#1874",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis._get_tick(self, major)",
        "snippet": "    def _get_tick(self, major):\n        if major:\n            tick_kw = self._major_tick_kw\n        else:\n            tick_kw = self._minor_tick_kw\n        return XTick(self.axes, 0, major=major, **tick_kw)",
        "begin_line": 1874,
        "end_line": 1879,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014577259475218659,
            "pseudo_dstar_susp": 0.0009345794392523365,
            "pseudo_tarantula_susp": 0.0009832841691248771,
            "pseudo_op2_susp": 0.0009345794392523365,
            "pseudo_barinel_susp": 0.0009832841691248771
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis.set_label_position#1881",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis.set_label_position(self, position)",
        "snippet": "    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (top or bottom)\n\n        Parameters\n        ----------\n        position : {'top', 'bottom'}\n        \"\"\"\n        self.label.set_verticalalignment(cbook._check_getitem({\n            'top': 'baseline', 'bottom': 'top',\n        }, position=position))\n        self.label_position = position\n        self.stale = True",
        "begin_line": 1881,
        "end_line": 1893,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis._get_tick_boxes_siblings#1895",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis._get_tick_boxes_siblings(self, renderer)",
        "snippet": "    def _get_tick_boxes_siblings(self, renderer):\n        \"\"\"\n        Get the bounding boxes for this `.axis` and its siblings\n        as set by `.Figure.align_xlabels` or  `.Figure.align_ylablels`.\n\n        By default it just gets bboxes for self.\n        \"\"\"\n        bboxes = []\n        bboxes2 = []\n        # get the Grouper that keeps track of x-label groups for this figure\n        grp = self.figure._align_xlabel_grp\n        # if we want to align labels from other axes:\n        for nn, axx in enumerate(grp.get_siblings(self.axes)):\n            ticks_to_draw = axx.xaxis._update_ticks()\n            tlb, tlb2 = axx.xaxis._get_tick_bboxes(ticks_to_draw, renderer)\n            bboxes.extend(tlb)\n            bboxes2.extend(tlb2)\n        return bboxes, bboxes2",
        "begin_line": 1895,
        "end_line": 1912,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0002857959416976279,
            "pseudo_dstar_susp": 0.0002857959416976279,
            "pseudo_tarantula_susp": 0.0002936857562408223,
            "pseudo_op2_susp": 0.0002857959416976279,
            "pseudo_barinel_susp": 0.0002936857562408223
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis._update_label_position#1914",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis._update_label_position(self, renderer)",
        "snippet": "    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_xlabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n\n        x, y = self.label.get_position()\n        if self.label_position == 'bottom':\n            try:\n                spine = self.axes.spines['bottom']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes + [spinebbox])\n            bottom = bbox.y0\n\n            self.label.set_position(\n                (x, bottom - self.labelpad * self.figure.dpi / 72)\n            )\n\n        else:\n            try:\n                spine = self.axes.spines['top']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes2 + [spinebbox])\n            top = bbox.y1\n\n            self.label.set_position(\n                (x, top + self.labelpad * self.figure.dpi / 72)\n            )",
        "begin_line": 1914,
        "end_line": 1955,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004280821917808219,
            "pseudo_dstar_susp": 0.0003837298541826554,
            "pseudo_tarantula_susp": 0.0012987012987012987,
            "pseudo_op2_susp": 0.0003837298541826554,
            "pseudo_barinel_susp": 0.0012987012987012987
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis._update_offset_text_position#1957",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis._update_offset_text_position(self, bboxes, bboxes2)",
        "snippet": "    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset_text position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        if not hasattr(self, '_tick_position'):\n            self._tick_position = 'bottom'\n        if self._tick_position == 'bottom':\n            if not len(bboxes):\n                bottom = self.axes.bbox.ymin\n            else:\n                bbox = mtransforms.Bbox.union(bboxes)\n                bottom = bbox.y0\n            self.offsetText.set_position(\n                (x, bottom - self.OFFSETTEXTPAD * self.figure.dpi / 72)\n            )\n        else:\n            if not len(bboxes2):\n                top = self.axes.bbox.ymax\n            else:\n                bbox = mtransforms.Bbox.union(bboxes2)\n                top = bbox.y1\n            self.offsetText.set_va('top')\n            self.offsetText.set_position(\n                (x, top + self.OFFSETTEXTPAD * self.figure.dpi / 72)\n            )",
        "begin_line": 1957,
        "end_line": 1983,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00035842293906810036,
            "pseudo_dstar_susp": 0.00033344448149383126,
            "pseudo_tarantula_susp": 0.000564652738565782,
            "pseudo_op2_susp": 0.00033344448149383126,
            "pseudo_barinel_susp": 0.000564334085778781
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis.set_ticks_position#2007",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis.set_ticks_position(self, position)",
        "snippet": "    def set_ticks_position(self, position):\n        \"\"\"\n        Set the ticks position (top, bottom, both, default or none)\n        both sets the ticks to appear on both positions, but does not\n        change the tick labels.  'default' resets the tick positions to\n        the default: ticks on both positions, labels at bottom.  'none'\n        can be used if you don't want any ticks. 'none' and 'both'\n        affect only the ticks, not the labels.\n\n        Parameters\n        ----------\n        position : {'top', 'bottom', 'both', 'default', 'none'}\n        \"\"\"\n        cbook._check_in_list(['top', 'bottom', 'both', 'default', 'none'],\n                             position=position)\n        if position == 'top':\n            self.set_tick_params(which='both', top=True, labeltop=True,\n                                 bottom=False, labelbottom=False)\n            self._tick_position = 'top'\n        elif position == 'bottom':\n            self.set_tick_params(which='both', top=False, labeltop=False,\n                                 bottom=True, labelbottom=True)\n            self._tick_position = 'bottom'\n        elif position == 'both':\n            self.set_tick_params(which='both', top=True,\n                                 bottom=True)\n        elif position == 'none':\n            self.set_tick_params(which='both', top=False,\n                                 bottom=False)\n        elif position == 'default':\n            self.set_tick_params(which='both', top=True, labeltop=False,\n                                 bottom=True, labelbottom=True)\n            self._tick_position = 'bottom'\n        else:\n            assert False, \"unhandled parameter not caught by _check_in_list\"\n        self.stale = True",
        "begin_line": 2007,
        "end_line": 2042,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005194805194805195,
            "pseudo_dstar_susp": 0.0004106776180698152,
            "pseudo_tarantula_susp": 0.0019569471624266144,
            "pseudo_op2_susp": 0.0004106776180698152,
            "pseudo_barinel_susp": 0.0019569471624266144
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis.tick_top#2044",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis.tick_top(self)",
        "snippet": "    def tick_top(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the top of the axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('top')\n        # If labels were turned off before this was called, leave them off.\n        self.set_tick_params(which='both', labeltop=label)",
        "begin_line": 2044,
        "end_line": 2054,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis.get_ticks_position#2068",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis.get_ticks_position(self)",
        "snippet": "    def get_ticks_position(self):\n        \"\"\"\n        Return the ticks position (\"top\", \"bottom\", \"default\", or \"unknown\").\n        \"\"\"\n        return {1: \"bottom\", 2: \"top\",\n                \"default\": \"default\", \"unknown\": \"unknown\"}[\n                    self._get_ticks_position()]",
        "begin_line": 2068,
        "end_line": 2074,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003861003861003861,
            "pseudo_dstar_susp": 0.000355998576005696,
            "pseudo_tarantula_susp": 0.0008077544426494346,
            "pseudo_op2_susp": 0.000355998576005696,
            "pseudo_barinel_susp": 0.0008077544426494346
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis.get_minpos#2081",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis.get_minpos(self)",
        "snippet": "    def get_minpos(self):\n        return self.axes.dataLim.minposx",
        "begin_line": 2081,
        "end_line": 2082,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004923682914820286,
            "pseudo_dstar_susp": 0.0005402485143165856,
            "pseudo_tarantula_susp": 0.0012315270935960591,
            "pseudo_op2_susp": 0.0005402485143165856,
            "pseudo_barinel_susp": 0.0012315270935960591
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis.set_default_intervals#2090",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis.set_default_intervals(self)",
        "snippet": "    def set_default_intervals(self):\n        # docstring inherited\n        xmin, xmax = 0., 1.\n        dataMutated = self.axes.dataLim.mutatedx()\n        viewMutated = self.axes.viewLim.mutatedx()\n        if not dataMutated or not viewMutated:\n            if self.converter is not None:\n                info = self.converter.axisinfo(self.units, self)\n                if info.default_limits is not None:\n                    valmin, valmax = info.default_limits\n                    xmin = self.converter.convert(valmin, self.units, self)\n                    xmax = self.converter.convert(valmax, self.units, self)\n            if not dataMutated:\n                self.axes.dataLim.intervalx = xmin, xmax\n            if not viewMutated:\n                self.axes.viewLim.intervalx = xmin, xmax\n        self.stale = True",
        "begin_line": 2090,
        "end_line": 2106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007401924500370096,
            "pseudo_dstar_susp": 0.00043346337234503684,
            "pseudo_tarantula_susp": 0.002967359050445104,
            "pseudo_op2_susp": 0.00043346337234503684,
            "pseudo_barinel_susp": 0.002967359050445104
        }
    },
    {
        "name": "lib.matplotlib.axis.XAxis.get_tick_space#2108",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.XAxis",
        "signature": "lib.matplotlib.axis.XAxis.get_tick_space(self)",
        "snippet": "    def get_tick_space(self):\n        ends = self.axes.transAxes.transform([[0, 0], [1, 0]])\n        length = ((ends[1][0] - ends[0][0]) / self.axes.figure.dpi) * 72\n        tick = self._get_tick(True)\n        # There is a heuristic here that the aspect ratio of tick text\n        # is no more than 3:1\n        size = tick.label1.get_size() * 3\n        if size > 0:\n            return int(np.floor(length / size))\n        else:\n            return 2**31 - 1",
        "begin_line": 2108,
        "end_line": 2118,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00010185373803218578,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.__init__#2125",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # x in display coords, y in axes coords (to be updated at draw time by\n        # _update_label_positions and _update_offset_text_position).\n        self.label.set(\n            x=0, y=0.5,\n            verticalalignment='bottom', horizontalalignment='center',\n            rotation='vertical', rotation_mode='anchor',\n            transform=mtransforms.blended_transform_factory(\n                mtransforms.IdentityTransform(), self.axes.transAxes),\n        )\n        self.label_position = 'left'\n        # x in axes coords, y in display coords(!).\n        self.offsetText.set(\n            x=0, y=0.5,\n            verticalalignment='baseline', horizontalalignment='left',\n            transform=mtransforms.blended_transform_factory(\n                self.axes.transAxes, mtransforms.IdentityTransform()),\n            fontsize=mpl.rcParams['ytick.labelsize'],\n            color=mpl.rcParams['ytick.color'],\n        )\n        self.offset_text_position = 'left'",
        "begin_line": 2125,
        "end_line": 2146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0027548209366391185,
            "pseudo_dstar_susp": 0.002577319587628866,
            "pseudo_tarantula_susp": 0.0008833922261484099,
            "pseudo_op2_susp": 0.002577319587628866,
            "pseudo_barinel_susp": 0.0008833922261484099
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis._get_tick#2169",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis._get_tick(self, major)",
        "snippet": "    def _get_tick(self, major):\n        if major:\n            tick_kw = self._major_tick_kw\n        else:\n            tick_kw = self._minor_tick_kw\n        return YTick(self.axes, 0, major=major, **tick_kw)",
        "begin_line": 2169,
        "end_line": 2174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002403846153846154,
            "pseudo_dstar_susp": 0.002352941176470588,
            "pseudo_tarantula_susp": 0.0017064846416382253,
            "pseudo_op2_susp": 0.002352941176470588,
            "pseudo_barinel_susp": 0.0017064846416382253
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.set_label_position#2176",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.set_label_position(self, position)",
        "snippet": "    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (left or right)\n\n        Parameters\n        ----------\n        position : {'left', 'right'}\n        \"\"\"\n        self.label.set_rotation_mode('anchor')\n        self.label.set_horizontalalignment('center')\n        self.label.set_verticalalignment(cbook._check_getitem({\n            'left': 'bottom', 'right': 'top',\n        }, position=position))\n        self.label_position = position\n        self.stale = True",
        "begin_line": 2176,
        "end_line": 2190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005107252298263534,
            "pseudo_dstar_susp": 0.0004073319755600815,
            "pseudo_tarantula_susp": 0.0018726591760299626,
            "pseudo_op2_susp": 0.0004073319755600815,
            "pseudo_barinel_susp": 0.0018726591760299626
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis._get_tick_boxes_siblings#2192",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis._get_tick_boxes_siblings(self, renderer)",
        "snippet": "    def _get_tick_boxes_siblings(self, renderer):\n        \"\"\"\n        Get the bounding boxes for this `.axis` and its siblings\n        as set by `.Figure.align_xlabels` or  `.Figure.align_ylablels`.\n\n        By default it just gets bboxes for self.\n        \"\"\"\n        bboxes = []\n        bboxes2 = []\n        # get the Grouper that keeps track of y-label groups for this figure\n        grp = self.figure._align_ylabel_grp\n        # if we want to align labels from other axes:\n        for axx in grp.get_siblings(self.axes):\n            ticks_to_draw = axx.yaxis._update_ticks()\n            tlb, tlb2 = axx.yaxis._get_tick_bboxes(ticks_to_draw, renderer)\n            bboxes.extend(tlb)\n            bboxes2.extend(tlb2)\n        return bboxes, bboxes2",
        "begin_line": 2192,
        "end_line": 2209,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003861003861003861,
            "pseudo_dstar_susp": 0.000355998576005696,
            "pseudo_tarantula_susp": 0.0008077544426494346,
            "pseudo_op2_susp": 0.000355998576005696,
            "pseudo_barinel_susp": 0.0008077544426494346
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis._update_label_position#2211",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis._update_label_position(self, renderer)",
        "snippet": "    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_ylabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n\n        x, y = self.label.get_position()\n        if self.label_position == 'left':\n            try:\n                spine = self.axes.spines['left']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes + [spinebbox])\n            left = bbox.x0\n            self.label.set_position(\n                (left - self.labelpad * self.figure.dpi / 72, y)\n            )\n\n        else:\n            try:\n                spine = self.axes.spines['right']\n                spinebbox = spine.get_transform().transform_path(\n                    spine.get_path()).get_extents()\n            except KeyError:\n                # use axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes2 + [spinebbox])\n            right = bbox.x1\n\n            self.label.set_position(\n                (right + self.labelpad * self.figure.dpi / 72, y)\n            )",
        "begin_line": 2211,
        "end_line": 2251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042607584149978694,
            "pseudo_dstar_susp": 0.0003831417624521073,
            "pseudo_tarantula_susp": 0.0012610340479192938,
            "pseudo_op2_susp": 0.0003831417624521073,
            "pseudo_barinel_susp": 0.0012626262626262627
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.set_offset_position#2264",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.set_offset_position(self, position)",
        "snippet": "    def set_offset_position(self, position):\n        \"\"\"\n        Parameters\n        ----------\n        position : {'left', 'right'}\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        x = cbook._check_getitem({'left': 0, 'right': 1}, position=position)\n\n        self.offsetText.set_ha(position)\n        self.offsetText.set_position((x, y))\n        self.stale = True",
        "begin_line": 2264,
        "end_line": 2275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004752851711026616,
            "pseudo_dstar_susp": 0.00040241448692152917,
            "pseudo_tarantula_susp": 0.0017482517482517483,
            "pseudo_op2_susp": 0.00040241448692152917,
            "pseudo_barinel_susp": 0.0017482517482517483
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.set_ticks_position#2295",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.set_ticks_position(self, position)",
        "snippet": "    def set_ticks_position(self, position):\n        \"\"\"\n        Set the ticks position (left, right, both, default or none)\n        'both' sets the ticks to appear on both positions, but does not\n        change the tick labels.  'default' resets the tick positions to\n        the default: ticks on both positions, labels at left.  'none'\n        can be used if you don't want any ticks. 'none' and 'both'\n        affect only the ticks, not the labels.\n\n        Parameters\n        ----------\n        position : {'left', 'right', 'both', 'default', 'none'}\n        \"\"\"\n        cbook._check_in_list(['left', 'right', 'both', 'default', 'none'],\n                             position=position)\n        if position == 'right':\n            self.set_tick_params(which='both', right=True, labelright=True,\n                                 left=False, labelleft=False)\n            self.set_offset_position(position)\n        elif position == 'left':\n            self.set_tick_params(which='both', right=False, labelright=False,\n                                 left=True, labelleft=True)\n            self.set_offset_position(position)\n        elif position == 'both':\n            self.set_tick_params(which='both', right=True,\n                                 left=True)\n        elif position == 'none':\n            self.set_tick_params(which='both', right=False,\n                                 left=False)\n        elif position == 'default':\n            self.set_tick_params(which='both', right=True, labelright=False,\n                                 left=True, labelleft=True)\n        else:\n            assert False, \"unhandled parameter not caught by _check_in_list\"\n        self.stale = True",
        "begin_line": 2295,
        "end_line": 2329,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004975124378109452,
            "pseudo_dstar_susp": 0.00040404040404040404,
            "pseudo_tarantula_susp": 0.0017921146953405018,
            "pseudo_op2_susp": 0.00040404040404040404,
            "pseudo_barinel_susp": 0.0017921146953405018
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.tick_right#2331",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.tick_right(self)",
        "snippet": "    def tick_right(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the right of the axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('right')\n        # if labels were turned off before this was called\n        # leave them off\n        self.set_tick_params(which='both', labelright=label)",
        "begin_line": 2331,
        "end_line": 2342,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004464285714285714,
            "pseudo_dstar_susp": 0.000390015600624025,
            "pseudo_tarantula_susp": 0.0014858841010401188,
            "pseudo_op2_susp": 0.000390015600624025,
            "pseudo_barinel_susp": 0.001483679525222552
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.tick_left#2344",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.tick_left(self)",
        "snippet": "    def tick_left(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the left of the axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('left')\n        # if labels were turned off before this was called\n        # leave them off\n        self.set_tick_params(which='both', labelleft=label)",
        "begin_line": 2344,
        "end_line": 2355,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.get_minpos#2370",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.get_minpos(self)",
        "snippet": "    def get_minpos(self):\n        return self.axes.dataLim.minposy",
        "begin_line": 2370,
        "end_line": 2371,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 8.252867871585376e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.set_inverted#2373",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.set_inverted(self, inverted)",
        "snippet": "    def set_inverted(self, inverted):\n        # docstring inherited\n        a, b = self.get_view_interval()\n        # cast to bool to avoid bad interaction between python 3.8 and np.bool_\n        self.axes.set_ylim(sorted((a, b), reverse=bool(inverted)), auto=None)",
        "begin_line": 2373,
        "end_line": 2377,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.00021119324181626187,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.set_default_intervals#2379",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.set_default_intervals(self)",
        "snippet": "    def set_default_intervals(self):\n        # docstring inherited\n        ymin, ymax = 0., 1.\n        dataMutated = self.axes.dataLim.mutatedy()\n        viewMutated = self.axes.viewLim.mutatedy()\n        if not dataMutated or not viewMutated:\n            if self.converter is not None:\n                info = self.converter.axisinfo(self.units, self)\n                if info.default_limits is not None:\n                    valmin, valmax = info.default_limits\n                    ymin = self.converter.convert(valmin, self.units, self)\n                    ymax = self.converter.convert(valmax, self.units, self)\n            if not dataMutated:\n                self.axes.dataLim.intervaly = ymin, ymax\n            if not viewMutated:\n                self.axes.viewLim.intervaly = ymin, ymax\n        self.stale = True",
        "begin_line": 2379,
        "end_line": 2395,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 0.0001208313194780087,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    },
    {
        "name": "lib.matplotlib.axis.YAxis.get_tick_space#2397",
        "src_path": "lib/matplotlib/axis.py",
        "class_name": "lib.matplotlib.axis.YAxis",
        "signature": "lib.matplotlib.axis.YAxis.get_tick_space(self)",
        "snippet": "    def get_tick_space(self):\n        ends = self.axes.transAxes.transform([[0, 0], [0, 1]])\n        length = ((ends[1][1] - ends[0][1]) / self.axes.figure.dpi) * 72\n        tick = self._get_tick(True)\n        # Having a spacing of at least 2 just looks good.\n        size = tick.label1.get_size() * 2.0\n        if size > 0:\n            return int(np.floor(length / size))\n        else:\n            return 2**31 - 1",
        "begin_line": 2397,
        "end_line": 2406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00011410314924691921,
            "pseudo_dstar_susp": 0.00011410314924691921,
            "pseudo_tarantula_susp": 0.00011410314924691921,
            "pseudo_op2_susp": 9.19793966151582e-05,
            "pseudo_barinel_susp": 0.00011410314924691921
        }
    }
]