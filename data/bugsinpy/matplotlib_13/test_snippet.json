[
    {
        "name": "lib.matplotlib.tests.test_path.test_empty_closed_path#17",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_empty_closed_path()",
        "snippet": "def test_empty_closed_path():\n    path = Path(np.zeros((0, 2)), closed=True)\n    assert path.vertices.shape == (0, 2)\n    assert path.codes is None",
        "begin_line": 17,
        "end_line": 20,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_readonly_path#23",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_readonly_path()",
        "snippet": "def test_readonly_path():\n    path = Path.unit_circle()\n\n    def modify_vertices():\n        path.vertices = path.vertices * 2.0\n\n    with pytest.raises(AttributeError):\n        modify_vertices()",
        "begin_line": 23,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.modify_vertices#26",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.modify_vertices()",
        "snippet": "    def modify_vertices():\n        path.vertices = path.vertices * 2.0",
        "begin_line": 26,
        "end_line": 27,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_point_in_path#33",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_point_in_path()",
        "snippet": "def test_point_in_path():\n    # Test #1787\n    verts2 = [(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)]\n\n    path = Path(verts2, closed=True)\n    points = [(0.5, 0.5), (1.5, 0.5)]\n    ret = path.contains_points(points)\n    assert ret.dtype == 'bool'\n    np.testing.assert_equal(ret, [True, False])",
        "begin_line": 33,
        "end_line": 41,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_contains_points_negative_radius#44",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_contains_points_negative_radius()",
        "snippet": "def test_contains_points_negative_radius():\n    path = Path.unit_circle()\n\n    points = [(0.0, 0.0), (1.25, 0.0), (0.9, 0.9)]\n    result = path.contains_points(points, radius=-0.5)\n    np.testing.assert_equal(result, [True, False, False])",
        "begin_line": 44,
        "end_line": 49,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_point_in_path_nan#52",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_point_in_path_nan()",
        "snippet": "def test_point_in_path_nan():\n    box = np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])\n    p = Path(box)\n    test = np.array([[np.nan, 0.5]])\n    contains = p.contains_points(test)\n    assert len(contains) == 1\n    assert not contains[0]",
        "begin_line": 52,
        "end_line": 58,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_nonlinear_containment#61",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_nonlinear_containment()",
        "snippet": "def test_nonlinear_containment():\n    fig, ax = plt.subplots()\n    ax.set(xscale=\"log\", ylim=(0, 1))\n    polygon = ax.axvspan(1, 10)\n    assert polygon.get_path().contains_point(\n        ax.transData.transform((5, .5)), ax.transData)\n    assert not polygon.get_path().contains_point(\n        ax.transData.transform((.5, .5)), ax.transData)\n    assert not polygon.get_path().contains_point(\n        ax.transData.transform((50, .5)), ax.transData)",
        "begin_line": 61,
        "end_line": 70,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_arrow_contains_point#75",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_arrow_contains_point()",
        "snippet": "def test_arrow_contains_point():\n    # fix bug (#8384)\n    fig, ax = plt.subplots()\n    ax.set_xlim((0, 2))\n    ax.set_ylim((0, 2))\n\n    # create an arrow with Curve style\n    arrow = patches.FancyArrowPatch((0.5, 0.25), (1.5, 0.75),\n                                    arrowstyle='->',\n                                    mutation_scale=40)\n    ax.add_patch(arrow)\n    # create an arrow with Bracket style\n    arrow1 = patches.FancyArrowPatch((0.5, 1), (1.5, 1.25),\n                                     arrowstyle=']-[',\n                                     mutation_scale=40)\n    ax.add_patch(arrow1)\n    # create an arrow with other arrow style\n    arrow2 = patches.FancyArrowPatch((0.5, 1.5), (1.5, 1.75),\n                                     arrowstyle='fancy',\n                                     fill=False,\n                                     mutation_scale=40)\n    ax.add_patch(arrow2)\n    patches_list = [arrow, arrow1, arrow2]\n\n    # generate some points\n    X, Y = np.meshgrid(np.arange(0, 2, 0.1),\n                       np.arange(0, 2, 0.1))\n    for k, (x, y) in enumerate(zip(X.ravel(), Y.ravel())):\n        xdisp, ydisp = ax.transData.transform([x, y])\n        event = MouseEvent('button_press_event', fig.canvas, xdisp, ydisp)\n        for m, patch in enumerate(patches_list):\n            # set the points to red only if the arrow contains the point\n            inside, res = patch.contains(event)\n            if inside:\n                ax.scatter(x, y, s=5, c=\"r\")",
        "begin_line": 75,
        "end_line": 109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_path_clipping#113",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_path_clipping()",
        "snippet": "def test_path_clipping():\n    fig = plt.figure(figsize=(6.0, 6.2))\n\n    for i, xy in enumerate([\n            [(200, 200), (200, 350), (400, 350), (400, 200)],\n            [(200, 200), (200, 350), (400, 350), (400, 100)],\n            [(200, 100), (200, 350), (400, 350), (400, 100)],\n            [(200, 100), (200, 415), (400, 350), (400, 100)],\n            [(200, 100), (200, 415), (400, 415), (400, 100)],\n            [(200, 415), (400, 415), (400, 100), (200, 100)],\n            [(400, 415), (400, 100), (200, 100), (200, 415)]]):\n        ax = fig.add_subplot(4, 2, i+1)\n        bbox = [0, 140, 640, 260]\n        ax.set_xlim(bbox[0], bbox[0] + bbox[2])\n        ax.set_ylim(bbox[1], bbox[1] + bbox[3])\n        ax.add_patch(Polygon(\n            xy, facecolor='none', edgecolor='red', closed=True))",
        "begin_line": 113,
        "end_line": 129,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_log_transform_with_zero#133",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_log_transform_with_zero()",
        "snippet": "def test_log_transform_with_zero():\n    x = np.arange(-10, 10)\n    y = (1.0 - 1.0/(x**2+1))**20\n\n    fig, ax = plt.subplots()\n    ax.semilogy(x, y, \"-o\", lw=15, markeredgecolor='k')\n    ax.set_ylim(1e-7, 1)\n    ax.grid(True)",
        "begin_line": 133,
        "end_line": 140,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_make_compound_path_empty#143",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_make_compound_path_empty()",
        "snippet": "def test_make_compound_path_empty():\n    # We should be able to make a compound path with no arguments.\n    # This makes it easier to write generic path based code.\n    r = Path.make_compound_path()\n    assert r.vertices.shape == (0, 2)",
        "begin_line": 143,
        "end_line": 147,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_make_compound_path_stops#150",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_make_compound_path_stops()",
        "snippet": "def test_make_compound_path_stops():\n    zero = [0, 0]\n    paths = 3*[Path([zero, zero], [Path.MOVETO, Path.STOP])]\n    compound_path = Path.make_compound_path(*paths)\n    assert np.sum(compound_path.codes == Path.STOP) == 1",
        "begin_line": 150,
        "end_line": 154,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_xkcd#158",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_xkcd()",
        "snippet": "def test_xkcd():\n    np.random.seed(0)\n\n    x = np.linspace(0, 2 * np.pi, 100)\n    y = np.sin(x)\n\n    with plt.xkcd():\n        fig, ax = plt.subplots()\n        ax.plot(x, y)",
        "begin_line": 158,
        "end_line": 166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_xkcd_marker#170",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_xkcd_marker()",
        "snippet": "def test_xkcd_marker():\n    np.random.seed(0)\n\n    x = np.linspace(0, 5, 8)\n    y1 = x\n    y2 = 5 - x\n    y3 = 2.5 * np.ones(8)\n\n    with plt.xkcd():\n        fig, ax = plt.subplots()\n        ax.plot(x, y1, '+', ms=10)\n        ax.plot(x, y2, 'o', ms=10)\n        ax.plot(x, y3, '^', ms=10)",
        "begin_line": 170,
        "end_line": 182,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_marker_paths_pdf#186",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_marker_paths_pdf()",
        "snippet": "def test_marker_paths_pdf():\n    N = 7\n\n    plt.errorbar(np.arange(N),\n                 np.ones(N) + 4,\n                 np.ones(N))\n    plt.xlim(-1, N)\n    plt.ylim(-1, 7)",
        "begin_line": 186,
        "end_line": 193,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_nan_isolated_points#198",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_nan_isolated_points()",
        "snippet": "def test_nan_isolated_points():\n\n    y0 = [0, np.nan, 2, np.nan, 4, 5, 6]\n    y1 = [np.nan, 7, np.nan, 9, 10, np.nan, 12]\n\n    fig, ax = plt.subplots()\n\n    ax.plot(y0, '-o')\n    ax.plot(y1, '-o')",
        "begin_line": 198,
        "end_line": 206,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_path_no_doubled_point_in_to_polygon#209",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_path_no_doubled_point_in_to_polygon()",
        "snippet": "def test_path_no_doubled_point_in_to_polygon():\n    hand = np.array(\n        [[1.64516129, 1.16145833],\n         [1.64516129, 1.59375],\n         [1.35080645, 1.921875],\n         [1.375, 2.18229167],\n         [1.68548387, 1.9375],\n         [1.60887097, 2.55208333],\n         [1.68548387, 2.69791667],\n         [1.76209677, 2.56770833],\n         [1.83064516, 1.97395833],\n         [1.89516129, 2.75],\n         [1.9516129, 2.84895833],\n         [2.01209677, 2.76041667],\n         [1.99193548, 1.99479167],\n         [2.11290323, 2.63020833],\n         [2.2016129, 2.734375],\n         [2.25403226, 2.60416667],\n         [2.14919355, 1.953125],\n         [2.30645161, 2.36979167],\n         [2.39112903, 2.36979167],\n         [2.41532258, 2.1875],\n         [2.1733871, 1.703125],\n         [2.07782258, 1.16666667]])\n\n    (r0, c0, r1, c1) = (1.0, 1.5, 2.1, 2.5)\n\n    poly = Path(np.vstack((hand[:, 1], hand[:, 0])).T, closed=True)\n    clip_rect = transforms.Bbox([[r0, c0], [r1, c1]])\n    poly_clipped = poly.clip_to_bbox(clip_rect).to_polygons()[0]\n\n    assert np.all(poly_clipped[-2] != poly_clipped[-1])\n    assert np.all(poly_clipped[-1] == poly_clipped[0])",
        "begin_line": 209,
        "end_line": 241,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_path_to_polygons#244",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_path_to_polygons()",
        "snippet": "def test_path_to_polygons():\n    data = [[10, 10], [20, 20]]\n    p = Path(data)\n\n    assert_array_equal(p.to_polygons(width=40, height=40), [])\n    assert_array_equal(p.to_polygons(width=40, height=40, closed_only=False),\n                       [data])\n    assert_array_equal(p.to_polygons(), [])\n    assert_array_equal(p.to_polygons(closed_only=False), [data])\n\n    data = [[10, 10], [20, 20], [30, 30]]\n    closed_data = [[10, 10], [20, 20], [30, 30], [10, 10]]\n    p = Path(data)\n\n    assert_array_equal(p.to_polygons(width=40, height=40), [closed_data])\n    assert_array_equal(p.to_polygons(width=40, height=40, closed_only=False),\n                       [data])\n    assert_array_equal(p.to_polygons(), [closed_data])\n    assert_array_equal(p.to_polygons(closed_only=False), [data])",
        "begin_line": 244,
        "end_line": 262,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_path_deepcopy#265",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_path_deepcopy()",
        "snippet": "def test_path_deepcopy():\n    # Should not raise any error\n    verts = [[0, 0], [1, 1]]\n    codes = [Path.MOVETO, Path.LINETO]\n    path1 = Path(verts)\n    path2 = Path(verts, codes)\n    copy.deepcopy(path1)\n    copy.deepcopy(path2)",
        "begin_line": 265,
        "end_line": 272,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_path_intersect_path#278",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_path_intersect_path(phi)",
        "snippet": "def test_path_intersect_path(phi):\n    # test for the range of intersection angles\n    eps_array = [1e-5, 1e-8, 1e-10, 1e-12]\n\n    transform = transforms.Affine2D().rotate(np.deg2rad(phi))\n\n    # a and b intersect at angle phi\n    a = Path([(-2, 0), (2, 0)])\n    b = transform.transform_path(a)\n    assert a.intersects_path(b) and b.intersects_path(a)\n\n    # a and b touch at angle phi at (0, 0)\n    a = Path([(0, 0), (2, 0)])\n    b = transform.transform_path(a)\n    assert a.intersects_path(b) and b.intersects_path(a)\n\n    # a and b are orthogonal and intersect at (0, 3)\n    a = transform.transform_path(Path([(0, 1), (0, 3)]))\n    b = transform.transform_path(Path([(1, 3), (0, 3)]))\n    assert a.intersects_path(b) and b.intersects_path(a)\n\n    # a and b are collinear and intersect at (0, 3)\n    a = transform.transform_path(Path([(0, 1), (0, 3)]))\n    b = transform.transform_path(Path([(0, 5), (0, 3)]))\n    assert a.intersects_path(b) and b.intersects_path(a)\n\n    # self-intersect\n    assert a.intersects_path(a)\n\n    # a contains b\n    a = transform.transform_path(Path([(0, 0), (5, 5)]))\n    b = transform.transform_path(Path([(1, 1), (3, 3)]))\n    assert a.intersects_path(b) and b.intersects_path(a)\n\n    # a and b are collinear but do not intersect\n    a = transform.transform_path(Path([(0, 1), (0, 5)]))\n    b = transform.transform_path(Path([(3, 0), (3, 3)]))\n    assert not a.intersects_path(b) and not b.intersects_path(a)\n\n    # a and b are on the same line but do not intersect\n    a = transform.transform_path(Path([(0, 1), (0, 5)]))\n    b = transform.transform_path(Path([(0, 6), (0, 7)]))\n    assert not a.intersects_path(b) and not b.intersects_path(a)\n\n    # Note: 1e-13 is the absolute tolerance error used for\n    # `isclose` function from src/_path.h\n\n    # a and b are parallel but do not touch\n    for eps in eps_array:\n        a = transform.transform_path(Path([(0, 1), (0, 5)]))\n        b = transform.transform_path(Path([(0 + eps, 1), (0 + eps, 5)]))\n        assert not a.intersects_path(b) and not b.intersects_path(a)\n\n    # a and b are on the same line but do not intersect (really close)\n    for eps in eps_array:\n        a = transform.transform_path(Path([(0, 1), (0, 5)]))\n        b = transform.transform_path(Path([(0, 5 + eps), (0, 7)]))\n        assert not a.intersects_path(b) and not b.intersects_path(a)\n\n    # a and b are on the same line and intersect (really close)\n    for eps in eps_array:\n        a = transform.transform_path(Path([(0, 1), (0, 5)]))\n        b = transform.transform_path(Path([(0, 5 - eps), (0, 7)]))\n        assert a.intersects_path(b) and b.intersects_path(a)\n\n    # b is the same as a but with an extra point\n    a = transform.transform_path(Path([(0, 1), (0, 5)]))\n    b = transform.transform_path(Path([(0, 1), (0, 2), (0, 5)]))\n    assert a.intersects_path(b) and b.intersects_path(a)",
        "begin_line": 278,
        "end_line": 346,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_full_arc#350",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_full_arc(offset)",
        "snippet": "def test_full_arc(offset):\n    low = offset\n    high = 360 + offset\n\n    path = Path.arc(low, high)\n    mins = np.min(path.vertices, axis=0)\n    maxs = np.max(path.vertices, axis=0)\n    np.testing.assert_allclose(mins, -1)\n    np.testing.assert_allclose(maxs, 1)",
        "begin_line": 350,
        "end_line": 358,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_disjoint_zero_length_segment#361",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_disjoint_zero_length_segment()",
        "snippet": "def test_disjoint_zero_length_segment():\n    this_path = Path(\n        np.array([\n            [824.85064295, 2056.26489203],\n            [861.69033931, 2041.00539016],\n            [868.57864109, 2057.63522175],\n            [831.73894473, 2072.89472361],\n            [824.85064295, 2056.26489203]]),\n        np.array([1, 2, 2, 2, 79], dtype=Path.code_type))\n\n    outline_path = Path(\n        np.array([\n            [859.91051028, 2165.38461538],\n            [859.06772495, 2149.30331334],\n            [859.06772495, 2181.46591743],\n            [859.91051028, 2165.38461538],\n            [859.91051028, 2165.38461538]]),\n        np.array([1, 2, 2, 2, 2],\n                 dtype=Path.code_type))\n\n    assert not outline_path.intersects_path(this_path)\n    assert not this_path.intersects_path(outline_path)",
        "begin_line": 361,
        "end_line": 382,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_path.test_intersect_zero_length_segment#385",
        "src_path": "lib/matplotlib/tests/test_path.py",
        "class_name": "lib.matplotlib.tests.test_path",
        "signature": "lib.matplotlib.tests.test_path.test_intersect_zero_length_segment()",
        "snippet": "def test_intersect_zero_length_segment():\n    this_path = Path(\n        np.array([\n            [0, 0],\n            [1, 1],\n        ]))\n\n    outline_path = Path(\n        np.array([\n            [1, 0],\n            [.5, .5],\n            [.5, .5],\n            [0, 1],\n        ]))\n\n    assert outline_path.intersects_path(this_path)\n    assert this_path.intersects_path(outline_path)",
        "begin_line": 385,
        "end_line": 401,
        "comment": "",
        "is_bug": false
    }
]