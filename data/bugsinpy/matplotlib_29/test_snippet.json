[
    {
        "name": "lib.matplotlib.tests.test_axes.test_get_labels#39",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_get_labels()",
        "snippet": "def test_get_labels():\n    fig, ax = plt.subplots()\n    ax.set_xlabel('x label')\n    ax.set_ylabel('y label')\n    assert ax.get_xlabel() == 'x label'\n    assert ax.get_ylabel() == 'y label'",
        "begin_line": 39,
        "end_line": 44,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_acorr#48",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_acorr()",
        "snippet": "def test_acorr():\n    np.random.seed(19680801)\n    n = 512\n    x = np.random.normal(0, 1, n).cumsum()\n\n    fig, ax = plt.subplots()\n    ax.acorr(x, maxlags=n - 1, label='acorr')\n    ax.legend()",
        "begin_line": 48,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_spy#59",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_spy()",
        "snippet": "def test_spy():\n    np.random.seed(19680801)\n    a = np.ones(32 * 32)\n    a[:16 * 32] = 0\n    np.random.shuffle(a)\n    a = np.reshape(a, (32, 32))\n\n    fig, ax = plt.subplots()\n    ax.spy(a)",
        "begin_line": 59,
        "end_line": 67,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_spy_invalid_kwargs#70",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_spy_invalid_kwargs()",
        "snippet": "def test_spy_invalid_kwargs():\n    fig, ax = plt.subplots()\n    for unsupported_kw in [{'interpolation': 'nearest'},\n                           {'marker': 'o', 'linestyle': 'solid'}]:\n        with pytest.raises(TypeError):\n            ax.spy(np.eye(3, 3), **unsupported_kw)",
        "begin_line": 70,
        "end_line": 75,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_matshow#80",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_matshow()",
        "snippet": "def test_matshow():\n    np.random.seed(19680801)\n    a = np.random.rand(32, 32)\n\n    fig, ax = plt.subplots()\n    ax.matshow(a)",
        "begin_line": 80,
        "end_line": 85,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_formatter_ticker#94",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_formatter_ticker()",
        "snippet": "def test_formatter_ticker():\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # This should affect the tick size.  (Tests issue #543)\n    matplotlib.rcParams['lines.markeredgewidth'] = 30\n\n    # This essentially test to see if user specified labels get overwritten\n    # by the auto labeler functionality of the axes.\n    xdata = [x*units.sec for x in range(10)]\n    ydata1 = [(1.5*y - 0.5)*units.km for y in range(10)]\n    ydata2 = [(1.75*y - 1.0)*units.km for y in range(10)]\n\n    fig = plt.figure()\n    ax = plt.subplot(111)\n    ax.set_xlabel(\"x-label 001\")\n\n    fig = plt.figure()\n    ax = plt.subplot(111)\n    ax.set_xlabel(\"x-label 001\")\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n\n    fig = plt.figure()\n    ax = plt.subplot(111)\n    ax.set_xlabel(\"x-label 001\")\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n    ax.set_xlabel(\"x-label 003\")\n\n    fig = plt.figure()\n    ax = plt.subplot(111)\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n    ax.plot(xdata, ydata2, color='green', xunits=\"hour\")\n    ax.set_xlabel(\"x-label 004\")\n\n    # See SF bug 2846058\n    # https://sourceforge.net/tracker/?func=detail&aid=2846058&group_id=80706&atid=560720\n    fig = plt.figure()\n    ax = plt.subplot(111)\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n    ax.plot(xdata, ydata2, color='green', xunits=\"hour\")\n    ax.set_xlabel(\"x-label 005\")\n    ax.autoscale_view()",
        "begin_line": 94,
        "end_line": 135,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twin_axis_locators_formatters#139",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twin_axis_locators_formatters()",
        "snippet": "def test_twin_axis_locators_formatters():\n    vals = np.linspace(0, 1, num=5, endpoint=True)\n    locs = np.sin(np.pi * vals / 2.0)\n\n    majl = plt.FixedLocator(locs)\n    minl = plt.FixedLocator([0.1, 0.2, 0.3])\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(1, 1, 1)\n    ax1.plot([0.1, 100], [0, 1])\n    ax1.yaxis.set_major_locator(majl)\n    ax1.yaxis.set_minor_locator(minl)\n    ax1.yaxis.set_major_formatter(plt.FormatStrFormatter('%08.2lf'))\n    ax1.yaxis.set_minor_formatter(plt.FixedFormatter(['tricks', 'mind',\n                                                      'jedi']))\n\n    ax1.xaxis.set_major_locator(plt.LinearLocator())\n    ax1.xaxis.set_minor_locator(plt.FixedLocator([15, 35, 55, 75]))\n    ax1.xaxis.set_major_formatter(plt.FormatStrFormatter('%05.2lf'))\n    ax1.xaxis.set_minor_formatter(plt.FixedFormatter(['c', '3', 'p', 'o']))\n    ax2 = ax1.twiny()\n    ax3 = ax1.twinx()",
        "begin_line": 139,
        "end_line": 160,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twinx_cla#163",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twinx_cla()",
        "snippet": "def test_twinx_cla():\n    fig, ax = plt.subplots()\n    ax2 = ax.twinx()\n    ax3 = ax2.twiny()\n    plt.draw()\n    assert not ax2.xaxis.get_visible()\n    assert not ax2.patch.get_visible()\n    ax2.cla()\n    ax3.cla()\n\n    assert not ax2.xaxis.get_visible()\n    assert not ax2.patch.get_visible()\n    assert ax2.yaxis.get_visible()\n\n    assert ax3.xaxis.get_visible()\n    assert not ax3.patch.get_visible()\n    assert not ax3.yaxis.get_visible()\n\n    assert ax.xaxis.get_visible()\n    assert ax.patch.get_visible()\n    assert ax.yaxis.get_visible()",
        "begin_line": 163,
        "end_line": 183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twinx_axis_scales#187",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twinx_axis_scales()",
        "snippet": "def test_twinx_axis_scales():\n    x = np.array([0, 0.5, 1])\n    y = 0.5 * x\n    x2 = np.array([0, 1, 2])\n    y2 = 2 * x2\n\n    fig = plt.figure()\n    ax = fig.add_axes((0, 0, 1, 1), autoscalex_on=False, autoscaley_on=False)\n    ax.plot(x, y, color='blue', lw=10)\n\n    ax2 = plt.twinx(ax)\n    ax2.plot(x2, y2, 'r--', lw=5)\n\n    ax.margins(0, 0)\n    ax2.margins(0, 0)",
        "begin_line": 187,
        "end_line": 201,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twin_inherit_autoscale_setting#204",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twin_inherit_autoscale_setting()",
        "snippet": "def test_twin_inherit_autoscale_setting():\n    fig, ax = plt.subplots()\n    ax_x_on = ax.twinx()\n    ax.set_autoscalex_on(False)\n    ax_x_off = ax.twinx()\n\n    assert ax_x_on.get_autoscalex_on()\n    assert not ax_x_off.get_autoscalex_on()\n\n    ax_y_on = ax.twiny()\n    ax.set_autoscaley_on(False)\n    ax_y_off = ax.twiny()\n\n    assert ax_y_on.get_autoscaley_on()\n    assert not ax_y_off.get_autoscaley_on()",
        "begin_line": 204,
        "end_line": 218,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_inverted_cla#221",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_inverted_cla()",
        "snippet": "def test_inverted_cla():\n    # Github PR #5450. Setting autoscale should reset\n    # axes to be non-inverted.\n    # plotting an image, then 1d graph, axis is now down\n    fig = plt.figure(0)\n    ax = fig.gca()\n    # 1. test that a new axis is not inverted per default\n    assert not ax.xaxis_inverted()\n    assert not ax.yaxis_inverted()\n    img = np.random.random((100, 100))\n    ax.imshow(img)\n    # 2. test that a image axis is inverted\n    assert not ax.xaxis_inverted()\n    assert ax.yaxis_inverted()\n    # 3. test that clearing and plotting a line, axes are\n    # not inverted\n    ax.cla()\n    x = np.linspace(0, 2*np.pi, 100)\n    ax.plot(x, np.cos(x))\n    assert not ax.xaxis_inverted()\n    assert not ax.yaxis_inverted()\n\n    # 4. autoscaling should not bring back axes to normal\n    ax.cla()\n    ax.imshow(img)\n    plt.autoscale()\n    assert not ax.xaxis_inverted()\n    assert ax.yaxis_inverted()\n\n    # 5. two shared axes. Inverting the master axis should invert the shared\n    # axes; clearing the master axis should bring axes in shared\n    # axes back to normal.\n    ax0 = plt.subplot(211)\n    ax1 = plt.subplot(212, sharey=ax0)\n    ax0.yaxis.set_inverted(True)\n    assert ax1.yaxis_inverted()\n    ax1.plot(x, np.cos(x))\n    ax0.cla()\n    assert not ax1.yaxis_inverted()\n    ax1.cla()\n    # 6. clearing the nonmaster should not touch limits\n    ax0.imshow(img)\n    ax1.plot(x, np.cos(x))\n    ax1.cla()\n    assert ax.yaxis_inverted()\n\n    # clean up\n    plt.close(fig)",
        "begin_line": 221,
        "end_line": 268,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_minorticks_on_rcParams_both#272",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_minorticks_on_rcParams_both(fig_test, fig_ref)",
        "snippet": "def test_minorticks_on_rcParams_both(fig_test, fig_ref):\n    with matplotlib.rc_context({\"xtick.minor.visible\": True,\n                                \"ytick.minor.visible\": True}):\n        ax_test = fig_test.subplots()\n        ax_test.plot([0, 1], [0, 1])\n    ax_ref = fig_ref.subplots()\n    ax_ref.plot([0, 1], [0, 1])\n    ax_ref.minorticks_on()",
        "begin_line": 272,
        "end_line": 279,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_autoscale_tiny_range#283",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_autoscale_tiny_range()",
        "snippet": "def test_autoscale_tiny_range():\n    # github pull #904\n    fig, axs = plt.subplots(2, 2)\n    for i, ax in enumerate(axs.flat):\n        y1 = 10**(-11 - i)\n        ax.plot([0, 1], [1, 1 + y1])",
        "begin_line": 283,
        "end_line": 288,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_autoscale_tight#292",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_autoscale_tight()",
        "snippet": "def test_autoscale_tight():\n    fig, ax = plt.subplots(1, 1)\n    ax.plot([1, 2, 3, 4])\n    ax.autoscale(enable=True, axis='x', tight=False)\n    ax.autoscale(enable=True, axis='y', tight=True)\n    assert_allclose(ax.get_xlim(), (-0.15, 3.15))\n    assert_allclose(ax.get_ylim(), (1.0, 4.0))",
        "begin_line": 292,
        "end_line": 298,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_autoscale_log_shared#302",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_autoscale_log_shared()",
        "snippet": "def test_autoscale_log_shared():\n    # related to github #7587\n    # array starts at zero to trigger _minpos handling\n    x = np.arange(100, dtype=float)\n    fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\n    ax1.loglog(x, x)\n    ax2.semilogx(x, x)\n    ax1.autoscale(tight=True)\n    ax2.autoscale(tight=True)\n    plt.draw()\n    lims = (x[1], x[-1])\n    assert_allclose(ax1.get_xlim(), lims)\n    assert_allclose(ax1.get_ylim(), lims)\n    assert_allclose(ax2.get_xlim(), lims)\n    assert_allclose(ax2.get_ylim(), (x[0], x[-1]))",
        "begin_line": 302,
        "end_line": 316,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_use_sticky_edges#320",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_use_sticky_edges()",
        "snippet": "def test_use_sticky_edges():\n    fig, ax = plt.subplots()\n    ax.imshow([[0, 1], [2, 3]], origin='lower')\n    assert_allclose(ax.get_xlim(), (-0.5, 1.5))\n    assert_allclose(ax.get_ylim(), (-0.5, 1.5))\n    ax.use_sticky_edges = False\n    ax.autoscale()\n    xlim = (-0.5 - 2 * ax._xmargin, 1.5 + 2 * ax._xmargin)\n    ylim = (-0.5 - 2 * ax._ymargin, 1.5 + 2 * ax._ymargin)\n    assert_allclose(ax.get_xlim(), xlim)\n    assert_allclose(ax.get_ylim(), ylim)\n    # Make sure it is reversible:\n    ax.use_sticky_edges = True\n    ax.autoscale()\n    assert_allclose(ax.get_xlim(), (-0.5, 1.5))\n    assert_allclose(ax.get_ylim(), (-0.5, 1.5))",
        "begin_line": 320,
        "end_line": 335,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_basic_annotate#340",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_basic_annotate()",
        "snippet": "def test_basic_annotate():\n    # Setup some data\n    t = np.arange(0.0, 5.0, 0.01)\n    s = np.cos(2.0*np.pi * t)\n\n    # Offset Points\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, autoscale_on=False, xlim=(-1, 5), ylim=(-3, 5))\n    line, = ax.plot(t, s, lw=3, color='purple')\n\n    ax.annotate('local max', xy=(3, 1), xycoords='data',\n                xytext=(3, 3), textcoords='offset points')",
        "begin_line": 340,
        "end_line": 352,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_arrow_simple#357",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_arrow_simple()",
        "snippet": "def test_arrow_simple():\n    # Simple image test for ax.arrow\n    # kwargs that take discrete values\n    length_includes_head = (True, False)\n    shape = ('full', 'left', 'right')\n    head_starts_at_zero = (True, False)\n    # Create outer product of values\n    kwargs = product(length_includes_head, shape, head_starts_at_zero)\n\n    fig, axs = plt.subplots(3, 4)\n    for i, (ax, kwarg) in enumerate(zip(axs.flat, kwargs)):\n        ax.set_xlim(-2, 2)\n        ax.set_ylim(-2, 2)\n        # Unpack kwargs\n        (length_includes_head, shape, head_starts_at_zero) = kwarg\n        theta = 2 * np.pi * i / 12\n        # Draw arrow\n        ax.arrow(0, 0, np.sin(theta), np.cos(theta),\n                 width=theta/100,\n                 length_includes_head=length_includes_head,\n                 shape=shape,\n                 head_starts_at_zero=head_starts_at_zero,\n                 head_width=theta / 10,\n                 head_length=theta / 10)",
        "begin_line": 357,
        "end_line": 380,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_arrow_empty#383",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_arrow_empty()",
        "snippet": "def test_arrow_empty():\n    _, ax = plt.subplots()\n    # Create an empty FancyArrow\n    ax.arrow(0, 0, 0, 0, head_length=0)",
        "begin_line": 383,
        "end_line": 386,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_annotate_default_arrow#389",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_annotate_default_arrow()",
        "snippet": "def test_annotate_default_arrow():\n    # Check that we can make an annotation arrow with only default properties.\n    fig, ax = plt.subplots()\n    ann = ax.annotate(\"foo\", (0, 1), xytext=(2, 3))\n    assert ann.arrow_patch is None\n    ann = ax.annotate(\"foo\", (0, 1), xytext=(2, 3), arrowprops={})\n    assert ann.arrow_patch is not None",
        "begin_line": 389,
        "end_line": 395,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_annotations#399",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_annotations()",
        "snippet": "def test_polar_annotations():\n    # you can specify the xypoint and the xytext in different\n    # positions and coordinate systems, and optionally turn on a\n    # connecting line and mark the point with a marker.  Annotations\n    # work on polar axes too.  In the example below, the xy point is\n    # in native coordinates (xycoords defaults to 'data').  For a\n    # polar axes, this is in (theta, radius) space.  The text in this\n    # example is placed in the fractional figure coordinate system.\n    # Text keyword args like horizontal and vertical alignment are\n    # respected\n\n    # Setup some data\n    r = np.arange(0.0, 1.0, 0.001)\n    theta = 2.0 * 2.0 * np.pi * r\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, polar=True)\n    line, = ax.plot(theta, r, color='#ee8d18', lw=3)\n    line, = ax.plot((0, 0), (0, 1), color=\"#0000ff\", lw=1)\n\n    ind = 800\n    thisr, thistheta = r[ind], theta[ind]\n    ax.plot([thistheta], [thisr], 'o')\n    ax.annotate('a polar annotation',\n                xy=(thistheta, thisr),  # theta, radius\n                xytext=(0.05, 0.05),    # fraction, fraction\n                textcoords='figure fraction',\n                arrowprops=dict(facecolor='black', shrink=0.05),\n                horizontalalignment='left',\n                verticalalignment='baseline',\n                )\n\n    ax.tick_params(axis='x', tick1On=True, tick2On=True, direction='out')",
        "begin_line": 399,
        "end_line": 431,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_coord_annotations#436",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_coord_annotations()",
        "snippet": "def test_polar_coord_annotations():\n    # You can also use polar notation on a cartesian axes.  Here the\n    # native coordinate system ('data') is cartesian, so you need to\n    # specify the xycoords and textcoords as 'polar' if you want to\n    # use (theta, radius)\n    from matplotlib.patches import Ellipse\n    el = Ellipse((0, 0), 10, 20, facecolor='r', alpha=0.5)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect='equal')\n\n    ax.add_artist(el)\n    el.set_clip_box(ax.bbox)\n\n    ax.annotate('the top',\n                xy=(np.pi/2., 10.),      # theta, radius\n                xytext=(np.pi/3, 20.),   # theta, radius\n                xycoords='polar',\n                textcoords='polar',\n                arrowprops=dict(facecolor='black', shrink=0.05),\n                horizontalalignment='left',\n                verticalalignment='baseline',\n                clip_on=True,  # clip to the axes bounding box\n                )\n\n    ax.set_xlim(-20, 20)\n    ax.set_ylim(-20, 20)",
        "begin_line": 436,
        "end_line": 462,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_alignment#466",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_alignment()",
        "snippet": "def test_polar_alignment():\n    '''\n    Test that changing the vertical/horizontal alignment of a polar graph\n    works as expected '''\n    ranges = [(0, 5), (0, 5)]\n\n    angles = np.arange(0, 360, 90)\n\n    levels = 5\n\n    fig = plt.figure()\n\n    figureSize = [0.1, 0.1, 0.8, 0.8]\n\n    horizontal = fig.add_axes(figureSize, polar=True, label='horizontal')\n    vertical = fig.add_axes(figureSize, polar=True, label='vertical')\n\n    axes = [horizontal, vertical]\n\n    horizontal.set_thetagrids(angles)\n\n    vertical.patch.set_visible(False)\n\n    for i in range(2):\n        grid = np.linspace(*ranges[i], num=levels)\n        gridValues = [0, 0.2, 0.4, 0.6, 0.8, 1]\n        axes[i].set_rgrids(gridValues, angle=angles[i],\n                           horizontalalignment='left',\n                           verticalalignment='top')",
        "begin_line": 466,
        "end_line": 494,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fill_units#499",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fill_units()",
        "snippet": "def test_fill_units():\n    from datetime import datetime\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # generate some data\n    t = units.Epoch(\"ET\", dt=datetime(2009, 4, 27))\n    value = 10.0 * units.deg\n    day = units.Duration(\"ET\", 24.0 * 60.0 * 60.0)\n\n    fig = plt.figure()\n\n    # Top-Left\n    ax1 = fig.add_subplot(221)\n    ax1.plot([t], [value], yunits='deg', color='red')\n    ax1.fill([733525.0, 733525.0, 733526.0, 733526.0],\n             [0.0, 0.0, 90.0, 0.0], 'b')\n\n    # Top-Right\n    ax2 = fig.add_subplot(222)\n    ax2.plot([t], [value], yunits='deg', color='red')\n    ax2.fill([t, t, t + day, t + day],\n             [0.0, 0.0, 90.0, 0.0], 'b')\n\n    # Bottom-Left\n    ax3 = fig.add_subplot(223)\n    ax3.plot([t], [value], yunits='deg', color='red')\n    ax3.fill([733525.0, 733525.0, 733526.0, 733526.0],\n             [0 * units.deg, 0 * units.deg, 90 * units.deg, 0 * units.deg],\n             'b')\n\n    # Bottom-Right\n    ax4 = fig.add_subplot(224)\n    ax4.plot([t], [value], yunits='deg', color='red')\n    ax4.fill([t, t, t + day, t + day],\n             [0 * units.deg, 0 * units.deg, 90 * units.deg, 0 * units.deg],\n             facecolor=\"blue\")\n\n    fig.autofmt_xdate()",
        "begin_line": 499,
        "end_line": 537,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_single_point#541",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_single_point()",
        "snippet": "def test_single_point():\n    # Issue #1796: don't let lines.marker affect the grid\n    matplotlib.rcParams['lines.marker'] = 'o'\n    matplotlib.rcParams['axes.grid'] = True\n\n    fig = plt.figure()\n    plt.subplot(211)\n    plt.plot([0], [0], 'o')\n\n    plt.subplot(212)\n    plt.plot([1], [1], 'o')\n\n    # Reuse testcase from above for a labeled data test\n    data = {'a': [0], 'b': [1]}\n\n    fig = plt.figure()\n    plt.subplot(211)\n    plt.plot('a', 'a', 'o', data=data)\n\n    plt.subplot(212)\n    plt.plot('b', 'b', 'o', data=data)",
        "begin_line": 541,
        "end_line": 561,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_single_date#566",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_single_date()",
        "snippet": "def test_single_date():\n    time1 = [721964.0]\n    data1 = [-65.54]\n\n    fig = plt.figure()\n    plt.subplot(211)\n    plt.plot_date(time1, data1, 'o', color='r')\n\n    plt.subplot(212)\n    plt.plot(time1, data1, 'o', color='r')",
        "begin_line": 566,
        "end_line": 575,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shaped_data#579",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shaped_data()",
        "snippet": "def test_shaped_data():\n    xdata = np.array([[0.53295185, 0.23052951, 0.19057629, 0.66724975,\n                       0.96577916, 0.73136095, 0.60823287, 0.01792100,\n                       0.29744742, 0.27164665],\n                      [0.27980120, 0.25814229, 0.02818193, 0.12966456,\n                       0.57446277, 0.58167607, 0.71028245, 0.69112737,\n                       0.89923072, 0.99072476],\n                      [0.81218578, 0.80464528, 0.76071809, 0.85616314,\n                       0.12757994, 0.94324936, 0.73078663, 0.09658102,\n                       0.60703967, 0.77664978],\n                      [0.28332265, 0.81479711, 0.86985333, 0.43797066,\n                       0.32540082, 0.43819229, 0.92230363, 0.49414252,\n                       0.68168256, 0.05922372],\n                      [0.10721335, 0.93904142, 0.79163075, 0.73232848,\n                       0.90283839, 0.68408046, 0.25502302, 0.95976614,\n                       0.59214115, 0.13663711],\n                      [0.28087456, 0.33127607, 0.15530412, 0.76558121,\n                       0.83389773, 0.03735974, 0.98717738, 0.71432229,\n                       0.54881366, 0.86893953],\n                      [0.77995937, 0.99555600, 0.29688434, 0.15646162,\n                       0.05184800, 0.37161935, 0.12998491, 0.09377296,\n                       0.36882507, 0.36583435],\n                      [0.37851836, 0.05315792, 0.63144617, 0.25003433,\n                       0.69586032, 0.11393988, 0.92362096, 0.88045438,\n                       0.93530252, 0.68275072],\n                      [0.86486596, 0.83236675, 0.82960664, 0.57796630,\n                       0.25724233, 0.84841095, 0.90862812, 0.64414887,\n                       0.35652720, 0.71026066],\n                      [0.01383268, 0.34060930, 0.76084285, 0.70800694,\n                       0.87634056, 0.08213693, 0.54655021, 0.98123181,\n                       0.44080053, 0.86815815]])\n\n    y1 = np.arange(10).reshape((1, -1))\n    y2 = np.arange(10).reshape((-1, 1))\n\n    fig = plt.figure()\n    plt.subplot(411)\n    plt.plot(y1)\n    plt.subplot(412)\n    plt.plot(y2)\n\n    plt.subplot(413)\n    with pytest.raises(ValueError):\n        plt.plot((y1, y2))\n\n    plt.subplot(414)\n    plt.plot(xdata[:, 1], xdata[1, :], 'o')",
        "begin_line": 579,
        "end_line": 625,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_structured_data#628",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_structured_data()",
        "snippet": "def test_structured_data():\n    # support for structured data\n    pts = np.array([(1, 1), (2, 2)], dtype=[(\"ones\", float), (\"twos\", float)])\n\n    # this should not read second name as a format and raise ValueError\n    fig, ax = plt.subplots(2)\n    ax[0].plot(\"ones\", \"twos\", data=pts)\n    ax[1].plot(\"ones\", \"twos\", \"r\", data=pts)",
        "begin_line": 628,
        "end_line": 635,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_const_xy#639",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_const_xy()",
        "snippet": "def test_const_xy():\n    fig = plt.figure()\n\n    plt.subplot(311)\n    plt.plot(np.arange(10), np.ones(10))\n\n    plt.subplot(312)\n    plt.plot(np.ones(10), np.arange(10))\n\n    plt.subplot(313)\n    plt.plot(np.ones(10), np.ones(10), 'o')",
        "begin_line": 639,
        "end_line": 649,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_wrap#654",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_wrap()",
        "snippet": "def test_polar_wrap():\n    fig = plt.figure()\n    plt.subplot(111, polar=True)\n    plt.polar(np.deg2rad([179, -179]), [0.2, 0.1], \"b.-\")\n    plt.polar(np.deg2rad([179,  181]), [0.2, 0.1], \"g.-\")\n    plt.rgrids([0.05, 0.1, 0.15, 0.2, 0.25, 0.3])\n    assert len(fig.axes) == 1, 'More than one polar axes created.'\n\n    fig = plt.figure()\n    plt.subplot(111, polar=True)\n    plt.polar(np.deg2rad([2, -2]), [0.2, 0.1], \"b.-\")\n    plt.polar(np.deg2rad([2, 358]), [0.2, 0.1], \"g.-\")\n    plt.polar(np.deg2rad([358, 2]), [0.2, 0.1], \"r.-\")\n    plt.rgrids([0.05, 0.1, 0.15, 0.2, 0.25, 0.3])",
        "begin_line": 654,
        "end_line": 667,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_units#672",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_units()",
        "snippet": "def test_polar_units():\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    pi = np.pi\n    deg = units.deg\n    km = units.km\n\n    x1 = [pi/6.0, pi/4.0, pi/3.0, pi/2.0]\n    x2 = [30.0*deg, 45.0*deg, 60.0*deg, 90.0*deg]\n\n    y1 = [1.0, 2.0, 3.0, 4.0]\n    y2 = [4.0, 3.0, 2.0, 1.0]\n\n    fig = plt.figure()\n\n    plt.polar(x2, y1, color=\"blue\")\n\n    # polar(x2, y1, color = \"red\", xunits=\"rad\")\n    # polar(x2, y2, color = \"green\")\n\n    fig = plt.figure()\n\n    # make sure runits and theta units work\n    y1 = [y*km for y in y1]\n    plt.polar(x2, y1, color=\"blue\", thetaunits=\"rad\", runits=\"km\")\n    assert isinstance(plt.gca().get_xaxis().get_major_formatter(),\n                      units.UnitDblFormatter)",
        "begin_line": 672,
        "end_line": 699,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_rmin#703",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_rmin()",
        "snippet": "def test_polar_rmin():\n    r = np.arange(0, 3.0, 0.01)\n    theta = 2*np.pi*r\n\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True)\n    ax.plot(theta, r)\n    ax.set_rmax(2.0)\n    ax.set_rmin(0.5)",
        "begin_line": 703,
        "end_line": 711,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_negative_rmin#715",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_negative_rmin()",
        "snippet": "def test_polar_negative_rmin():\n    r = np.arange(-3.0, 0.0, 0.01)\n    theta = 2*np.pi*r\n\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True)\n    ax.plot(theta, r)\n    ax.set_rmax(0.0)\n    ax.set_rmin(-3.0)",
        "begin_line": 715,
        "end_line": 723,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_rorigin#727",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_rorigin()",
        "snippet": "def test_polar_rorigin():\n    r = np.arange(0, 3.0, 0.01)\n    theta = 2*np.pi*r\n\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True)\n    ax.plot(theta, r)\n    ax.set_rmax(2.0)\n    ax.set_rmin(0.5)\n    ax.set_rorigin(0.0)",
        "begin_line": 727,
        "end_line": 736,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_invertedylim#741",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_invertedylim()",
        "snippet": "def test_polar_invertedylim():\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True)\n    ax.set_ylim(2, 0)",
        "begin_line": 741,
        "end_line": 744,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_invertedylim_rorigin#749",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_invertedylim_rorigin()",
        "snippet": "def test_polar_invertedylim_rorigin():\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True)\n    ax.set_ylim(2, 0)\n    ax.set_rorigin(3)",
        "begin_line": 749,
        "end_line": 753,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_theta_position#757",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_theta_position()",
        "snippet": "def test_polar_theta_position():\n    r = np.arange(0, 3.0, 0.01)\n    theta = 2*np.pi*r\n\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True)\n    ax.plot(theta, r)\n    ax.set_theta_zero_location(\"NW\", 30)\n    ax.set_theta_direction('clockwise')",
        "begin_line": 757,
        "end_line": 765,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_rlabel_position#769",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_rlabel_position()",
        "snippet": "def test_polar_rlabel_position():\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='polar')\n    ax.set_rlabel_position(315)\n    ax.tick_params(rotation='auto')",
        "begin_line": 769,
        "end_line": 773,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_theta_limits#777",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_theta_limits()",
        "snippet": "def test_polar_theta_limits():\n    r = np.arange(0, 3.0, 0.01)\n    theta = 2*np.pi*r\n\n    theta_mins = np.arange(15.0, 361.0, 90.0)\n    theta_maxs = np.arange(50.0, 361.0, 90.0)\n    DIRECTIONS = ('out', 'in', 'inout')\n\n    fig, axes = plt.subplots(len(theta_mins), len(theta_maxs),\n                             subplot_kw={'polar': True},\n                             figsize=(8, 6))\n\n    for i, start in enumerate(theta_mins):\n        for j, end in enumerate(theta_maxs):\n            ax = axes[i, j]\n            ax.plot(theta, r)\n            if start < end:\n                ax.set_thetamin(start)\n                ax.set_thetamax(end)\n            else:\n                # Plot with clockwise orientation instead.\n                ax.set_thetamin(end)\n                ax.set_thetamax(start)\n                ax.set_theta_direction('clockwise')\n            ax.tick_params(tick1On=True, tick2On=True,\n                           direction=DIRECTIONS[i % len(DIRECTIONS)],\n                           rotation='auto')\n            ax.yaxis.set_tick_params(label2On=True, rotation='auto')",
        "begin_line": 777,
        "end_line": 804,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_rlim#808",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_rlim(fig_test, fig_ref)",
        "snippet": "def test_polar_rlim(fig_test, fig_ref):\n    ax = fig_test.subplots(subplot_kw={'polar': True})\n    ax.set_rlim(top=10)\n    ax.set_rlim(bottom=.5)\n\n    ax = fig_ref.subplots(subplot_kw={'polar': True})\n    ax.set_rmax(10.)\n    ax.set_rmin(.5)",
        "begin_line": 808,
        "end_line": 815,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_rlim_bottom#819",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_rlim_bottom(fig_test, fig_ref)",
        "snippet": "def test_polar_rlim_bottom(fig_test, fig_ref):\n    ax = fig_test.subplots(subplot_kw={'polar': True})\n    ax.set_rlim(bottom=[.5, 10])\n\n    ax = fig_ref.subplots(subplot_kw={'polar': True})\n    ax.set_rmax(10.)\n    ax.set_rmin(.5)",
        "begin_line": 819,
        "end_line": 825,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axvspan_epoch#829",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axvspan_epoch()",
        "snippet": "def test_axvspan_epoch():\n    from datetime import datetime\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # generate some data\n    t0 = units.Epoch(\"ET\", dt=datetime(2009, 1, 20))\n    tf = units.Epoch(\"ET\", dt=datetime(2009, 1, 21))\n\n    dt = units.Duration(\"ET\", units.day.convert(\"sec\"))\n\n    fig = plt.figure()\n\n    plt.axvspan(t0, tf, facecolor=\"blue\", alpha=0.25)\n\n    ax = plt.gca()\n    ax.set_xlim(t0 - 5.0*dt, tf + 5.0*dt)",
        "begin_line": 829,
        "end_line": 845,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axhspan_epoch#849",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axhspan_epoch()",
        "snippet": "def test_axhspan_epoch():\n    from datetime import datetime\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # generate some data\n    t0 = units.Epoch(\"ET\", dt=datetime(2009, 1, 20))\n    tf = units.Epoch(\"ET\", dt=datetime(2009, 1, 21))\n\n    dt = units.Duration(\"ET\", units.day.convert(\"sec\"))\n\n    fig = plt.figure()\n\n    plt.axhspan(t0, tf, facecolor=\"blue\", alpha=0.25)\n\n    ax = plt.gca()\n    ax.set_ylim(t0 - 5.0*dt, tf + 5.0*dt)",
        "begin_line": 849,
        "end_line": 865,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hexbin_extent#870",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hexbin_extent()",
        "snippet": "def test_hexbin_extent():\n    # this test exposes sf bug 2856228\n    fig, ax = plt.subplots()\n    data = (np.arange(2000) / 2000).reshape((2, 1000))\n    x, y = data\n\n    ax.hexbin(x, y, extent=[.1, .3, .6, .7])\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"x\": x, \"y\": y}\n\n    fig, ax = plt.subplots()\n    ax.hexbin(\"x\", \"y\", extent=[.1, .3, .6, .7], data=data)",
        "begin_line": 870,
        "end_line": 882,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hexbin_empty#887",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hexbin_empty()",
        "snippet": "def test_hexbin_empty():\n    # From #3886: creating hexbin from empty dataset raises ValueError\n    ax = plt.gca()\n    ax.hexbin([], [])",
        "begin_line": 887,
        "end_line": 890,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hexbin_pickable#893",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hexbin_pickable()",
        "snippet": "def test_hexbin_pickable():\n    # From #1973: Test that picking a hexbin collection works\n    class FauxMouseEvent:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n\n    fig, ax = plt.subplots()\n    data = (np.arange(200) / 200).reshape((2, 100))\n    x, y = data\n    hb = ax.hexbin(x, y, extent=[.1, .3, .6, .7], picker=-1)\n\n    assert hb.contains(FauxMouseEvent(400, 300))[0]",
        "begin_line": 893,
        "end_line": 905,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.FauxMouseEvent.test_hexbin_pickable#893",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.FauxMouseEvent",
        "signature": "lib.matplotlib.tests.test_axes.FauxMouseEvent.test_hexbin_pickable()",
        "snippet": "def test_hexbin_pickable():\n    # From #1973: Test that picking a hexbin collection works\n    class FauxMouseEvent:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n\n    fig, ax = plt.subplots()\n    data = (np.arange(200) / 200).reshape((2, 100))\n    x, y = data\n    hb = ax.hexbin(x, y, extent=[.1, .3, .6, .7], picker=-1)\n\n    assert hb.contains(FauxMouseEvent(400, 300))[0]",
        "begin_line": 893,
        "end_line": 905,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.FauxMouseEvent.__init__#896",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.FauxMouseEvent",
        "signature": "lib.matplotlib.tests.test_axes.FauxMouseEvent.__init__(self, x, y)",
        "snippet": "        def __init__(self, x, y):\n            self.x = x\n            self.y = y",
        "begin_line": 896,
        "end_line": 898,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hexbin_log#910",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hexbin_log()",
        "snippet": "def test_hexbin_log():\n    # Issue #1636 (and also test log scaled colorbar)\n    np.random.seed(19680801)\n    n = 100000\n    x = np.random.standard_normal(n)\n    y = 2.0 + 3.0 * x + 4.0 * np.random.standard_normal(n)\n    y = np.power(2, y * 0.5)\n\n    fig, ax = plt.subplots()\n    h = ax.hexbin(x, y, yscale='log', bins='log')\n    plt.colorbar(h)",
        "begin_line": 910,
        "end_line": 920,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_inverted_limits#923",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_inverted_limits()",
        "snippet": "def test_inverted_limits():\n    # Test gh:1553\n    # Calling invert_xaxis prior to plotting should not disable autoscaling\n    # while still maintaining the inverted direction\n    fig, ax = plt.subplots()\n    ax.invert_xaxis()\n    ax.plot([-5, -3, 2, 4], [1, 2, -3, 5])\n\n    assert ax.get_xlim() == (4, -5)\n    assert ax.get_ylim() == (-3, 5)\n    plt.close()\n\n    fig, ax = plt.subplots()\n    ax.invert_yaxis()\n    ax.plot([-5, -3, 2, 4], [1, 2, -3, 5])\n\n    assert ax.get_xlim() == (-5, 4)\n    assert ax.get_ylim() == (5, -3)\n    plt.close()",
        "begin_line": 923,
        "end_line": 941,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_nonfinite_limits#945",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_nonfinite_limits()",
        "snippet": "def test_nonfinite_limits():\n    x = np.arange(0., np.e, 0.01)\n    # silence divide by zero warning from log(0)\n    with np.errstate(divide='ignore'):\n        y = np.log(x)\n    x[len(x)//2] = np.nan\n    fig, ax = plt.subplots()\n    ax.plot(x, y)",
        "begin_line": 945,
        "end_line": 952,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_imshow#957",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_imshow()",
        "snippet": "def test_imshow():\n    # Create a NxN image\n    N = 100\n    (x, y) = np.indices((N, N))\n    x -= N//2\n    y -= N//2\n    r = np.sqrt(x**2+y**2-x*y)\n\n    # Create a contour plot at N/4 and extract both the clip path and transform\n    fig, ax = plt.subplots()\n    ax.imshow(r)\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"r\": r}\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.imshow(\"r\", data=data)",
        "begin_line": 957,
        "end_line": 973,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_imshow_clip#977",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_imshow_clip()",
        "snippet": "def test_imshow_clip():\n    # As originally reported by Gellule Xg <gellule.xg@free.fr>\n\n    # Create a NxN image\n    N = 100\n    (x, y) = np.indices((N, N))\n    x -= N//2\n    y -= N//2\n    r = np.sqrt(x**2+y**2-x*y)\n\n    # Create a contour plot at N/4 and extract both the clip path and transform\n    fig, ax = plt.subplots()\n\n    c = ax.contour(r, [N/4])\n    x = c.collections[0]\n    clipPath = x.get_paths()[0]\n    clipTransform = x.get_transform()\n\n    from matplotlib.transforms import TransformedPath\n    clip_path = TransformedPath(clipPath, clipTransform)\n\n    # Plot the image clipped by the contour\n    ax.imshow(r, clip_path=clip_path)",
        "begin_line": 977,
        "end_line": 999,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polycollection_joinstyle#1004",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polycollection_joinstyle()",
        "snippet": "def test_polycollection_joinstyle():\n    # Bug #2890979 reported by Matthew West\n\n    from matplotlib import collections as mcoll\n\n    fig, ax = plt.subplots()\n    verts = np.array([[1, 1], [1, 2], [2, 2], [2, 1]])\n    c = mcoll.PolyCollection([verts], linewidths=40)\n    ax.add_collection(c)\n    ax.set_xbound(0, 3)\n    ax.set_ybound(0, 3)",
        "begin_line": 1004,
        "end_line": 1014,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fill_between_input#1028",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fill_between_input(x, y1, y2)",
        "snippet": "def test_fill_between_input(x, y1, y2):\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.fill_between(x, y1, y2)",
        "begin_line": 1028,
        "end_line": 1031,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fill_betweenx_input#1045",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fill_betweenx_input(y, x1, x2)",
        "snippet": "def test_fill_betweenx_input(y, x1, x2):\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.fill_betweenx(y, x1, x2)",
        "begin_line": 1045,
        "end_line": 1048,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fill_between_interpolate#1053",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fill_between_interpolate()",
        "snippet": "def test_fill_between_interpolate():\n    x = np.arange(0.0, 2, 0.02)\n    y1 = np.sin(2*np.pi*x)\n    y2 = 1.2*np.sin(4*np.pi*x)\n\n    fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\n    ax1.plot(x, y1, x, y2, color='black')\n    ax1.fill_between(x, y1, y2, where=y2 >= y1, facecolor='white', hatch='/',\n                     interpolate=True)\n    ax1.fill_between(x, y1, y2, where=y2 <= y1, facecolor='red',\n                     interpolate=True)\n\n    # Test support for masked arrays.\n    y2 = np.ma.masked_greater(y2, 1.0)\n    # Test that plotting works for masked arrays with the first element masked\n    y2[0] = np.ma.masked\n    ax2.plot(x, y1, x, y2, color='black')\n    ax2.fill_between(x, y1, y2, where=y2 >= y1, facecolor='green',\n                     interpolate=True)\n    ax2.fill_between(x, y1, y2, where=y2 <= y1, facecolor='red',\n                     interpolate=True)",
        "begin_line": 1053,
        "end_line": 1073,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fill_between_interpolate_decreasing#1078",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fill_between_interpolate_decreasing()",
        "snippet": "def test_fill_between_interpolate_decreasing():\n    p = np.array([724.3, 700, 655])\n    t = np.array([9.4, 7, 2.2])\n    prof = np.array([7.9, 6.6, 3.8])\n\n    fig, ax = plt.subplots(figsize=(9, 9))\n\n    ax.plot(t, p, 'tab:red')\n    ax.plot(prof, p, 'k')\n\n    ax.fill_betweenx(p, t, prof, where=prof < t,\n                     facecolor='blue', interpolate=True, alpha=0.4)\n    ax.fill_betweenx(p, t, prof, where=prof > t,\n                     facecolor='red', interpolate=True, alpha=0.4)\n\n    ax.set_xlim(0, 30)\n    ax.set_ylim(800, 600)",
        "begin_line": 1078,
        "end_line": 1094,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_symlog#1101",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_symlog()",
        "snippet": "def test_symlog():\n    x = np.array([0, 1, 2, 4, 6, 9, 12, 24])\n    y = np.array([1000000, 500000, 100000, 100, 5, 0, 0, 0])\n\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    ax.set_yscale('symlog')\n    ax.set_xscale('linear')\n    ax.set_ylim(-1, 10000000)",
        "begin_line": 1101,
        "end_line": 1109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_symlog2#1114",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_symlog2()",
        "snippet": "def test_symlog2():\n    # Numbers from -50 to 50, with 0.1 as step\n    x = np.arange(-50, 50, 0.001)\n\n    fig, axs = plt.subplots(5, 1)\n    for ax, linthreshx in zip(axs, [20., 2., 1., 0.1, 0.01]):\n        ax.plot(x, x)\n        ax.set_xscale('symlog', linthreshx=linthreshx)\n        ax.grid(True)\n    axs[-1].set_ylim(-0.1, 0.1)",
        "begin_line": 1114,
        "end_line": 1123,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolorargs_5205#1126",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolorargs_5205()",
        "snippet": "def test_pcolorargs_5205():\n    # Smoketest to catch issue found in gh:5205\n    x = [-1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5]\n    y = [-1.5, -1.25, -1.0, -0.75, -0.5, -0.25, 0,\n         0.25, 0.5, 0.75, 1.0, 1.25, 1.5]\n    X, Y = np.meshgrid(x, y)\n    Z = np.hypot(X, Y)\n\n    plt.pcolor(Z)\n    plt.pcolor(list(Z))\n    plt.pcolor(x, y, Z)\n    plt.pcolor(X, Y, list(Z))",
        "begin_line": 1126,
        "end_line": 1137,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolormesh#1141",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolormesh()",
        "snippet": "def test_pcolormesh():\n    n = 12\n    x = np.linspace(-1.5, 1.5, n)\n    y = np.linspace(-1.5, 1.5, n*2)\n    X, Y = np.meshgrid(x, y)\n    Qx = np.cos(Y) - np.cos(X)\n    Qz = np.sin(Y) + np.sin(X)\n    Qx = (Qx + 1.1)\n    Z = np.hypot(X, Y) / 5\n    Z = (Z - Z.min()) / Z.ptp()\n\n    # The color array can include masked values:\n    Zm = ma.masked_where(np.abs(Qz) < 0.5 * np.max(Qz), Z)\n\n    fig, (ax1, ax2, ax3) = plt.subplots(1, 3)\n    ax1.pcolormesh(Qx, Qz, Z, lw=0.5, edgecolors='k')\n    ax2.pcolormesh(Qx, Qz, Z, lw=2, edgecolors=['b', 'w'])\n    ax3.pcolormesh(Qx, Qz, Z, shading=\"gouraud\")",
        "begin_line": 1141,
        "end_line": 1158,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolormesh_datetime_axis#1163",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolormesh_datetime_axis()",
        "snippet": "def test_pcolormesh_datetime_axis():\n    fig = plt.figure()\n    fig.subplots_adjust(hspace=0.4, top=0.98, bottom=.15)\n    base = datetime.datetime(2013, 1, 1)\n    x = np.array([base + datetime.timedelta(days=d) for d in range(21)])\n    y = np.arange(21)\n    z1, z2 = np.meshgrid(np.arange(20), np.arange(20))\n    z = z1 * z2\n    plt.subplot(221)\n    plt.pcolormesh(x[:-1], y[:-1], z)\n    plt.subplot(222)\n    plt.pcolormesh(x, y, z)\n    x = np.repeat(x[np.newaxis], 21, axis=0)\n    y = np.repeat(y[:, np.newaxis], 21, axis=1)\n    plt.subplot(223)\n    plt.pcolormesh(x[:-1, :-1], y[:-1, :-1], z)\n    plt.subplot(224)\n    plt.pcolormesh(x, y, z)\n    for ax in fig.get_axes():\n        for label in ax.get_xticklabels():\n            label.set_ha('right')\n            label.set_rotation(30)",
        "begin_line": 1163,
        "end_line": 1184,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolor_datetime_axis#1189",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolor_datetime_axis()",
        "snippet": "def test_pcolor_datetime_axis():\n    fig = plt.figure()\n    fig.subplots_adjust(hspace=0.4, top=0.98, bottom=.15)\n    base = datetime.datetime(2013, 1, 1)\n    x = np.array([base + datetime.timedelta(days=d) for d in range(21)])\n    y = np.arange(21)\n    z1, z2 = np.meshgrid(np.arange(20), np.arange(20))\n    z = z1 * z2\n    plt.subplot(221)\n    plt.pcolor(x[:-1], y[:-1], z)\n    plt.subplot(222)\n    plt.pcolor(x, y, z)\n    x = np.repeat(x[np.newaxis], 21, axis=0)\n    y = np.repeat(y[:, np.newaxis], 21, axis=1)\n    plt.subplot(223)\n    plt.pcolor(x[:-1, :-1], y[:-1, :-1], z)\n    plt.subplot(224)\n    plt.pcolor(x, y, z)\n    for ax in fig.get_axes():\n        for label in ax.get_xticklabels():\n            label.set_ha('right')\n            label.set_rotation(30)",
        "begin_line": 1189,
        "end_line": 1210,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolorargs#1213",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolorargs()",
        "snippet": "def test_pcolorargs():\n    n = 12\n    x = np.linspace(-1.5, 1.5, n)\n    y = np.linspace(-1.5, 1.5, n*2)\n    X, Y = np.meshgrid(x, y)\n    Z = np.hypot(X, Y) / 5\n\n    _, ax = plt.subplots()\n    with pytest.raises(TypeError):\n        ax.pcolormesh(y, x, Z)\n    with pytest.raises(TypeError):\n        ax.pcolormesh(X, Y, Z.T)\n    with pytest.raises(TypeError):\n        ax.pcolormesh(x, y, Z[:-1, :-1], shading=\"gouraud\")\n    with pytest.raises(TypeError):\n        ax.pcolormesh(X, Y, Z[:-1, :-1], shading=\"gouraud\")\n    x[0] = np.NaN\n    with pytest.raises(ValueError):\n        ax.pcolormesh(x, y, Z[:-1, :-1])\n    with np.errstate(invalid='ignore'):\n        x = np.ma.array(x, mask=(x < 0))\n    with pytest.raises(ValueError):\n        ax.pcolormesh(x, y, Z[:-1, :-1])",
        "begin_line": 1213,
        "end_line": 1235,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_canonical#1239",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_canonical()",
        "snippet": "def test_canonical():\n    fig, ax = plt.subplots()\n    ax.plot([1, 2, 3])",
        "begin_line": 1239,
        "end_line": 1241,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_arc_angles#1246",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_arc_angles()",
        "snippet": "def test_arc_angles():\n    from matplotlib import patches\n    # Ellipse parameters\n    w = 2\n    h = 1\n    centre = (0.2, 0.5)\n    scale = 2\n\n    fig, axs = plt.subplots(3, 3)\n    for i, ax in enumerate(axs.flat):\n        theta2 = i * 360 / 9\n        theta1 = theta2 - 45\n\n        ax.add_patch(patches.Ellipse(centre, w, h, alpha=0.3))\n        ax.add_patch(patches.Arc(centre, w, h, theta1=theta1, theta2=theta2))\n        # Straight lines intersecting start and end of arc\n        ax.plot([scale * np.cos(np.deg2rad(theta1)) + centre[0],\n                 centre[0],\n                 scale * np.cos(np.deg2rad(theta2)) + centre[0]],\n                [scale * np.sin(np.deg2rad(theta1)) + centre[1],\n                 centre[1],\n                 scale * np.sin(np.deg2rad(theta2)) + centre[1]])\n\n        ax.set_xlim(-scale, scale)\n        ax.set_ylim(-scale, scale)\n\n        # This looks the same, but it triggers a different code path when it\n        # gets large enough.\n        w *= 10\n        h *= 10\n        centre = (centre[0] * 10, centre[1] * 10)\n        scale *= 10",
        "begin_line": 1246,
        "end_line": 1277,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_arc_ellipse#1282",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_arc_ellipse()",
        "snippet": "def test_arc_ellipse():\n    from matplotlib import patches\n    xcenter, ycenter = 0.38, 0.52\n    width, height = 1e-1, 3e-1\n    angle = -30\n\n    theta = np.deg2rad(np.arange(360))\n    x = width / 2. * np.cos(theta)\n    y = height / 2. * np.sin(theta)\n\n    rtheta = np.deg2rad(angle)\n    R = np.array([\n        [np.cos(rtheta), -np.sin(rtheta)],\n        [np.sin(rtheta), np.cos(rtheta)]])\n\n    x, y = np.dot(R, np.array([x, y]))\n    x += xcenter\n    y += ycenter\n\n    fig = plt.figure()\n    ax = fig.add_subplot(211, aspect='auto')\n    ax.fill(x, y, alpha=0.2, facecolor='yellow', edgecolor='yellow',\n            linewidth=1, zorder=1)\n\n    e1 = patches.Arc((xcenter, ycenter), width, height,\n                     angle=angle, linewidth=2, fill=False, zorder=2)\n\n    ax.add_patch(e1)\n\n    ax = fig.add_subplot(212, aspect='equal')\n    ax.fill(x, y, alpha=0.2, facecolor='green', edgecolor='green', zorder=1)\n    e2 = patches.Arc((xcenter, ycenter), width, height,\n                     angle=angle, linewidth=2, fill=False, zorder=2)\n\n    ax.add_patch(e2)",
        "begin_line": 1282,
        "end_line": 1316,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery#1321",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery()",
        "snippet": "def test_markevery():\n    x = np.linspace(0, 10, 100)\n    y = np.sin(x) * np.sqrt(x/10 + 0.5)\n\n    # check marker only plot\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x, y, 'o', label='default')\n    ax.plot(x, y, 'd', markevery=None, label='mark all')\n    ax.plot(x, y, 's', markevery=10, label='mark every 10')\n    ax.plot(x, y, '+', markevery=(5, 20), label='mark every 5 starting at 10')\n    ax.legend()",
        "begin_line": 1321,
        "end_line": 1332,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery_line#1337",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery_line()",
        "snippet": "def test_markevery_line():\n    x = np.linspace(0, 10, 100)\n    y = np.sin(x) * np.sqrt(x/10 + 0.5)\n\n    # check line/marker combos\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x, y, '-o', label='default')\n    ax.plot(x, y, '-d', markevery=None, label='mark all')\n    ax.plot(x, y, '-s', markevery=10, label='mark every 10')\n    ax.plot(x, y, '-+', markevery=(5, 20), label='mark every 5 starting at 10')\n    ax.legend()",
        "begin_line": 1337,
        "end_line": 1348,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery_linear_scales#1353",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery_linear_scales()",
        "snippet": "def test_markevery_linear_scales():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    delta = 0.11\n    x = np.linspace(0, 10 - 2 * delta, 200) + delta\n    y = np.sin(x) + 1.0 + delta\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col])\n        plt.title('markevery=%s' % str(case))\n        plt.plot(x, y, 'o', ls='-', ms=4,  markevery=case)",
        "begin_line": 1353,
        "end_line": 1374,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery_linear_scales_zoomed#1379",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery_linear_scales_zoomed()",
        "snippet": "def test_markevery_linear_scales_zoomed():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    delta = 0.11\n    x = np.linspace(0, 10 - 2 * delta, 200) + delta\n    y = np.sin(x) + 1.0 + delta\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col])\n        plt.title('markevery=%s' % str(case))\n        plt.plot(x, y, 'o', ls='-', ms=4,  markevery=case)\n        plt.xlim((6, 6.7))\n        plt.ylim((1.1, 1.7))",
        "begin_line": 1379,
        "end_line": 1402,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery_log_scales#1407",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery_log_scales()",
        "snippet": "def test_markevery_log_scales():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    delta = 0.11\n    x = np.linspace(0, 10 - 2 * delta, 200) + delta\n    y = np.sin(x) + 1.0 + delta\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col])\n        plt.title('markevery=%s' % str(case))\n        plt.xscale('log')\n        plt.yscale('log')\n        plt.plot(x, y, 'o', ls='-', ms=4,  markevery=case)",
        "begin_line": 1407,
        "end_line": 1430,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery_polar#1435",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery_polar()",
        "snippet": "def test_markevery_polar():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    r = np.linspace(0, 3.0, 200)\n    theta = 2 * np.pi * r\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col], polar=True)\n        plt.title('markevery=%s' % str(case))\n        plt.plot(theta, r, 'o', ls='-', ms=4,  markevery=case)",
        "begin_line": 1435,
        "end_line": 1455,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_marker_edges#1460",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_marker_edges()",
        "snippet": "def test_marker_edges():\n    x = np.linspace(0, 1, 10)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x, np.sin(x), 'y.', ms=30.0, mew=0, mec='r')\n    ax.plot(x+0.1, np.sin(x), 'y.', ms=30.0, mew=1, mec='r')\n    ax.plot(x+0.2, np.sin(x), 'y.', ms=30.0, mew=2, mec='b')",
        "begin_line": 1460,
        "end_line": 1466,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_tick_label_single#1472",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_tick_label_single()",
        "snippet": "def test_bar_tick_label_single():\n    # From 2516: plot bar with array of string labels for x axis\n    ax = plt.gca()\n    ax.bar(0, 1, align='edge', tick_label='0')\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"a\": 0, \"b\": 1}\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax = plt.gca()\n    ax.bar(\"a\", \"b\", align='edge', tick_label='0', data=data)",
        "begin_line": 1472,
        "end_line": 1482,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_ticklabel_fail#1485",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_ticklabel_fail()",
        "snippet": "def test_bar_ticklabel_fail():\n    fig, ax = plt.subplots()\n    ax.bar([], [])",
        "begin_line": 1485,
        "end_line": 1487,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_tick_label_multiple#1492",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_tick_label_multiple()",
        "snippet": "def test_bar_tick_label_multiple():\n    # From 2516: plot bar with array of string labels for x axis\n    ax = plt.gca()\n    ax.bar([1, 2.5], [1, 2], width=[0.2, 0.5], tick_label=['a', 'b'],\n           align='center')",
        "begin_line": 1492,
        "end_line": 1496,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_tick_label_multiple_old_alignment#1502",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_tick_label_multiple_old_alignment()",
        "snippet": "def test_bar_tick_label_multiple_old_alignment():\n    # Test that the alignment for class is backward compatible\n    matplotlib.rcParams[\"ytick.alignment\"] = \"center\"\n    ax = plt.gca()\n    ax.bar([1, 2.5], [1, 2], width=[0.2, 0.5], tick_label=['a', 'b'],\n           align='center')",
        "begin_line": 1502,
        "end_line": 1507,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_color_none_alpha#1510",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_color_none_alpha()",
        "snippet": "def test_bar_color_none_alpha():\n    ax = plt.gca()\n    rects = ax.bar([1, 2], [2, 4], alpha=0.3, color='none', edgecolor='r')\n    for rect in rects:\n        assert rect.get_facecolor() == (0, 0, 0, 0)\n        assert rect.get_edgecolor() == (1, 0, 0, 0.3)",
        "begin_line": 1510,
        "end_line": 1515,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_edgecolor_none_alpha#1518",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_edgecolor_none_alpha()",
        "snippet": "def test_bar_edgecolor_none_alpha():\n    ax = plt.gca()\n    rects = ax.bar([1, 2], [2, 4], alpha=0.3, color='r', edgecolor='none')\n    for rect in rects:\n        assert rect.get_facecolor() == (1, 0, 0, 0.3)\n        assert rect.get_edgecolor() == (0, 0, 0, 0)",
        "begin_line": 1518,
        "end_line": 1523,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_barh_tick_label#1528",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_barh_tick_label()",
        "snippet": "def test_barh_tick_label():\n    # From 2516: plot barh with array of string labels for y axis\n    ax = plt.gca()\n    ax.barh([1, 2.5], [1, 2], height=[0.2, 0.5], tick_label=['a', 'b'],\n            align='center')",
        "begin_line": 1528,
        "end_line": 1532,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_timedelta#1535",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_timedelta()",
        "snippet": "def test_bar_timedelta():\n    \"\"\"smoketest that bar can handle width and height in delta units\"\"\"\n    fig, ax = plt.subplots()\n    ax.bar(datetime.datetime(2018, 1, 1), 1.,\n           width=datetime.timedelta(hours=3))\n    ax.bar(datetime.datetime(2018, 1, 1), 1.,\n           xerr=datetime.timedelta(hours=2),\n           width=datetime.timedelta(hours=3))\n    fig, ax = plt.subplots()\n    ax.barh(datetime.datetime(2018, 1, 1), 1,\n            height=datetime.timedelta(hours=3))\n    ax.barh(datetime.datetime(2018, 1, 1), 1,\n            height=datetime.timedelta(hours=3),\n            yerr=datetime.timedelta(hours=2))\n    fig, ax = plt.subplots()\n    ax.barh([datetime.datetime(2018, 1, 1), datetime.datetime(2018, 1, 1)],\n            np.array([1, 1.5]),\n            height=datetime.timedelta(hours=3))\n    ax.barh([datetime.datetime(2018, 1, 1), datetime.datetime(2018, 1, 1)],\n            np.array([1, 1.5]),\n            height=[datetime.timedelta(hours=t) for t in [1, 2]])\n    ax.broken_barh([(datetime.datetime(2018, 1, 1),\n                     datetime.timedelta(hours=1))],\n                   (10, 20))",
        "begin_line": 1535,
        "end_line": 1558,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_dates_pandas#1561",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_dates_pandas(pd)",
        "snippet": "def test_boxplot_dates_pandas(pd):\n    # smoke test for boxplot and dates in pandas\n    data = np.random.rand(5, 2)\n    years = pd.date_range('1/1/2000',\n                          periods=2, freq=pd.DateOffset(years=1)).year\n    plt.figure()\n    plt.boxplot(data, positions=years)",
        "begin_line": 1561,
        "end_line": 1567,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_pandas#1570",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_pandas(pd)",
        "snippet": "def test_bar_pandas(pd):\n    # Smoke test for pandas\n\n    fig, ax = plt.subplots()\n\n    df = pd.DataFrame(\n        {'year': [2018, 2018, 2018],\n         'month': [1, 1, 1],\n         'day': [1, 2, 3],\n         'value': [1, 2, 3]})\n    df['date'] = pd.to_datetime(df[['year', 'month', 'day']])\n\n    monthly = df[['date', 'value']].groupby(['date']).sum()\n    dates = monthly.index\n    forecast = monthly['value']\n    baseline = monthly['value']\n    ax.bar(dates, forecast, width=10, align='center')\n    ax.plot(dates, baseline, color='orange', lw=4)",
        "begin_line": 1570,
        "end_line": 1587,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_log#1592",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_log()",
        "snippet": "def test_hist_log():\n    data0 = np.linspace(0, 1, 200)**3\n    data = np.r_[1-data0, 1+data0]\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(data, fill=False, log=True)",
        "begin_line": 1592,
        "end_line": 1597,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_bar_empty#1602",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_bar_empty()",
        "snippet": "def test_hist_bar_empty():\n    # From #3886: creating hist from empty dataset raises ValueError\n    ax = plt.gca()\n    ax.hist([], histtype='bar')",
        "begin_line": 1602,
        "end_line": 1605,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_empty#1610",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_empty()",
        "snippet": "def test_hist_step_empty():\n    # From #3886: creating hist from empty dataset raises ValueError\n    ax = plt.gca()\n    ax.hist([], histtype='step')",
        "begin_line": 1610,
        "end_line": 1613,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_steplog#1617",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_steplog()",
        "snippet": "def test_hist_steplog():\n    np.random.seed(0)\n    data = np.random.standard_normal(2000)\n    data += -2.0 - np.min(data)\n    data_pos = data + 2.1\n    data_big = data_pos + 30\n    weights = np.ones_like(data) * 1.e-5\n\n    ax = plt.subplot(4, 1, 1)\n    plt.hist(data, 100, histtype='stepfilled', log=True)\n\n    ax = plt.subplot(4, 1, 2)\n    plt.hist(data_pos, 100, histtype='stepfilled', log=True)\n\n    ax = plt.subplot(4, 1, 3)\n    plt.hist(data, 100, weights=weights, histtype='stepfilled', log=True)\n\n    ax = plt.subplot(4, 1, 4)\n    plt.hist(data_big, 100, histtype='stepfilled', log=True,\n             orientation='horizontal')",
        "begin_line": 1617,
        "end_line": 1636,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_filled#1641",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_filled()",
        "snippet": "def test_hist_step_filled():\n    np.random.seed(0)\n    x = np.random.randn(1000, 3)\n    n_bins = 10\n\n    kwargs = [{'fill': True}, {'fill': False}, {'fill': None}, {}]*2\n    types = ['step']*4+['stepfilled']*4\n    fig, axes = plt.subplots(nrows=2, ncols=4)\n    axes = axes.flatten()\n\n    for kg, _type, ax in zip(kwargs, types, axes):\n        ax.hist(x, n_bins, histtype=_type, stacked=True, **kg)\n        ax.set_title('%s/%s' % (kg, _type))\n        ax.set_ylim(bottom=-50)\n\n    patches = axes[0].patches\n    assert all(p.get_facecolor() == p.get_edgecolor() for p in patches)",
        "begin_line": 1641,
        "end_line": 1657,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_density#1661",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_density()",
        "snippet": "def test_hist_density():\n    np.random.seed(19680801)\n    data = np.random.standard_normal(2000)\n    fig, ax = plt.subplots()\n    ax.hist(data, density=True)",
        "begin_line": 1661,
        "end_line": 1665,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_log_bottom#1670",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_log_bottom()",
        "snippet": "def test_hist_step_log_bottom():\n    # check that bottom doesn't get overwritten by the 'minimum' on a\n    # log scale histogram (https://github.com/matplotlib/matplotlib/pull/4608)\n    np.random.seed(0)\n    data = np.random.standard_normal(2000)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    # normal hist (should clip minimum to 1/base)\n    ax.hist(data, bins=10, log=True, histtype='stepfilled',\n            alpha=0.5, color='b')\n    # manual bottom < 1/base (previously buggy, see #4608)\n    ax.hist(data, bins=10, log=True, histtype='stepfilled',\n            alpha=0.5, color='g', bottom=1e-2)\n    # manual bottom > 1/base\n    ax.hist(data, bins=10, log=True, histtype='stepfilled',\n            alpha=0.5, color='r', bottom=0.5)\n    # array bottom with some less than 1/base (should clip to 1/base)\n    ax.hist(data, bins=10, log=True, histtype='stepfilled',\n            alpha=0.5, color='y', bottom=np.arange(10))\n    ax.set_ylim(9e-3, 1e3)",
        "begin_line": 1670,
        "end_line": 1689,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_unequal_bins_density#1692",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_unequal_bins_density()",
        "snippet": "def test_hist_unequal_bins_density():\n    # Test correct behavior of normalized histogram with unequal bins\n    # https://github.com/matplotlib/matplotlib/issues/9557\n    rng = np.random.RandomState(57483)\n    t = rng.randn(100)\n    bins = [-3, -1, -0.5, 0, 1, 5]\n    mpl_heights, _, _ = plt.hist(t, bins=bins, density=True)\n    np_heights, _ = np.histogram(t, bins=bins, density=True)\n    assert_allclose(mpl_heights, np_heights)",
        "begin_line": 1692,
        "end_line": 1700,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_datetime_datasets#1703",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_datetime_datasets()",
        "snippet": "def test_hist_datetime_datasets():\n    data = [[datetime.datetime(2017, 1, 1), datetime.datetime(2017, 1, 1)],\n            [datetime.datetime(2017, 1, 1), datetime.datetime(2017, 1, 2)]]\n    fig, ax = plt.subplots()\n    ax.hist(data, stacked=True)\n    ax.hist(data, stacked=False)",
        "begin_line": 1703,
        "end_line": 1708,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_with_empty_input#1715",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_with_empty_input(data, expected_number_of_hists)",
        "snippet": "def test_hist_with_empty_input(data, expected_number_of_hists):\n    hists, _, _ = plt.hist(data)\n    hists = np.asarray(hists)\n\n    if hists.ndim == 1:\n        assert 1 == expected_number_of_hists\n    else:\n        assert hists.shape[0] == expected_number_of_hists",
        "begin_line": 1715,
        "end_line": 1722,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.contour_dat#1725",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.contour_dat()",
        "snippet": "def contour_dat():\n    x = np.linspace(-3, 5, 150)\n    y = np.linspace(-3, 5, 120)\n    z = np.cos(x) + np.sin(y[:, np.newaxis])\n    return x, y, z",
        "begin_line": 1725,
        "end_line": 1729,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_contour_hatching#1734",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_contour_hatching()",
        "snippet": "def test_contour_hatching():\n    x, y, z = contour_dat()\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    cs = ax.contourf(x, y, z, 7, hatches=['/', '\\\\', '//', '-'],\n                     cmap=plt.get_cmap('gray'),\n                     extend='both', alpha=0.5)",
        "begin_line": 1734,
        "end_line": 1741,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_contour_colorbar#1746",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_contour_colorbar()",
        "snippet": "def test_contour_colorbar():\n    x, y, z = contour_dat()\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    cs = ax.contourf(x, y, z, levels=np.arange(-1.8, 1.801, 0.2),\n                     cmap=plt.get_cmap('RdBu'),\n                     vmin=-0.6,\n                     vmax=0.6,\n                     extend='both')\n    cs1 = ax.contour(x, y, z, levels=np.arange(-2.2, -0.599, 0.2),\n                     colors=['y'],\n                     linestyles='solid',\n                     linewidths=2)\n    cs2 = ax.contour(x, y, z, levels=np.arange(0.6, 2.2, 0.2),\n                     colors=['c'],\n                     linewidths=2)\n    cbar = fig.colorbar(cs, ax=ax)\n    cbar.add_lines(cs1)\n    cbar.add_lines(cs2, erase=False)",
        "begin_line": 1746,
        "end_line": 1765,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist2d#1770",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist2d()",
        "snippet": "def test_hist2d():\n    np.random.seed(0)\n    # make it not symmetric in case we switch x and y axis\n    x = np.random.randn(100)*2+5\n    y = np.random.randn(100)-2\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist2d(x, y, bins=10, rasterized=True)\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"x\": x, \"y\": y}\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist2d(\"x\", \"y\", bins=10, data=data, rasterized=True)",
        "begin_line": 1770,
        "end_line": 1783,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist2d_transpose#1788",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist2d_transpose()",
        "snippet": "def test_hist2d_transpose():\n    np.random.seed(0)\n    # make sure the output from np.histogram is transposed before\n    # passing to pcolorfast\n    x = np.array([5]*100)\n    y = np.random.randn(100)-2\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist2d(x, y, bins=10, rasterized=True)",
        "begin_line": 1788,
        "end_line": 1796,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist2d_density_normed#1799",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist2d_density_normed()",
        "snippet": "def test_hist2d_density_normed():\n    x, y = np.random.random((2, 100))\n    ax = plt.figure().subplots()\n    for obj in [ax, plt]:\n        obj.hist2d(x, y, density=True)\n        with pytest.warns(MatplotlibDeprecationWarning):\n            obj.hist2d(x, y, normed=True)\n        with pytest.warns(MatplotlibDeprecationWarning):\n            obj.hist2d(x, y, density=True, normed=True)",
        "begin_line": 1799,
        "end_line": 1807,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_plot#1813",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_plot(self)",
        "snippet": "    def test_scatter_plot(self):\n        data = {\"x\": np.array([3, 4, 2, 6]), \"y\": np.array([2, 5, 2, 3]),\n                \"c\": ['r', 'y', 'b', 'lime'], \"s\": [24, 15, 19, 29],\n                \"c2\": ['0.5', '0.6', '0.7', '0.8']}\n\n        fig, ax = plt.subplots()\n        ax.scatter(data[\"x\"] - 1., data[\"y\"] - 1., c=data[\"c\"], s=data[\"s\"])\n        ax.scatter(data[\"x\"] + 1., data[\"y\"] + 1., c=data[\"c2\"], s=data[\"s\"])\n        ax.scatter(\"x\", \"y\", c=\"c\", s=\"s\", data=data)",
        "begin_line": 1813,
        "end_line": 1821,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_marker#1825",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_marker(self)",
        "snippet": "    def test_scatter_marker(self):\n        fig, (ax0, ax1, ax2) = plt.subplots(ncols=3)\n        ax0.scatter([3, 4, 2, 6], [2, 5, 2, 3],\n                    c=[(1, 0, 0), 'y', 'b', 'lime'],\n                    s=[60, 50, 40, 30],\n                    edgecolors=['k', 'r', 'g', 'b'],\n                    marker='s')\n        ax1.scatter([3, 4, 2, 6], [2, 5, 2, 3],\n                    c=[(1, 0, 0), 'y', 'b', 'lime'],\n                    s=[60, 50, 40, 30],\n                    edgecolors=['k', 'r', 'g', 'b'],\n                    marker=mmarkers.MarkerStyle('o', fillstyle='top'))\n        # unit area ellipse\n        rx, ry = 3, 1\n        area = rx * ry * np.pi\n        theta = np.linspace(0, 2 * np.pi, 21)\n        verts = np.column_stack([np.cos(theta) * rx / area,\n                                 np.sin(theta) * ry / area])\n        ax2.scatter([3, 4, 2, 6], [2, 5, 2, 3],\n                    c=[(1, 0, 0), 'y', 'b', 'lime'],\n                    s=[60, 50, 40, 30],\n                    edgecolors=['k', 'r', 'g', 'b'],\n                    marker=verts)",
        "begin_line": 1825,
        "end_line": 1847,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_2D#1851",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_2D(self)",
        "snippet": "    def test_scatter_2D(self):\n        x = np.arange(3)\n        y = np.arange(2)\n        x, y = np.meshgrid(x, y)\n        z = x + y\n        fig, ax = plt.subplots()\n        ax.scatter(x, y, c=z, s=200, edgecolors='face')",
        "begin_line": 1851,
        "end_line": 1857,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_color#1859",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_color(self)",
        "snippet": "    def test_scatter_color(self):\n        # Try to catch cases where 'c' kwarg should have been used.\n        with pytest.raises(ValueError):\n            plt.scatter([1, 2], [1, 2], color=[0.1, 0.2])\n        with pytest.raises(ValueError):\n            plt.scatter([1, 2, 3], [1, 2, 3], color=[1, 2, 3])",
        "begin_line": 1859,
        "end_line": 1864,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_invalid_color#1867",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_invalid_color(self, fig_test, fig_ref)",
        "snippet": "    def test_scatter_invalid_color(self, fig_test, fig_ref):\n        ax = fig_test.subplots()\n        cmap = plt.get_cmap(\"viridis\", 16)\n        cmap.set_bad(\"k\", 1)\n        # Set a nonuniform size to prevent the last call to `scatter` (plotting\n        # the invalid points separately in fig_ref) from using the marker\n        # stamping fast path, which would result in slightly offset markers.\n        ax.scatter(range(4), range(4),\n                   c=[1, np.nan, 2, np.nan], s=[1, 2, 3, 4],\n                   cmap=cmap, plotnonfinite=True)\n        ax = fig_ref.subplots()\n        cmap = plt.get_cmap(\"viridis\", 16)\n        ax.scatter([0, 2], [0, 2], c=[1, 2], s=[1, 3], cmap=cmap)\n        ax.scatter([1, 3], [1, 3], s=[2, 4], color=\"k\")",
        "begin_line": 1867,
        "end_line": 1880,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_no_invalid_color#1883",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_no_invalid_color(self, fig_test, fig_ref)",
        "snippet": "    def test_scatter_no_invalid_color(self, fig_test, fig_ref):\n        # With plotninfinite=False we plot only 2 points.\n        ax = fig_test.subplots()\n        cmap = plt.get_cmap(\"viridis\", 16)\n        cmap.set_bad(\"k\", 1)\n        ax.scatter(range(4), range(4),\n                   c=[1, np.nan, 2, np.nan], s=[1, 2, 3, 4],\n                   cmap=cmap, plotnonfinite=False)\n        ax = fig_ref.subplots()\n        ax.scatter([0, 2], [0, 2], c=[1, 2], s=[1, 3], cmap=cmap)",
        "begin_line": 1883,
        "end_line": 1892,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_c#1944",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_c(self, c_case, re_key)",
        "snippet": "    def test_scatter_c(self, c_case, re_key):\n        def get_next_color():\n            return 'blue'  # currently unused\n\n        from matplotlib.axes import Axes\n\n        xshape = yshape = (4,)\n\n        # Additional checking of *c* (introduced in #11383).\n        REGEXP = {\n            \"shape\": \"^'c' argument has [0-9]+ elements\",  # shape mismatch\n            \"conversion\": \"^'c' argument must be a mpl color\",  # bad vals\n            }\n\n        if re_key is None:\n            Axes._parse_scatter_color_args(\n                c=c_case, edgecolors=\"black\", kwargs={},\n                xshape=xshape, yshape=yshape,\n                get_next_color_func=get_next_color)\n        else:\n            with pytest.raises(ValueError, match=REGEXP[re_key]):\n                Axes._parse_scatter_color_args(\n                    c=c_case, edgecolors=\"black\", kwargs={},\n                    xshape=xshape, yshape=yshape,\n                    get_next_color_func=get_next_color)",
        "begin_line": 1944,
        "end_line": 1968,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.get_next_color#1945",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.get_next_color()",
        "snippet": "        def get_next_color():\n            return 'blue'  # currently unused",
        "begin_line": 1945,
        "end_line": 1946,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._params#1971",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._params(c=None, xshape=(2,), yshape=(2,), **kwargs)",
        "snippet": "def _params(c=None, xshape=(2,), yshape=(2,), **kwargs):\n    edgecolors = kwargs.pop('edgecolors', None)\n    return (c, edgecolors, kwargs if kwargs is not None else {},\n            xshape, yshape)",
        "begin_line": 1971,
        "end_line": 1974,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_parse_scatter_color_args#1991",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_parse_scatter_color_args(params, expected_result)",
        "snippet": "def test_parse_scatter_color_args(params, expected_result):\n    def get_next_color():\n        return 'blue'  # currently unused\n\n    from matplotlib.axes import Axes\n    c, colors, _edgecolors = Axes._parse_scatter_color_args(\n        *params, get_next_color_func=get_next_color)\n    assert c == expected_result.c\n    assert_allclose(colors, expected_result.colors)",
        "begin_line": 1991,
        "end_line": 1999,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.get_next_color#1992",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.get_next_color()",
        "snippet": "    def get_next_color():\n        return 'blue'  # currently unused",
        "begin_line": 1992,
        "end_line": 1993,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_parse_scatter_color_args_edgecolors#2018",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_parse_scatter_color_args_edgecolors(kwargs, expected_edgecolors)",
        "snippet": "def test_parse_scatter_color_args_edgecolors(kwargs, expected_edgecolors):\n    def get_next_color():\n        return 'blue'  # currently unused\n\n    from matplotlib.axes import Axes\n    c = kwargs.pop('c', None)\n    edgecolors = kwargs.pop('edgecolors', None)\n    _, _, result_edgecolors = \\\n        Axes._parse_scatter_color_args(c, edgecolors, kwargs,\n                                       xshape=(2,), yshape=(2,),\n                                       get_next_color_func=get_next_color)\n    assert result_edgecolors == expected_edgecolors",
        "begin_line": 2018,
        "end_line": 2029,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.get_next_color#2019",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.get_next_color()",
        "snippet": "    def get_next_color():\n        return 'blue'  # currently unused",
        "begin_line": 2019,
        "end_line": 2020,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_as_mpl_axes_api#2032",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_as_mpl_axes_api()",
        "snippet": "def test_as_mpl_axes_api():\n    # tests the _as_mpl_axes api\n    from matplotlib.projections.polar import PolarAxes\n    import matplotlib.axes as maxes\n\n    class Polar(object):\n        def __init__(self):\n            self.theta_offset = 0\n\n        def _as_mpl_axes(self):\n            # implement the matplotlib axes interface\n            return PolarAxes, {'theta_offset': self.theta_offset}\n\n    prj = Polar()\n    prj2 = Polar()\n    prj2.theta_offset = np.pi\n    prj3 = Polar()\n\n    # testing axes creation with plt.axes\n    ax = plt.axes([0, 0, 1, 1], projection=prj)\n    assert type(ax) == PolarAxes\n    ax_via_gca = plt.gca(projection=prj)\n    assert ax_via_gca is ax\n    plt.close()\n\n    # testing axes creation with gca\n    ax = plt.gca(projection=prj)\n    assert type(ax) == maxes._subplots.subplot_class_factory(PolarAxes)\n    ax_via_gca = plt.gca(projection=prj)\n    assert ax_via_gca is ax\n    # try getting the axes given a different polar projection\n    with pytest.warns(UserWarning) as rec:\n        ax_via_gca = plt.gca(projection=prj2)\n        assert len(rec) == 1\n        assert 'Requested projection is different' in str(rec[0].message)\n    assert ax_via_gca is not ax\n    assert ax.get_theta_offset() == 0\n    assert ax_via_gca.get_theta_offset() == np.pi\n    # try getting the axes given an == (not is) polar projection\n    with pytest.warns(UserWarning):\n        ax_via_gca = plt.gca(projection=prj3)\n        assert len(rec) == 1\n        assert 'Requested projection is different' in str(rec[0].message)\n    assert ax_via_gca is ax\n    plt.close()\n\n    # testing axes creation with subplot\n    ax = plt.subplot(121, projection=prj)\n    assert type(ax) == maxes._subplots.subplot_class_factory(PolarAxes)\n    plt.close()",
        "begin_line": 2032,
        "end_line": 2081,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.Polar.test_as_mpl_axes_api#2032",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.Polar",
        "signature": "lib.matplotlib.tests.test_axes.Polar.test_as_mpl_axes_api()",
        "snippet": "def test_as_mpl_axes_api():\n    # tests the _as_mpl_axes api\n    from matplotlib.projections.polar import PolarAxes\n    import matplotlib.axes as maxes\n\n    class Polar(object):\n        def __init__(self):\n            self.theta_offset = 0\n\n        def _as_mpl_axes(self):\n            # implement the matplotlib axes interface\n            return PolarAxes, {'theta_offset': self.theta_offset}\n\n    prj = Polar()\n    prj2 = Polar()\n    prj2.theta_offset = np.pi\n    prj3 = Polar()\n\n    # testing axes creation with plt.axes\n    ax = plt.axes([0, 0, 1, 1], projection=prj)\n    assert type(ax) == PolarAxes\n    ax_via_gca = plt.gca(projection=prj)\n    assert ax_via_gca is ax\n    plt.close()\n\n    # testing axes creation with gca\n    ax = plt.gca(projection=prj)\n    assert type(ax) == maxes._subplots.subplot_class_factory(PolarAxes)\n    ax_via_gca = plt.gca(projection=prj)\n    assert ax_via_gca is ax\n    # try getting the axes given a different polar projection\n    with pytest.warns(UserWarning) as rec:\n        ax_via_gca = plt.gca(projection=prj2)\n        assert len(rec) == 1\n        assert 'Requested projection is different' in str(rec[0].message)\n    assert ax_via_gca is not ax\n    assert ax.get_theta_offset() == 0\n    assert ax_via_gca.get_theta_offset() == np.pi\n    # try getting the axes given an == (not is) polar projection\n    with pytest.warns(UserWarning):\n        ax_via_gca = plt.gca(projection=prj3)\n        assert len(rec) == 1\n        assert 'Requested projection is different' in str(rec[0].message)\n    assert ax_via_gca is ax\n    plt.close()\n\n    # testing axes creation with subplot\n    ax = plt.subplot(121, projection=prj)\n    assert type(ax) == maxes._subplots.subplot_class_factory(PolarAxes)\n    plt.close()",
        "begin_line": 2032,
        "end_line": 2081,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.Polar.__init__#2038",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.Polar",
        "signature": "lib.matplotlib.tests.test_axes.Polar.__init__(self)",
        "snippet": "        def __init__(self):\n            self.theta_offset = 0",
        "begin_line": 2038,
        "end_line": 2039,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.Polar._as_mpl_axes#2041",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.Polar",
        "signature": "lib.matplotlib.tests.test_axes.Polar._as_mpl_axes(self)",
        "snippet": "        def _as_mpl_axes(self):\n            # implement the matplotlib axes interface\n            return PolarAxes, {'theta_offset': self.theta_offset}",
        "begin_line": 2041,
        "end_line": 2043,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pyplot_axes#2084",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pyplot_axes()",
        "snippet": "def test_pyplot_axes():\n    # test focusing of Axes in other Figure\n    fig1, ax1 = plt.subplots()\n    fig2, ax2 = plt.subplots()\n    plt.sca(ax1)\n    assert ax1 is plt.gca()\n    assert fig1 is plt.gcf()\n    plt.close(fig1)\n    plt.close(fig2)",
        "begin_line": 2084,
        "end_line": 2092,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_log_scales#2096",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_log_scales()",
        "snippet": "def test_log_scales():\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax.plot(np.log(np.linspace(0.1, 100)))\n    ax.set_yscale('log', basey=5.5)\n    ax.invert_yaxis()\n    ax.set_xscale('log', basex=9.0)",
        "begin_line": 2096,
        "end_line": 2102,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stackplot#2107",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stackplot()",
        "snippet": "def test_stackplot():\n    fig = plt.figure()\n    x = np.linspace(0, 10, 10)\n    y1 = 1.0 * x\n    y2 = 2.0 * x + 1\n    y3 = 3.0 * x + 2\n    ax = fig.add_subplot(1, 1, 1)\n    ax.stackplot(x, y1, y2, y3)\n    ax.set_xlim((0, 10))\n    ax.set_ylim((0, 70))\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"x\": x, \"y1\": y1, \"y2\": y2, \"y3\": y3}\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax.stackplot(\"x\", \"y1\", \"y2\", \"y3\", data=data)\n    ax.set_xlim((0, 10))\n    ax.set_ylim((0, 70))",
        "begin_line": 2107,
        "end_line": 2124,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stackplot_baseline#2129",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stackplot_baseline()",
        "snippet": "def test_stackplot_baseline():\n    np.random.seed(0)\n\n    def layers(n, m):\n        a = np.zeros((m, n))\n        for i in range(n):\n            for j in range(5):\n                x = 1 / (.1 + np.random.random())\n                y = 2 * np.random.random() - .5\n                z = 10 / (.1 + np.random.random())\n                a[:, i] += x * np.exp(-((np.arange(m) / m - y) * z) ** 2)\n        return a\n\n    d = layers(3, 100)\n    d[50, :] = 0  # test for fixed weighted wiggle (issue #6313)\n\n    fig, axs = plt.subplots(2, 2)\n\n    axs[0, 0].stackplot(range(100), d.T, baseline='zero')\n    axs[0, 1].stackplot(range(100), d.T, baseline='sym')\n    axs[1, 0].stackplot(range(100), d.T, baseline='wiggle')\n    axs[1, 1].stackplot(range(100), d.T, baseline='weighted_wiggle')",
        "begin_line": 2129,
        "end_line": 2150,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.layers#2132",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.layers(n, m)",
        "snippet": "    def layers(n, m):\n        a = np.zeros((m, n))\n        for i in range(n):\n            for j in range(5):\n                x = 1 / (.1 + np.random.random())\n                y = 2 * np.random.random() - .5\n                z = 10 / (.1 + np.random.random())\n                a[:, i] += x * np.exp(-((np.arange(m) / m - y) * z) ** 2)\n        return a",
        "begin_line": 2132,
        "end_line": 2140,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._bxp_test_helper#2153",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._bxp_test_helper(stats_kwargs={}, transform_stats=lambda s: s, bxp_kwargs={})",
        "snippet": "def _bxp_test_helper(\n        stats_kwargs={}, transform_stats=lambda s: s, bxp_kwargs={}):\n    np.random.seed(937)\n    logstats = mpl.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4)), **stats_kwargs)\n    fig, ax = plt.subplots()\n    if bxp_kwargs.get('vert', True):\n        ax.set_yscale('log')\n    else:\n        ax.set_xscale('log')\n    # Work around baseline images generate back when bxp did not respect the\n    # boxplot.boxprops.linewidth rcParam when patch_artist is False.\n    if not bxp_kwargs.get('patch_artist', False):\n        mpl.rcParams['boxplot.boxprops.linewidth'] = \\\n            mpl.rcParams['lines.linewidth']\n    ax.bxp(transform_stats(logstats), **bxp_kwargs)",
        "begin_line": 2153,
        "end_line": 2168,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_baseline#2175",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_baseline()",
        "snippet": "def test_bxp_baseline():\n    _bxp_test_helper()",
        "begin_line": 2175,
        "end_line": 2176,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_rangewhis#2183",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_rangewhis()",
        "snippet": "def test_bxp_rangewhis():\n    _bxp_test_helper(stats_kwargs=dict(whis='range'))",
        "begin_line": 2183,
        "end_line": 2184,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_precentilewhis#2191",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_precentilewhis()",
        "snippet": "def test_bxp_precentilewhis():\n    _bxp_test_helper(stats_kwargs=dict(whis=[5, 95]))",
        "begin_line": 2191,
        "end_line": 2192,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_with_xlabels#2199",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_with_xlabels()",
        "snippet": "def test_bxp_with_xlabels():\n    def transform(stats):\n        for s, label in zip(stats, list('ABCD')):\n            s['label'] = label\n        return stats\n\n    _bxp_test_helper(transform_stats=transform)",
        "begin_line": 2199,
        "end_line": 2205,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.transform#2200",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.transform(stats)",
        "snippet": "    def transform(stats):\n        for s, label in zip(stats, list('ABCD')):\n            s['label'] = label\n        return stats",
        "begin_line": 2200,
        "end_line": 2203,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_horizontal#2213",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_horizontal()",
        "snippet": "def test_bxp_horizontal():\n    _bxp_test_helper(bxp_kwargs=dict(vert=False))",
        "begin_line": 2213,
        "end_line": 2214,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_with_ylabels#2222",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_with_ylabels()",
        "snippet": "def test_bxp_with_ylabels():\n    def transform(stats):\n        for s, label in zip(stats, list('ABCD')):\n            s['label'] = label\n        return stats\n\n    _bxp_test_helper(transform_stats=transform, bxp_kwargs=dict(vert=False))",
        "begin_line": 2222,
        "end_line": 2228,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.transform#2223",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.transform(stats)",
        "snippet": "    def transform(stats):\n        for s, label in zip(stats, list('ABCD')):\n            s['label'] = label\n        return stats",
        "begin_line": 2223,
        "end_line": 2226,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_patchartist#2235",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_patchartist()",
        "snippet": "def test_bxp_patchartist():\n    _bxp_test_helper(bxp_kwargs=dict(patch_artist=True))",
        "begin_line": 2235,
        "end_line": 2236,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_custompatchartist#2243",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_custompatchartist()",
        "snippet": "def test_bxp_custompatchartist():\n    _bxp_test_helper(bxp_kwargs=dict(\n        patch_artist=True,\n        boxprops=dict(facecolor='yellow', edgecolor='green', ls=':')))",
        "begin_line": 2243,
        "end_line": 2246,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_customoutlier#2253",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_customoutlier()",
        "snippet": "def test_bxp_customoutlier():\n    _bxp_test_helper(bxp_kwargs=dict(\n        flierprops=dict(linestyle='none', marker='d', mfc='g')))",
        "begin_line": 2253,
        "end_line": 2255,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_showcustommean#2262",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_showcustommean()",
        "snippet": "def test_bxp_showcustommean():\n    _bxp_test_helper(bxp_kwargs=dict(\n        showmeans=True,\n        meanprops=dict(linestyle='none', marker='d', mfc='green'),\n    ))",
        "begin_line": 2262,
        "end_line": 2266,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_custombox#2273",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_custombox()",
        "snippet": "def test_bxp_custombox():\n    _bxp_test_helper(bxp_kwargs=dict(\n        boxprops=dict(linestyle='--', color='b', lw=3)))",
        "begin_line": 2273,
        "end_line": 2275,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_custommedian#2282",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_custommedian()",
        "snippet": "def test_bxp_custommedian():\n    _bxp_test_helper(bxp_kwargs=dict(\n        medianprops=dict(linestyle='--', color='b', lw=3)))",
        "begin_line": 2282,
        "end_line": 2284,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_customcap#2291",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_customcap()",
        "snippet": "def test_bxp_customcap():\n    _bxp_test_helper(bxp_kwargs=dict(\n        capprops=dict(linestyle='--', color='g', lw=3)))",
        "begin_line": 2291,
        "end_line": 2293,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_customwhisker#2300",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_customwhisker()",
        "snippet": "def test_bxp_customwhisker():\n    _bxp_test_helper(bxp_kwargs=dict(\n        whiskerprops=dict(linestyle='-', color='m', lw=3)))",
        "begin_line": 2300,
        "end_line": 2302,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_shownotches#2309",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_shownotches()",
        "snippet": "def test_bxp_shownotches():\n    _bxp_test_helper(bxp_kwargs=dict(shownotches=True))",
        "begin_line": 2309,
        "end_line": 2310,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_nocaps#2317",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_nocaps()",
        "snippet": "def test_bxp_nocaps():\n    _bxp_test_helper(bxp_kwargs=dict(showcaps=False))",
        "begin_line": 2317,
        "end_line": 2318,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_nobox#2325",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_nobox()",
        "snippet": "def test_bxp_nobox():\n    _bxp_test_helper(bxp_kwargs=dict(showbox=False))",
        "begin_line": 2325,
        "end_line": 2326,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_no_flier_stats#2333",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_no_flier_stats()",
        "snippet": "def test_bxp_no_flier_stats():\n    def transform(stats):\n        for s in stats:\n            s.pop('fliers', None)\n        return stats\n\n    _bxp_test_helper(transform_stats=transform,\n                     bxp_kwargs=dict(showfliers=False))",
        "begin_line": 2333,
        "end_line": 2340,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.transform#2334",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.transform(stats)",
        "snippet": "    def transform(stats):\n        for s in stats:\n            s.pop('fliers', None)\n        return stats",
        "begin_line": 2334,
        "end_line": 2337,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_showmean#2347",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_showmean()",
        "snippet": "def test_bxp_showmean():\n    _bxp_test_helper(bxp_kwargs=dict(showmeans=True, meanline=False))",
        "begin_line": 2347,
        "end_line": 2348,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_showmeanasline#2355",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_showmeanasline()",
        "snippet": "def test_bxp_showmeanasline():\n    _bxp_test_helper(bxp_kwargs=dict(showmeans=True, meanline=True))",
        "begin_line": 2355,
        "end_line": 2356,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_scalarwidth#2363",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_scalarwidth()",
        "snippet": "def test_bxp_scalarwidth():\n    _bxp_test_helper(bxp_kwargs=dict(widths=.25))",
        "begin_line": 2363,
        "end_line": 2364,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_customwidths#2371",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_customwidths()",
        "snippet": "def test_bxp_customwidths():\n    _bxp_test_helper(bxp_kwargs=dict(widths=[0.10, 0.25, 0.65, 0.85]))",
        "begin_line": 2371,
        "end_line": 2372,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_custompositions#2379",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_custompositions()",
        "snippet": "def test_bxp_custompositions():\n    _bxp_test_helper(bxp_kwargs=dict(positions=[1, 5, 6, 7]))",
        "begin_line": 2379,
        "end_line": 2380,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_bad_widths#2383",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_bad_widths()",
        "snippet": "def test_bxp_bad_widths():\n    with pytest.raises(ValueError):\n        _bxp_test_helper(bxp_kwargs=dict(widths=[1]))",
        "begin_line": 2383,
        "end_line": 2385,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_bad_positions#2388",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_bad_positions()",
        "snippet": "def test_bxp_bad_positions():\n    with pytest.raises(ValueError):\n        _bxp_test_helper(bxp_kwargs=dict(positions=[2, 3]))",
        "begin_line": 2388,
        "end_line": 2390,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot#2396",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot()",
        "snippet": "def test_boxplot():\n    # Randomness used for bootstrapping.\n    np.random.seed(937)\n\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n\n    ax.boxplot([x, x], bootstrap=10000, notch=1)\n    ax.set_ylim((-30, 30))\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"x\": [x, x]}\n    fig, ax = plt.subplots()\n    ax.boxplot(\"x\", bootstrap=10000, notch=1, data=data)\n    ax.set_ylim((-30, 30))",
        "begin_line": 2396,
        "end_line": 2411,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_sym2#2417",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_sym2()",
        "snippet": "def test_boxplot_sym2():\n    # Randomness used for bootstrapping.\n    np.random.seed(937)\n\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, [ax1, ax2] = plt.subplots(1, 2)\n\n    ax1.boxplot([x, x], bootstrap=10000, sym='^')\n    ax1.set_ylim((-30, 30))\n\n    ax2.boxplot([x, x], bootstrap=10000, sym='g')\n    ax2.set_ylim((-30, 30))",
        "begin_line": 2417,
        "end_line": 2429,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_sym#2436",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_sym()",
        "snippet": "def test_boxplot_sym():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n\n    ax.boxplot([x, x], sym='gs')\n    ax.set_ylim((-30, 30))",
        "begin_line": 2436,
        "end_line": 2442,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_autorange_whiskers#2451",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_autorange_whiskers()",
        "snippet": "def test_boxplot_autorange_whiskers():\n    # Randomness used for bootstrapping.\n    np.random.seed(937)\n\n    x = np.ones(140)\n    x = np.hstack([0, x, 2])\n\n    fig1, ax1 = plt.subplots()\n    ax1.boxplot([x, x], bootstrap=10000, notch=1)\n    ax1.set_ylim((-5, 5))\n\n    fig2, ax2 = plt.subplots()\n    ax2.boxplot([x, x], bootstrap=10000, notch=1, autorange=True)\n    ax2.set_ylim((-5, 5))",
        "begin_line": 2451,
        "end_line": 2464,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._rc_test_bxp_helper#2467",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._rc_test_bxp_helper(ax, rc_dict)",
        "snippet": "def _rc_test_bxp_helper(ax, rc_dict):\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    with matplotlib.rc_context(rc_dict):\n        ax.boxplot([x, x])\n    return ax",
        "begin_line": 2467,
        "end_line": 2472,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_rc_parameters#2478",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_rc_parameters()",
        "snippet": "def test_boxplot_rc_parameters():\n    # Randomness used for bootstrapping.\n    np.random.seed(937)\n\n    fig, ax = plt.subplots(3)\n\n    rc_axis0 = {\n        'boxplot.notch': True,\n        'boxplot.whiskers': [5, 95],\n        'boxplot.bootstrap': 10000,\n\n        'boxplot.flierprops.color': 'b',\n        'boxplot.flierprops.marker': 'o',\n        'boxplot.flierprops.markerfacecolor': 'g',\n        'boxplot.flierprops.markeredgecolor': 'b',\n        'boxplot.flierprops.markersize': 5,\n        'boxplot.flierprops.linestyle': '--',\n        'boxplot.flierprops.linewidth': 2.0,\n\n        'boxplot.boxprops.color': 'r',\n        'boxplot.boxprops.linewidth': 2.0,\n        'boxplot.boxprops.linestyle': '--',\n\n        'boxplot.capprops.color': 'c',\n        'boxplot.capprops.linewidth': 2.0,\n        'boxplot.capprops.linestyle': '--',\n\n        'boxplot.medianprops.color': 'k',\n        'boxplot.medianprops.linewidth': 2.0,\n        'boxplot.medianprops.linestyle': '--',\n    }\n\n    rc_axis1 = {\n        'boxplot.vertical': False,\n        'boxplot.whiskers': 'range',\n        'boxplot.patchartist': True,\n    }\n\n    rc_axis2 = {\n        'boxplot.whiskers': 2.0,\n        'boxplot.showcaps': False,\n        'boxplot.showbox': False,\n        'boxplot.showfliers': False,\n        'boxplot.showmeans': True,\n        'boxplot.meanline': True,\n\n        'boxplot.meanprops.color': 'c',\n        'boxplot.meanprops.linewidth': 2.0,\n        'boxplot.meanprops.linestyle': '--',\n\n        'boxplot.whiskerprops.color': 'r',\n        'boxplot.whiskerprops.linewidth': 2.0,\n        'boxplot.whiskerprops.linestyle': '-.',\n    }\n    dict_list = [rc_axis0, rc_axis1, rc_axis2]\n    for axis, rc_axis in zip(ax, dict_list):\n        _rc_test_bxp_helper(axis, rc_axis)\n\n    assert (matplotlib.patches.PathPatch in\n            [type(t) for t in ax[1].get_children()])",
        "begin_line": 2478,
        "end_line": 2537,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_with_CIarray#2543",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_with_CIarray()",
        "snippet": "def test_boxplot_with_CIarray():\n    # Randomness used for bootstrapping.\n    np.random.seed(937)\n\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    CIs = np.array([[-1.5, 3.], [-1., 3.5]])\n\n    # show 1 boxplot with mpl medians/conf. intervals, 1 with manual values\n    ax.boxplot([x, x], bootstrap=10000, usermedians=[None, 1.0],\n               conf_intervals=CIs, notch=1)\n    ax.set_ylim((-30, 30))",
        "begin_line": 2543,
        "end_line": 2556,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_no_weird_whisker#2562",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_no_weird_whisker()",
        "snippet": "def test_boxplot_no_weird_whisker():\n    x = np.array([3, 9000, 150, 88, 350, 200000, 1400, 960],\n                 dtype=np.float64)\n    ax1 = plt.axes()\n    ax1.boxplot(x)\n    ax1.set_yscale('log')\n    ax1.yaxis.grid(False, which='minor')\n    ax1.xaxis.grid(False)",
        "begin_line": 2562,
        "end_line": 2569,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_bad_medians_1#2572",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_bad_medians_1()",
        "snippet": "def test_boxplot_bad_medians_1():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.boxplot(x, usermedians=[1, 2])",
        "begin_line": 2572,
        "end_line": 2577,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_bad_medians_2#2580",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_bad_medians_2()",
        "snippet": "def test_boxplot_bad_medians_2():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.boxplot([x, x], usermedians=[[1, 2], [1, 2]])",
        "begin_line": 2580,
        "end_line": 2585,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_bad_ci_1#2588",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_bad_ci_1()",
        "snippet": "def test_boxplot_bad_ci_1():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.boxplot([x, x], conf_intervals=[[1, 2]])",
        "begin_line": 2588,
        "end_line": 2593,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_zorder#2596",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_zorder()",
        "snippet": "def test_boxplot_zorder():\n    x = np.arange(10)\n    fix, ax = plt.subplots()\n    assert ax.boxplot(x)['boxes'][0].get_zorder() == 2\n    assert ax.boxplot(x, zorder=10)['boxes'][0].get_zorder() == 10",
        "begin_line": 2596,
        "end_line": 2600,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_bad_ci_2#2603",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_bad_ci_2()",
        "snippet": "def test_boxplot_bad_ci_2():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.boxplot([x, x], conf_intervals=[[1, 2], [1]])",
        "begin_line": 2603,
        "end_line": 2608,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_mod_artist_after_plotting#2614",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_mod_artist_after_plotting()",
        "snippet": "def test_boxplot_mod_artist_after_plotting():\n    x = [0.15, 0.11, 0.06, 0.06, 0.12, 0.56, -0.56]\n    fig, ax = plt.subplots()\n    bp = ax.boxplot(x, sym=\"o\")\n    for key in bp:\n        for obj in bp[key]:\n            obj.set_color('green')",
        "begin_line": 2614,
        "end_line": 2620,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_baseline#2626",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_baseline()",
        "snippet": "def test_vert_violinplot_baseline():\n    # First 9 digits of frac(sqrt(2))\n    np.random.seed(414213562)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax = plt.axes()\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=0)\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"d\": data}\n    fig, ax = plt.subplots()\n    ax = plt.axes()\n    ax.violinplot(\"d\", positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=0, data=data)",
        "begin_line": 2626,
        "end_line": 2639,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showmeans#2644",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showmeans()",
        "snippet": "def test_vert_violinplot_showmeans():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(3))\n    np.random.seed(732050807)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=1, showextrema=0,\n                  showmedians=0)",
        "begin_line": 2644,
        "end_line": 2650,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showextrema#2655",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showextrema()",
        "snippet": "def test_vert_violinplot_showextrema():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(5))\n    np.random.seed(236067977)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=1,\n                  showmedians=0)",
        "begin_line": 2655,
        "end_line": 2661,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showmedians#2666",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showmedians()",
        "snippet": "def test_vert_violinplot_showmedians():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(7))\n    np.random.seed(645751311)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=1)",
        "begin_line": 2666,
        "end_line": 2672,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showall#2677",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showall()",
        "snippet": "def test_vert_violinplot_showall():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(11))\n    np.random.seed(316624790)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=1, showextrema=1,\n                  showmedians=1)",
        "begin_line": 2677,
        "end_line": 2683,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_custompoints_10#2688",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_custompoints_10()",
        "snippet": "def test_vert_violinplot_custompoints_10():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(13))\n    np.random.seed(605551275)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=0, points=10)",
        "begin_line": 2688,
        "end_line": 2694,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_custompoints_200#2699",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_custompoints_200()",
        "snippet": "def test_vert_violinplot_custompoints_200():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(17))\n    np.random.seed(123105625)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=0, points=200)",
        "begin_line": 2699,
        "end_line": 2705,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_baseline#2710",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_baseline()",
        "snippet": "def test_horiz_violinplot_baseline():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(19))\n    np.random.seed(358898943)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=0)",
        "begin_line": 2710,
        "end_line": 2716,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showmedians#2721",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showmedians()",
        "snippet": "def test_horiz_violinplot_showmedians():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(23))\n    np.random.seed(795831523)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=1)",
        "begin_line": 2721,
        "end_line": 2727,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showmeans#2732",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showmeans()",
        "snippet": "def test_horiz_violinplot_showmeans():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(29))\n    np.random.seed(385164807)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=1,\n                  showextrema=0, showmedians=0)",
        "begin_line": 2732,
        "end_line": 2738,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showextrema#2743",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showextrema()",
        "snippet": "def test_horiz_violinplot_showextrema():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(31))\n    np.random.seed(567764362)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=1, showmedians=0)",
        "begin_line": 2743,
        "end_line": 2749,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showall#2754",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showall()",
        "snippet": "def test_horiz_violinplot_showall():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(37))\n    np.random.seed(82762530)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=1,\n                  showextrema=1, showmedians=1)",
        "begin_line": 2754,
        "end_line": 2760,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_custompoints_10#2765",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_custompoints_10()",
        "snippet": "def test_horiz_violinplot_custompoints_10():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(41))\n    np.random.seed(403124237)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=0, points=10)",
        "begin_line": 2765,
        "end_line": 2771,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_custompoints_200#2776",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_custompoints_200()",
        "snippet": "def test_horiz_violinplot_custompoints_200():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(43))\n    np.random.seed(557438524)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=0, points=200)",
        "begin_line": 2776,
        "end_line": 2782,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violinplot_bad_positions#2785",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violinplot_bad_positions()",
        "snippet": "def test_violinplot_bad_positions():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(47))\n    np.random.seed(855654600)\n    data = [np.random.normal(size=100) for i in range(4)]\n    with pytest.raises(ValueError):\n        ax.violinplot(data, positions=range(5))",
        "begin_line": 2785,
        "end_line": 2791,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violinplot_bad_widths#2794",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violinplot_bad_widths()",
        "snippet": "def test_violinplot_bad_widths():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(53))\n    np.random.seed(280109889)\n    data = [np.random.normal(size=100) for i in range(4)]\n    with pytest.raises(ValueError):\n        ax.violinplot(data, positions=range(4), widths=[1, 2, 3])",
        "begin_line": 2794,
        "end_line": 2800,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_manage_xticks#2803",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_manage_xticks()",
        "snippet": "def test_manage_xticks():\n    _, ax = plt.subplots()\n    ax.set_xlim(0, 4)\n    old_xlim = ax.get_xlim()\n    np.random.seed(0)\n    y1 = np.random.normal(10, 3, 20)\n    y2 = np.random.normal(3, 1, 20)\n    ax.boxplot([y1, y2], positions=[1, 2], manage_ticks=False)\n    new_xlim = ax.get_xlim()\n    assert_array_equal(old_xlim, new_xlim)",
        "begin_line": 2803,
        "end_line": 2812,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_not_single#2815",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_not_single()",
        "snippet": "def test_boxplot_not_single():\n    fig, ax = plt.subplots()\n    ax.boxplot(np.random.rand(100), positions=[3])\n    ax.boxplot(np.random.rand(100), positions=[5])\n    fig.canvas.draw()\n    assert ax.get_xlim() == (2.5, 5.5)\n    assert list(ax.get_xticks()) == [3, 5]\n    assert [t.get_text() for t in ax.get_xticklabels()] == [\"3\", \"5\"]",
        "begin_line": 2815,
        "end_line": 2822,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_tick_space_size_0#2825",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_tick_space_size_0()",
        "snippet": "def test_tick_space_size_0():\n    # allow font size to be zero, which affects ticks when there is\n    # no other text in the figure.\n    plt.plot([0, 1], [0, 1])\n    matplotlib.rcParams.update({'font.size': 0})\n    b = io.BytesIO()\n    plt.savefig(b, dpi=80, format='raw')",
        "begin_line": 2825,
        "end_line": 2831,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar#2836",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar()",
        "snippet": "def test_errorbar():\n    x = np.arange(0.1, 4, 0.5)\n    y = np.exp(-x)\n\n    yerr = 0.1 + 0.2*np.sqrt(x)\n    xerr = 0.1 + yerr\n\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.errorbar(x, y, xerr=0.2, yerr=0.4)\n    ax.set_title(\"Simplest errorbars, 0.2 in x, 0.4 in y\")\n\n    # Now switch to a more OO interface to exercise more features.\n    fig, axs = plt.subplots(nrows=2, ncols=2, sharex=True)\n    ax = axs[0, 0]\n    # Try a Nx1 shaped error just to check\n    with pytest.warns(MatplotlibDeprecationWarning):\n        ax.errorbar(x, y, yerr=np.reshape(yerr, (len(y), 1)), fmt='o')\n    ax.set_title('Vert. symmetric')\n\n    # With 4 subplots, reduce the number of axis ticks to avoid crowding.\n    ax.locator_params(nbins=4)\n\n    ax = axs[0, 1]\n    ax.errorbar(x, y, xerr=xerr, fmt='o', alpha=0.4)\n    ax.set_title('Hor. symmetric w/ alpha')\n\n    ax = axs[1, 0]\n    ax.errorbar(x, y, yerr=[yerr, 2*yerr], xerr=[xerr, 2*xerr], fmt='--o')\n    ax.set_title('H, V asymmetric')\n\n    ax = axs[1, 1]\n    ax.set_yscale('log')\n    # Here we have to be careful to keep all y values positive:\n    ylower = np.maximum(1e-2, y - yerr)\n    yerr_lower = y - ylower\n\n    ax.errorbar(x, y, yerr=[yerr_lower, 2*yerr], xerr=xerr,\n                fmt='o', ecolor='g', capthick=2)\n    ax.set_title('Mixed sym., log y')\n\n    fig.suptitle('Variable errorbars')\n\n    # Reuse the first testcase from above for a labeled data test\n    data = {\"x\": x, \"y\": y}\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.errorbar(\"x\", \"y\", xerr=0.2, yerr=0.4, data=data)\n    ax.set_title(\"Simplest errorbars, 0.2 in x, 0.4 in y\")",
        "begin_line": 2836,
        "end_line": 2885,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_colorcycle#2888",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_colorcycle()",
        "snippet": "def test_errorbar_colorcycle():\n\n    f, ax = plt.subplots()\n    x = np.arange(10)\n    y = 2*x\n\n    e1, _, _ = ax.errorbar(x, y, c=None)\n    e2, _, _ = ax.errorbar(x, 2*y, c=None)\n    ln1, = ax.plot(x, 4*y)\n\n    assert mcolors.to_rgba(e1.get_color()) == mcolors.to_rgba('C0')\n    assert mcolors.to_rgba(e2.get_color()) == mcolors.to_rgba('C1')\n    assert mcolors.to_rgba(ln1.get_color()) == mcolors.to_rgba('C2')",
        "begin_line": 2888,
        "end_line": 2900,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_shape#2903",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_shape()",
        "snippet": "def test_errorbar_shape():\n    fig = plt.figure()\n    ax = fig.gca()\n\n    x = np.arange(0.1, 4, 0.5)\n    y = np.exp(-x)\n    yerr1 = 0.1 + 0.2*np.sqrt(x)\n    yerr = np.vstack((yerr1, 2*yerr1)).T\n    xerr = 0.1 + yerr\n\n    with pytest.raises(ValueError):\n        ax.errorbar(x, y, yerr=yerr, fmt='o')\n    with pytest.raises(ValueError):\n        ax.errorbar(x, y, xerr=xerr, fmt='o')\n    with pytest.raises(ValueError):\n        ax.errorbar(x, y, yerr=yerr, xerr=xerr, fmt='o')",
        "begin_line": 2903,
        "end_line": 2918,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_limits#2922",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_limits()",
        "snippet": "def test_errorbar_limits():\n    x = np.arange(0.5, 5.5, 0.5)\n    y = np.exp(-x)\n    xerr = 0.1\n    yerr = 0.2\n    ls = 'dotted'\n\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n\n    # standard error bars\n    plt.errorbar(x, y, xerr=xerr, yerr=yerr, ls=ls, color='blue')\n\n    # including upper limits\n    uplims = np.zeros_like(x)\n    uplims[[1, 5, 9]] = True\n    plt.errorbar(x, y+0.5, xerr=xerr, yerr=yerr, uplims=uplims, ls=ls,\n                 color='green')\n\n    # including lower limits\n    lolims = np.zeros_like(x)\n    lolims[[2, 4, 8]] = True\n    plt.errorbar(x, y+1.0, xerr=xerr, yerr=yerr, lolims=lolims, ls=ls,\n                 color='red')\n\n    # including upper and lower limits\n    plt.errorbar(x, y+1.5, marker='o', ms=8, xerr=xerr, yerr=yerr,\n                 lolims=lolims, uplims=uplims, ls=ls, color='magenta')\n\n    # including xlower and xupper limits\n    xerr = 0.2\n    yerr = np.zeros_like(x) + 0.2\n    yerr[[3, 6]] = 0.3\n    xlolims = lolims\n    xuplims = uplims\n    lolims = np.zeros_like(x)\n    uplims = np.zeros_like(x)\n    lolims[[6]] = True\n    uplims[[3]] = True\n    plt.errorbar(x, y+2.1, marker='o', ms=8, xerr=xerr, yerr=yerr,\n                 xlolims=xlolims, xuplims=xuplims, uplims=uplims,\n                 lolims=lolims, ls='none', mec='blue', capsize=0,\n                 color='cyan')\n    ax.set_xlim((0, 5.5))\n    ax.set_title('Errorbar upper and lower limits')",
        "begin_line": 2922,
        "end_line": 2966,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errobar_nonefmt#2969",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errobar_nonefmt()",
        "snippet": "def test_errobar_nonefmt():\n    # Check that passing 'none' as a format still plots errorbars\n    x = np.arange(5)\n    y = np.arange(5)\n\n    plotline, _, barlines = plt.errorbar(x, y, xerr=1, yerr=1, fmt='none')\n    assert plotline is None\n    for errbar in barlines:\n        assert np.all(errbar.get_color() == mcolors.to_rgba('C0'))",
        "begin_line": 2969,
        "end_line": 2977,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_with_prop_cycle#2982",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_with_prop_cycle()",
        "snippet": "def test_errorbar_with_prop_cycle():\n    _cycle = cycler(ls=['--', ':'], marker=['s', 's'], mfc=['k', 'w'])\n    plt.rc(\"axes\", prop_cycle=_cycle)\n    fig, ax = plt.subplots()\n    ax.errorbar(x=[2, 4, 10], y=[3, 2, 4], yerr=0.5)\n    ax.errorbar(x=[2, 4, 10], y=[6, 4, 2], yerr=0.5)",
        "begin_line": 2982,
        "end_line": 2987,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled#2992",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled()",
        "snippet": "def test_hist_stacked_stepfilled():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"stepfilled\", stacked=True)\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"x\": (d1, d2)}\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(\"x\", histtype=\"stepfilled\", stacked=True, data=data)",
        "begin_line": 2992,
        "end_line": 3004,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_offset#3008",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_offset()",
        "snippet": "def test_hist_offset():\n    # make some data\n    d1 = np.linspace(0, 10, 50)\n    d2 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d1, bottom=5)\n    ax.hist(d2, bottom=15)",
        "begin_line": 3008,
        "end_line": 3015,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step#3020",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step()",
        "snippet": "def test_hist_step():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d1, histtype=\"step\")\n    ax.set_ylim(0, 10)\n    ax.set_xlim(-1, 5)",
        "begin_line": 3020,
        "end_line": 3027,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_horiz#3031",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_horiz()",
        "snippet": "def test_hist_step_horiz():\n    # make some data\n    d1 = np.linspace(0, 10, 50)\n    d2 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"step\", orientation=\"horizontal\")",
        "begin_line": 3031,
        "end_line": 3037,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_weighted#3041",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_weighted()",
        "snippet": "def test_hist_stacked_weighted():\n    # make some data\n    d1 = np.linspace(0, 10, 50)\n    d2 = np.linspace(1, 3, 20)\n    w1 = np.linspace(0.01, 3.5, 50)\n    w2 = np.linspace(0.05, 2., 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), weights=(w1, w2), histtype=\"stepfilled\", stacked=True)",
        "begin_line": 3041,
        "end_line": 3049,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stem#3056",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stem(use_line_collection)",
        "snippet": "def test_stem(use_line_collection):\n    x = np.linspace(0.1, 2 * np.pi, 100)\n    args = (x, np.cos(x))\n    # Label is a single space to force a legend to be drawn, but to avoid any\n    # text being drawn\n    kwargs = dict(linefmt='C2-.', markerfmt='k+', basefmt='C1-.',\n                  label=' ', use_line_collection=use_line_collection)\n\n    fig, ax = plt.subplots()\n    if use_line_collection:\n        ax.stem(*args, **kwargs)\n    else:\n        with pytest.warns(UserWarning):\n            ax.stem(*args, **kwargs)\n\n    ax.legend()",
        "begin_line": 3056,
        "end_line": 3071,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stem_params#3075",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stem_params(fig_test, fig_ref)",
        "snippet": "def test_stem_params(fig_test, fig_ref):\n    x = np.linspace(0, 3.14, 37)\n    y = np.sin(x)\n\n    ax = fig_test.subplots()\n    ax.stem(x, y, linefmt='grey', use_line_collection=True)\n\n    ax = fig_ref.subplots()\n    with pytest.warns(UserWarning):\n        ax.stem(x, y, linefmt='grey')",
        "begin_line": 3075,
        "end_line": 3084,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stem_args#3087",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stem_args()",
        "snippet": "def test_stem_args():\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n\n    x = list(range(10))\n    y = list(range(10))\n\n    # Test the call signatures\n    ax.stem(y)\n    ax.stem(x, y)\n    ax.stem(x, y, 'r--')\n    ax.stem(x, y, 'r--', basefmt='b--')",
        "begin_line": 3087,
        "end_line": 3098,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stem_dates#3101",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stem_dates()",
        "snippet": "def test_stem_dates():\n    fig, ax = plt.subplots(1, 1)\n    from dateutil import parser\n    x = parser.parse(\"2013-9-28 11:00:00\")\n    y = 100\n\n    x1 = parser.parse(\"2013-9-28 12:00:00\")\n    y1 = 200\n\n    ax.stem([x, x1], [y, y1], \"*-\")",
        "begin_line": 3101,
        "end_line": 3110,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled_alpha#3114",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled_alpha()",
        "snippet": "def test_hist_stacked_stepfilled_alpha():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"stepfilled\", stacked=True, alpha=0.5)",
        "begin_line": 3114,
        "end_line": 3120,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_step#3124",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_step()",
        "snippet": "def test_hist_stacked_step():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"step\", stacked=True)",
        "begin_line": 3124,
        "end_line": 3130,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_density#3135",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_density()",
        "snippet": "def test_hist_stacked_density():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n\n    fig, ax = plt.subplots()\n    ax.hist((d1, d2), stacked=True, density=True)\n\n    # Also check that the old keyword works.\n    fig, ax = plt.subplots()\n    with pytest.warns(UserWarning):\n        ax.hist((d1, d2), stacked=True, normed=True)",
        "begin_line": 3135,
        "end_line": 3146,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_normed_density#3151",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_normed_density(normed, density)",
        "snippet": "def test_hist_normed_density(normed, density):\n    # Normed and density should not be used simultaneously\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig, ax = plt.subplots()\n    # test that kwargs normed and density cannot be set both.\n    with pytest.raises(Exception):\n        ax.hist((d1, d2), stacked=True, normed=normed, density=density)",
        "begin_line": 3151,
        "end_line": 3158,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_bottom#3163",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_bottom()",
        "snippet": "def test_hist_step_bottom():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d1, bottom=np.arange(10), histtype=\"stepfilled\")",
        "begin_line": 3163,
        "end_line": 3168,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_bar#3172",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_bar()",
        "snippet": "def test_hist_stacked_bar():\n    # make some data\n    d = [[100, 100, 100, 100, 200, 320, 450, 80, 20, 600, 310, 800],\n         [20, 23, 50, 11, 100, 420], [120, 120, 120, 140, 140, 150, 180],\n         [60, 60, 60, 60, 300, 300, 5, 5, 5, 5, 10, 300],\n         [555, 555, 555, 30, 30, 30, 30, 30, 100, 100, 100, 100, 30, 30],\n         [30, 30, 30, 30, 400, 400, 400, 400, 400, 400, 400, 400]]\n    colors = [(0.5759849696758961, 1.0, 0.0), (0.0, 1.0, 0.350624650815206),\n              (0.0, 1.0, 0.6549834156005998), (0.0, 0.6569064625276622, 1.0),\n              (0.28302699607823545, 0.0, 1.0), (0.6849123462299822, 0.0, 1.0)]\n    labels = ['green', 'orange', ' yellow', 'magenta', 'black']\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d, bins=10, histtype='barstacked', align='mid', color=colors,\n            label=labels)\n    ax.legend(loc='upper right', bbox_to_anchor=(1.0, 1.0), ncol=1)",
        "begin_line": 3172,
        "end_line": 3187,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_emptydata#3190",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_emptydata()",
        "snippet": "def test_hist_emptydata():\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist([[], range(10), range(10)], histtype=\"step\")",
        "begin_line": 3190,
        "end_line": 3193,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_labels#3196",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_labels()",
        "snippet": "def test_hist_labels():\n    # test singleton labels OK\n    fig, ax = plt.subplots()\n    l = ax.hist([0, 1], label=0)\n    assert l[2][0].get_label() == '0'\n    l = ax.hist([0, 1], label=[0])\n    assert l[2][0].get_label() == '0'\n    l = ax.hist([0, 1], label=None)\n    assert l[2][0].get_label() == '_nolegend_'\n    l = ax.hist([0, 1], label='0')\n    assert l[2][0].get_label() == '0'\n    l = ax.hist([0, 1], label='00')\n    assert l[2][0].get_label() == '00'",
        "begin_line": 3196,
        "end_line": 3208,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_transparent_markers#3212",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_transparent_markers()",
        "snippet": "def test_transparent_markers():\n    np.random.seed(0)\n    data = np.random.random(50)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(data, 'D', mfc='none', markersize=100)",
        "begin_line": 3212,
        "end_line": 3218,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rgba_markers#3222",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rgba_markers()",
        "snippet": "def test_rgba_markers():\n    fig, axs = plt.subplots(ncols=2)\n    rcolors = [(1, 0, 0, 1), (1, 0, 0, 0.5)]\n    bcolors = [(0, 0, 1, 1), (0, 0, 1, 0.5)]\n    alphas = [None, 0.2]\n    kw = dict(ms=100, mew=20)\n    for i, alpha in enumerate(alphas):\n        for j, rcolor in enumerate(rcolors):\n            for k, bcolor in enumerate(bcolors):\n                axs[i].plot(j+1, k+1, 'o', mfc=bcolor, mec=rcolor,\n                            alpha=alpha, **kw)\n                axs[i].plot(j+1, k+3, 'x', mec=rcolor, alpha=alpha, **kw)\n    for ax in axs:\n        ax.axis([-1, 4, 0, 5])",
        "begin_line": 3222,
        "end_line": 3235,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_mollweide_grid#3239",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_mollweide_grid()",
        "snippet": "def test_mollweide_grid():\n    # test that both horizontal and vertical gridlines appear on the Mollweide\n    # projection\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='mollweide')\n    ax.grid()",
        "begin_line": 3239,
        "end_line": 3244,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_mollweide_forward_inverse_closure#3247",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_mollweide_forward_inverse_closure()",
        "snippet": "def test_mollweide_forward_inverse_closure():\n    # test that the round-trip Mollweide forward->inverse transformation is an\n    # approximate identity\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='mollweide')\n\n    # set up 1-degree grid in longitude, latitude\n    lon = np.linspace(-np.pi, np.pi, 360)\n    lat = np.linspace(-np.pi / 2.0, np.pi / 2.0, 180)\n    lon, lat = np.meshgrid(lon, lat)\n    ll = np.vstack((lon.flatten(), lat.flatten())).T\n\n    # perform forward transform\n    xy = ax.transProjection.transform(ll)\n\n    # perform inverse transform\n    ll2 = ax.transProjection.inverted().transform(xy)\n\n    # compare\n    np.testing.assert_array_almost_equal(ll, ll2, 3)",
        "begin_line": 3247,
        "end_line": 3266,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_mollweide_inverse_forward_closure#3269",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_mollweide_inverse_forward_closure()",
        "snippet": "def test_mollweide_inverse_forward_closure():\n    # test that the round-trip Mollweide inverse->forward transformation is an\n    # approximate identity\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='mollweide')\n\n    # set up grid in x, y\n    x = np.linspace(0, 1, 500)\n    x, y = np.meshgrid(x, x)\n    xy = np.vstack((x.flatten(), y.flatten())).T\n\n    # perform inverse transform\n    ll = ax.transProjection.inverted().transform(xy)\n\n    # perform forward transform\n    xy2 = ax.transProjection.transform(ll)\n\n    # compare\n    np.testing.assert_array_almost_equal(xy, xy2, 3)",
        "begin_line": 3269,
        "end_line": 3287,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_alpha#3291",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_alpha()",
        "snippet": "def test_alpha():\n    np.random.seed(0)\n    data = np.random.random(50)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n\n    # alpha=.5 markers, solid line\n    ax.plot(data, '-D', color=[1, 0, 0], mfc=[1, 0, 0, .5],\n            markersize=20, lw=10)\n\n    # everything solid by kwarg\n    ax.plot(data + 2, '-D', color=[1, 0, 0, .5], mfc=[1, 0, 0, .5],\n            markersize=20, lw=10,\n            alpha=1)\n\n    # everything alpha=.5 by kwarg\n    ax.plot(data + 4, '-D', color=[1, 0, 0], mfc=[1, 0, 0],\n            markersize=20, lw=10,\n            alpha=.5)\n\n    # everything alpha=.5 by colors\n    ax.plot(data + 6, '-D', color=[1, 0, 0, .5], mfc=[1, 0, 0, .5],\n            markersize=20, lw=10)\n\n    # alpha=.5 line, solid markers\n    ax.plot(data + 8, '-D', color=[1, 0, 0, .5], mfc=[1, 0, 0],\n            markersize=20, lw=10)",
        "begin_line": 3291,
        "end_line": 3318,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot#3322",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot()",
        "snippet": "def test_eventplot():\n    '''\n    test that eventplot produces the correct output\n    '''\n    np.random.seed(0)\n\n    data1 = np.random.random([32, 20]).tolist()\n    data2 = np.random.random([6, 20]).tolist()\n    data = data1 + data2\n    num_datasets = len(data)\n\n    colors1 = [[0, 1, .7]] * len(data1)\n    colors2 = [[1, 0, 0],\n               [0, 1, 0],\n               [0, 0, 1],\n               [1, .75, 0],\n               [1, 0, 1],\n               [0, 1, 1]]\n    colors = colors1 + colors2\n\n    lineoffsets1 = 12 + np.arange(0, len(data1)) * .33\n    lineoffsets2 = [-15, -3, 1, 1.5, 6, 10]\n    lineoffsets = lineoffsets1.tolist() + lineoffsets2\n\n    linelengths1 = [.33] * len(data1)\n    linelengths2 = [5, 2, 1, 1, 3, 1.5]\n    linelengths = linelengths1 + linelengths2\n\n    fig = plt.figure()\n    axobj = fig.add_subplot(111)\n    colls = axobj.eventplot(data, colors=colors, lineoffsets=lineoffsets,\n                            linelengths=linelengths)\n\n    num_collections = len(colls)\n    assert num_collections == num_datasets\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"pos\": data, \"c\": colors, \"lo\": lineoffsets, \"ll\": linelengths}\n    fig = plt.figure()\n    axobj = fig.add_subplot(111)\n    colls = axobj.eventplot(\"pos\", colors=\"c\", lineoffsets=\"lo\",\n                            linelengths=\"ll\", data=data)\n    num_collections = len(colls)\n    assert num_collections == num_datasets",
        "begin_line": 3322,
        "end_line": 3365,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot_defaults#3370",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot_defaults()",
        "snippet": "def test_eventplot_defaults():\n    '''\n    test that eventplot produces the correct output given the default params\n    (see bug #3728)\n    '''\n    np.random.seed(0)\n\n    data1 = np.random.random([32, 20]).tolist()\n    data2 = np.random.random([6, 20]).tolist()\n    data = data1 + data2\n\n    fig = plt.figure()\n    axobj = fig.add_subplot(111)\n    colls = axobj.eventplot(data)",
        "begin_line": 3370,
        "end_line": 3383,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot_colors#3392",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot_colors(colors)",
        "snippet": "def test_eventplot_colors(colors):\n    '''Test the *colors* parameter of eventplot. Inspired by the issue #8193.\n    '''\n    data = [[i] for i in range(4)]  # 4 successive events of different nature\n\n    # Build the list of the expected colors\n    expected = [c if c is not None else 'C0' for c in colors]\n    # Convert the list into an array of RGBA values\n    # NB: ['rgbk'] is not a valid argument for to_rgba_array, while 'rgbk' is.\n    if len(expected) == 1:\n        expected = expected[0]\n    expected = np.broadcast_to(mcolors.to_rgba_array(expected), (len(data), 4))\n\n    fig, ax = plt.subplots()\n    if len(colors) == 1:  # tuple with a single string (like '0.5' or 'rgbk')\n        colors = colors[0]\n    collections = ax.eventplot(data, colors=colors)\n\n    for coll, color in zip(collections, expected):\n        assert_allclose(coll.get_color(), color)",
        "begin_line": 3392,
        "end_line": 3411,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot_problem_kwargs#3416",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot_problem_kwargs()",
        "snippet": "def test_eventplot_problem_kwargs():\n    '''\n    test that 'singular' versions of LineCollection props raise an\n    IgnoredKeywordWarning rather than overriding the 'plural' versions (e.g.\n    to prevent 'color' from overriding 'colors', see issue #4297)\n    '''\n    np.random.seed(0)\n\n    data1 = np.random.random([20]).tolist()\n    data2 = np.random.random([10]).tolist()\n    data = [data1, data2]\n\n    fig = plt.figure()\n    axobj = fig.add_subplot(111)\n\n    with warnings.catch_warnings(record=True) as w:\n        warnings.simplefilter(\"always\")\n        colls = axobj.eventplot(data,\n                                colors=['r', 'b'],\n                                color=['c', 'm'],\n                                linewidths=[2, 1],\n                                linewidth=[1, 2],\n                                linestyles=['solid', 'dashed'],\n                                linestyle=['dashdot', 'dotted'])\n\n        # check that three IgnoredKeywordWarnings were raised\n        assert len(w) == 3\n        assert all(issubclass(wi.category, IgnoredKeywordWarning) for wi in w)",
        "begin_line": 3416,
        "end_line": 3443,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_empty_eventplot#3446",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_empty_eventplot()",
        "snippet": "def test_empty_eventplot():\n    fig, ax = plt.subplots(1, 1)\n    ax.eventplot([[]], colors=[(0.0, 0.0, 0.0, 0.0)])\n    plt.draw()",
        "begin_line": 3446,
        "end_line": 3449,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot_orientation#3455",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot_orientation(data, orientation)",
        "snippet": "def test_eventplot_orientation(data, orientation):\n    \"\"\"Introduced when fixing issue #6412. \"\"\"\n    opts = {} if orientation == \"_empty\" else {'orientation': orientation}\n    fig, ax = plt.subplots(1, 1)\n    ax.eventplot(data, **opts)\n    plt.draw()",
        "begin_line": 3455,
        "end_line": 3460,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_marker_styles#3465",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_marker_styles()",
        "snippet": "def test_marker_styles():\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    for y, marker in enumerate(sorted(matplotlib.markers.MarkerStyle.markers,\n                                      key=lambda x: str(type(x))+str(x))):\n        ax.plot((y % 2)*5 + np.arange(10)*10, np.ones(10)*10*y, linestyle='',\n                marker=marker, markersize=10+y/5, label=marker)",
        "begin_line": 3465,
        "end_line": 3471,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markers_fillstyle_rcparams#3475",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markers_fillstyle_rcparams()",
        "snippet": "def test_markers_fillstyle_rcparams():\n    fig, ax = plt.subplots()\n    x = np.arange(7)\n    for idx, (style, marker) in enumerate(\n            [('top', 's'), ('bottom', 'o'), ('none', '^')]):\n        matplotlib.rcParams['markers.fillstyle'] = style\n        ax.plot(x+idx, marker=marker)",
        "begin_line": 3475,
        "end_line": 3481,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vertex_markers#3486",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vertex_markers()",
        "snippet": "def test_vertex_markers():\n    data = list(range(10))\n    marker_as_tuple = ((-1, -1), (1, -1), (1, 1), (-1, 1))\n    marker_as_list = [(-1, -1), (1, -1), (1, 1), (-1, 1)]\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(data, linestyle='', marker=marker_as_tuple, mfc='k')\n    ax.plot(data[::-1], linestyle='', marker=marker_as_list, mfc='b')\n    ax.set_xlim([-1, 10])\n    ax.set_ylim([-1, 10])",
        "begin_line": 3486,
        "end_line": 3495,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eb_line_zorder#3501",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eb_line_zorder()",
        "snippet": "def test_eb_line_zorder():\n    x = list(range(10))\n\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.plot(x, lw=10, zorder=5)\n    ax.axhline(1, color='red', lw=10, zorder=1)\n    ax.axhline(5, color='green', lw=10, zorder=10)\n    ax.axvline(7, color='m', lw=10, zorder=7)\n    ax.axvline(2, color='k', lw=10, zorder=3)\n\n    ax.set_title(\"axvline and axhline zorder test\")\n\n    # Now switch to a more OO interface to exercise more features.\n    fig = plt.figure()\n    ax = fig.gca()\n    x = list(range(10))\n    y = np.zeros(10)\n    yerr = list(range(10))\n    ax.errorbar(x, y, yerr=yerr, zorder=5, lw=5, color='r')\n    for j in range(10):\n        ax.axhline(j, lw=5, color='k', zorder=j)\n        ax.axhline(-j, lw=5, color='k', zorder=j)\n\n    ax.set_title(\"errorbar zorder test\")",
        "begin_line": 3501,
        "end_line": 3526,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vlines#3533",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vlines()",
        "snippet": "def test_vlines():\n    # normal\n    x1 = [2, 3, 4, 5, 7]\n    y1 = [2, -6, 3, 8, 2]\n    fig1, ax1 = plt.subplots()\n    ax1.vlines(x1, 0, y1, colors='g', linewidth=5)\n\n    # GH #7406\n    x2 = [2, 3, 4, 5, 6, 7]\n    y2 = [2, -6, 3, 8, np.nan, 2]\n    fig2, (ax2, ax3, ax4) = plt.subplots(nrows=3, figsize=(4, 8))\n    ax2.vlines(x2, 0, y2, colors='g', linewidth=5)\n\n    x3 = [2, 3, 4, 5, 6, 7]\n    y3 = [np.nan, 2, -6, 3, 8, 2]\n    ax3.vlines(x3, 0, y3, colors='r', linewidth=3, linestyle='--')\n\n    x4 = [2, 3, 4, 5, 6, 7]\n    y4 = [np.nan, 2, -6, 3, 8, np.nan]\n    ax4.vlines(x4, 0, y4, colors='k', linewidth=2)\n\n    # tweak the x-axis so we can see the lines better\n    for ax in [ax1, ax2, ax3, ax4]:\n        ax.set_xlim(0, 10)\n\n    # check that the y-lims are all automatically the same\n    assert ax1.get_ylim() == ax2.get_ylim()\n    assert ax1.get_ylim() == ax3.get_ylim()\n    assert ax1.get_ylim() == ax4.get_ylim()\n\n    fig3, ax5 = plt.subplots()\n    x5 = np.ma.masked_equal([2, 4, 6, 8, 10, 12], 8)\n    ymin5 = np.ma.masked_equal([0, 1, -1, 0, 2, 1], 2)\n    ymax5 = np.ma.masked_equal([13, 14, 15, 16, 17, 18], 18)\n    ax5.vlines(x5, ymin5, ymax5, colors='k', linewidth=2)\n    ax5.set_xlim(0, 15)",
        "begin_line": 3533,
        "end_line": 3568,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hlines#3575",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hlines()",
        "snippet": "def test_hlines():\n    # normal\n    y1 = [2, 3, 4, 5, 7]\n    x1 = [2, -6, 3, 8, 2]\n    fig1, ax1 = plt.subplots()\n    ax1.hlines(y1, 0, x1, colors='g', linewidth=5)\n\n    # GH #7406\n    y2 = [2, 3, 4, 5, 6, 7]\n    x2 = [2, -6, 3, 8, np.nan, 2]\n    fig2, (ax2, ax3, ax4) = plt.subplots(nrows=3, figsize=(4, 8))\n    ax2.hlines(y2, 0, x2, colors='g', linewidth=5)\n\n    y3 = [2, 3, 4, 5, 6, 7]\n    x3 = [np.nan, 2, -6, 3, 8, 2]\n    ax3.hlines(y3, 0, x3, colors='r', linewidth=3, linestyle='--')\n\n    y4 = [2, 3, 4, 5, 6, 7]\n    x4 = [np.nan, 2, -6, 3, 8, np.nan]\n    ax4.hlines(y4, 0, x4, colors='k', linewidth=2)\n\n    # tweak the y-axis so we can see the lines better\n    for ax in [ax1, ax2, ax3, ax4]:\n        ax.set_ylim(0, 10)\n\n    # check that the x-lims are all automatically the same\n    assert ax1.get_xlim() == ax2.get_xlim()\n    assert ax1.get_xlim() == ax3.get_xlim()\n    assert ax1.get_xlim() == ax4.get_xlim()\n\n    fig3, ax5 = plt.subplots()\n    y5 = np.ma.masked_equal([2, 4, 6, 8, 10, 12], 8)\n    xmin5 = np.ma.masked_equal([0, 1, -1, 0, 2, 1], 2)\n    xmax5 = np.ma.masked_equal([13, 14, 15, 16, 17, 18], 18)\n    ax5.hlines(y5, xmin5, xmax5, colors='k', linewidth=2)\n    ax5.set_ylim(0, 15)",
        "begin_line": 3575,
        "end_line": 3610,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_step_linestyle#3615",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_step_linestyle()",
        "snippet": "def test_step_linestyle():\n    x = y = np.arange(10)\n\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig, ax_lst = plt.subplots(2, 2)\n    ax_lst = ax_lst.flatten()\n\n    ln_styles = ['-', '--', '-.', ':']\n\n    for ax, ls in zip(ax_lst, ln_styles):\n        ax.step(x, y, lw=5, linestyle=ls, where='pre')\n        ax.step(x, y + 1, lw=5, linestyle=ls, where='mid')\n        ax.step(x, y + 2, lw=5, linestyle=ls, where='post')\n        ax.set_xlim([-1, 5])\n        ax.set_ylim([-1, 7])\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"X\": x, \"Y0\": y, \"Y1\": y+1, \"Y2\": y+2}\n    fig, ax_lst = plt.subplots(2, 2)\n    ax_lst = ax_lst.flatten()\n    ln_styles = ['-', '--', '-.', ':']\n    for ax, ls in zip(ax_lst, ln_styles):\n        ax.step(\"X\", \"Y0\", lw=5, linestyle=ls, where='pre', data=data)\n        ax.step(\"X\", \"Y1\", lw=5, linestyle=ls, where='mid', data=data)\n        ax.step(\"X\", \"Y2\", lw=5, linestyle=ls, where='post', data=data)\n        ax.set_xlim([-1, 5])\n        ax.set_ylim([-1, 7])",
        "begin_line": 3615,
        "end_line": 3641,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_mixed_collection#3645",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_mixed_collection()",
        "snippet": "def test_mixed_collection():\n    from matplotlib import patches\n    from matplotlib import collections\n\n    x = list(range(10))\n\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n\n    c = patches.Circle((8, 8), radius=4, facecolor='none', edgecolor='green')\n\n    # PDF can optimize this one\n    p1 = collections.PatchCollection([c], match_original=True)\n    p1.set_offsets([[0, 0], [24, 24]])\n    p1.set_linewidths([1, 5])\n\n    # PDF can't optimize this one, because the alpha of the edge changes\n    p2 = collections.PatchCollection([c], match_original=True)\n    p2.set_offsets([[48, 0], [-32, -16]])\n    p2.set_linewidths([1, 5])\n    p2.set_edgecolors([[0, 0, 0.1, 1.0], [0, 0, 0.1, 0.5]])\n\n    ax.patch.set_color('0.5')\n    ax.add_collection(p1)\n    ax.add_collection(p2)\n\n    ax.set_xlim(0, 16)\n    ax.set_ylim(0, 16)",
        "begin_line": 3645,
        "end_line": 3673,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_subplot_key_hash#3676",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_subplot_key_hash()",
        "snippet": "def test_subplot_key_hash():\n    ax = plt.subplot(np.float64(5.5), np.int64(1), np.float64(1.2))\n    ax.twinx()\n    assert ax.get_subplotspec().get_geometry() == (5, 1, 0, 0)",
        "begin_line": 3676,
        "end_line": 3679,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_freqs#3686",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_freqs()",
        "snippet": "def test_specgram_freqs():\n    '''test axes.specgram in default (psd) mode with sinusoidal stimuli'''\n    n = 1000\n    Fs = 10.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(10 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for fstim1, fstim2 in zip(fstims1, fstims2):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided')\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided')\n\n    spec21 = ax21.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec22 = ax22.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec23 = ax23.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided',\n                           scale='linear', norm=matplotlib.colors.LogNorm())",
        "begin_line": 3686,
        "end_line": 3733,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_noise#3740",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_noise()",
        "snippet": "def test_specgram_noise():\n    '''test axes.specgram in default (psd) mode with noise stimuli'''\n    np.random.seed(0)\n\n    n = 1000\n    Fs = 10.\n\n    NFFT = int(10 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided')\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided')\n\n    spec21 = ax21.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec22 = ax22.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec23 = ax23.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided',\n                           scale='linear', norm=matplotlib.colors.LogNorm())",
        "begin_line": 3740,
        "end_line": 3781,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_magnitude_freqs#3788",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_magnitude_freqs()",
        "snippet": "def test_specgram_magnitude_freqs():\n    '''test axes.specgram in magnitude mode with sinusoidal stimuli'''\n    n = 1000\n    Fs = 10.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(100 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for i, (fstim1, fstim2) in enumerate(zip(fstims1, fstims2)):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n        y1[-1] = y1[-1]/y1[-1]\n        y2[-1] = y2[-1]/y2[-1]\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default', mode='magnitude')\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided', mode='magnitude')\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided', mode='magnitude')\n\n    spec21 = ax21.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default', mode='magnitude',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec22 = ax22.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided', mode='magnitude',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec23 = ax23.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided', mode='magnitude',\n                           scale='linear', norm=matplotlib.colors.LogNorm())",
        "begin_line": 3788,
        "end_line": 3837,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_magnitude_noise#3844",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_magnitude_noise()",
        "snippet": "def test_specgram_magnitude_noise():\n    '''test axes.specgram in magnitude mode with noise stimuli'''\n    np.random.seed(0)\n\n    n = 1000\n    Fs = 10.\n\n    NFFT = int(10 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default', mode='magnitude')\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided', mode='magnitude')\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided', mode='magnitude')\n\n    spec21 = ax21.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default', mode='magnitude',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec22 = ax22.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided', mode='magnitude',\n                           scale='linear', norm=matplotlib.colors.LogNorm())\n    spec23 = ax23.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided', mode='magnitude',\n                           scale='linear', norm=matplotlib.colors.LogNorm())",
        "begin_line": 3844,
        "end_line": 3885,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_angle_freqs#3891",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_angle_freqs()",
        "snippet": "def test_specgram_angle_freqs():\n    '''test axes.specgram in angle mode with sinusoidal stimuli'''\n    n = 1000\n    Fs = 10.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(10 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for i, (fstim1, fstim2) in enumerate(zip(fstims1, fstims2)):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n        y1[-1] = y1[-1]/y1[-1]\n        y2[-1] = y2[-1]/y2[-1]\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default', mode='angle')\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided', mode='angle')\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided', mode='angle')\n\n    with pytest.raises(ValueError):\n        ax11.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='default',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax12.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='onesided',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax13.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='twosided',\n                      mode='phase', scale='dB')",
        "begin_line": 3891,
        "end_line": 3940,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_noise_angle#3946",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_noise_angle()",
        "snippet": "def test_specgram_noise_angle():\n    '''test axes.specgram in angle mode with noise stimuli'''\n    np.random.seed(0)\n\n    n = 1000\n    Fs = 10.\n\n    NFFT = int(10 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default', mode='angle')\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided', mode='angle')\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided', mode='angle')\n\n    with pytest.raises(ValueError):\n        ax11.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='default',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax12.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='onesided',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax13.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='twosided',\n                      mode='phase', scale='dB')",
        "begin_line": 3946,
        "end_line": 3987,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_freqs_phase#3993",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_freqs_phase()",
        "snippet": "def test_specgram_freqs_phase():\n    '''test axes.specgram in phase mode with sinusoidal stimuli'''\n    n = 1000\n    Fs = 10.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(10 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for i, (fstim1, fstim2) in enumerate(zip(fstims1, fstims2)):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n        y1[-1] = y1[-1]/y1[-1]\n        y2[-1] = y2[-1]/y2[-1]\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default', mode='phase')\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided', mode='phase')\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided', mode='phase')\n\n    with pytest.raises(ValueError):\n        ax11.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='default',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax12.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='onesided',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax13.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='twosided',\n                      mode='phase', scale='dB')",
        "begin_line": 3993,
        "end_line": 4042,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_noise_phase#4048",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_noise_phase()",
        "snippet": "def test_specgram_noise_phase():\n    '''test axes.specgram in phase mode with noise stimuli'''\n    np.random.seed(0)\n\n    n = 1000\n    Fs = 10.\n\n    NFFT = int(10 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    spec11 = ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default',\n                           mode='phase', )\n    spec12 = ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           mode='phase', )\n    spec13 = ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='twosided',\n                           mode='phase', )\n\n    with pytest.raises(ValueError):\n        ax11.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='default',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax12.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='onesided',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax13.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='twosided',\n                      mode='phase', scale='dB')",
        "begin_line": 4048,
        "end_line": 4092,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_psd_freqs#4097",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_psd_freqs()",
        "snippet": "def test_psd_freqs():\n    '''test axes.psd with sinusoidal stimuli'''\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(1000 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for fstim1, fstim2 in zip(fstims1, fstims2):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n    y = np.hstack([y1, y2])\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    psd1, freqs1 = ax1.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    psd2, freqs2 = ax2.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           return_line=False)\n    psd3, freqs3, line3 = ax3.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                                  pad_to=pad_to, sides='twosided',\n                                  return_line=True)\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4097,
        "end_line": 4137,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_psd_noise#4142",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_psd_noise()",
        "snippet": "def test_psd_noise():\n    '''test axes.psd with noise stimuli'''\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2])\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    psd1, freqs1 = ax1.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    psd2, freqs2 = ax2.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           return_line=False)\n    psd3, freqs3, line3 = ax3.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                                  pad_to=pad_to, sides='twosided',\n                                  return_line=True)\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4142,
        "end_line": 4176,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_csd_freqs#4181",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_csd_freqs()",
        "snippet": "def test_csd_freqs():\n    '''test axes.csd with sinusoidal stimuli'''\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(1000 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for fstim1, fstim2 in zip(fstims1, fstims2):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    csd1, freqs1 = ax1.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    csd2, freqs2 = ax2.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           return_line=False)\n    csd3, freqs3, line3 = ax3.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                                  pad_to=pad_to, sides='twosided',\n                                  return_line=True)\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4181,
        "end_line": 4220,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_csd_noise#4225",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_csd_noise()",
        "snippet": "def test_csd_noise():\n    '''test axes.csd with noise stimuli'''\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    csd1, freqs1 = ax1.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    csd2, freqs2 = ax2.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           return_line=False)\n    csd3, freqs3, line3 = ax3.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                                  pad_to=pad_to, sides='twosided',\n                                  return_line=True)\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4225,
        "end_line": 4258,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_magnitude_spectrum_freqs#4265",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_magnitude_spectrum_freqs()",
        "snippet": "def test_magnitude_spectrum_freqs():\n    '''test axes.magnitude_spectrum with sinusoidal stimuli'''\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n\n    NFFT = int(1000 * Fs / min(fstims1))\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y = np.zeros(x.size)\n    for i, fstim1 in enumerate(fstims1):\n        y += np.sin(fstim1 * x * np.pi * 2) * 10**i\n    y = y\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    spec11, freqs11, line11 = ax11.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='default')\n    spec12, freqs12, line12 = ax12.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='onesided')\n    spec13, freqs13, line13 = ax13.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='twosided')\n\n    spec21, freqs21, line21 = ax21.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='default',\n                                                      scale='dB')\n    spec22, freqs22, line22 = ax22.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='onesided',\n                                                      scale='dB')\n    spec23, freqs23, line23 = ax23.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='twosided',\n                                                      scale='dB')\n\n    ax11.set_xlabel('')\n    ax12.set_xlabel('')\n    ax13.set_xlabel('')\n    ax11.set_ylabel('')\n    ax12.set_ylabel('')\n    ax13.set_ylabel('')\n\n    ax21.set_xlabel('')\n    ax22.set_xlabel('')\n    ax23.set_xlabel('')\n    ax21.set_ylabel('')\n    ax22.set_ylabel('')\n    ax23.set_ylabel('')",
        "begin_line": 4265,
        "end_line": 4322,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_magnitude_spectrum_noise#4329",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_magnitude_spectrum_noise()",
        "snippet": "def test_magnitude_spectrum_noise():\n    '''test axes.magnitude_spectrum with noise stimuli'''\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2]) - .5\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    spec11, freqs11, line11 = ax11.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='default')\n    spec12, freqs12, line12 = ax12.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='onesided')\n    spec13, freqs13, line13 = ax13.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='twosided')\n\n    spec21, freqs21, line21 = ax21.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='default',\n                                                      scale='dB')\n    spec22, freqs22, line22 = ax22.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='onesided',\n                                                      scale='dB')\n    spec23, freqs23, line23 = ax23.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='twosided',\n                                                      scale='dB')\n\n    ax11.set_xlabel('')\n    ax12.set_xlabel('')\n    ax13.set_xlabel('')\n    ax11.set_ylabel('')\n    ax12.set_ylabel('')\n    ax13.set_ylabel('')\n\n    ax21.set_xlabel('')\n    ax22.set_xlabel('')\n    ax23.set_xlabel('')\n    ax21.set_ylabel('')\n    ax22.set_ylabel('')\n    ax23.set_ylabel('')",
        "begin_line": 4329,
        "end_line": 4383,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_angle_spectrum_freqs#4389",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_angle_spectrum_freqs()",
        "snippet": "def test_angle_spectrum_freqs():\n    '''test axes.angle_spectrum with sinusoidal stimuli'''\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n\n    NFFT = int(1000 * Fs / min(fstims1))\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y = np.zeros(x.size)\n    for i, fstim1 in enumerate(fstims1):\n        y += np.sin(fstim1 * x * np.pi * 2) * 10**i\n    y = y\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    spec1, freqs1, line1 = ax1.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='default')\n    spec2, freqs2, line2 = ax2.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='onesided')\n    spec3, freqs3, line3 = ax3.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='twosided')\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4389,
        "end_line": 4423,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_angle_spectrum_noise#4429",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_angle_spectrum_noise()",
        "snippet": "def test_angle_spectrum_noise():\n    '''test axes.angle_spectrum with noise stimuli'''\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2]) - .5\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    spec1, freqs1, line1 = ax1.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='default')\n    spec2, freqs2, line2 = ax2.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='onesided')\n    spec3, freqs3, line3 = ax3.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='twosided')\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4429,
        "end_line": 4460,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_phase_spectrum_freqs#4466",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_phase_spectrum_freqs()",
        "snippet": "def test_phase_spectrum_freqs():\n    '''test axes.phase_spectrum with sinusoidal stimuli'''\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n\n    NFFT = int(1000 * Fs / min(fstims1))\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y = np.zeros(x.size)\n    for i, fstim1 in enumerate(fstims1):\n        y += np.sin(fstim1 * x * np.pi * 2) * 10**i\n    y = y\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    spec1, freqs1, line1 = ax1.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='default')\n    spec2, freqs2, line2 = ax2.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='onesided')\n    spec3, freqs3, line3 = ax3.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='twosided')\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4466,
        "end_line": 4500,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_phase_spectrum_noise#4506",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_phase_spectrum_noise()",
        "snippet": "def test_phase_spectrum_noise():\n    '''test axes.phase_spectrum with noise stimuli'''\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2]) - .5\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    spec1, freqs1, line1 = ax1.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='default')\n    spec2, freqs2, line2 = ax2.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='onesided')\n    spec3, freqs3, line3 = ax3.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='twosided')\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4506,
        "end_line": 4537,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twin_spines#4542",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twin_spines()",
        "snippet": "def test_twin_spines():\n\n    def make_patch_spines_invisible(ax):\n        ax.set_frame_on(True)\n        ax.patch.set_visible(False)\n        for sp in ax.spines.values():\n            sp.set_visible(False)\n\n    fig = plt.figure(figsize=(4, 3))\n    fig.subplots_adjust(right=0.75)\n\n    host = fig.add_subplot(111)\n    par1 = host.twinx()\n    par2 = host.twinx()\n\n    # Offset the right spine of par2.  The ticks and label have already been\n    # placed on the right by twinx above.\n    par2.spines[\"right\"].set_position((\"axes\", 1.2))\n    # Having been created by twinx, par2 has its frame off, so the line of\n    # its detached spine is invisible.  First, activate the frame but make\n    # the patch and spines invisible.\n    make_patch_spines_invisible(par2)\n    # Second, show the right spine.\n    par2.spines[\"right\"].set_visible(True)\n\n    p1, = host.plot([0, 1, 2], [0, 1, 2], \"b-\")\n    p2, = par1.plot([0, 1, 2], [0, 3, 2], \"r-\")\n    p3, = par2.plot([0, 1, 2], [50, 30, 15], \"g-\")\n\n    host.set_xlim(0, 2)\n    host.set_ylim(0, 2)\n    par1.set_ylim(0, 4)\n    par2.set_ylim(1, 65)\n\n    host.yaxis.label.set_color(p1.get_color())\n    par1.yaxis.label.set_color(p2.get_color())\n    par2.yaxis.label.set_color(p3.get_color())\n\n    tkw = dict(size=4, width=1.5)\n    host.tick_params(axis='y', colors=p1.get_color(), **tkw)\n    par1.tick_params(axis='y', colors=p2.get_color(), **tkw)\n    par2.tick_params(axis='y', colors=p3.get_color(), **tkw)\n    host.tick_params(axis='x', **tkw)",
        "begin_line": 4542,
        "end_line": 4584,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.make_patch_spines_invisible#4544",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.make_patch_spines_invisible(ax)",
        "snippet": "    def make_patch_spines_invisible(ax):\n        ax.set_frame_on(True)\n        ax.patch.set_visible(False)\n        for sp in ax.spines.values():\n            sp.set_visible(False)",
        "begin_line": 4544,
        "end_line": 4548,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twin_spines_on_top#4589",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twin_spines_on_top()",
        "snippet": "def test_twin_spines_on_top():\n    matplotlib.rcParams['axes.linewidth'] = 48.0\n    matplotlib.rcParams['lines.linewidth'] = 48.0\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(1, 1, 1)\n\n    data = np.array([[1000, 1100, 1200, 1250],\n                     [310, 301, 360, 400]])\n\n    ax2 = ax1.twinx()\n\n    ax1.plot(data[0], data[1]/1E3, color='#BEAED4')\n    ax1.fill_between(data[0], data[1]/1E3, color='#BEAED4', alpha=.8)\n\n    ax2.plot(data[0], data[1]/1E3, color='#7FC97F')\n    ax2.fill_between(data[0], data[1]/1E3, color='#7FC97F', alpha=.5)\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"i\": data[0], \"j\": data[1]/1E3}\n    fig = plt.figure()\n    ax1 = fig.add_subplot(1, 1, 1)\n    ax2 = ax1.twinx()\n    ax1.plot(\"i\", \"j\", color='#BEAED4', data=data)\n    ax1.fill_between(\"i\", \"j\", color='#BEAED4', alpha=.8, data=data)\n    ax2.plot(\"i\", \"j\", color='#7FC97F', data=data)\n    ax2.fill_between(\"i\", \"j\", color='#7FC97F', alpha=.5, data=data)",
        "begin_line": 4589,
        "end_line": 4615,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rcparam_grid_minor#4618",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rcparam_grid_minor()",
        "snippet": "def test_rcparam_grid_minor():\n    orig_grid = matplotlib.rcParams['axes.grid']\n    orig_locator = matplotlib.rcParams['axes.grid.which']\n\n    matplotlib.rcParams['axes.grid'] = True\n\n    values = (\n        (('both'), (True, True)),\n        (('major'), (True, False)),\n        (('minor'), (False, True))\n        )\n\n    for locator, result in values:\n        matplotlib.rcParams['axes.grid.which'] = locator\n        fig = plt.figure()\n        ax = fig.add_subplot(1, 1, 1)\n        assert (ax.xaxis._gridOnMajor, ax.xaxis._gridOnMinor) == result\n\n    matplotlib.rcParams['axes.grid'] = orig_grid\n    matplotlib.rcParams['axes.grid.which'] = orig_locator",
        "begin_line": 4618,
        "end_line": 4637,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vline_limit#4640",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vline_limit()",
        "snippet": "def test_vline_limit():\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.axvline(0.5)\n    ax.plot([-0.1, 0, 0.2, 0.1])\n    (ymin, ymax) = ax.get_ylim()\n    assert_allclose(ax.get_ylim(), (-.1, .2))",
        "begin_line": 4640,
        "end_line": 4646,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_empty_shared_subplots#4649",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_empty_shared_subplots()",
        "snippet": "def test_empty_shared_subplots():\n    # empty plots with shared axes inherit limits from populated plots\n    fig, axes = plt.subplots(nrows=1, ncols=2, sharex=True, sharey=True)\n    axes[0].plot([1, 2, 3], [2, 4, 6])\n    x0, x1 = axes[1].get_xlim()\n    y0, y1 = axes[1].get_ylim()\n    assert x0 <= 1\n    assert x1 >= 3\n    assert y0 <= 2\n    assert y1 >= 6",
        "begin_line": 4649,
        "end_line": 4658,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_1#4661",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_1()",
        "snippet": "def test_shared_with_aspect_1():\n    # allow sharing one axis\n    for adjustable in ['box', 'datalim']:\n        fig, axes = plt.subplots(nrows=2, sharex=True)\n        axes[0].set_aspect(2, adjustable=adjustable, share=True)\n        assert axes[1].get_aspect() == 2\n        assert axes[1].get_adjustable() == adjustable\n\n        fig, axes = plt.subplots(nrows=2, sharex=True)\n        axes[0].set_aspect(2, adjustable=adjustable)\n        assert axes[1].get_aspect() == 'auto'",
        "begin_line": 4661,
        "end_line": 4671,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_2#4674",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_2()",
        "snippet": "def test_shared_with_aspect_2():\n    # Share 2 axes only with 'box':\n    fig, axes = plt.subplots(nrows=2, sharex=True, sharey=True)\n    axes[0].set_aspect(2, share=True)\n    axes[0].plot([1, 2], [3, 4])\n    axes[1].plot([3, 4], [1, 2])\n    plt.draw()  # Trigger apply_aspect().\n    assert axes[0].get_xlim() == axes[1].get_xlim()\n    assert axes[0].get_ylim() == axes[1].get_ylim()",
        "begin_line": 4674,
        "end_line": 4682,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_3#4685",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_3()",
        "snippet": "def test_shared_with_aspect_3():\n    # Different aspect ratios:\n    for adjustable in ['box', 'datalim']:\n        fig, axes = plt.subplots(nrows=2, sharey=True)\n        axes[0].set_aspect(2, adjustable=adjustable)\n        axes[1].set_aspect(0.5, adjustable=adjustable)\n        axes[0].plot([1, 2], [3, 4])\n        axes[1].plot([3, 4], [1, 2])\n        plt.draw()  # Trigger apply_aspect().\n        assert axes[0].get_xlim() != axes[1].get_xlim()\n        assert axes[0].get_ylim() == axes[1].get_ylim()\n        fig_aspect = fig.bbox_inches.height / fig.bbox_inches.width\n        for ax in axes:\n            p = ax.get_position()\n            box_aspect = p.height / p.width\n            lim_aspect = ax.viewLim.height / ax.viewLim.width\n            expected = fig_aspect * box_aspect / lim_aspect\n            assert round(expected, 4) == round(ax.get_aspect(), 4)",
        "begin_line": 4685,
        "end_line": 4702,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twin_with_aspect#4706",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twin_with_aspect(twin)",
        "snippet": "def test_twin_with_aspect(twin):\n    fig, ax = plt.subplots()\n    # test twinx or twiny\n    ax_twin = getattr(ax, 'twin{}'.format(twin))()\n    ax.set_aspect(5)\n    ax_twin.set_aspect(2)\n    assert_array_equal(ax.bbox.extents,\n                       ax_twin.bbox.extents)",
        "begin_line": 4706,
        "end_line": 4713,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_relim_visible_only#4716",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_relim_visible_only()",
        "snippet": "def test_relim_visible_only():\n    x1 = (0., 10.)\n    y1 = (0., 10.)\n    x2 = (-10., 20.)\n    y2 = (-10., 30.)\n\n    fig = matplotlib.figure.Figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x1, y1)\n    assert ax.get_xlim() == x1\n    assert ax.get_ylim() == y1\n    l = ax.plot(x2, y2)\n    assert ax.get_xlim() == x2\n    assert ax.get_ylim() == y2\n    l[0].set_visible(False)\n    assert ax.get_xlim() == x2\n    assert ax.get_ylim() == y2\n\n    ax.relim(visible_only=True)\n    ax.autoscale_view()\n\n    assert ax.get_xlim() == x1\n    assert ax.get_ylim() == y1",
        "begin_line": 4716,
        "end_line": 4738,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_text_labelsize#4741",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_text_labelsize()",
        "snippet": "def test_text_labelsize():\n    \"\"\"\n    tests for issue #1172\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.tick_params(labelsize='large')\n    ax.tick_params(direction='out')",
        "begin_line": 4741,
        "end_line": 4748,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_default#4752",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_default()",
        "snippet": "def test_pie_default():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n    fig1, ax1 = plt.subplots(figsize=(8, 6))\n    pie1 = ax1.pie(sizes, explode=explode, labels=labels, colors=colors,\n                autopct='%1.1f%%', shadow=True, startangle=90)",
        "begin_line": 4752,
        "end_line": 4760,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_linewidth_0#4766",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_linewidth_0()",
        "snippet": "def test_pie_linewidth_0():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0})\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"l\": labels, \"s\": sizes, \"c\": colors, \"ex\": explode}\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.pie(\"s\", explode=\"ex\", labels=\"l\", colors=\"c\",\n           autopct='%1.1f%%', shadow=True, startangle=90,\n           wedgeprops={'linewidth': 0}, data=data)\n    ax.axis('equal')\n\n    # And again to test the pyplot functions which should also be able to be\n    # called with a data kwarg\n    plt.figure()\n    plt.pie(\"s\", explode=\"ex\", labels=\"l\", colors=\"c\",\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0}, data=data)\n    plt.axis('equal')",
        "begin_line": 4766,
        "end_line": 4794,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_center_radius#4798",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_center_radius()",
        "snippet": "def test_pie_center_radius():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0}, center=(1, 2), radius=1.5)\n\n    plt.annotate(\"Center point\", xy=(1, 2), xytext=(1, 1.5),\n                 arrowprops=dict(arrowstyle=\"->\",\n                                 connectionstyle=\"arc3\"))\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')",
        "begin_line": 4798,
        "end_line": 4813,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_linewidth_2#4817",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_linewidth_2()",
        "snippet": "def test_pie_linewidth_2():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 2})\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')",
        "begin_line": 4817,
        "end_line": 4828,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_ccw_true#4832",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_ccw_true()",
        "snippet": "def test_pie_ccw_true():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            counterclock=True)\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')",
        "begin_line": 4832,
        "end_line": 4843,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_frame_grid#4847",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_frame_grid()",
        "snippet": "def test_pie_frame_grid():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    # only \"explode\" the 2nd slice (i.e. 'Hogs')\n    explode = (0, 0.1, 0, 0)\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0},\n            frame=True, center=(2, 2))\n\n    plt.pie(sizes[::-1], explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0},\n            frame=True, center=(5, 2))\n\n    plt.pie(sizes, explode=explode[::-1], labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0},\n            frame=True, center=(3, 5))\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')",
        "begin_line": 4847,
        "end_line": 4870,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_rotatelabels_true#4875",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_rotatelabels_true()",
        "snippet": "def test_pie_rotatelabels_true():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Hogwarts', 'Frogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            rotatelabels=True)\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')",
        "begin_line": 4875,
        "end_line": 4886,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_nolabel_but_legend#4890",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_nolabel_but_legend()",
        "snippet": "def test_pie_nolabel_but_legend():\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90, labeldistance=None,\n            rotatelabels=True)\n    plt.axis('equal')\n    plt.ylim(-1.2, 1.2)\n    plt.legend()",
        "begin_line": 4890,
        "end_line": 4900,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_textprops#4903",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_textprops()",
        "snippet": "def test_pie_textprops():\n    data = [23, 34, 45]\n    labels = [\"Long name 1\", \"Long name 2\", \"Long name 3\"]\n\n    textprops = dict(horizontalalignment=\"center\",\n                     verticalalignment=\"top\",\n                     rotation=90,\n                     rotation_mode=\"anchor\",\n                     size=12, color=\"red\")\n\n    _, texts, autopct = plt.gca().pie(data, labels=labels, autopct='%.2f',\n                                      textprops=textprops)\n    for labels in [texts, autopct]:\n        for tx in labels:\n            assert tx.get_ha() == textprops[\"horizontalalignment\"]\n            assert tx.get_va() == textprops[\"verticalalignment\"]\n            assert tx.get_rotation() == textprops[\"rotation\"]\n            assert tx.get_rotation_mode() == textprops[\"rotation_mode\"]\n            assert tx.get_size() == textprops[\"size\"]\n            assert tx.get_color() == textprops[\"color\"]",
        "begin_line": 4903,
        "end_line": 4922,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_set_get_ticklabels#4926",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_set_get_ticklabels()",
        "snippet": "def test_set_get_ticklabels():\n    # test issue 2246\n    fig, ax = plt.subplots(2)\n    ha = ['normal', 'set_x/yticklabels']\n\n    ax[0].plot(np.arange(10))\n    ax[0].set_title(ha[0])\n\n    ax[1].plot(np.arange(10))\n    ax[1].set_title(ha[1])\n\n    # set ticklabel to 1 plot in normal way\n    ax[0].set_xticklabels(('a', 'b', 'c', 'd'))\n    ax[0].set_yticklabels(('11', '12', '13', '14'))\n\n    # set ticklabel to the other plot, expect the 2 plots have same label\n    # setting pass get_ticklabels return value as ticklabels argument\n    ax[1].set_xticklabels(ax[0].get_xticklabels())\n    ax[1].set_yticklabels(ax[0].get_yticklabels())",
        "begin_line": 4926,
        "end_line": 4944,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_retain_tick_visibility#4951",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_retain_tick_visibility()",
        "snippet": "def test_retain_tick_visibility():\n    fig, ax = plt.subplots()\n    plt.plot([0, 1, 2], [0, -1, 4])\n    plt.setp(ax.get_yticklabels(), visible=False)\n    ax.tick_params(axis=\"y\", which=\"both\", length=0)",
        "begin_line": 4951,
        "end_line": 4955,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_tick_label_update#4958",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_tick_label_update()",
        "snippet": "def test_tick_label_update():\n    # test issue 9397\n\n    fig, ax = plt.subplots()\n\n    # Set up a dummy formatter\n    def formatter_func(x, pos):\n        return \"unit value\" if x == 1 else \"\"\n    ax.xaxis.set_major_formatter(plt.FuncFormatter(formatter_func))\n\n    # Force some of the x-axis ticks to be outside of the drawn range\n    ax.set_xticks([-1, 0, 1, 2, 3])\n    ax.set_xlim(-0.5, 2.5)\n\n    ax.figure.canvas.draw()\n    tick_texts = [tick.get_text() for tick in ax.xaxis.get_ticklabels()]\n    assert tick_texts == [\"\", \"\", \"unit value\", \"\", \"\"]",
        "begin_line": 4958,
        "end_line": 4974,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.formatter_func#4964",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.formatter_func(x, pos)",
        "snippet": "    def formatter_func(x, pos):\n        return \"unit value\" if x == 1 else \"\"",
        "begin_line": 4964,
        "end_line": 4965,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_o_marker_path_snap#4979",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_o_marker_path_snap()",
        "snippet": "def test_o_marker_path_snap():\n    fig, ax = plt.subplots()\n    ax.margins(.1)\n    for ms in range(1, 15):\n        ax.plot([1, 2, ], np.ones(2) + ms, 'o', ms=ms)\n\n    for ms in np.linspace(1, 10, 25):\n        ax.plot([3, 4, ], np.ones(2) + ms, 'o', ms=ms)",
        "begin_line": 4979,
        "end_line": 4986,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_margins#4989",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_margins()",
        "snippet": "def test_margins():\n    # test all ways margins can be called\n    data = [1, 10]\n    xmin = 0.0\n    xmax = len(data) - 1.0\n    ymin = min(data)\n    ymax = max(data)\n\n    fig1, ax1 = plt.subplots(1, 1)\n    ax1.plot(data)\n    ax1.margins(1)\n    assert ax1.margins() == (1, 1)\n    assert ax1.get_xlim() == (xmin - (xmax - xmin) * 1,\n                              xmax + (xmax - xmin) * 1)\n    assert ax1.get_ylim() == (ymin - (ymax - ymin) * 1,\n                              ymax + (ymax - ymin) * 1)\n\n    fig2, ax2 = plt.subplots(1, 1)\n    ax2.plot(data)\n    ax2.margins(0.5, 2)\n    assert ax2.margins() == (0.5, 2)\n    assert ax2.get_xlim() == (xmin - (xmax - xmin) * 0.5,\n                              xmax + (xmax - xmin) * 0.5)\n    assert ax2.get_ylim() == (ymin - (ymax - ymin) * 2,\n                              ymax + (ymax - ymin) * 2)\n\n    fig3, ax3 = plt.subplots(1, 1)\n    ax3.plot(data)\n    ax3.margins(x=-0.2, y=0.5)\n    assert ax3.margins() == (-0.2, 0.5)\n    assert ax3.get_xlim() == (xmin - (xmax - xmin) * -0.2,\n                              xmax + (xmax - xmin) * -0.2)\n    assert ax3.get_ylim() == (ymin - (ymax - ymin) * 0.5,\n                              ymax + (ymax - ymin) * 0.5)",
        "begin_line": 4989,
        "end_line": 5022,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_length_one_hist#5025",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_length_one_hist()",
        "snippet": "def test_length_one_hist():\n    fig, ax = plt.subplots()\n    ax.hist(1)\n    ax.hist([1])",
        "begin_line": 5025,
        "end_line": 5028,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pathological_hexbin#5031",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pathological_hexbin()",
        "snippet": "def test_pathological_hexbin():\n    # issue #2863\n    out = io.BytesIO()\n\n    with warnings.catch_warnings(record=True) as w:\n        warnings.simplefilter(\"always\")\n        mylist = [10] * 100\n        fig, ax = plt.subplots(1, 1)\n        ax.hexbin(mylist, mylist)\n        fig.savefig(out)\n        assert len(w) == 0",
        "begin_line": 5031,
        "end_line": 5041,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_color_None#5044",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_color_None()",
        "snippet": "def test_color_None():\n    # issue 3855\n    fig, ax = plt.subplots()\n    ax.plot([1, 2], [1, 2], color=None)",
        "begin_line": 5044,
        "end_line": 5047,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_color_alias#5050",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_color_alias()",
        "snippet": "def test_color_alias():\n    # issues 4157 and 4162\n    fig, ax = plt.subplots()\n    line = ax.plot([0, 1], c='lime')[0]\n    assert 'lime' == line.get_color()",
        "begin_line": 5050,
        "end_line": 5054,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_numerical_hist_label#5057",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_numerical_hist_label()",
        "snippet": "def test_numerical_hist_label():\n    fig, ax = plt.subplots()\n    ax.hist([range(15)] * 5, label=range(5))\n    ax.legend()",
        "begin_line": 5057,
        "end_line": 5060,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_unicode_hist_label#5063",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_unicode_hist_label()",
        "snippet": "def test_unicode_hist_label():\n    fig, ax = plt.subplots()\n    a = (b'\\xe5\\xbe\\x88\\xe6\\xbc\\x82\\xe4\\xba\\xae, ' +\n         b'r\\xc3\\xb6m\\xc3\\xa4n ch\\xc3\\xa4r\\xc3\\xa1ct\\xc3\\xa8rs')\n    b = b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d'\n    labels = [a.decode('utf-8'),\n              'hi aardvark',\n              b.decode('utf-8'),\n              ]\n\n    ax.hist([range(15)] * 3, label=labels)\n    ax.legend()",
        "begin_line": 5063,
        "end_line": 5074,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_move_offsetlabel#5077",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_move_offsetlabel()",
        "snippet": "def test_move_offsetlabel():\n    data = np.random.random(10) * 1e-22\n    fig, ax = plt.subplots()\n    ax.plot(data)\n    ax.yaxis.tick_right()\n    assert (1, 0.5) == ax.yaxis.offsetText.get_position()",
        "begin_line": 5077,
        "end_line": 5082,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rc_spines#5087",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rc_spines()",
        "snippet": "def test_rc_spines():\n    rc_dict = {\n        'axes.spines.left': False,\n        'axes.spines.right': False,\n        'axes.spines.top': False,\n        'axes.spines.bottom': False}\n    with matplotlib.rc_context(rc_dict):\n        fig, ax = plt.subplots()",
        "begin_line": 5087,
        "end_line": 5094,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rc_grid#5099",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rc_grid()",
        "snippet": "def test_rc_grid():\n    fig = plt.figure()\n    rc_dict0 = {\n        'axes.grid': True,\n        'axes.grid.axis': 'both'\n    }\n    rc_dict1 = {\n        'axes.grid': True,\n        'axes.grid.axis': 'x'\n    }\n    rc_dict2 = {\n        'axes.grid': True,\n        'axes.grid.axis': 'y'\n    }\n    dict_list = [rc_dict0, rc_dict1, rc_dict2]\n\n    i = 1\n    for rc_dict in dict_list:\n        with matplotlib.rc_context(rc_dict):\n            fig.add_subplot(3, 1, i)\n            i += 1",
        "begin_line": 5099,
        "end_line": 5119,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rc_tick#5122",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rc_tick()",
        "snippet": "def test_rc_tick():\n    d = {'xtick.bottom': False, 'xtick.top': True,\n         'ytick.left': True, 'ytick.right': False}\n    with plt.rc_context(rc=d):\n        fig = plt.figure()\n        ax1 = fig.add_subplot(1, 1, 1)\n        xax = ax1.xaxis\n        yax = ax1.yaxis\n        # tick1On bottom/left\n        assert not xax._major_tick_kw['tick1On']\n        assert xax._major_tick_kw['tick2On']\n        assert not xax._minor_tick_kw['tick1On']\n        assert xax._minor_tick_kw['tick2On']\n\n        assert yax._major_tick_kw['tick1On']\n        assert not yax._major_tick_kw['tick2On']\n        assert yax._minor_tick_kw['tick1On']\n        assert not yax._minor_tick_kw['tick2On']",
        "begin_line": 5122,
        "end_line": 5139,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rc_major_minor_tick#5142",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rc_major_minor_tick()",
        "snippet": "def test_rc_major_minor_tick():\n    d = {'xtick.top': True, 'ytick.right': True,  # Enable all ticks\n         'xtick.bottom': True, 'ytick.left': True,\n         # Selectively disable\n         'xtick.minor.bottom': False, 'xtick.major.bottom': False,\n         'ytick.major.left': False, 'ytick.minor.left': False}\n    with plt.rc_context(rc=d):\n        fig = plt.figure()\n        ax1 = fig.add_subplot(1, 1, 1)\n        xax = ax1.xaxis\n        yax = ax1.yaxis\n        # tick1On bottom/left\n        assert not xax._major_tick_kw['tick1On']\n        assert xax._major_tick_kw['tick2On']\n        assert not xax._minor_tick_kw['tick1On']\n        assert xax._minor_tick_kw['tick2On']\n\n        assert not yax._major_tick_kw['tick1On']\n        assert yax._major_tick_kw['tick2On']\n        assert not yax._minor_tick_kw['tick1On']\n        assert yax._minor_tick_kw['tick2On']",
        "begin_line": 5142,
        "end_line": 5162,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_square_plot#5165",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_square_plot()",
        "snippet": "def test_square_plot():\n    x = np.arange(4)\n    y = np.array([1., 3., 5., 7.])\n    fig, ax = plt.subplots()\n    ax.plot(x, y, 'mo')\n    ax.axis('square')\n    xlim, ylim = ax.get_xlim(), ax.get_ylim()\n    assert np.diff(xlim) == np.diff(ylim)\n    assert ax.get_aspect() == 'equal'\n    assert_array_almost_equal(\n            ax.get_position(original=True).extents,\n            np.array((0.125, 0.1, 0.9, 0.9)))\n    assert_array_almost_equal(\n        ax.get_position(original=False).extents,\n        np.array((0.2125, 0.1, 0.8125, 0.9)))",
        "begin_line": 5165,
        "end_line": 5179,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_no_None#5182",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_no_None()",
        "snippet": "def test_no_None():\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        plt.plot(None)\n    with pytest.raises(ValueError):\n        plt.plot(None, None)",
        "begin_line": 5182,
        "end_line": 5187,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolorfast_colormapped#5201",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolorfast_colormapped(xy, cls)",
        "snippet": "def test_pcolorfast_colormapped(xy, cls):\n    fig, ax = plt.subplots()\n    data = np.arange(12).reshape((3, 4))\n    assert type(ax.pcolorfast(*xy, data)) == cls",
        "begin_line": 5201,
        "end_line": 5204,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolor_fast_RGB#5207",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolor_fast_RGB()",
        "snippet": "def test_pcolor_fast_RGB():\n\n    fig, ax = plt.subplots(1, 1)\n\n    np.random.seed(19680801)\n    C = np.random.rand(10, 10, 3)  # RGB image [0,1]\n    x = np.arange(11, dtype=np.float)\n    y = np.arange(11, dtype=np.float)\n\n    xv, yv = np.meshgrid(x, y)\n\n    with pytest.raises(ValueError):\n        ax.pcolorfast(xv, yv, C)",
        "begin_line": 5207,
        "end_line": 5219,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_scale#5222",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_scale()",
        "snippet": "def test_shared_scale():\n    fig, axs = plt.subplots(2, 2, sharex=True, sharey=True)\n\n    axs[0, 0].set_xscale(\"log\")\n    axs[0, 0].set_yscale(\"log\")\n\n    for ax in axs.flat:\n        assert ax.get_yscale() == 'log'\n        assert ax.get_xscale() == 'log'\n\n    axs[1, 1].set_xscale(\"linear\")\n    axs[1, 1].set_yscale(\"linear\")\n\n    for ax in axs.flat:\n        assert ax.get_yscale() == 'linear'\n        assert ax.get_xscale() == 'linear'",
        "begin_line": 5222,
        "end_line": 5237,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violin_point_mass#5240",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violin_point_mass()",
        "snippet": "def test_violin_point_mass():\n    \"\"\"Violin plot should handle point mass pdf gracefully.\"\"\"\n    plt.violinplot(np.array([0, 0]))",
        "begin_line": 5240,
        "end_line": 5242,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.generate_errorbar_inputs#5245",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.generate_errorbar_inputs()",
        "snippet": "def generate_errorbar_inputs():\n    base_xy = cycler('x', [np.arange(5)]) + cycler('y', [np.ones(5)])\n    err_cycler = cycler('err', [1,\n                                [1, 1, 1, 1, 1],\n                                [[1, 1, 1, 1, 1],\n                                 [1, 1, 1, 1, 1]],\n                                [[1]] * 5,\n                                np.ones(5),\n                                np.ones((2, 5)),\n                                np.ones((5, 1)),\n                                None\n                                ])\n    xerr_cy = cycler('xerr', err_cycler)\n    yerr_cy = cycler('yerr', err_cycler)\n\n    empty = ((cycler('x', [[]]) + cycler('y', [[]])) *\n             cycler('xerr', [[], None]) * cycler('yerr', [[], None]))\n    xerr_only = base_xy * xerr_cy\n    yerr_only = base_xy * yerr_cy\n    both_err = base_xy * yerr_cy * xerr_cy\n\n    return [*xerr_only, *yerr_only, *both_err, *empty]",
        "begin_line": 5245,
        "end_line": 5266,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_inputs_shotgun#5270",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_inputs_shotgun(kwargs)",
        "snippet": "def test_errorbar_inputs_shotgun(kwargs):\n    with warnings.catch_warnings():\n        # (n, 1)-shaped error deprecation already tested by test_errorbar.\n        warnings.simplefilter(\"ignore\", MatplotlibDeprecationWarning)\n        ax = plt.gca()\n        eb = ax.errorbar(**kwargs)\n        eb.remove()",
        "begin_line": 5270,
        "end_line": 5276,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_dash_offset#5280",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_dash_offset()",
        "snippet": "def test_dash_offset():\n    fig, ax = plt.subplots()\n    x = np.linspace(0, 10)\n    y = np.ones_like(x)\n    for j in range(0, 100, 2):\n        ax.plot(x, j*y, ls=(j, (10, 10)), lw=5, color='k')",
        "begin_line": 5280,
        "end_line": 5285,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_title_pad#5288",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_title_pad()",
        "snippet": "def test_title_pad():\n    # check that title padding puts the title in the right\n    # place...\n    fig, ax = plt.subplots()\n    ax.set_title('aardvark', pad=30.)\n    m = ax.titleOffsetTrans.get_matrix()\n    assert m[1, -1] == (30. / 72. * fig.dpi)\n    ax.set_title('aardvark', pad=0.)\n    m = ax.titleOffsetTrans.get_matrix()\n    assert m[1, -1] == 0.\n    # check that it is reverted...\n    ax.set_title('aardvark', pad=None)\n    m = ax.titleOffsetTrans.get_matrix()\n    assert m[1, -1] == (matplotlib.rcParams['axes.titlepad'] / 72. * fig.dpi)",
        "begin_line": 5288,
        "end_line": 5301,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_title_location_roundtrip#5304",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_title_location_roundtrip()",
        "snippet": "def test_title_location_roundtrip():\n    fig, ax = plt.subplots()\n    ax.set_title('aardvark')\n    ax.set_title('left', loc='left')\n    ax.set_title('right', loc='right')\n\n    assert 'left' == ax.get_title(loc='left')\n    assert 'right' == ax.get_title(loc='right')\n    assert 'aardvark' == ax.get_title()\n\n    with pytest.raises(ValueError):\n        ax.get_title(loc='foo')\n    with pytest.raises(ValueError):\n        ax.set_title('fail', loc='foo')",
        "begin_line": 5304,
        "end_line": 5317,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_loglog#5322",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_loglog()",
        "snippet": "def test_loglog():\n    fig, ax = plt.subplots()\n    x = np.arange(1, 11)\n    ax.loglog(x, x**3, lw=5)\n    ax.tick_params(length=25, width=2)\n    ax.tick_params(length=15, width=2, which='minor')",
        "begin_line": 5322,
        "end_line": 5327,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_loglog_nonpos#5332",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_loglog_nonpos()",
        "snippet": "def test_loglog_nonpos():\n    fig, ax = plt.subplots(3, 3)\n    x = np.arange(1, 11)\n    y = x**3\n    y[7] = -3.\n    x[4] = -10\n    for nn, mcx in enumerate(['mask', 'clip', '']):\n        for mm, mcy in enumerate(['mask', 'clip', '']):\n            kws = {}\n            if mcx:\n                kws['nonposx'] = mcx\n            if mcy:\n                kws['nonposy'] = mcy\n            ax[mm, nn].loglog(x, y**3, lw=2, **kws)",
        "begin_line": 5332,
        "end_line": 5345,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axes_margins#5349",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axes_margins()",
        "snippet": "def test_axes_margins():\n    fig, ax = plt.subplots()\n    ax.plot([0, 1, 2, 3])\n    assert ax.get_ybound()[0] != 0\n\n    fig, ax = plt.subplots()\n    ax.bar([0, 1, 2, 3], [1, 1, 1, 1])\n    assert ax.get_ybound()[0] == 0\n\n    fig, ax = plt.subplots()\n    ax.barh([0, 1, 2, 3], [1, 1, 1, 1])\n    assert ax.get_xbound()[0] == 0\n\n    fig, ax = plt.subplots()\n    ax.pcolor(np.zeros((10, 10)))\n    assert ax.get_xbound() == (0, 10)\n    assert ax.get_ybound() == (0, 10)\n\n    fig, ax = plt.subplots()\n    ax.pcolorfast(np.zeros((10, 10)))\n    assert ax.get_xbound() == (0, 10)\n    assert ax.get_ybound() == (0, 10)\n\n    fig, ax = plt.subplots()\n    ax.hist(np.arange(10))\n    assert ax.get_ybound()[0] == 0\n\n    fig, ax = plt.subplots()\n    ax.imshow(np.zeros((10, 10)))\n    assert ax.get_xbound() == (-0.5, 9.5)\n    assert ax.get_ybound() == (-0.5, 9.5)",
        "begin_line": 5349,
        "end_line": 5379,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.shared_axis_remover#5383",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.shared_axis_remover(request)",
        "snippet": "def shared_axis_remover(request):\n    def _helper_x(ax):\n        ax2 = ax.twinx()\n        ax2.remove()\n        ax.set_xlim(0, 15)\n        r = ax.xaxis.get_major_locator()()\n        assert r[-1] > 14\n\n    def _helper_y(ax):\n        ax2 = ax.twiny()\n        ax2.remove()\n        ax.set_ylim(0, 15)\n        r = ax.yaxis.get_major_locator()()\n        assert r[-1] > 14\n\n    return {\"x\": _helper_x, \"y\": _helper_y}[request.param]",
        "begin_line": 5383,
        "end_line": 5398,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._helper_x#5384",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._helper_x(ax)",
        "snippet": "    def _helper_x(ax):\n        ax2 = ax.twinx()\n        ax2.remove()\n        ax.set_xlim(0, 15)\n        r = ax.xaxis.get_major_locator()()\n        assert r[-1] > 14",
        "begin_line": 5384,
        "end_line": 5389,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._helper_y#5391",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._helper_y(ax)",
        "snippet": "    def _helper_y(ax):\n        ax2 = ax.twiny()\n        ax2.remove()\n        ax.set_ylim(0, 15)\n        r = ax.yaxis.get_major_locator()()\n        assert r[-1] > 14",
        "begin_line": 5391,
        "end_line": 5396,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.shared_axes_generator#5402",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.shared_axes_generator(request)",
        "snippet": "def shared_axes_generator(request):\n    # test all of the ways to get fig/ax sets\n    if request.param == 'gca':\n        fig = plt.figure()\n        ax = fig.gca()\n    elif request.param == 'subplots':\n        fig, ax = plt.subplots()\n    elif request.param == 'subplots_shared':\n        fig, ax_lst = plt.subplots(2, 2, sharex='all', sharey='all')\n        ax = ax_lst[0][0]\n    elif request.param == 'add_axes':\n        fig = plt.figure()\n        ax = fig.add_axes([.1, .1, .8, .8])\n    return fig, ax",
        "begin_line": 5402,
        "end_line": 5415,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_remove_shared_axes#5418",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_remove_shared_axes(shared_axes_generator, shared_axis_remover)",
        "snippet": "def test_remove_shared_axes(shared_axes_generator, shared_axis_remover):\n    # test all of the ways to get fig/ax sets\n    fig, ax = shared_axes_generator\n    shared_axis_remover(ax)",
        "begin_line": 5418,
        "end_line": 5421,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_remove_shared_axes_relim#5424",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_remove_shared_axes_relim()",
        "snippet": "def test_remove_shared_axes_relim():\n    fig, ax_lst = plt.subplots(2, 2, sharex='all', sharey='all')\n    ax = ax_lst[0][0]\n    orig_xlim = ax_lst[0][1].get_xlim()\n    ax.remove()\n    ax.set_xlim(0, 5)\n    assert_array_equal(ax_lst[0][1].get_xlim(), orig_xlim)",
        "begin_line": 5424,
        "end_line": 5430,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_axes_autoscale#5433",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_axes_autoscale()",
        "snippet": "def test_shared_axes_autoscale():\n    l = np.arange(-80, 90, 40)\n    t = np.random.random_sample((l.size, l.size))\n\n    ax1 = plt.subplot(211)\n    ax1.set_xlim(-1000, 1000)\n    ax1.set_ylim(-1000, 1000)\n    ax1.contour(l, l, t)\n\n    ax2 = plt.subplot(212, sharex=ax1, sharey=ax1)\n    ax2.contour(l, l, t)\n    assert not ax1.get_autoscalex_on() and not ax2.get_autoscalex_on()\n    assert not ax1.get_autoscaley_on() and not ax2.get_autoscaley_on()\n    assert ax1.get_xlim() == ax2.get_xlim() == (-1000, 1000)\n    assert ax1.get_ylim() == ax2.get_ylim() == (-1000, 1000)",
        "begin_line": 5433,
        "end_line": 5447,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_adjust_numtick_aspect#5450",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_adjust_numtick_aspect()",
        "snippet": "def test_adjust_numtick_aspect():\n    fig, ax = plt.subplots()\n    ax.yaxis.get_major_locator().set_params(nbins='auto')\n    ax.set_xlim(0, 1000)\n    ax.set_aspect('equal')\n    fig.canvas.draw()\n    assert len(ax.yaxis.get_major_locator()()) == 2\n    ax.set_ylim(0, 1000)\n    fig.canvas.draw()\n    assert len(ax.yaxis.get_major_locator()()) > 2",
        "begin_line": 5450,
        "end_line": 5459,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_auto_numticks#5464",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_auto_numticks()",
        "snippet": "def test_auto_numticks():\n    # Make tiny, empty subplots, verify that there are only 3 ticks.\n    fig, axes = plt.subplots(4, 4)",
        "begin_line": 5464,
        "end_line": 5466,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_auto_numticks_log#5471",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_auto_numticks_log()",
        "snippet": "def test_auto_numticks_log():\n    # Verify that there are not too many ticks with a large log range.\n    fig, ax = plt.subplots()\n    matplotlib.rcParams['axes.autolimit_mode'] = 'round_numbers'\n    ax.loglog([1e-20, 1e5], [1e-16, 10])",
        "begin_line": 5471,
        "end_line": 5475,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_broken_barh_empty#5478",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_broken_barh_empty()",
        "snippet": "def test_broken_barh_empty():\n    fig, ax = plt.subplots()\n    ax.broken_barh([], (.1, .5))",
        "begin_line": 5478,
        "end_line": 5480,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_broken_barh_timedelta#5483",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_broken_barh_timedelta()",
        "snippet": "def test_broken_barh_timedelta():\n    \"\"\"Check that timedelta works as x, dx pair for this method \"\"\"\n    fig, ax = plt.subplots()\n    pp = ax.broken_barh([(datetime.datetime(2018, 11, 9, 0, 0, 0),\n                          datetime.timedelta(hours=1))], [1, 2])\n    assert pp.get_paths()[0].vertices[0, 0] == 737007.0\n    assert pp.get_paths()[0].vertices[2, 0] == 737007.0 + 1 / 24",
        "begin_line": 5483,
        "end_line": 5489,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_pcolormesh#5492",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_pcolormesh(pd)",
        "snippet": "def test_pandas_pcolormesh(pd):\n    time = pd.date_range('2000-01-01', periods=10)\n    depth = np.arange(20)\n    data = np.random.rand(20, 10)\n\n    fig, ax = plt.subplots()\n    ax.pcolormesh(time, depth, data)",
        "begin_line": 5492,
        "end_line": 5498,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_indexing_dates#5501",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_indexing_dates(pd)",
        "snippet": "def test_pandas_indexing_dates(pd):\n    dates = np.arange('2005-02', '2005-03', dtype='datetime64[D]')\n    values = np.sin(np.array(range(len(dates))))\n    df = pd.DataFrame({'dates': dates, 'values': values})\n\n    ax = plt.gca()\n\n    without_zero_index = df[np.array(df.index) % 2 == 1].copy()\n    ax.plot('dates', 'values', data=without_zero_index)",
        "begin_line": 5501,
        "end_line": 5509,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_errorbar_indexing#5512",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_errorbar_indexing(pd)",
        "snippet": "def test_pandas_errorbar_indexing(pd):\n    df = pd.DataFrame(np.random.uniform(size=(5, 4)),\n                      columns=['x', 'y', 'xe', 'ye'],\n                      index=[1, 2, 3, 4, 5])\n    fig, ax = plt.subplots()\n    ax.errorbar('x', 'y', xerr='xe', yerr='ye', data=df)",
        "begin_line": 5512,
        "end_line": 5517,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_indexing_hist#5520",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_indexing_hist(pd)",
        "snippet": "def test_pandas_indexing_hist(pd):\n    ser_1 = pd.Series(data=[1, 2, 2, 3, 3, 4, 4, 4, 4, 5])\n    ser_2 = ser_1.iloc[1:]\n    fig, axes = plt.subplots()\n    axes.hist(ser_2)",
        "begin_line": 5520,
        "end_line": 5524,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_bar_align_center#5527",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_bar_align_center(pd)",
        "snippet": "def test_pandas_bar_align_center(pd):\n    # Tests fix for issue 8767\n    df = pd.DataFrame({'a': range(2), 'b': range(2)})\n\n    fig, ax = plt.subplots(1)\n\n    ax.bar(df.loc[df['a'] == 1, 'b'],\n           df.loc[df['a'] == 1, 'b'],\n           align='center')\n\n    fig.canvas.draw()",
        "begin_line": 5527,
        "end_line": 5537,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axis_set_tick_params_labelsize_labelcolor#5540",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axis_set_tick_params_labelsize_labelcolor()",
        "snippet": "def test_axis_set_tick_params_labelsize_labelcolor():\n    # Tests fix for issue 4346\n    axis_1 = plt.subplot()\n    axis_1.yaxis.set_tick_params(labelsize=30, labelcolor='red',\n                                 direction='out')\n\n    # Expected values after setting the ticks\n    assert axis_1.yaxis.majorTicks[0]._size == 4.0\n    assert axis_1.yaxis.majorTicks[0]._color == 'k'\n    assert axis_1.yaxis.majorTicks[0]._labelsize == 30.0\n    assert axis_1.yaxis.majorTicks[0]._labelcolor == 'red'",
        "begin_line": 5540,
        "end_line": 5550,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axes_tick_params_gridlines#5553",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axes_tick_params_gridlines()",
        "snippet": "def test_axes_tick_params_gridlines():\n    # Now treating grid params like other Tick params\n    ax = plt.subplot()\n    ax.tick_params(grid_color='b', grid_linewidth=5, grid_alpha=0.5,\n                   grid_linestyle='dashdot')\n    for axis in ax.xaxis, ax.yaxis:\n        assert axis.majorTicks[0]._grid_color == 'b'\n        assert axis.majorTicks[0]._grid_linewidth == 5\n        assert axis.majorTicks[0]._grid_alpha == 0.5\n        assert axis.majorTicks[0]._grid_linestyle == 'dashdot'",
        "begin_line": 5553,
        "end_line": 5562,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axes_tick_params_ylabelside#5565",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axes_tick_params_ylabelside()",
        "snippet": "def test_axes_tick_params_ylabelside():\n    # Tests fix for issue 10267\n    ax = plt.subplot()\n    ax.tick_params(labelleft=False, labelright=True,\n                   which='major')\n    ax.tick_params(labelleft=False, labelright=True,\n                   which='minor')\n    # expects left false, right true\n    assert ax.yaxis.majorTicks[0].label1.get_visible() is False\n    assert ax.yaxis.majorTicks[0].label2.get_visible() is True\n    assert ax.yaxis.minorTicks[0].label1.get_visible() is False\n    assert ax.yaxis.minorTicks[0].label2.get_visible() is True",
        "begin_line": 5565,
        "end_line": 5576,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axes_tick_params_xlabelside#5579",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axes_tick_params_xlabelside()",
        "snippet": "def test_axes_tick_params_xlabelside():\n    # Tests fix for issue 10267\n    ax = plt.subplot()\n    ax.tick_params(labeltop=True, labelbottom=False,\n                   which='major')\n    ax.tick_params(labeltop=True, labelbottom=False,\n                   which='minor')\n    # expects top True, bottom False\n    # label1.get_visible() mapped to labelbottom\n    # label2.get_visible() mapped to labeltop\n    assert ax.xaxis.majorTicks[0].label1.get_visible() is False\n    assert ax.xaxis.majorTicks[0].label2.get_visible() is True\n    assert ax.xaxis.minorTicks[0].label1.get_visible() is False\n    assert ax.xaxis.minorTicks[0].label2.get_visible() is True",
        "begin_line": 5579,
        "end_line": 5592,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_none_kwargs#5595",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_none_kwargs()",
        "snippet": "def test_none_kwargs():\n    fig, ax = plt.subplots()\n    ln, = ax.plot(range(32), linestyle=None)\n    assert ln.get_linestyle() == '-'",
        "begin_line": 5595,
        "end_line": 5598,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_ls_ds_conflict#5601",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_ls_ds_conflict()",
        "snippet": "def test_ls_ds_conflict():\n    # Passing the drawstyle with the linestyle is deprecated since 3.1.\n    # We still need to test this until it's removed from the code.\n    # But we don't want to see the deprecation warning in the test.\n    with matplotlib.cbook._suppress_matplotlib_deprecation_warning(), \\\n         pytest.raises(ValueError):\n        plt.plot(range(32), linestyle='steps-pre:', drawstyle='steps-post')",
        "begin_line": 5601,
        "end_line": 5607,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_uint8#5610",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_uint8()",
        "snippet": "def test_bar_uint8():\n    xs = [0, 1, 2, 3]\n    b = plt.bar(np.array(xs, dtype=np.uint8), [2, 3, 4, 5], align=\"edge\")\n    for (patch, x) in zip(b.patches, xs):\n        assert patch.xy[0] == x",
        "begin_line": 5610,
        "end_line": 5614,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_date_timezone_x#5618",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_date_timezone_x()",
        "snippet": "def test_date_timezone_x():\n    # Tests issue 5575\n    time_index = [datetime.datetime(2016, 2, 22, hour=x,\n                                    tzinfo=dutz.gettz('Canada/Eastern'))\n                  for x in range(3)]\n\n    # Same Timezone\n    fig = plt.figure(figsize=(20, 12))\n    plt.subplot(2, 1, 1)\n    plt.plot_date(time_index, [3] * 3, tz='Canada/Eastern')\n\n    # Different Timezone\n    plt.subplot(2, 1, 2)\n    plt.plot_date(time_index, [3] * 3, tz='UTC')",
        "begin_line": 5618,
        "end_line": 5631,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_date_timezone_y#5636",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_date_timezone_y()",
        "snippet": "def test_date_timezone_y():\n    # Tests issue 5575\n    time_index = [datetime.datetime(2016, 2, 22, hour=x,\n                                    tzinfo=dutz.gettz('Canada/Eastern'))\n                  for x in range(3)]\n\n    # Same Timezone\n    fig = plt.figure(figsize=(20, 12))\n    plt.subplot(2, 1, 1)\n    plt.plot_date([3] * 3,\n                  time_index, tz='Canada/Eastern', xdate=False, ydate=True)\n\n    # Different Timezone\n    plt.subplot(2, 1, 2)\n    plt.plot_date([3] * 3, time_index, tz='UTC', xdate=False, ydate=True)",
        "begin_line": 5636,
        "end_line": 5650,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_date_timezone_x_and_y#5655",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_date_timezone_x_and_y()",
        "snippet": "def test_date_timezone_x_and_y():\n    # Tests issue 5575\n    UTC = datetime.timezone.utc\n    time_index = [datetime.datetime(2016, 2, 22, hour=x, tzinfo=UTC)\n                  for x in range(3)]\n\n    # Same Timezone\n    fig = plt.figure(figsize=(20, 12))\n    plt.subplot(2, 1, 1)\n    plt.plot_date(time_index, time_index, tz='UTC', ydate=True)\n\n    # Different Timezone\n    plt.subplot(2, 1, 2)\n    plt.plot_date(time_index, time_index, tz='US/Eastern', ydate=True)",
        "begin_line": 5655,
        "end_line": 5668,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axisbelow#5673",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axisbelow()",
        "snippet": "def test_axisbelow():\n    # Test 'line' setting added in 6287.\n    # Show only grids, not frame or ticks, to make this test\n    # independent of future change to drawing order of those elements.\n    fig, axs = plt.subplots(ncols=3, sharex=True, sharey=True)\n    settings = (False, 'line', True)\n\n    for ax, setting in zip(axs, settings):\n        ax.plot((0, 10), (0, 10), lw=10, color='m')\n        circ = mpatches.Circle((3, 3), color='r')\n        ax.add_patch(circ)\n        ax.grid(color='c', linestyle='-', linewidth=3)\n        ax.tick_params(top=False, bottom=False,\n                       left=False, right=False)\n        for spine in ax.spines.values():\n            spine.set_visible(False)\n        ax.set_axisbelow(setting)",
        "begin_line": 5673,
        "end_line": 5689,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_titletwiny#5694",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_titletwiny()",
        "snippet": "def test_titletwiny():\n    # Test that title is put above xlabel if xlabel at top\n    fig, ax = plt.subplots()\n    fig.subplots_adjust(top=0.8)\n    ax2 = ax.twiny()\n    ax.set_xlabel('Xlabel')\n    ax2.set_xlabel('Xlabel2')\n    ax.set_title('Title')",
        "begin_line": 5694,
        "end_line": 5701,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_titlesetpos#5704",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_titlesetpos()",
        "snippet": "def test_titlesetpos():\n    # Test that title stays put if we set it manually\n    fig, ax = plt.subplots()\n    fig.subplots_adjust(top=0.8)\n    ax2 = ax.twiny()\n    ax.set_xlabel('Xlabel')\n    ax2.set_xlabel('Xlabel2')\n    ax.set_title('Title')\n    pos = (0.5, 1.11)\n    ax.title.set_position(pos)\n    renderer = fig.canvas.get_renderer()\n    ax._update_title_position(renderer)\n    assert ax.title.get_position() == pos",
        "begin_line": 5704,
        "end_line": 5716,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_title_xticks_top#5719",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_title_xticks_top()",
        "snippet": "def test_title_xticks_top():\n    # Test that title moves if xticks on top of axes.\n    fig, ax = plt.subplots()\n    ax.xaxis.set_ticks_position('top')\n    ax.set_title('xlabel top')\n    fig.canvas.draw()\n    assert ax.title.get_position()[1] > 1.04",
        "begin_line": 5719,
        "end_line": 5725,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_title_xticks_top_both#5728",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_title_xticks_top_both()",
        "snippet": "def test_title_xticks_top_both():\n    # Test that title moves if xticks on top of axes.\n    fig, ax = plt.subplots()\n    ax.tick_params(axis=\"x\", bottom=True, top=True,\n                             labelbottom=True, labeltop=True)\n    ax.set_title('xlabel top')\n    fig.canvas.draw()\n    assert ax.title.get_position()[1] > 1.04",
        "begin_line": 5728,
        "end_line": 5735,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_offset_label_color#5738",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_offset_label_color()",
        "snippet": "def test_offset_label_color():\n    # Tests issue 6440\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax.plot([1.01e9, 1.02e9, 1.03e9])\n    ax.yaxis.set_tick_params(labelcolor='red')\n    assert ax.yaxis.get_offset_text().get_color() == 'red'",
        "begin_line": 5738,
        "end_line": 5744,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_large_offset#5747",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_large_offset()",
        "snippet": "def test_large_offset():\n    fig, ax = plt.subplots()\n    ax.plot((1 + np.array([0, 1.e-12])) * 1.e27)\n    fig.canvas.draw()",
        "begin_line": 5747,
        "end_line": 5750,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_barb_units#5753",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_barb_units()",
        "snippet": "def test_barb_units():\n    fig, ax = plt.subplots()\n    dates = [datetime.datetime(2017, 7, 15, 18, i) for i in range(0, 60, 10)]\n    y = np.linspace(0, 5, len(dates))\n    u = v = np.linspace(0, 50, len(dates))\n    ax.barbs(dates, y, u, v)",
        "begin_line": 5753,
        "end_line": 5758,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_quiver_units#5761",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_quiver_units()",
        "snippet": "def test_quiver_units():\n    fig, ax = plt.subplots()\n    dates = [datetime.datetime(2017, 7, 15, 18, i) for i in range(0, 60, 10)]\n    y = np.linspace(0, 5, len(dates))\n    u = v = np.linspace(0, 50, len(dates))\n    ax.quiver(dates, y, u, v)",
        "begin_line": 5761,
        "end_line": 5766,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_color_cycle#5769",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_color_cycle()",
        "snippet": "def test_bar_color_cycle():\n    to_rgb = mcolors.to_rgb\n    fig, ax = plt.subplots()\n    for j in range(5):\n        ln, = ax.plot(range(3))\n        brs = ax.bar(range(3), range(3))\n        for br in brs:\n            assert to_rgb(ln.get_color()) == to_rgb(br.get_facecolor())",
        "begin_line": 5769,
        "end_line": 5776,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_tick_param_label_rotation#5779",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_tick_param_label_rotation()",
        "snippet": "def test_tick_param_label_rotation():\n    fix, (ax, ax2) = plt.subplots(1, 2)\n    ax.plot([0, 1], [0, 1])\n    ax2.plot([0, 1], [0, 1])\n    ax.xaxis.set_tick_params(which='both', rotation=75)\n    ax.yaxis.set_tick_params(which='both', rotation=90)\n    for text in ax.get_xticklabels(which='both'):\n        assert text.get_rotation() == 75\n    for text in ax.get_yticklabels(which='both'):\n        assert text.get_rotation() == 90\n\n    ax2.tick_params(axis='x', labelrotation=53)\n    ax2.tick_params(axis='y', rotation=35)\n    for text in ax2.get_xticklabels(which='major'):\n        assert text.get_rotation() == 53\n    for text in ax2.get_yticklabels(which='major'):\n        assert text.get_rotation() == 35",
        "begin_line": 5779,
        "end_line": 5795,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fillbetween_cycle#5799",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fillbetween_cycle()",
        "snippet": "def test_fillbetween_cycle():\n    fig, ax = plt.subplots()\n\n    for j in range(3):\n        cc = ax.fill_between(range(3), range(3))\n        target = mcolors.to_rgba('C{}'.format(j))\n        assert tuple(cc.get_facecolors().squeeze()) == tuple(target)\n\n    for j in range(3, 6):\n        cc = ax.fill_betweenx(range(3), range(3))\n        target = mcolors.to_rgba('C{}'.format(j))\n        assert tuple(cc.get_facecolors().squeeze()) == tuple(target)\n\n    target = mcolors.to_rgba('k')\n\n    for al in ['facecolor', 'facecolors', 'color']:\n        cc = ax.fill_between(range(3), range(3), **{al: 'k'})\n        assert tuple(cc.get_facecolors().squeeze()) == tuple(target)\n\n    edge_target = mcolors.to_rgba('k')\n    for j, el in enumerate(['edgecolor', 'edgecolors'], start=6):\n        cc = ax.fill_between(range(3), range(3), **{el: 'k'})\n        face_target = mcolors.to_rgba('C{}'.format(j))\n        assert tuple(cc.get_facecolors().squeeze()) == tuple(face_target)\n        assert tuple(cc.get_edgecolors().squeeze()) == tuple(edge_target)",
        "begin_line": 5799,
        "end_line": 5823,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_log_margins#5826",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_log_margins()",
        "snippet": "def test_log_margins():\n    plt.rcParams['axes.autolimit_mode'] = 'data'\n    fig, ax = plt.subplots()\n    margin = 0.05\n    ax.set_xmargin(margin)\n    ax.semilogx([10, 100], [10, 100])\n    xlim0, xlim1 = ax.get_xlim()\n    transform = ax.xaxis.get_transform()\n    xlim0t, xlim1t = transform.transform([xlim0, xlim1])\n    x0t, x1t = transform.transform([10, 100])\n    delta = (x1t - x0t) * margin\n    assert_allclose([xlim0t + delta, xlim1t - delta], [x0t, x1t])",
        "begin_line": 5826,
        "end_line": 5837,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_color_length_mismatch#5840",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_color_length_mismatch()",
        "snippet": "def test_color_length_mismatch():\n    N = 5\n    x, y = np.arange(N), np.arange(N)\n    colors = np.arange(N+1)\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.scatter(x, y, c=colors)\n    c_rgb = (0.5, 0.5, 0.5)\n    ax.scatter(x, y, c=c_rgb)\n    ax.scatter(x, y, c=[c_rgb] * N)",
        "begin_line": 5840,
        "end_line": 5849,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot_legend#5852",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot_legend()",
        "snippet": "def test_eventplot_legend():\n    plt.eventplot([1.0], label='Label')\n    plt.legend()",
        "begin_line": 5852,
        "end_line": 5854,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_broadcast_args#5857",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_broadcast_args()",
        "snippet": "def test_bar_broadcast_args():\n    fig, ax = plt.subplots()\n    # Check that a bar chart with a single height for all bars works.\n    ax.bar(range(4), 1)\n    # Check that a horizontal chart with one width works.\n    ax.bar(0, 1, bottom=range(4), width=1, orientation='horizontal')\n    # Check that edgecolor gets broadcast.\n    rect1, rect2 = ax.bar([0, 1], [0, 1], edgecolor=(.1, .2, .3, .4))\n    assert rect1.get_edgecolor() == rect2.get_edgecolor() == (.1, .2, .3, .4)",
        "begin_line": 5857,
        "end_line": 5865,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_invalid_axis_limits#5868",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_invalid_axis_limits()",
        "snippet": "def test_invalid_axis_limits():\n    plt.plot([0, 1], [0, 1])\n    with pytest.raises(ValueError):\n        plt.xlim(np.nan)\n    with pytest.raises(ValueError):\n        plt.xlim(np.inf)\n    with pytest.raises(ValueError):\n        plt.ylim(np.nan)\n    with pytest.raises(ValueError):\n        plt.ylim(np.inf)",
        "begin_line": 5868,
        "end_line": 5877,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_minorticks_on#5883",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_minorticks_on(xscale, yscale)",
        "snippet": "def test_minorticks_on(xscale, yscale):\n    ax = plt.subplot(111)\n    ax.plot([1, 2, 3, 4])\n    ax.set_xscale(xscale)\n    ax.set_yscale(yscale)\n    ax.minorticks_on()",
        "begin_line": 5883,
        "end_line": 5888,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twinx_knows_limits#5891",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twinx_knows_limits()",
        "snippet": "def test_twinx_knows_limits():\n    fig, ax = plt.subplots()\n\n    ax.axvspan(1, 2)\n    xtwin = ax.twinx()\n    xtwin.plot([0, 0.5], [1, 2])\n    # control axis\n    fig2, ax2 = plt.subplots()\n\n    ax2.axvspan(1, 2)\n    ax2.plot([0, 0.5], [1, 2])\n\n    assert_array_equal(xtwin.viewLim.intervalx, ax2.viewLim.intervalx)",
        "begin_line": 5891,
        "end_line": 5903,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_zero_linewidth#5906",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_zero_linewidth()",
        "snippet": "def test_zero_linewidth():\n    # Check that setting a zero linewidth doesn't error\n    plt.plot([0, 1], [0, 1], ls='--', lw=0)",
        "begin_line": 5906,
        "end_line": 5908,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_gridlines#5911",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_gridlines()",
        "snippet": "def test_polar_gridlines():\n    fig = plt.figure()\n    ax = fig.add_subplot(111, polar=True)\n\n    # make all major grid lines lighter, only x grid lines set in 2.1.0\n    ax.grid(alpha=0.2)\n\n    # hide y tick labels, no effect in 2.1.0\n    plt.setp(ax.yaxis.get_ticklabels(), visible=False)\n\n    fig.canvas.draw()\n\n    assert ax.xaxis.majorTicks[0].gridline.get_alpha() == .2\n    assert ax.yaxis.majorTicks[0].gridline.get_alpha() == .2",
        "begin_line": 5911,
        "end_line": 5924,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_empty_errorbar_legend#5927",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_empty_errorbar_legend()",
        "snippet": "def test_empty_errorbar_legend():\n    fig, ax = plt.subplots()\n    ax.errorbar([], [], xerr=[], label='empty y')\n    ax.errorbar([], [], yerr=[], label='empty x')\n    ax.legend()",
        "begin_line": 5927,
        "end_line": 5931,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_plot_columns_cycle_deprecation#5934",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_plot_columns_cycle_deprecation()",
        "snippet": "def test_plot_columns_cycle_deprecation():\n    with pytest.warns(MatplotlibDeprecationWarning):\n        plt.plot(np.zeros((2, 2)), np.zeros((2, 3)))",
        "begin_line": 5934,
        "end_line": 5936,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markerfacecolor_none_alpha#5941",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markerfacecolor_none_alpha(fig_test, fig_ref)",
        "snippet": "def test_markerfacecolor_none_alpha(fig_test, fig_ref):\n    fig_test.subplots().plot(0, \"o\", mfc=\"none\", alpha=.5)\n    fig_ref.subplots().plot(0, \"o\", mfc=\"w\", alpha=.5)",
        "begin_line": 5941,
        "end_line": 5943,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_tick_padding_tightbbox#5946",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_tick_padding_tightbbox()",
        "snippet": "def test_tick_padding_tightbbox():\n    \"Test that tick padding gets turned off if axis is off\"\n    plt.rcParams[\"xtick.direction\"] = \"out\"\n    plt.rcParams[\"ytick.direction\"] = \"out\"\n    fig, ax = plt.subplots()\n    bb = ax.get_tightbbox(fig.canvas.get_renderer())\n    ax.axis('off')\n    bb2 = ax.get_tightbbox(fig.canvas.get_renderer())\n    assert bb.x0 < bb2.x0\n    assert bb.y0 < bb2.y0",
        "begin_line": 5946,
        "end_line": 5955,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_zoom_inset#5958",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_zoom_inset()",
        "snippet": "def test_zoom_inset():\n    dx, dy = 0.05, 0.05\n    # generate 2 2d grids for the x & y bounds\n    y, x = np.mgrid[slice(1, 5 + dy, dy),\n                    slice(1, 5 + dx, dx)]\n    z = np.sin(x)**10 + np.cos(10 + y*x) * np.cos(x)\n\n    fig, ax = plt.subplots()\n    ax.pcolormesh(x, y, z)\n    ax.set_aspect(1.)\n    ax.apply_aspect()\n    # we need to apply_aspect to make the drawing below work.\n\n    # Make the inset_axes...  Position axes co-ordinates...\n    axin1 = ax.inset_axes([0.7, 0.7, 0.35, 0.35])\n    # redraw the data in the inset axes...\n    axin1.pcolormesh(x, y, z)\n    axin1.set_xlim([1.5, 2.15])\n    axin1.set_ylim([2, 2.5])\n    axin1.set_aspect(ax.get_aspect())\n\n    rec, connectors = ax.indicate_inset_zoom(axin1)\n    fig.canvas.draw()\n    xx = np.array([[1.5,  2.],\n                   [2.15, 2.5]])\n    assert(np.all(rec.get_bbox().get_points() == xx))\n    xx = np.array([[0.6325, 0.692308],\n                   [0.8425, 0.907692]])\n    np.testing.assert_allclose(axin1.get_position().get_points(),\n            xx, rtol=1e-4)",
        "begin_line": 5958,
        "end_line": 5987,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_set_position#5990",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_set_position()",
        "snippet": "def test_set_position():\n    fig, ax = plt.subplots()\n    ax.set_aspect(3.)\n    ax.set_position([0.1, 0.1, 0.4, 0.4], which='both')\n    assert np.allclose(ax.get_position().width, 0.1)\n    ax.set_aspect(2.)\n    ax.set_position([0.1, 0.1, 0.4, 0.4], which='original')\n    assert np.allclose(ax.get_position().width, 0.15)\n    ax.set_aspect(3.)\n    ax.set_position([0.1, 0.1, 0.4, 0.4], which='active')\n    assert np.allclose(ax.get_position().width, 0.1)",
        "begin_line": 5990,
        "end_line": 6000,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_spines_properbbox_after_zoom#6003",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_spines_properbbox_after_zoom()",
        "snippet": "def test_spines_properbbox_after_zoom():\n    fig, ax = plt.subplots()\n    bb = ax.spines['bottom'].get_window_extent(fig.canvas.get_renderer())\n    # this is what zoom calls:\n    ax._set_view_from_bbox((320, 320, 500, 500), 'in',\n                           None, False, False)\n    bb2 = ax.spines['bottom'].get_window_extent(fig.canvas.get_renderer())\n    np.testing.assert_allclose(bb.get_points(), bb2.get_points(), rtol=1e-6)",
        "begin_line": 6003,
        "end_line": 6010,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_cartopy_backcompat#6013",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_cartopy_backcompat()",
        "snippet": "def test_cartopy_backcompat():\n    import matplotlib\n    import matplotlib.axes\n    import matplotlib.axes._subplots\n\n    class Dummy(matplotlib.axes.Axes):\n        ...\n\n    class DummySubplot(matplotlib.axes.SubplotBase, Dummy):\n        _axes_class = Dummy\n\n    matplotlib.axes._subplots._subplot_classes[Dummy] = DummySubplot\n\n    FactoryDummySubplot = matplotlib.axes.subplot_class_factory(Dummy)\n\n    assert DummySubplot is FactoryDummySubplot",
        "begin_line": 6013,
        "end_line": 6028,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.Dummy.test_cartopy_backcompat#6013",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.Dummy",
        "signature": "lib.matplotlib.tests.test_axes.Dummy.test_cartopy_backcompat()",
        "snippet": "def test_cartopy_backcompat():\n    import matplotlib\n    import matplotlib.axes\n    import matplotlib.axes._subplots\n\n    class Dummy(matplotlib.axes.Axes):\n        ...\n\n    class DummySubplot(matplotlib.axes.SubplotBase, Dummy):\n        _axes_class = Dummy\n\n    matplotlib.axes._subplots._subplot_classes[Dummy] = DummySubplot\n\n    FactoryDummySubplot = matplotlib.axes.subplot_class_factory(Dummy)\n\n    assert DummySubplot is FactoryDummySubplot",
        "begin_line": 6013,
        "end_line": 6028,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.DummySubplot.test_cartopy_backcompat#6013",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.DummySubplot",
        "signature": "lib.matplotlib.tests.test_axes.DummySubplot.test_cartopy_backcompat()",
        "snippet": "def test_cartopy_backcompat():\n    import matplotlib\n    import matplotlib.axes\n    import matplotlib.axes._subplots\n\n    class Dummy(matplotlib.axes.Axes):\n        ...\n\n    class DummySubplot(matplotlib.axes.SubplotBase, Dummy):\n        _axes_class = Dummy\n\n    matplotlib.axes._subplots._subplot_classes[Dummy] = DummySubplot\n\n    FactoryDummySubplot = matplotlib.axes.subplot_class_factory(Dummy)\n\n    assert DummySubplot is FactoryDummySubplot",
        "begin_line": 6013,
        "end_line": 6028,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_gettightbbox_ignoreNaN#6031",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_gettightbbox_ignoreNaN()",
        "snippet": "def test_gettightbbox_ignoreNaN():\n    fig, ax = plt.subplots()\n    remove_ticks_and_titles(fig)\n    t = ax.text(np.NaN, 1, 'Boo')\n    renderer = fig.canvas.get_renderer()\n    np.testing.assert_allclose(ax.get_tightbbox(renderer).width, 496)",
        "begin_line": 6031,
        "end_line": 6036,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_scatter_series_non_zero_index#6039",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_scatter_series_non_zero_index(pd)",
        "snippet": "def test_scatter_series_non_zero_index(pd):\n    # create non-zero index\n    ids = range(10, 18)\n    x = pd.Series(np.random.uniform(size=8), index=ids)\n    y = pd.Series(np.random.uniform(size=8), index=ids)\n    c = pd.Series([1, 1, 1, 1, 1, 0, 0, 0], index=ids)\n    plt.scatter(x, y, c)",
        "begin_line": 6039,
        "end_line": 6045,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_scatter_empty_data#6048",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_scatter_empty_data()",
        "snippet": "def test_scatter_empty_data():\n    # making sure this does not raise an exception\n    plt.scatter([], [])\n    plt.scatter([], [], s=[], c=[])",
        "begin_line": 6048,
        "end_line": 6051,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_annotate_across_transforms#6056",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_annotate_across_transforms()",
        "snippet": "def test_annotate_across_transforms():\n    x = np.linspace(0, 10, 200)\n    y = np.exp(-x) * np.sin(x)\n\n    fig, ax = plt.subplots(figsize=(3.39, 3))\n    ax.plot(x, y)\n    axins = ax.inset_axes([0.4, 0.5, 0.3, 0.3])\n    axins.set_aspect(0.2)\n    axins.xaxis.set_visible(False)\n    axins.yaxis.set_visible(False)\n    ax.annotate(\"\", xy=(x[150], y[150]), xycoords=ax.transData,\n            xytext=(1, 0), textcoords=axins.transAxes,\n            arrowprops=dict(arrowstyle=\"->\"))",
        "begin_line": 6056,
        "end_line": 6068,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_deprecated_uppercase_colors#6071",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_deprecated_uppercase_colors()",
        "snippet": "def test_deprecated_uppercase_colors():\n    # Remove after end of deprecation period.\n    fig, ax = plt.subplots()\n    with pytest.warns(MatplotlibDeprecationWarning):\n        ax.plot([1, 2], color=\"B\")\n        fig.canvas.draw()",
        "begin_line": 6071,
        "end_line": 6076,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_secondary_xy#6081",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_secondary_xy()",
        "snippet": "def test_secondary_xy():\n    fig, axs = plt.subplots(1, 2, figsize=(10, 5), constrained_layout=True)\n\n    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x\n\n    for nn, ax in enumerate(axs):\n        ax.plot(np.arange(2, 11), np.arange(2, 11))\n        if nn == 0:\n            secax = ax.secondary_xaxis\n        else:\n            secax = ax.secondary_yaxis\n\n        axsec = secax(0.2, functions=(invert, invert))\n        axsec = secax(0.4, functions=(lambda x: 2 * x, lambda x: x / 2))\n        axsec = secax(0.6, functions=(lambda x: x**2, lambda x: x**(1/2)))\n        axsec = secax(0.8)",
        "begin_line": 6081,
        "end_line": 6098,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.invert#6084",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.invert(x)",
        "snippet": "    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x",
        "begin_line": 6084,
        "end_line": 6086,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_secondary_fail#6101",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_secondary_fail()",
        "snippet": "def test_secondary_fail():\n    fig, ax = plt.subplots()\n    ax.plot(np.arange(2, 11), np.arange(2, 11))\n    with pytest.raises(ValueError):\n        axsec = ax.secondary_xaxis(0.2, functions=(lambda x: 1 / x))\n    with pytest.raises(ValueError):\n        axsec = ax.secondary_xaxis('right')\n    with pytest.raises(ValueError):\n        axsec = ax.secondary_yaxis('bottom')",
        "begin_line": 6101,
        "end_line": 6109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_secondary_resize#6112",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_secondary_resize()",
        "snippet": "def test_secondary_resize():\n    fig, ax = plt.subplots(figsize=(10, 5))\n    ax.plot(np.arange(2, 11), np.arange(2, 11))\n    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x\n\n    axsec = ax.secondary_xaxis('top', functions=(invert, invert))\n    fig.canvas.draw()\n    fig.set_size_inches((7, 4))\n    assert_allclose(ax.get_position().extents, [0.125, 0.1, 0.9, 0.9])",
        "begin_line": 6112,
        "end_line": 6122,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.invert#6115",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.invert(x)",
        "snippet": "    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x",
        "begin_line": 6115,
        "end_line": 6117,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.color_boxes#6125",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.color_boxes(fig, axs)",
        "snippet": "def color_boxes(fig, axs):\n    \"\"\"\n    Helper for the tests below that test the extents of various axes elements\n    \"\"\"\n    fig.canvas.draw()\n\n    renderer = fig.canvas.get_renderer()\n    bbaxis = []\n    for nn, axx in enumerate([axs.xaxis, axs.yaxis]):\n        bb = axx.get_tightbbox(renderer)\n        if bb:\n            axisr = plt.Rectangle((bb.x0, bb.y0), width=bb.width,\n                     height=bb.height, linewidth=0.7, edgecolor='y',\n                    facecolor=\"none\", transform=None, zorder=3)\n            fig.add_artist(axisr)\n        bbaxis += [bb]\n\n    bbspines = []\n    for nn, a in enumerate(['bottom', 'top', 'left', 'right']):\n        bb = axs.spines[a].get_window_extent(renderer)\n        spiner = plt.Rectangle((bb.x0, bb.y0), width=bb.width,\n                              height=bb.height, linewidth=0.7,\n                              edgecolor=\"green\", facecolor=\"none\",\n                              transform=None, zorder=3)\n        fig.add_artist(spiner)\n        bbspines += [bb]\n\n    bb = axs.get_window_extent()\n    rect2 = plt.Rectangle((bb.x0, bb.y0), width=bb.width, height=bb.height,\n                         linewidth=1.5, edgecolor=\"magenta\",\n                         facecolor=\"none\", transform=None, zorder=2)\n    fig.add_artist(rect2)\n    bbax = bb\n\n    bb2 = axs.get_tightbbox(renderer)\n    rect2 = plt.Rectangle((bb2.x0, bb2.y0), width=bb2.width,\n                         height=bb2.height, linewidth=3, edgecolor=\"red\",\n                         facecolor=\"none\", transform=None, zorder=1)\n    fig.add_artist(rect2)\n    bbtb = bb2\n    return bbaxis, bbspines, bbax, bbtb",
        "begin_line": 6125,
        "end_line": 6165,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_normal_axes#6168",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_normal_axes()",
        "snippet": "def test_normal_axes():\n    with rc_context({'_internal.classic_mode': False}):\n        fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n        fig.canvas.draw()\n        plt.close(fig)\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n\n    # test the axis bboxes\n    target = [\n        [123.375, 75.88888888888886, 983.25, 33.0],\n        [85.51388888888889, 99.99999999999997, 53.375, 993.0]\n    ]\n    for nn, b in enumerate(bbaxis):\n        targetbb = mtransforms.Bbox.from_bounds(*target[nn])\n        assert_array_almost_equal(b.bounds, targetbb.bounds, decimal=2)\n\n    target = [\n        [150.0, 119.999, 930.0, 11.111],\n        [150.0, 1080.0, 930.0, 0.0],\n        [150.0, 119.9999, 11.111, 960.0],\n        [1068.8888, 119.9999, 11.111, 960.0]\n    ]\n    for nn, b in enumerate(bbspines):\n        targetbb = mtransforms.Bbox.from_bounds(*target[nn])\n        assert_array_almost_equal(b.bounds, targetbb.bounds, decimal=2)\n\n    target = [150.0, 119.99999999999997, 930.0, 960.0]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_array_almost_equal(bbax.bounds, targetbb.bounds, decimal=2)\n\n    target = [85.5138, 75.88888, 1021.11, 1017.11]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_array_almost_equal(bbtb.bounds, targetbb.bounds, decimal=2)\n\n    # test that get_position roundtrips to get_window_extent\n    axbb = ax.get_position().transformed(fig.transFigure).bounds\n    assert_array_almost_equal(axbb, ax.get_window_extent().bounds, decimal=2)",
        "begin_line": 6168,
        "end_line": 6204,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_nodecorator#6207",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_nodecorator()",
        "snippet": "def test_nodecorator():\n    with rc_context({'_internal.classic_mode': False}):\n        fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n        fig.canvas.draw()\n        ax.set(xticklabels=[], yticklabels=[])\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n\n    # test the axis bboxes\n    target = [\n        None,\n        None\n    ]\n    for nn, b in enumerate(bbaxis):\n        assert b is None\n\n    target = [\n        [150.0, 119.999, 930.0, 11.111],\n        [150.0, 1080.0, 930.0, 0.0],\n        [150.0, 119.9999, 11.111, 960.0],\n        [1068.8888, 119.9999, 11.111, 960.0]\n    ]\n    for nn, b in enumerate(bbspines):\n        targetbb = mtransforms.Bbox.from_bounds(*target[nn])\n        assert_allclose(b.bounds, targetbb.bounds, atol=1e-2)\n\n    target = [150.0, 119.99999999999997, 930.0, 960.0]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_allclose(bbax.bounds, targetbb.bounds, atol=1e-2)\n\n    target = [150., 120., 930., 960.]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_allclose(bbtb.bounds, targetbb.bounds, atol=1e-2)",
        "begin_line": 6207,
        "end_line": 6238,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_displaced_spine#6241",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_displaced_spine()",
        "snippet": "def test_displaced_spine():\n    with rc_context({'_internal.classic_mode': False}):\n        fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n        ax.set(xticklabels=[], yticklabels=[])\n        ax.spines['bottom'].set_position(('axes', -0.1))\n        fig.canvas.draw()\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n\n    target = [\n        [150., 24., 930., 11.111111],\n        [150.0, 1080.0, 930.0, 0.0],\n        [150.0, 119.9999, 11.111, 960.0],\n        [1068.8888, 119.9999, 11.111, 960.0]\n    ]\n    for nn, b in enumerate(bbspines):\n        targetbb = mtransforms.Bbox.from_bounds(*target[nn])\n\n    target = [150.0, 119.99999999999997, 930.0, 960.0]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_allclose(bbax.bounds, targetbb.bounds, atol=1e-2)\n\n    target = [150., 24., 930., 1056.]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_allclose(bbtb.bounds, targetbb.bounds, atol=1e-2)",
        "begin_line": 6241,
        "end_line": 6264,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_tickdirs#6267",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_tickdirs()",
        "snippet": "def test_tickdirs():\n    \"\"\"\n    Switch the tickdirs and make sure the bboxes switch with them\n    \"\"\"\n    targets = [[[150.0, 120.0, 930.0, 11.1111],\n                [150.0, 120.0, 11.111, 960.0]],\n               [[150.0, 108.8889, 930.0, 11.111111111111114],\n                [138.889, 120, 11.111, 960.0]],\n               [[150.0, 114.44444444444441, 930.0, 11.111111111111114],\n                [144.44444444444446, 119.999, 11.111, 960.0]]]\n    for dnum, dirs in enumerate(['in', 'out', 'inout']):\n        with rc_context({'_internal.classic_mode': False}):\n            fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n            ax.tick_params(direction=dirs)\n            fig.canvas.draw()\n            bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n            for nn, num in enumerate([0, 2]):\n                targetbb = mtransforms.Bbox.from_bounds(*targets[dnum][nn])\n                assert_allclose(bbspines[num].bounds, targetbb.bounds,\n                               atol=1e-2)",
        "begin_line": 6267,
        "end_line": 6286,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_minor_accountedfor#6289",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_minor_accountedfor()",
        "snippet": "def test_minor_accountedfor():\n    with rc_context({'_internal.classic_mode': False}):\n        fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n        fig.canvas.draw()\n        ax.tick_params(which='both', direction='out')\n\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n        targets = [[150.0, 108.88888888888886, 930.0, 11.111111111111114],\n                   [138.8889, 119.9999, 11.1111, 960.0]]\n        for n in range(2):\n            targetbb = mtransforms.Bbox.from_bounds(*targets[n])\n            assert_allclose(bbspines[n * 2].bounds, targetbb.bounds,\n                           atol=1e-2)\n\n        fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n        fig.canvas.draw()\n        ax.tick_params(which='both', direction='out')\n        ax.minorticks_on()\n        ax.tick_params(axis='both', which='minor', length=30)\n        fig.canvas.draw()\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n        targets = [[150.0, 36.66666666666663, 930.0, 83.33333333333334],\n                   [66.6667, 120.0, 83.3333, 960.0]]\n\n        for n in range(2):\n            targetbb = mtransforms.Bbox.from_bounds(*targets[n])\n            assert_allclose(bbspines[n * 2].bounds, targetbb.bounds,\n                           atol=1e-2)",
        "begin_line": 6289,
        "end_line": 6317,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_get_tightbbox_polar#6320",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_get_tightbbox_polar()",
        "snippet": "def test_get_tightbbox_polar():\n    fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n    fig.canvas.draw()\n    bb = ax.get_tightbbox(fig.canvas.get_renderer())\n    assert_allclose(bb.extents,\n        [107.7778,  29.2778, 539.7847, 450.7222], rtol=1e-03)",
        "begin_line": 6320,
        "end_line": 6325,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axis_bool_arguments#6329",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axis_bool_arguments(fig_test, fig_ref)",
        "snippet": "def test_axis_bool_arguments(fig_test, fig_ref):\n    # Test if False and \"off\" give the same\n    fig_test.add_subplot(211).axis(False)\n    fig_ref.add_subplot(211).axis(\"off\")\n    # Test if True after False gives the same as \"on\"\n    ax = fig_test.add_subplot(212)\n    ax.axis(False)\n    ax.axis(True)\n    fig_ref.add_subplot(212).axis(\"on\")",
        "begin_line": 6329,
        "end_line": 6337,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axis_extent_arg#6340",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axis_extent_arg()",
        "snippet": "def test_axis_extent_arg():\n    fig, ax = plt.subplots()\n    xmin = 5\n    xmax = 10\n    ymin = 15\n    ymax = 20\n    extent = ax.axis([xmin, xmax, ymin, ymax])\n\n    # test that the docstring is correct\n    assert tuple(extent) == (xmin, xmax, ymin, ymax)\n\n    # test that limits were set per the docstring\n    assert (xmin, xmax) == ax.get_xlim()\n    assert (ymin, ymax) == ax.get_ylim()",
        "begin_line": 6340,
        "end_line": 6353,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_datetime_masked#6356",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_datetime_masked()",
        "snippet": "def test_datetime_masked():\n    # make sure that all-masked data falls back to the viewlim\n    # set in convert.axisinfo....\n    x = np.array([datetime.datetime(2017, 1, n) for n in range(1, 6)])\n    y = np.array([1, 2, 3, 4, 5])\n    m = np.ma.masked_greater(y, 0)\n\n    fig, ax = plt.subplots()\n    ax.plot(x, m)\n    # these are the default viewlim\n    assert ax.get_xlim() == (730120.0, 733773.0)",
        "begin_line": 6356,
        "end_line": 6366,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_auto_bins#6369",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_auto_bins()",
        "snippet": "def test_hist_auto_bins():\n    _, bins, _ = plt.hist([[1, 2, 3], [3, 4, 5, 6]], bins='auto')\n    assert bins[0] <= 1\n    assert bins[-1] >= 6",
        "begin_line": 6369,
        "end_line": 6372,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_nan_data#6375",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_nan_data()",
        "snippet": "def test_hist_nan_data():\n    fig, (ax1, ax2) = plt.subplots(2)\n\n    data = [1, 2, 3]\n    nan_data = data + [np.nan]\n\n    bins, edges, _ = ax1.hist(data)\n    with np.errstate(invalid='ignore'):\n        nanbins, nanedges, _ = ax2.hist(nan_data)\n\n    assert np.allclose(bins, nanbins)\n    assert np.allclose(edges, nanedges)",
        "begin_line": 6375,
        "end_line": 6386,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_range_and_density#6389",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_range_and_density()",
        "snippet": "def test_hist_range_and_density():\n    _, bins, _ = plt.hist(np.random.rand(10), \"auto\",\n                          range=(0, 1), density=True)\n    assert bins[0] == 0\n    assert bins[-1] == 1",
        "begin_line": 6389,
        "end_line": 6393,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_errbar_zorder#6396",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_errbar_zorder()",
        "snippet": "def test_bar_errbar_zorder():\n    # Check that the zorder of errorbars is always greater than the bar they\n    # are plotted on\n    fig, ax = plt.subplots()\n    x = [1, 2, 3]\n    barcont = ax.bar(x=x, height=x, yerr=x, capsize=5, zorder=3)\n\n    data_line, caplines, barlinecols = barcont.errorbar.lines\n    for bar in barcont.patches:\n        for capline in caplines:\n            assert capline.zorder > bar.zorder\n        for barlinecol in barlinecols:\n            assert barlinecol.zorder > bar.zorder",
        "begin_line": 6396,
        "end_line": 6408,
        "comment": "",
        "is_bug": false
    }
]