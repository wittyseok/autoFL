[
    {
        "name": "tornado.http1connection._ExceptionLoggingContext.__init__#53",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._ExceptionLoggingContext",
        "signature": "tornado.http1connection._ExceptionLoggingContext.__init__(self, logger: logging.Logger)",
        "snippet": "    def __init__(self, logger: logging.Logger) -> None:\n        self.logger = logger",
        "begin_line": 53,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007352941176470588,
            "pseudo_dstar_susp": 0.0009319664492078285,
            "pseudo_tarantula_susp": 0.0006849315068493151,
            "pseudo_op2_susp": 0.0009319664492078285,
            "pseudo_barinel_susp": 0.0006849315068493151
        }
    },
    {
        "name": "tornado.http1connection._ExceptionLoggingContext.__enter__#56",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._ExceptionLoggingContext",
        "signature": "tornado.http1connection._ExceptionLoggingContext.__enter__(self)",
        "snippet": "    def __enter__(self) -> None:\n        pass",
        "begin_line": 56,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007352941176470588,
            "pseudo_dstar_susp": 0.0009319664492078285,
            "pseudo_tarantula_susp": 0.0006849315068493151,
            "pseudo_op2_susp": 0.0009319664492078285,
            "pseudo_barinel_susp": 0.0006849315068493151
        }
    },
    {
        "name": "tornado.http1connection._ExceptionLoggingContext.__exit__#59",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._ExceptionLoggingContext",
        "signature": "tornado.http1connection._ExceptionLoggingContext.__exit__(self, typ: Optional[Type[BaseException]], value: Optional[BaseException], tb: types.TracebackType)",
        "snippet": "    def __exit__(\n        self,\n        typ: Optional[Type[BaseException]],\n        value: Optional[BaseException],\n        tb: types.TracebackType,\n    ) -> None:\n        if value is not None:\n            assert typ is not None\n            self.logger.error(\"Uncaught exception\", exc_info=(typ, value, tb))\n            raise _QuietException",
        "begin_line": 59,
        "end_line": 68,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007352941176470588,
            "pseudo_dstar_susp": 0.0009319664492078285,
            "pseudo_tarantula_susp": 0.0006849315068493151,
            "pseudo_op2_susp": 0.0009319664492078285,
            "pseudo_barinel_susp": 0.0006849315068493151
        }
    },
    {
        "name": "tornado.http1connection.HTTP1ConnectionParameters.__init__#75",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1ConnectionParameters",
        "signature": "tornado.http1connection.HTTP1ConnectionParameters.__init__(self, no_keep_alive: bool=False, chunk_size: int=None, max_header_size: int=None, header_timeout: float=None, max_body_size: int=None, body_timeout: float=None, decompress: bool=False)",
        "snippet": "    def __init__(\n        self,\n        no_keep_alive: bool = False,\n        chunk_size: int = None,\n        max_header_size: int = None,\n        header_timeout: float = None,\n        max_body_size: int = None,\n        body_timeout: float = None,\n        decompress: bool = False,\n    ) -> None:\n        \"\"\"\n        :arg bool no_keep_alive: If true, always close the connection after\n            one request.\n        :arg int chunk_size: how much data to read into memory at once\n        :arg int max_header_size:  maximum amount of data for HTTP headers\n        :arg float header_timeout: how long to wait for all headers (seconds)\n        :arg int max_body_size: maximum amount of data for body\n        :arg float body_timeout: how long to wait while reading body (seconds)\n        :arg bool decompress: if true, decode incoming\n            ``Content-Encoding: gzip``\n        \"\"\"\n        self.no_keep_alive = no_keep_alive\n        self.chunk_size = chunk_size or 65536\n        self.max_header_size = max_header_size or 65536\n        self.header_timeout = header_timeout\n        self.max_body_size = max_body_size\n        self.body_timeout = body_timeout\n        self.decompress = decompress",
        "begin_line": 75,
        "end_line": 102,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009250693802035153,
            "pseudo_dstar_susp": 0.0012376237623762376,
            "pseudo_tarantula_susp": 0.0008123476848090983,
            "pseudo_op2_susp": 0.0012376237623762376,
            "pseudo_barinel_susp": 0.0008123476848090983
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.__init__#112",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.__init__(self, stream: iostream.IOStream, is_client: bool, params: HTTP1ConnectionParameters=None, context: object=None)",
        "snippet": "    def __init__(\n        self,\n        stream: iostream.IOStream,\n        is_client: bool,\n        params: HTTP1ConnectionParameters = None,\n        context: object = None,\n    ) -> None:\n        \"\"\"\n        :arg stream: an `.IOStream`\n        :arg bool is_client: client or server\n        :arg params: a `.HTTP1ConnectionParameters` instance or ``None``\n        :arg context: an opaque application-defined object that can be accessed\n            as ``connection.context``.\n        \"\"\"\n        self.is_client = is_client\n        self.stream = stream\n        if params is None:\n            params = HTTP1ConnectionParameters()\n        self.params = params\n        self.context = context\n        self.no_keep_alive = params.no_keep_alive\n        # The body limits can be altered by the delegate, so save them\n        # here instead of just referencing self.params later.\n        self._max_body_size = self.params.max_body_size or self.stream.max_buffer_size\n        self._body_timeout = self.params.body_timeout\n        # _write_finished is set to True when finish() has been called,\n        # i.e. there will be no more data sent.  Data may still be in the\n        # stream's write buffer.\n        self._write_finished = False\n        # True when we have read the entire incoming body.\n        self._read_finished = False\n        # _finish_future resolves when all data has been written and flushed\n        # to the IOStream.\n        self._finish_future = Future()  # type: Future[None]\n        # If true, the connection should be closed after this request\n        # (after the response has been written in the server side,\n        # and after it has been read in the client)\n        self._disconnect_on_finish = False\n        self._clear_callbacks()\n        # Save the start lines after we read or write them; they\n        # affect later processing (e.g. 304 responses and HEAD methods\n        # have content-length but no bodies)\n        self._request_start_line = None  # type: Optional[httputil.RequestStartLine]\n        self._response_start_line = None  # type: Optional[httputil.ResponseStartLine]\n        self._request_headers = None  # type: Optional[httputil.HTTPHeaders]\n        # True if we are writing output with chunked encoding.\n        self._chunking_output = False\n        # While reading a body with a content-length, this is the\n        # amount left to read.\n        self._expected_content_remaining = None  # type: Optional[int]\n        # A Future for our outgoing writes, returned by IOStream.write.\n        self._pending_write = None  # type: Optional[Future[None]]",
        "begin_line": 112,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009950248756218905,
            "pseudo_dstar_susp": 0.0013440860215053765,
            "pseudo_tarantula_susp": 0.006578947368421052,
            "pseudo_op2_susp": 0.0013440860215053765,
            "pseudo_barinel_susp": 0.006493506493506494
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.read_response#165",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.read_response(self, delegate: httputil.HTTPMessageDelegate)",
        "snippet": "    def read_response(self, delegate: httputil.HTTPMessageDelegate) -> Awaitable[bool]:\n        \"\"\"Read a single HTTP response.\n\n        Typical client-mode usage is to write a request using `write_headers`,\n        `write`, and `finish`, and then call ``read_response``.\n\n        :arg delegate: a `.HTTPMessageDelegate`\n\n        Returns a `.Future` that resolves to a bool after the full response has\n        been read. The result is true if the stream is still open.\n        \"\"\"\n        if self.params.decompress:\n            delegate = _GzipMessageDelegate(delegate, self.params.chunk_size)\n        return self._read_message(delegate)",
        "begin_line": 165,
        "end_line": 178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009950248756218905,
            "pseudo_dstar_susp": 0.0013440860215053765,
            "pseudo_tarantula_susp": 0.0008620689655172414,
            "pseudo_op2_susp": 0.0013440860215053765,
            "pseudo_barinel_susp": 0.0008620689655172414
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._read_message#180",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._read_message(self, delegate: httputil.HTTPMessageDelegate)",
        "snippet": "    async def _read_message(self, delegate: httputil.HTTPMessageDelegate) -> bool:\n        need_delegate_close = False\n        try:\n            header_future = self.stream.read_until_regex(\n                b\"\\r?\\n\\r?\\n\", max_bytes=self.params.max_header_size\n            )\n            if self.params.header_timeout is None:\n                header_data = await header_future\n            else:\n                try:\n                    header_data = await gen.with_timeout(\n                        self.stream.io_loop.time() + self.params.header_timeout,\n                        header_future,\n                        quiet_exceptions=iostream.StreamClosedError,\n                    )\n                except gen.TimeoutError:\n                    self.close()\n                    return False\n            start_line_str, headers = self._parse_headers(header_data)\n            if self.is_client:\n                resp_start_line = httputil.parse_response_start_line(start_line_str)\n                self._response_start_line = resp_start_line\n                start_line = (\n                    resp_start_line\n                )  # type: Union[httputil.RequestStartLine, httputil.ResponseStartLine]\n                # TODO: this will need to change to support client-side keepalive\n                self._disconnect_on_finish = False\n            else:\n                req_start_line = httputil.parse_request_start_line(start_line_str)\n                self._request_start_line = req_start_line\n                self._request_headers = headers\n                start_line = req_start_line\n                self._disconnect_on_finish = not self._can_keep_alive(\n                    req_start_line, headers\n                )\n            need_delegate_close = True\n            with _ExceptionLoggingContext(app_log):\n                header_recv_future = delegate.headers_received(start_line, headers)\n                if header_recv_future is not None:\n                    await header_recv_future\n            if self.stream is None:\n                # We've been detached.\n                need_delegate_close = False\n                return False\n            skip_body = False\n            if self.is_client:\n                assert isinstance(start_line, httputil.ResponseStartLine)\n                if (\n                    self._request_start_line is not None\n                    and self._request_start_line.method == \"HEAD\"\n                ):\n                    skip_body = True\n                code = start_line.code\n                if code == 304:\n                    # 304 responses may include the content-length header\n                    # but do not actually have a body.\n                    # http://tools.ietf.org/html/rfc7230#section-3.3\n                    skip_body = True\n                if code >= 100 and code < 200:\n                    # 1xx responses should never indicate the presence of\n                    # a body.\n                    if \"Content-Length\" in headers or \"Transfer-Encoding\" in headers:\n                        raise httputil.HTTPInputError(\n                            \"Response code %d cannot have body\" % code\n                        )\n                    # TODO: client delegates will get headers_received twice\n                    # in the case of a 100-continue.  Document or change?\n                    await self._read_message(delegate)\n            else:\n                if headers.get(\"Expect\") == \"100-continue\" and not self._write_finished:\n                    self.stream.write(b\"HTTP/1.1 100 (Continue)\\r\\n\\r\\n\")\n            if not skip_body:\n                body_future = self._read_body(\n                    resp_start_line.code if self.is_client else 0, headers, delegate\n                )\n                if body_future is not None:\n                    if self._body_timeout is None:\n                        await body_future\n                    else:\n                        try:\n                            await gen.with_timeout(\n                                self.stream.io_loop.time() + self._body_timeout,\n                                body_future,\n                                quiet_exceptions=iostream.StreamClosedError,\n                            )\n                        except gen.TimeoutError:\n                            gen_log.info(\"Timeout reading body from %s\", self.context)\n                            self.stream.close()\n                            return False\n            self._read_finished = True\n            if not self._write_finished or self.is_client:\n                need_delegate_close = False\n                with _ExceptionLoggingContext(app_log):\n                    delegate.finish()\n            # If we're waiting for the application to produce an asynchronous\n            # response, and we're not detached, register a close callback\n            # on the stream (we didn't need one while we were reading)\n            if (\n                not self._finish_future.done()\n                and self.stream is not None\n                and not self.stream.closed()\n            ):\n                self.stream.set_close_callback(self._on_connection_close)\n                await self._finish_future\n            if self.is_client and self._disconnect_on_finish:\n                self.close()\n            if self.stream is None:\n                return False\n        except httputil.HTTPInputError as e:\n            gen_log.info(\"Malformed HTTP message from %s: %s\", self.context, e)\n            if not self.is_client:\n                await self.stream.write(b\"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\")\n            self.close()\n            return False\n        finally:\n            if need_delegate_close:\n                with _ExceptionLoggingContext(app_log):\n                    delegate.on_connection_close()\n            header_future = None  # type: ignore\n            self._clear_callbacks()\n        return True",
        "begin_line": 180,
        "end_line": 300,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03333333333333333,
            "pseudo_dstar_susp": 0.001488095238095238,
            "pseudo_tarantula_susp": 0.05,
            "pseudo_op2_susp": 0.001488095238095238,
            "pseudo_barinel_susp": 0.05
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._clear_callbacks#302",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._clear_callbacks(self)",
        "snippet": "    def _clear_callbacks(self) -> None:\n        \"\"\"Clears the callback attributes.\n\n        This allows the request handler to be garbage collected more\n        quickly in CPython by breaking up reference cycles.\n        \"\"\"\n        self._write_callback = None\n        self._write_future = None  # type: Optional[Future[None]]\n        self._close_callback = None  # type: Optional[Callable[[], None]]\n        if self.stream is not None:\n            self.stream.set_close_callback(None)",
        "begin_line": 302,
        "end_line": 312,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009950248756218905,
            "pseudo_dstar_susp": 0.0013440860215053765,
            "pseudo_tarantula_susp": 0.0008620689655172414,
            "pseudo_op2_susp": 0.0013440860215053765,
            "pseudo_barinel_susp": 0.0008620689655172414
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.set_close_callback#314",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.set_close_callback(self, callback: Optional[Callable[[], None]])",
        "snippet": "    def set_close_callback(self, callback: Optional[Callable[[], None]]) -> None:\n        \"\"\"Sets a callback that will be run when the connection is closed.\n\n        Note that this callback is slightly different from\n        `.HTTPMessageDelegate.on_connection_close`: The\n        `.HTTPMessageDelegate` method is called when the connection is\n        closed while recieving a message. This callback is used when\n        there is not an active delegate (for example, on the server\n        side this callback is used if the client closes the connection\n        after sending its request but before receiving all the\n        response.\n        \"\"\"\n        self._close_callback = callback",
        "begin_line": 314,
        "end_line": 326,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000496031746031746,
            "pseudo_dstar_susp": 0.0005491488193300384,
            "pseudo_tarantula_susp": 0.0004597701149425287,
            "pseudo_op2_susp": 0.0005491488193300384,
            "pseudo_barinel_susp": 0.0004597701149425287
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._on_connection_close#328",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._on_connection_close(self)",
        "snippet": "    def _on_connection_close(self) -> None:\n        # Note that this callback is only registered on the IOStream\n        # when we have finished reading the request and are waiting for\n        # the application to produce its response.\n        if self._close_callback is not None:\n            callback = self._close_callback\n            self._close_callback = None\n            callback()\n        if not self._finish_future.done():\n            future_set_result_unless_cancelled(self._finish_future, None)\n        self._clear_callbacks()",
        "begin_line": 328,
        "end_line": 338,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.close#340",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.close(self)",
        "snippet": "    def close(self) -> None:\n        if self.stream is not None:\n            self.stream.close()\n        self._clear_callbacks()\n        if not self._finish_future.done():\n            future_set_result_unless_cancelled(self._finish_future, None)",
        "begin_line": 340,
        "end_line": 345,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010857763300760044,
            "pseudo_dstar_susp": 0.0011682242990654205,
            "pseudo_tarantula_susp": 0.0009514747859181732,
            "pseudo_op2_susp": 0.0011682242990654205,
            "pseudo_barinel_susp": 0.0009514747859181732
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.detach#347",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.detach(self)",
        "snippet": "    def detach(self) -> iostream.IOStream:\n        \"\"\"Take control of the underlying stream.\n\n        Returns the underlying `.IOStream` object and stops all further\n        HTTP processing.  May only be called during\n        `.HTTPMessageDelegate.headers_received`.  Intended for implementing\n        protocols like websockets that tunnel over an HTTP handshake.\n        \"\"\"\n        self._clear_callbacks()\n        stream = self.stream\n        self.stream = None  # type: ignore\n        if not self._finish_future.done():\n            future_set_result_unless_cancelled(self._finish_future, None)\n        return stream",
        "begin_line": 347,
        "end_line": 360,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017543859649122807,
            "pseudo_dstar_susp": 0.0004967709885742673,
            "pseudo_tarantula_susp": 0.008928571428571428,
            "pseudo_op2_susp": 0.0004967709885742673,
            "pseudo_barinel_susp": 0.008928571428571428
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.set_body_timeout#362",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.set_body_timeout(self, timeout: float)",
        "snippet": "    def set_body_timeout(self, timeout: float) -> None:\n        \"\"\"Sets the body timeout for a single request.\n\n        Overrides the value from `.HTTP1ConnectionParameters`.\n        \"\"\"\n        self._body_timeout = timeout",
        "begin_line": 362,
        "end_line": 367,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011441647597254005,
            "pseudo_dstar_susp": 0.0004253509145044662,
            "pseudo_tarantula_susp": 0.05,
            "pseudo_op2_susp": 0.0004253509145044662,
            "pseudo_barinel_susp": 0.05
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.set_max_body_size#369",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.set_max_body_size(self, max_body_size: int)",
        "snippet": "    def set_max_body_size(self, max_body_size: int) -> None:\n        \"\"\"Sets the body size limit for a single request.\n\n        Overrides the value from `.HTTP1ConnectionParameters`.\n        \"\"\"\n        self._max_body_size = max_body_size",
        "begin_line": 369,
        "end_line": 374,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006578947368421052,
            "pseudo_dstar_susp": 0.0004210526315789474,
            "pseudo_tarantula_susp": 0.00684931506849315,
            "pseudo_op2_susp": 0.0004210526315789474,
            "pseudo_barinel_susp": 0.00684931506849315
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.write_headers#376",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.write_headers(self, start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine], headers: httputil.HTTPHeaders, chunk: bytes=None)",
        "snippet": "    def write_headers(\n        self,\n        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],\n        headers: httputil.HTTPHeaders,\n        chunk: bytes = None,\n    ) -> \"Future[None]\":\n        \"\"\"Implements `.HTTPConnection.write_headers`.\"\"\"\n        lines = []\n        if self.is_client:\n            assert isinstance(start_line, httputil.RequestStartLine)\n            self._request_start_line = start_line\n            lines.append(utf8(\"%s %s HTTP/1.1\" % (start_line[0], start_line[1])))\n            # Client requests with a non-empty body must have either a\n            # Content-Length or a Transfer-Encoding.\n            self._chunking_output = (\n                start_line.method in (\"POST\", \"PUT\", \"PATCH\")\n                and \"Content-Length\" not in headers\n                and \"Transfer-Encoding\" not in headers\n            )\n        else:\n            assert isinstance(start_line, httputil.ResponseStartLine)\n            assert self._request_start_line is not None\n            assert self._request_headers is not None\n            self._response_start_line = start_line\n            lines.append(utf8(\"HTTP/1.1 %d %s\" % (start_line[1], start_line[2])))\n            self._chunking_output = (\n                # TODO: should this use\n                # self._request_start_line.version or\n                # start_line.version?\n                self._request_start_line.version == \"HTTP/1.1\"\n                # 1xx, 204 and 304 responses have no body (not even a zero-length\n                # body), and so should not have either Content-Length or\n                # Transfer-Encoding headers.\n                and start_line.code not in (204, 304)\n                and (start_line.code < 100 or start_line.code >= 200)\n                # No need to chunk the output if a Content-Length is specified.\n                and \"Content-Length\" not in headers\n                # Applications are discouraged from touching Transfer-Encoding,\n                # but if they do, leave it alone.\n                and \"Transfer-Encoding\" not in headers\n            )\n            # If connection to a 1.1 client will be closed, inform client\n            if (\n                self._request_start_line.version == \"HTTP/1.1\"\n                and self._disconnect_on_finish\n            ):\n                headers[\"Connection\"] = \"close\"\n            # If a 1.0 client asked for keep-alive, add the header.\n            if (\n                self._request_start_line.version == \"HTTP/1.0\"\n                and self._request_headers.get(\"Connection\", \"\").lower() == \"keep-alive\"\n            ):\n                headers[\"Connection\"] = \"Keep-Alive\"\n        if self._chunking_output:\n            headers[\"Transfer-Encoding\"] = \"chunked\"\n        if not self.is_client and (\n            self._request_start_line.method == \"HEAD\"\n            or cast(httputil.ResponseStartLine, start_line).code == 304\n        ):\n            self._expected_content_remaining = 0\n        elif \"Content-Length\" in headers:\n            self._expected_content_remaining = int(headers[\"Content-Length\"])\n        else:\n            self._expected_content_remaining = None\n        # TODO: headers are supposed to be of type str, but we still have some\n        # cases that let bytes slip through. Remove these native_str calls when those\n        # are fixed.\n        header_lines = (\n            native_str(n) + \": \" + native_str(v) for n, v in headers.get_all()\n        )\n        lines.extend(l.encode(\"latin1\") for l in header_lines)\n        for line in lines:\n            if b\"\\n\" in line:\n                raise ValueError(\"Newline in header: \" + repr(line))\n        future = None\n        if self.stream.closed():\n            future = self._write_future = Future()\n            future.set_exception(iostream.StreamClosedError())\n            future.exception()\n        else:\n            future = self._write_future = Future()\n            data = b\"\\r\\n\".join(lines) + b\"\\r\\n\\r\\n\"\n            if chunk:\n                data += self._format_chunk(chunk)\n            self._pending_write = self.stream.write(data)\n            future_add_done_callback(self._pending_write, self._on_write_complete)\n        return future",
        "begin_line": 376,
        "end_line": 462,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007686395080707148,
            "pseudo_dstar_susp": 0.001658374792703151,
            "pseudo_tarantula_susp": 0.0027472527472527475,
            "pseudo_op2_susp": 0.001658374792703151,
            "pseudo_barinel_susp": 0.0027472527472527475
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._format_chunk#464",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._format_chunk(self, chunk: bytes)",
        "snippet": "    def _format_chunk(self, chunk: bytes) -> bytes:\n        if self._expected_content_remaining is not None:\n            self._expected_content_remaining -= len(chunk)\n            if self._expected_content_remaining < 0:\n                # Close the stream now to stop further framing errors.\n                self.stream.close()\n                raise httputil.HTTPOutputError(\n                    \"Tried to write more data than Content-Length\"\n                )\n        if self._chunking_output and chunk:\n            # Don't write out empty chunks because that means END-OF-STREAM\n            # with chunked encoding\n            return utf8(\"%x\" % len(chunk)) + b\"\\r\\n\" + chunk + b\"\\r\\n\"\n        else:\n            return chunk",
        "begin_line": 464,
        "end_line": 478,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005032712632108706,
            "pseudo_dstar_susp": 0.0005376344086021505,
            "pseudo_tarantula_susp": 0.0023923444976076554,
            "pseudo_op2_susp": 0.0005376344086021505,
            "pseudo_barinel_susp": 0.0023923444976076554
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.write#480",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.write(self, chunk: bytes)",
        "snippet": "    def write(self, chunk: bytes) -> \"Future[None]\":\n        \"\"\"Implements `.HTTPConnection.write`.\n\n        For backwards compatibility it is allowed but deprecated to\n        skip `write_headers` and instead call `write()` with a\n        pre-encoded header block.\n        \"\"\"\n        future = None\n        if self.stream.closed():\n            future = self._write_future = Future()\n            self._write_future.set_exception(iostream.StreamClosedError())\n            self._write_future.exception()\n        else:\n            future = self._write_future = Future()\n            self._pending_write = self.stream.write(self._format_chunk(chunk))\n            self._pending_write.add_done_callback(self._on_write_complete)\n        return future",
        "begin_line": 480,
        "end_line": 496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048007681228996637,
            "pseudo_dstar_susp": 0.0004786979415988511,
            "pseudo_tarantula_susp": 0.0007246376811594203,
            "pseudo_op2_susp": 0.0004786979415988511,
            "pseudo_barinel_susp": 0.0007246376811594203
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.finish#498",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.finish(self)",
        "snippet": "    def finish(self) -> None:\n        \"\"\"Implements `.HTTPConnection.finish`.\"\"\"\n        if (\n            self._expected_content_remaining is not None\n            and self._expected_content_remaining != 0\n            and not self.stream.closed()\n        ):\n            self.stream.close()\n            raise httputil.HTTPOutputError(\n                \"Tried to write %d bytes less than Content-Length\"\n                % self._expected_content_remaining\n            )\n        if self._chunking_output:\n            if not self.stream.closed():\n                self._pending_write = self.stream.write(b\"0\\r\\n\\r\\n\")\n                self._pending_write.add_done_callback(self._on_write_complete)\n        self._write_finished = True\n        # If the app finished the request while we're still reading,\n        # divert any remaining data away from the delegate and\n        # close the connection when we're done sending our response.\n        # Closing the connection is the only way to avoid reading the\n        # whole input body.\n        if not self._read_finished:\n            self._disconnect_on_finish = True\n        # No more data is coming, so instruct TCP to send any remaining\n        # data immediately instead of waiting for a full packet or ack.\n        self.stream.set_nodelay(True)\n        if self._pending_write is None:\n            self._finish_request(None)\n        else:\n            future_add_done_callback(self._pending_write, self._finish_request)",
        "begin_line": 498,
        "end_line": 528,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006406149903907751,
            "pseudo_dstar_susp": 0.0007390983000739098,
            "pseudo_tarantula_susp": 0.00234192037470726,
            "pseudo_op2_susp": 0.0007390983000739098,
            "pseudo_barinel_susp": 0.00234192037470726
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._on_write_complete#530",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._on_write_complete(self, future: 'Future[None]')",
        "snippet": "    def _on_write_complete(self, future: \"Future[None]\") -> None:\n        exc = future.exception()\n        if exc is not None and not isinstance(exc, iostream.StreamClosedError):\n            future.result()\n        if self._write_callback is not None:\n            callback = self._write_callback\n            self._write_callback = None\n            self.stream.io_loop.add_callback(callback)\n        if self._write_future is not None:\n            future = self._write_future\n            self._write_future = None\n            future_set_result_unless_cancelled(future, None)",
        "begin_line": 530,
        "end_line": 541,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006406149903907751,
            "pseudo_dstar_susp": 0.0007390983000739098,
            "pseudo_tarantula_susp": 0.0005580357142857143,
            "pseudo_op2_susp": 0.0007390983000739098,
            "pseudo_barinel_susp": 0.0005580357142857143
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._can_keep_alive#543",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._can_keep_alive(self, start_line: httputil.RequestStartLine, headers: httputil.HTTPHeaders)",
        "snippet": "    def _can_keep_alive(\n        self, start_line: httputil.RequestStartLine, headers: httputil.HTTPHeaders\n    ) -> bool:\n        if self.params.no_keep_alive:\n            return False\n        connection_header = headers.get(\"Connection\")\n        if connection_header is not None:\n            connection_header = connection_header.lower()\n        if start_line.version == \"HTTP/1.1\":\n            return connection_header != \"close\"\n        elif (\n            \"Content-Length\" in headers\n            or headers.get(\"Transfer-Encoding\", \"\").lower() == \"chunked\"\n            or getattr(start_line, \"method\", None) in (\"HEAD\", \"GET\")\n        ):\n            # start_line may be a request or response start line; only\n            # the former has a method attribute.\n            return connection_header == \"keep-alive\"\n        return False",
        "begin_line": 543,
        "end_line": 561,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007072135785007072,
            "pseudo_dstar_susp": 0.0008361204013377926,
            "pseudo_tarantula_susp": 0.0009689922480620155,
            "pseudo_op2_susp": 0.0008361204013377926,
            "pseudo_barinel_susp": 0.0009689922480620155
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._finish_request#563",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._finish_request(self, future: Optional['Future[None]'])",
        "snippet": "    def _finish_request(self, future: Optional[\"Future[None]\"]) -> None:\n        self._clear_callbacks()\n        if not self.is_client and self._disconnect_on_finish:\n            self.close()\n            return\n        # Turn Nagle's algorithm back on, leaving the stream in its\n        # default state for the next request.\n        self.stream.set_nodelay(False)\n        if not self._finish_future.done():\n            future_set_result_unless_cancelled(self._finish_future, None)",
        "begin_line": 563,
        "end_line": 572,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006493506493506494,
            "pseudo_dstar_susp": 0.0007462686567164179,
            "pseudo_tarantula_susp": 0.0005757052389176742,
            "pseudo_op2_susp": 0.0007462686567164179,
            "pseudo_barinel_susp": 0.0005757052389176742
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._parse_headers#574",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._parse_headers(self, data: bytes)",
        "snippet": "    def _parse_headers(self, data: bytes) -> Tuple[str, httputil.HTTPHeaders]:\n        # The lstrip removes newlines that some implementations sometimes\n        # insert between messages of a reused connection.  Per RFC 7230,\n        # we SHOULD ignore at least one empty line before the request.\n        # http://tools.ietf.org/html/rfc7230#section-3.5\n        data_str = native_str(data.decode(\"latin1\")).lstrip(\"\\r\\n\")\n        # RFC 7230 section allows for both CRLF and bare LF.\n        eol = data_str.find(\"\\n\")\n        start_line = data_str[:eol].rstrip(\"\\r\")\n        headers = httputil.HTTPHeaders.parse(data_str[eol:])\n        return start_line, headers",
        "begin_line": 574,
        "end_line": 584,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001076426264800861,
            "pseudo_dstar_susp": 0.001488095238095238,
            "pseudo_tarantula_susp": 0.000925925925925926,
            "pseudo_op2_susp": 0.001488095238095238,
            "pseudo_barinel_susp": 0.000925925925925926
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._read_body#586",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._read_body(self, code: int, headers: httputil.HTTPHeaders, delegate: httputil.HTTPMessageDelegate)",
        "snippet": "    def _read_body(\n        self,\n        code: int,\n        headers: httputil.HTTPHeaders,\n        delegate: httputil.HTTPMessageDelegate,\n    ) -> Optional[Awaitable[None]]:\n        if \"Content-Length\" in headers:\n            if \"Transfer-Encoding\" in headers:\n                # Response cannot contain both Content-Length and\n                # Transfer-Encoding headers.\n                # http://tools.ietf.org/html/rfc7230#section-3.3.3\n                raise httputil.HTTPInputError(\n                    \"Response with both Transfer-Encoding and Content-Length\"\n                )\n            if \",\" in headers[\"Content-Length\"]:\n                # Proxies sometimes cause Content-Length headers to get\n                # duplicated.  If all the values are identical then we can\n                # use them but if they differ it's an error.\n                pieces = re.split(r\",\\s*\", headers[\"Content-Length\"])\n                if any(i != pieces[0] for i in pieces):\n                    raise httputil.HTTPInputError(\n                        \"Multiple unequal Content-Lengths: %r\"\n                        % headers[\"Content-Length\"]\n                    )\n                headers[\"Content-Length\"] = pieces[0]\n\n            try:\n                content_length = int(headers[\"Content-Length\"])  # type: Optional[int]\n            except ValueError:\n                # Handles non-integer Content-Length value.\n                raise httputil.HTTPInputError(\n                    \"Only integer Content-Length is allowed: %s\"\n                    % headers[\"Content-Length\"]\n                )\n\n            if cast(int, content_length) > self._max_body_size:\n                raise httputil.HTTPInputError(\"Content-Length too long\")\n        else:\n            content_length = None\n\n        if code == 204:\n            # This response code is not allowed to have a non-empty body,\n            # and has an implicit length of zero instead of read-until-close.\n            # http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\n            if \"Transfer-Encoding\" in headers or content_length not in (None, 0):\n                raise httputil.HTTPInputError(\n                    \"Response with code %d should not have body\" % code\n                )\n            content_length = 0\n\n        if content_length is not None:\n            return self._read_fixed_body(content_length, delegate)\n        if headers.get(\"Transfer-Encoding\", \"\").lower() == \"chunked\":\n            return self._read_chunked_body(delegate)\n        if self.is_client:\n            return self._read_body_until_close(delegate)\n        return None",
        "begin_line": 586,
        "end_line": 642,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009523809523809525,
            "pseudo_dstar_susp": 0.0009319664492078285,
            "pseudo_tarantula_susp": 0.05,
            "pseudo_op2_susp": 0.0009319664492078285,
            "pseudo_barinel_susp": 0.05
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._read_fixed_body#644",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._read_fixed_body(self, content_length: int, delegate: httputil.HTTPMessageDelegate)",
        "snippet": "    async def _read_fixed_body(\n        self, content_length: int, delegate: httputil.HTTPMessageDelegate\n    ) -> None:\n        while content_length > 0:\n            body = await self.stream.read_bytes(\n                min(self.params.chunk_size, content_length), partial=True\n            )\n            content_length -= len(body)\n            if not self._write_finished or self.is_client:\n                with _ExceptionLoggingContext(app_log):\n                    ret = delegate.data_received(body)\n                    if ret is not None:\n                        await ret",
        "begin_line": 644,
        "end_line": 656,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004452359750667854,
            "pseudo_dstar_susp": 0.00047551117451260106,
            "pseudo_tarantula_susp": 0.0004286326618088298,
            "pseudo_op2_susp": 0.00047551117451260106,
            "pseudo_barinel_susp": 0.0004286326618088298
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._read_chunked_body#658",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._read_chunked_body(self, delegate: httputil.HTTPMessageDelegate)",
        "snippet": "    async def _read_chunked_body(self, delegate: httputil.HTTPMessageDelegate) -> None:\n        # TODO: \"chunk extensions\" http://tools.ietf.org/html/rfc2616#section-3.6.1\n        total_size = 0\n        while True:\n            chunk_len_str = await self.stream.read_until(b\"\\r\\n\", max_bytes=64)\n            chunk_len = int(chunk_len_str.strip(), 16)\n            if chunk_len == 0:\n                crlf = await self.stream.read_bytes(2)\n                if crlf != b\"\\r\\n\":\n                    raise httputil.HTTPInputError(\n                        \"improperly terminated chunked request\"\n                    )\n                return\n            total_size += chunk_len\n            if total_size > self._max_body_size:\n                raise httputil.HTTPInputError(\"chunked body too large\")\n            bytes_to_read = chunk_len\n            while bytes_to_read:\n                chunk = await self.stream.read_bytes(\n                    min(bytes_to_read, self.params.chunk_size), partial=True\n                )\n                bytes_to_read -= len(chunk)\n                if not self._write_finished or self.is_client:\n                    with _ExceptionLoggingContext(app_log):\n                        ret = delegate.data_received(chunk)\n                        if ret is not None:\n                            await ret\n            # chunk ends with \\r\\n\n            crlf = await self.stream.read_bytes(2)\n            assert crlf == b\"\\r\\n\"",
        "begin_line": 658,
        "end_line": 687,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014684287812041115,
            "pseudo_dstar_susp": 0.00044365572315882877,
            "pseudo_tarantula_susp": 0.05,
            "pseudo_op2_susp": 0.00044365572315882877,
            "pseudo_barinel_susp": 0.05
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._read_body_until_close#689",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._read_body_until_close(self, delegate: httputil.HTTPMessageDelegate)",
        "snippet": "    async def _read_body_until_close(\n        self, delegate: httputil.HTTPMessageDelegate\n    ) -> None:\n        body = await self.stream.read_until_close()\n        if not self._write_finished or self.is_client:\n            with _ExceptionLoggingContext(app_log):\n                ret = delegate.data_received(body)\n                if ret is not None:\n                    await ret",
        "begin_line": 689,
        "end_line": 697,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001445086705202312,
            "pseudo_dstar_susp": 0.0004957858205255329,
            "pseudo_tarantula_susp": 0.007575757575757576,
            "pseudo_op2_susp": 0.0004957858205255329,
            "pseudo_barinel_susp": 0.007575757575757576
        }
    },
    {
        "name": "tornado.http1connection._GzipMessageDelegate.__init__#704",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._GzipMessageDelegate",
        "signature": "tornado.http1connection._GzipMessageDelegate.__init__(self, delegate: httputil.HTTPMessageDelegate, chunk_size: int)",
        "snippet": "    def __init__(self, delegate: httputil.HTTPMessageDelegate, chunk_size: int) -> None:\n        self._delegate = delegate\n        self._chunk_size = chunk_size\n        self._decompressor = None  # type: Optional[GzipDecompressor]",
        "begin_line": 704,
        "end_line": 707,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005924170616113745,
            "pseudo_dstar_susp": 0.0006711409395973154,
            "pseudo_tarantula_susp": 0.0005455537370430987,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005455537370430987
        }
    },
    {
        "name": "tornado.http1connection._GzipMessageDelegate.headers_received#709",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._GzipMessageDelegate",
        "signature": "tornado.http1connection._GzipMessageDelegate.headers_received(self, start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine], headers: httputil.HTTPHeaders)",
        "snippet": "    def headers_received(\n        self,\n        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],\n        headers: httputil.HTTPHeaders,\n    ) -> Optional[Awaitable[None]]:\n        if headers.get(\"Content-Encoding\") == \"gzip\":\n            self._decompressor = GzipDecompressor()\n            # Downstream delegates will only see uncompressed data,\n            # so rename the content-encoding header.\n            # (but note that curl_httpclient doesn't do this).\n            headers.add(\"X-Consumed-Content-Encoding\", headers[\"Content-Encoding\"])\n            del headers[\"Content-Encoding\"]\n        return self._delegate.headers_received(start_line, headers)",
        "begin_line": 709,
        "end_line": 721,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005058168942842691,
            "pseudo_dstar_susp": 0.0005589714924538849,
            "pseudo_tarantula_susp": 0.000493339911198816,
            "pseudo_op2_susp": 0.0005589714924538849,
            "pseudo_barinel_susp": 0.000493339911198816
        }
    },
    {
        "name": "tornado.http1connection._GzipMessageDelegate.data_received#723",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._GzipMessageDelegate",
        "signature": "tornado.http1connection._GzipMessageDelegate.data_received(self, chunk: bytes)",
        "snippet": "    async def data_received(self, chunk: bytes) -> None:\n        if self._decompressor:\n            compressed_data = chunk\n            while compressed_data:\n                decompressed = self._decompressor.decompress(\n                    compressed_data, self._chunk_size\n                )\n                if decompressed:\n                    ret = self._delegate.data_received(decompressed)\n                    if ret is not None:\n                        await ret\n                compressed_data = self._decompressor.unconsumed_tail\n        else:\n            ret = self._delegate.data_received(chunk)\n            if ret is not None:\n                await ret",
        "begin_line": 723,
        "end_line": 738,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00047596382674916705,
            "pseudo_dstar_susp": 0.0005165289256198347,
            "pseudo_tarantula_susp": 0.00045351473922902497,
            "pseudo_op2_susp": 0.0005165289256198347,
            "pseudo_barinel_susp": 0.00045351473922902497
        }
    },
    {
        "name": "tornado.http1connection._GzipMessageDelegate.finish#740",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._GzipMessageDelegate",
        "signature": "tornado.http1connection._GzipMessageDelegate.finish(self)",
        "snippet": "    def finish(self) -> None:\n        if self._decompressor is not None:\n            tail = self._decompressor.flush()\n            if tail:\n                # The tail should always be empty: decompress returned\n                # all that it can in data_received and the only\n                # purpose of the flush call is to detect errors such\n                # as truncated input. If we did legitimately get a new\n                # chunk at this point we'd need to change the\n                # interface to make finish() a coroutine.\n                raise ValueError(\n                    \"decompressor.flush returned data; possile truncated input\"\n                )\n        return self._delegate.finish()",
        "begin_line": 740,
        "end_line": 753,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004692632566870014,
            "pseudo_dstar_susp": 0.0005122950819672131,
            "pseudo_tarantula_susp": 0.0004450378282153983,
            "pseudo_op2_susp": 0.0005122950819672131,
            "pseudo_barinel_susp": 0.0004450378282153983
        }
    },
    {
        "name": "tornado.http1connection._GzipMessageDelegate.on_connection_close#755",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._GzipMessageDelegate",
        "signature": "tornado.http1connection._GzipMessageDelegate.on_connection_close(self)",
        "snippet": "    def on_connection_close(self) -> None:\n        return self._delegate.on_connection_close()",
        "begin_line": 755,
        "end_line": 756,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010752688172043012,
            "pseudo_dstar_susp": 0.00049800796812749,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.00049800796812749,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "tornado.http1connection.HTTP1ServerConnection.__init__#762",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1ServerConnection",
        "signature": "tornado.http1connection.HTTP1ServerConnection.__init__(self, stream: iostream.IOStream, params: HTTP1ConnectionParameters=None, context: object=None)",
        "snippet": "    def __init__(\n        self,\n        stream: iostream.IOStream,\n        params: HTTP1ConnectionParameters = None,\n        context: object = None,\n    ) -> None:\n        \"\"\"\n        :arg stream: an `.IOStream`\n        :arg params: a `.HTTP1ConnectionParameters` or None\n        :arg context: an opaque application-defined object that is accessible\n            as ``connection.context``\n        \"\"\"\n        self.stream = stream\n        if params is None:\n            params = HTTP1ConnectionParameters()\n        self.params = params\n        self.context = context\n        self._serving_future = None  # type: Optional[Future[None]]",
        "begin_line": 762,
        "end_line": 779,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010395010395010396,
            "pseudo_dstar_susp": 0.0014265335235378032,
            "pseudo_tarantula_susp": 0.0008984725965858042,
            "pseudo_op2_susp": 0.0014265335235378032,
            "pseudo_barinel_susp": 0.0008984725965858042
        }
    },
    {
        "name": "tornado.http1connection.HTTP1ServerConnection.close#781",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1ServerConnection",
        "signature": "tornado.http1connection.HTTP1ServerConnection.close(self)",
        "snippet": "    async def close(self) -> None:\n        \"\"\"Closes the connection.\n\n        Returns a `.Future` that resolves after the serving loop has exited.\n        \"\"\"\n        self.stream.close()\n        # Block until the serving loop is done, but ignore any exceptions\n        # (start_serving is already responsible for logging them).\n        assert self._serving_future is not None\n        try:\n            await self._serving_future\n        except Exception:\n            pass",
        "begin_line": 781,
        "end_line": 793,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.http1connection.HTTP1ServerConnection.start_serving#795",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1ServerConnection",
        "signature": "tornado.http1connection.HTTP1ServerConnection.start_serving(self, delegate: httputil.HTTPServerConnectionDelegate)",
        "snippet": "    def start_serving(self, delegate: httputil.HTTPServerConnectionDelegate) -> None:\n        \"\"\"Starts serving requests on this connection.\n\n        :arg delegate: a `.HTTPServerConnectionDelegate`\n        \"\"\"\n        assert isinstance(delegate, httputil.HTTPServerConnectionDelegate)\n        fut = gen.convert_yielded(self._server_request_loop(delegate))\n        self._serving_future = fut\n        # Register the future on the IOLoop so its errors get logged.\n        self.stream.io_loop.add_future(fut, lambda f: f.result())",
        "begin_line": 795,
        "end_line": 804,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012468827930174563,
            "pseudo_dstar_susp": 0.0022271714922048997,
            "pseudo_tarantula_susp": 0.0008984725965858042,
            "pseudo_op2_susp": 0.0022271714922048997,
            "pseudo_barinel_susp": 0.0008984725965858042
        }
    },
    {
        "name": "tornado.http1connection.HTTP1ServerConnection._server_request_loop#806",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1ServerConnection",
        "signature": "tornado.http1connection.HTTP1ServerConnection._server_request_loop(self, delegate: httputil.HTTPServerConnectionDelegate)",
        "snippet": "    async def _server_request_loop(\n        self, delegate: httputil.HTTPServerConnectionDelegate\n    ) -> None:\n        try:\n            while True:\n                conn = HTTP1Connection(self.stream, False, self.params, self.context)\n                request_delegate = delegate.start_request(self, conn)\n                try:\n                    ret = await conn.read_response(request_delegate)\n                except (iostream.StreamClosedError, iostream.UnsatisfiableReadError):\n                    return\n                except _QuietException:\n                    # This exception was already logged.\n                    conn.close()\n                    return\n                except Exception:\n                    gen_log.error(\"Uncaught exception\", exc_info=True)\n                    conn.close()\n                    return\n                if not ret:\n                    return\n                await asyncio.sleep(0)\n        finally:\n            delegate.on_close(self)",
        "begin_line": 806,
        "end_line": 829,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009009009009009009,
            "pseudo_dstar_susp": 0.0014947683109118087,
            "pseudo_tarantula_susp": 0.00625,
            "pseudo_op2_susp": 0.0014947683109118087,
            "pseudo_barinel_susp": 0.00625
        }
    },
    {
        "name": "tornado.options.OptionParser.__init__#127",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.__init__(self)",
        "snippet": "    def __init__(self) -> None:\n        # we have to use self.__dict__ because we override setattr.\n        self.__dict__[\"_options\"] = {}\n        self.__dict__[\"_parse_callbacks\"] = []\n        self.define(\n            \"help\",\n            type=bool,\n            help=\"show this help information\",\n            callback=self._help_callback,\n        )",
        "begin_line": 127,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001588057805304113,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser._normalize_name#138",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser._normalize_name(self, name: str)",
        "snippet": "    def _normalize_name(self, name: str) -> str:\n        return name.replace(\"_\", \"-\")",
        "begin_line": 138,
        "end_line": 139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001588057805304113,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.__getattr__#141",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.__getattr__(self, name: str)",
        "snippet": "    def __getattr__(self, name: str) -> Any:\n        name = self._normalize_name(name)\n        if isinstance(self._options.get(name), _Option):\n            return self._options[name].value()\n        raise AttributeError(\"Unrecognized option %r\" % name)",
        "begin_line": 141,
        "end_line": 145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016466326362588507,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.__setattr__#147",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.__setattr__(self, name: str, value: Any)",
        "snippet": "    def __setattr__(self, name: str, value: Any) -> None:\n        name = self._normalize_name(name)\n        if isinstance(self._options.get(name), _Option):\n            return self._options[name].set(value)\n        raise AttributeError(\"Unrecognized option %r\" % name)",
        "begin_line": 147,
        "end_line": 151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.__iter__#153",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.__iter__(self)",
        "snippet": "    def __iter__(self) -> Iterator:\n        return (opt.name for opt in self._options.values())",
        "begin_line": 153,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.__getitem__#160",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.__getitem__(self, name: str)",
        "snippet": "    def __getitem__(self, name: str) -> Any:\n        return self.__getattr__(name)",
        "begin_line": 160,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.__setitem__#163",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.__setitem__(self, name: str, value: Any)",
        "snippet": "    def __setitem__(self, name: str, value: Any) -> None:\n        return self.__setattr__(name, value)",
        "begin_line": 163,
        "end_line": 164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.items#166",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.items(self)",
        "snippet": "    def items(self) -> Iterable[Tuple[str, Any]]:\n        \"\"\"An iterable of (name, value) pairs.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        return [(opt.name, opt.value()) for name, opt in self._options.items()]",
        "begin_line": 166,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.groups#173",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.groups(self)",
        "snippet": "    def groups(self) -> Set[str]:\n        \"\"\"The set of option-groups created by ``define``.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        return set(opt.group_name for opt in self._options.values())",
        "begin_line": 173,
        "end_line": 178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.group_dict#180",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.group_dict(self, group: str)",
        "snippet": "    def group_dict(self, group: str) -> Dict[str, Any]:\n        \"\"\"The names and values of options in a group.\n\n        Useful for copying options into Application settings::\n\n            from tornado.options import define, parse_command_line, options\n\n            define('template_path', group='application')\n            define('static_path', group='application')\n\n            parse_command_line()\n\n            application = Application(\n                handlers, **options.group_dict('application'))\n\n        .. versionadded:: 3.1\n        \"\"\"\n        return dict(\n            (opt.name, opt.value())\n            for name, opt in self._options.items()\n            if not group or group == opt.group_name\n        )",
        "begin_line": 180,
        "end_line": 201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.as_dict#203",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.as_dict(self)",
        "snippet": "    def as_dict(self) -> Dict[str, Any]:\n        \"\"\"The names and values of all options.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        return dict((opt.name, opt.value()) for name, opt in self._options.items())",
        "begin_line": 203,
        "end_line": 208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.define#210",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.define(self, name: str, default: Any=None, type: type=None, help: str=None, metavar: str=None, multiple: bool=False, group: str=None, callback: Callable[[Any], None]=None)",
        "snippet": "    def define(\n        self,\n        name: str,\n        default: Any = None,\n        type: type = None,\n        help: str = None,\n        metavar: str = None,\n        multiple: bool = False,\n        group: str = None,\n        callback: Callable[[Any], None] = None,\n    ) -> None:\n        \"\"\"Defines a new command line option.\n\n        ``type`` can be any of `str`, `int`, `float`, `bool`,\n        `~datetime.datetime`, or `~datetime.timedelta`. If no ``type``\n        is given but a ``default`` is, ``type`` is the type of\n        ``default``. Otherwise, ``type`` defaults to `str`.\n\n        If ``multiple`` is True, the option value is a list of ``type``\n        instead of an instance of ``type``.\n\n        ``help`` and ``metavar`` are used to construct the\n        automatically generated command line help string. The help\n        message is formatted like::\n\n           --name=METAVAR      help string\n\n        ``group`` is used to group the defined options in logical\n        groups. By default, command line options are grouped by the\n        file in which they are defined.\n\n        Command line option names must be unique globally.\n\n        If a ``callback`` is given, it will be run with the new value whenever\n        the option is changed.  This can be used to combine command-line\n        and file-based options::\n\n            define(\"config\", type=str, help=\"path to config file\",\n                   callback=lambda path: parse_config_file(path, final=False))\n\n        With this definition, options in the file specified by ``--config`` will\n        override options set earlier on the command line, but can be overridden\n        by later flags.\n\n        \"\"\"\n        normalized = self._normalize_name(name)\n        if normalized in self._options:\n            raise Error(\n                \"Option %r already defined in %s\"\n                % (normalized, self._options[normalized].file_name)\n            )\n        frame = sys._getframe(0)\n        options_file = frame.f_code.co_filename\n\n        # Can be called directly, or through top level define() fn, in which\n        # case, step up above that frame to look for real caller.\n        if (\n            frame.f_back.f_code.co_filename == options_file\n            and frame.f_back.f_code.co_name == \"define\"\n        ):\n            frame = frame.f_back\n\n        file_name = frame.f_back.f_code.co_filename\n        if file_name == options_file:\n            file_name = \"\"\n        if type is None:\n            if not multiple and default is not None:\n                type = default.__class__\n            else:\n                type = str\n        if group:\n            group_name = group  # type: Optional[str]\n        else:\n            group_name = file_name\n        option = _Option(\n            name,\n            file_name=file_name,\n            default=default,\n            type=type,\n            help=help,\n            metavar=metavar,\n            multiple=multiple,\n            group_name=group_name,\n            callback=callback,\n        )\n        self._options[normalized] = option",
        "begin_line": 210,
        "end_line": 295,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.parse_command_line#297",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.parse_command_line(self, args: List[str]=None, final: bool=True)",
        "snippet": "    def parse_command_line(\n        self, args: List[str] = None, final: bool = True\n    ) -> List[str]:\n        \"\"\"Parses all options given on the command line (defaults to\n        `sys.argv`).\n\n        Options look like ``--option=value`` and are parsed according\n        to their ``type``. For boolean options, ``--option`` is\n        equivalent to ``--option=true``\n\n        If the option has ``multiple=True``, comma-separated values\n        are accepted. For multi-value integer options, the syntax\n        ``x:y`` is also accepted and equivalent to ``range(x, y)``.\n\n        Note that ``args[0]`` is ignored since it is the program name\n        in `sys.argv`.\n\n        We return a list of all arguments that are not parsed as options.\n\n        If ``final`` is ``False``, parse callbacks will not be run.\n        This is useful for applications that wish to combine configurations\n        from multiple sources.\n\n        \"\"\"\n        if args is None:\n            args = sys.argv\n        remaining = []  # type: List[str]\n        for i in range(1, len(args)):\n            # All things after the last option are command line arguments\n            if not args[i].startswith(\"-\"):\n                remaining = args[i:]\n                break\n            if args[i] == \"--\":\n                remaining = args[i + 1 :]\n                break\n            arg = args[i].lstrip(\"-\")\n            name, equals, value = arg.partition(\"=\")\n            name = self._normalize_name(name)\n            if name not in self._options:\n                self.print_help()\n                raise Error(\"Unrecognized command line option: %r\" % name)\n            option = self._options[name]\n            if not equals:\n                if option.type == bool:\n                    value = \"true\"\n                else:\n                    raise Error(\"Option %r requires a value\" % name)\n            option.parse(value)\n\n        if final:\n            self.run_parse_callbacks()\n\n        return remaining",
        "begin_line": 297,
        "end_line": 349,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.parse_config_file#351",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.parse_config_file(self, path: str, final: bool=True)",
        "snippet": "    def parse_config_file(self, path: str, final: bool = True) -> None:\n        \"\"\"Parses and loads the config file at the given path.\n\n        The config file contains Python code that will be executed (so\n        it is **not safe** to use untrusted config files). Anything in\n        the global namespace that matches a defined option will be\n        used to set that option's value.\n\n        Options may either be the specified type for the option or\n        strings (in which case they will be parsed the same way as in\n        `.parse_command_line`)\n\n        Example (using the options defined in the top-level docs of\n        this module)::\n\n            port = 80\n            mysql_host = 'mydb.example.com:3306'\n            # Both lists and comma-separated strings are allowed for\n            # multiple=True.\n            memcache_hosts = ['cache1.example.com:11011',\n                              'cache2.example.com:11011']\n            memcache_hosts = 'cache1.example.com:11011,cache2.example.com:11011'\n\n        If ``final`` is ``False``, parse callbacks will not be run.\n        This is useful for applications that wish to combine configurations\n        from multiple sources.\n\n        .. note::\n\n            `tornado.options` is primarily a command-line library.\n            Config file support is provided for applications that wish\n            to use it, but applications that prefer config files may\n            wish to look at other libraries instead.\n\n        .. versionchanged:: 4.1\n           Config files are now always interpreted as utf-8 instead of\n           the system default encoding.\n\n        .. versionchanged:: 4.4\n           The special variable ``__file__`` is available inside config\n           files, specifying the absolute path to the config file itself.\n\n        .. versionchanged:: 5.1\n           Added the ability to set options via strings in config files.\n\n        \"\"\"\n        config = {\"__file__\": os.path.abspath(path)}\n        with open(path, \"rb\") as f:\n            exec_in(native_str(f.read()), config, config)\n        for name in config:\n            normalized = self._normalize_name(name)\n            if normalized in self._options:\n                option = self._options[normalized]\n                if option.multiple:\n                    if not isinstance(config[name], (list, str)):\n                        raise Error(\n                            \"Option %r is required to be a list of %s \"\n                            \"or a comma-separated string\"\n                            % (option.name, option.type.__name__)\n                        )\n\n                if type(config[name]) == str and option.type != str:\n                    option.parse(config[name])\n                else:\n                    option.set(config[name])\n\n        if final:\n            self.run_parse_callbacks()",
        "begin_line": 351,
        "end_line": 418,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.print_help#420",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.print_help(self, file: TextIO=None)",
        "snippet": "    def print_help(self, file: TextIO = None) -> None:\n        \"\"\"Prints all the command line options to stderr (or another file).\"\"\"\n        if file is None:\n            file = sys.stderr\n        print(\"Usage: %s [OPTIONS]\" % sys.argv[0], file=file)\n        print(\"\\nOptions:\\n\", file=file)\n        by_group = {}  # type: Dict[str, List[_Option]]\n        for option in self._options.values():\n            by_group.setdefault(option.group_name, []).append(option)\n\n        for filename, o in sorted(by_group.items()):\n            if filename:\n                print(\"\\n%s options:\\n\" % os.path.normpath(filename), file=file)\n            o.sort(key=lambda option: option.name)\n            for option in o:\n                # Always print names with dashes in a CLI context.\n                prefix = self._normalize_name(option.name)\n                if option.metavar:\n                    prefix += \"=\" + option.metavar\n                description = option.help or \"\"\n                if option.default is not None and option.default != \"\":\n                    description += \" (default %s)\" % option.default\n                lines = textwrap.wrap(description, 79 - 35)\n                if len(prefix) > 30 or len(lines) == 0:\n                    lines.insert(0, \"\")\n                print(\"  --%-30s %s\" % (prefix, lines[0]), file=file)\n                for line in lines[1:]:\n                    print(\"%-34s %s\" % (\" \", line), file=file)\n        print(file=file)",
        "begin_line": 420,
        "end_line": 448,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser._help_callback#450",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser._help_callback(self, value: bool)",
        "snippet": "    def _help_callback(self, value: bool) -> None:\n        if value:\n            self.print_help()\n            sys.exit(0)",
        "begin_line": 450,
        "end_line": 453,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.add_parse_callback#455",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.add_parse_callback(self, callback: Callable[[], None])",
        "snippet": "    def add_parse_callback(self, callback: Callable[[], None]) -> None:\n        \"\"\"Adds a parse callback, to be invoked when option parsing is done.\"\"\"\n        self._parse_callbacks.append(callback)",
        "begin_line": 455,
        "end_line": 457,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.run_parse_callbacks#459",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.run_parse_callbacks(self)",
        "snippet": "    def run_parse_callbacks(self) -> None:\n        for callback in self._parse_callbacks:\n            callback()",
        "begin_line": 459,
        "end_line": 461,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options.OptionParser.mockable#463",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.mockable(self)",
        "snippet": "    def mockable(self) -> \"_Mockable\":\n        \"\"\"Returns a wrapper around self that is compatible with\n        `mock.patch <unittest.mock.patch>`.\n\n        The `mock.patch <unittest.mock.patch>` function (included in\n        the standard library `unittest.mock` package since Python 3.3,\n        or in the third-party ``mock`` package for older versions of\n        Python) is incompatible with objects like ``options`` that\n        override ``__getattr__`` and ``__setattr__``.  This function\n        returns an object that can be used with `mock.patch.object\n        <unittest.mock.patch.object>` to modify option values::\n\n            with mock.patch.object(options.mockable(), 'name', value):\n                assert options.name == value\n        \"\"\"\n        return _Mockable(self)",
        "begin_line": 463,
        "end_line": 478,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options._Mockable.__init__#494",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Mockable",
        "signature": "tornado.options._Mockable.__init__(self, options: OptionParser)",
        "snippet": "    def __init__(self, options: OptionParser) -> None:\n        # Modify __dict__ directly to bypass __setattr__\n        self.__dict__[\"_options\"] = options\n        self.__dict__[\"_originals\"] = {}",
        "begin_line": 494,
        "end_line": 497,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options._Mockable.__getattr__#499",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Mockable",
        "signature": "tornado.options._Mockable.__getattr__(self, name: str)",
        "snippet": "    def __getattr__(self, name: str) -> Any:\n        return getattr(self._options, name)",
        "begin_line": 499,
        "end_line": 500,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options._Mockable.__setattr__#502",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Mockable",
        "signature": "tornado.options._Mockable.__setattr__(self, name: str, value: Any)",
        "snippet": "    def __setattr__(self, name: str, value: Any) -> None:\n        assert name not in self._originals, \"don't reuse mockable objects\"\n        self._originals[name] = getattr(self._options, name)\n        setattr(self._options, name, value)",
        "begin_line": 502,
        "end_line": 505,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options._Mockable.__delattr__#507",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Mockable",
        "signature": "tornado.options._Mockable.__delattr__(self, name: str)",
        "snippet": "    def __delattr__(self, name: str) -> None:\n        setattr(self._options, name, self._originals.pop(name))",
        "begin_line": 507,
        "end_line": 508,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options._Option.__init__#517",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option.__init__(self, name: str, default: Any=None, type: type=None, help: str=None, metavar: str=None, multiple: bool=False, file_name: str=None, group_name: str=None, callback: Callable[[Any], None]=None)",
        "snippet": "    def __init__(\n        self,\n        name: str,\n        default: Any = None,\n        type: type = None,\n        help: str = None,\n        metavar: str = None,\n        multiple: bool = False,\n        file_name: str = None,\n        group_name: str = None,\n        callback: Callable[[Any], None] = None,\n    ) -> None:\n        if default is None and multiple:\n            default = []\n        self.name = name\n        if type is None:\n            raise ValueError(\"type must not be None\")\n        self.type = type\n        self.help = help\n        self.metavar = metavar\n        self.multiple = multiple\n        self.file_name = file_name\n        self.group_name = group_name\n        self.callback = callback\n        self.default = default\n        self._value = _Option.UNSET  # type: Any",
        "begin_line": 517,
        "end_line": 542,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options._Option.value#544",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option.value(self)",
        "snippet": "    def value(self) -> Any:\n        return self.default if self._value is _Option.UNSET else self._value",
        "begin_line": 544,
        "end_line": 545,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001636929120969062,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options._Option.parse#547",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option.parse(self, value: str)",
        "snippet": "    def parse(self, value: str) -> Any:\n        _parse = {\n            datetime.datetime: self._parse_datetime,\n            datetime.timedelta: self._parse_timedelta,\n            bool: self._parse_bool,\n            basestring_type: self._parse_string,\n        }.get(\n            self.type, self.type\n        )  # type: Callable[[str], Any]\n        if self.multiple:\n            self._value = []\n            for part in value.split(\",\"):\n                if issubclass(self.type, numbers.Integral):\n                    # allow ranges of the form X:Y (inclusive at both ends)\n                    lo_str, _, hi_str = part.partition(\":\")\n                    lo = _parse(lo_str)\n                    hi = _parse(hi_str) if hi_str else lo\n                    self._value.extend(range(lo, hi + 1))\n                else:\n                    self._value.append(_parse(part))\n        else:\n            self._value = _parse(value)\n        if self.callback is not None:\n            self.callback(self._value)\n        return self.value()",
        "begin_line": 547,
        "end_line": 571,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options._Option.set#573",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option.set(self, value: Any)",
        "snippet": "    def set(self, value: Any) -> None:\n        if self.multiple:\n            if not isinstance(value, list):\n                raise Error(\n                    \"Option %r is required to be a list of %s\"\n                    % (self.name, self.type.__name__)\n                )\n            for item in value:\n                if item is not None and not isinstance(item, self.type):\n                    raise Error(\n                        \"Option %r is required to be a list of %s\"\n                        % (self.name, self.type.__name__)\n                    )\n        else:\n            if value is not None and not isinstance(value, self.type):\n                raise Error(\n                    \"Option %r is required to be a %s (%s given)\"\n                    % (self.name, self.type.__name__, type(value))\n                )\n        self._value = value\n        if self.callback is not None:\n            self.callback(self._value)",
        "begin_line": 573,
        "end_line": 594,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options._Option._parse_datetime#610",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option._parse_datetime(self, value: str)",
        "snippet": "    def _parse_datetime(self, value: str) -> datetime.datetime:\n        for format in self._DATETIME_FORMATS:\n            try:\n                return datetime.datetime.strptime(value, format)\n            except ValueError:\n                pass\n        raise Error(\"Unrecognized date/time format: %r\" % value)",
        "begin_line": 610,
        "end_line": 616,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options._Option._parse_timedelta#636",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option._parse_timedelta(self, value: str)",
        "snippet": "    def _parse_timedelta(self, value: str) -> datetime.timedelta:\n        try:\n            sum = datetime.timedelta()\n            start = 0\n            while start < len(value):\n                m = self._TIMEDELTA_PATTERN.match(value, start)\n                if not m:\n                    raise Exception()\n                num = float(m.group(1))\n                units = m.group(2) or \"seconds\"\n                units = self._TIMEDELTA_ABBREV_DICT.get(units, units)\n                sum += datetime.timedelta(**{units: num})\n                start = m.end()\n            return sum\n        except Exception:\n            raise",
        "begin_line": 636,
        "end_line": 651,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options._Option._parse_bool#653",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option._parse_bool(self, value: str)",
        "snippet": "    def _parse_bool(self, value: str) -> bool:\n        return value.lower() not in (\"false\", \"0\", \"f\")",
        "begin_line": 653,
        "end_line": 654,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.options._Option._parse_string#656",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option._parse_string(self, value: str)",
        "snippet": "    def _parse_string(self, value: str) -> str:\n        return _unicode(value)",
        "begin_line": 656,
        "end_line": 657,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.__init__#198",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.__init__(self, application: 'Application', request: httputil.HTTPServerRequest, **kwargs: Any)",
        "snippet": "    def __init__(\n        self,\n        application: \"Application\",\n        request: httputil.HTTPServerRequest,\n        **kwargs: Any\n    ) -> None:\n        super(RequestHandler, self).__init__()\n\n        self.application = application\n        self.request = request\n        self._headers_written = False\n        self._finished = False\n        self._auto_finish = True\n        self._prepared_future = None\n        self.ui = ObjectDict(\n            (n, self._ui_method(m)) for n, m in application.ui_methods.items()\n        )\n        # UIModules are available as both `modules` and `_tt_modules` in the\n        # template namespace.  Historically only `modules` was available\n        # but could be clobbered by user additions to the namespace.\n        # The template {% module %} directive looks in `_tt_modules` to avoid\n        # possible conflicts.\n        self.ui[\"_tt_modules\"] = _UIModuleNamespace(self, application.ui_modules)\n        self.ui[\"modules\"] = self.ui[\"_tt_modules\"]\n        self.clear()\n        assert self.request.connection is not None\n        # TODO: need to add set_close_callback to HTTPConnection interface\n        self.request.connection.set_close_callback(  # type: ignore\n            self.on_connection_close\n        )\n        self.initialize(**kwargs)  # type: ignore",
        "begin_line": 198,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007017543859649122,
            "pseudo_dstar_susp": 0.0014992503748125937,
            "pseudo_tarantula_susp": 0.0004597701149425287,
            "pseudo_op2_susp": 0.0014992503748125937,
            "pseudo_barinel_susp": 0.0004597701149425287
        }
    },
    {
        "name": "tornado.web.RequestHandler._initialize#230",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._initialize(self)",
        "snippet": "    def _initialize(self) -> None:\n        pass",
        "begin_line": 230,
        "end_line": 231,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00045829514207149406,
            "pseudo_dstar_susp": 0.0004921259842519685,
            "pseudo_tarantula_susp": 0.000449034575662326,
            "pseudo_op2_susp": 0.0004921259842519685,
            "pseudo_barinel_susp": 0.000449034575662326
        }
    },
    {
        "name": "tornado.web.RequestHandler.settings#254",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.settings(self)",
        "snippet": "    def settings(self) -> Dict[str, Any]:\n        \"\"\"An alias for `self.application.settings <Application.settings>`.\"\"\"\n        return self.application.settings",
        "begin_line": 254,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00013900472616068947,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler._unimplemented_method#258",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._unimplemented_method(self, *args: str, **kwargs: str)",
        "snippet": "    def _unimplemented_method(self, *args: str, **kwargs: str) -> None:\n        raise HTTPError(405)",
        "begin_line": 258,
        "end_line": 259,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.prepare#269",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.prepare(self)",
        "snippet": "    def prepare(self) -> Optional[Awaitable[None]]:\n        \"\"\"Called at the beginning of a request before  `get`/`post`/etc.\n\n        Override this method to perform common initialization regardless\n        of the request method.\n\n        Asynchronous support: Decorate this method with `.gen.coroutine`\n        or use ``async def`` to make it asynchronous.\n        If this method returns a `.Future` execution will not proceed\n        until the `.Future` is done.\n\n        .. versionadded:: 3.1\n           Asynchronous support.\n        \"\"\"\n        pass",
        "begin_line": 269,
        "end_line": 283,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00045372050816696913,
            "pseudo_dstar_susp": 0.0004916420845624386,
            "pseudo_tarantula_susp": 0.0004269854824935952,
            "pseudo_op2_susp": 0.0004916420845624386,
            "pseudo_barinel_susp": 0.0004269854824935952
        }
    },
    {
        "name": "tornado.web.RequestHandler.on_finish#285",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.on_finish(self)",
        "snippet": "    def on_finish(self) -> None:\n        \"\"\"Called after the end of a request.\n\n        Override this method to perform cleanup, logging, etc.\n        This method is a counterpart to `prepare`.  ``on_finish`` may\n        not produce any output, as it is called after the response\n        has been sent to the client.\n        \"\"\"\n        pass",
        "begin_line": 285,
        "end_line": 293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043122035360068997,
            "pseudo_dstar_susp": 0.0004631773969430292,
            "pseudo_tarantula_susp": 0.0004127115146512588,
            "pseudo_op2_susp": 0.0004631773969430292,
            "pseudo_barinel_susp": 0.0004127115146512588
        }
    },
    {
        "name": "tornado.web.RequestHandler.on_connection_close#295",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.on_connection_close(self)",
        "snippet": "    def on_connection_close(self) -> None:\n        \"\"\"Called in async handlers if the client closed the connection.\n\n        Override this to clean up resources associated with\n        long-lived connections.  Note that this method is called only if\n        the connection was closed during asynchronous processing; if you\n        need to do cleanup after every request override `on_finish`\n        instead.\n\n        Proxies may keep a connection open for a time (perhaps\n        indefinitely) after the client has gone away, so this method\n        may not be called promptly after the end user closes their\n        connection.\n        \"\"\"\n        if _has_stream_request_body(self.__class__):\n            if not self.request._body_future.done():\n                self.request._body_future.set_exception(iostream.StreamClosedError())\n                self.request._body_future.exception()",
        "begin_line": 295,
        "end_line": 312,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014084507042253522,
            "pseudo_dstar_susp": 0.00048756704046806434,
            "pseudo_tarantula_susp": 0.009259259259259259,
            "pseudo_op2_susp": 0.00048756704046806434,
            "pseudo_barinel_susp": 0.009259259259259259
        }
    },
    {
        "name": "tornado.web.RequestHandler.clear#314",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.clear(self)",
        "snippet": "    def clear(self) -> None:\n        \"\"\"Resets all headers and content for this response.\"\"\"\n        self._headers = httputil.HTTPHeaders(\n            {\n                \"Server\": \"TornadoServer/%s\" % tornado.version,\n                \"Content-Type\": \"text/html; charset=UTF-8\",\n                \"Date\": httputil.format_timestamp(time.time()),\n            }\n        )\n        self.set_default_headers()\n        self._write_buffer = []  # type: List[bytes]\n        self._status_code = 200\n        self._reason = httputil.responses[200]",
        "begin_line": 314,
        "end_line": 326,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000496031746031746,
            "pseudo_dstar_susp": 0.0005491488193300384,
            "pseudo_tarantula_susp": 0.0004597701149425287,
            "pseudo_op2_susp": 0.0005491488193300384,
            "pseudo_barinel_susp": 0.0004597701149425287
        }
    },
    {
        "name": "tornado.web.RequestHandler.set_default_headers#328",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.set_default_headers(self)",
        "snippet": "    def set_default_headers(self) -> None:\n        \"\"\"Override this to set HTTP headers at the beginning of the request.\n\n        For example, this is the place to set a custom ``Server`` header.\n        Note that setting such headers in the normal flow of request\n        processing may not do what you want, since headers may be reset\n        during error handling.\n        \"\"\"\n        pass",
        "begin_line": 328,
        "end_line": 336,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000502008032128514,
            "pseudo_dstar_susp": 0.0005564830272676684,
            "pseudo_tarantula_susp": 0.0004655493482309125,
            "pseudo_op2_susp": 0.0005564830272676684,
            "pseudo_barinel_susp": 0.0004655493482309125
        }
    },
    {
        "name": "tornado.web.RequestHandler.set_status#338",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.set_status(self, status_code: int, reason: str=None)",
        "snippet": "    def set_status(self, status_code: int, reason: str = None) -> None:\n        \"\"\"Sets the status code for our response.\n\n        :arg int status_code: Response status code.\n        :arg str reason: Human-readable reason phrase describing the status\n            code. If ``None``, it will be filled in from\n            `http.client.responses` or \"Unknown\".\n\n        .. versionchanged:: 5.0\n\n           No longer validates that the response code is in\n           `http.client.responses`.\n        \"\"\"\n        self._status_code = status_code\n        if reason is not None:\n            self._reason = escape.native_str(reason)\n        else:\n            self._reason = httputil.responses.get(status_code, \"Unknown\")",
        "begin_line": 338,
        "end_line": 355,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_status#357",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_status(self)",
        "snippet": "    def get_status(self) -> int:\n        \"\"\"Returns the status code for our response.\"\"\"\n        return self._status_code",
        "begin_line": 357,
        "end_line": 359,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043122035360068997,
            "pseudo_dstar_susp": 0.0004631773969430292,
            "pseudo_tarantula_susp": 0.0004127115146512588,
            "pseudo_op2_susp": 0.0004631773969430292,
            "pseudo_barinel_susp": 0.0004127115146512588
        }
    },
    {
        "name": "tornado.web.RequestHandler.set_header#361",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.set_header(self, name: str, value: _HeaderTypes)",
        "snippet": "    def set_header(self, name: str, value: _HeaderTypes) -> None:\n        \"\"\"Sets the given response header name and value.\n\n        If a datetime is given, we automatically format it according to the\n        HTTP specification. If the value is not a string, we convert it to\n        a string. All header values are then encoded as UTF-8.\n        \"\"\"\n        self._headers[name] = self._convert_header_value(value)",
        "begin_line": 361,
        "end_line": 368,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043649061545176777,
            "pseudo_dstar_susp": 0.00046904315196998124,
            "pseudo_tarantula_susp": 0.00041736227045075126,
            "pseudo_op2_susp": 0.00046904315196998124,
            "pseudo_barinel_susp": 0.00041736227045075126
        }
    },
    {
        "name": "tornado.web.RequestHandler.add_header#370",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.add_header(self, name: str, value: _HeaderTypes)",
        "snippet": "    def add_header(self, name: str, value: _HeaderTypes) -> None:\n        \"\"\"Adds the given response header and value.\n\n        Unlike `set_header`, `add_header` may be called multiple times\n        to return multiple values for the same header.\n        \"\"\"\n        self._headers.add(name, self._convert_header_value(value))",
        "begin_line": 370,
        "end_line": 376,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014858841010401187,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.clear_header#378",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.clear_header(self, name: str)",
        "snippet": "    def clear_header(self, name: str) -> None:\n        \"\"\"Clears an outgoing header, undoing a previous `set_header` call.\n\n        Note that this method does not apply to multi-valued headers\n        set by `add_header`.\n        \"\"\"\n        if name in self._headers:\n            del self._headers[name]",
        "begin_line": 378,
        "end_line": 385,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001429592566118656,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler._convert_header_value#389",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._convert_header_value(self, value: _HeaderTypes)",
        "snippet": "    def _convert_header_value(self, value: _HeaderTypes) -> str:\n        # Convert the input value to a str. This type check is a bit\n        # subtle: The bytes case only executes on python 3, and the\n        # unicode case only executes on python 2, because the other\n        # cases are covered by the first match for str.\n        if isinstance(value, str):\n            retval = value\n        elif isinstance(value, bytes):  # py3\n            # Non-ascii characters in headers are not well supported,\n            # but if you pass bytes, use latin1 so they pass through as-is.\n            retval = value.decode(\"latin1\")\n        elif isinstance(value, unicode_type):  # py2\n            # TODO: This is inconsistent with the use of latin1 above,\n            # but it's been that way for a long time. Should it change?\n            retval = escape.utf8(value)\n        elif isinstance(value, numbers.Integral):\n            # return immediately since we know the converted value will be safe\n            return str(value)\n        elif isinstance(value, datetime.datetime):\n            return httputil.format_timestamp(value)\n        else:\n            raise TypeError(\"Unsupported header value %r\" % value)\n        # If \\n is allowed into the header, it is possible to inject\n        # additional headers or split the request.\n        if RequestHandler._INVALID_HEADER_CHAR_RE.search(retval):\n            raise ValueError(\"Unsafe header value %r\", retval)\n        return retval",
        "begin_line": 389,
        "end_line": 415,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004415011037527594,
            "pseudo_dstar_susp": 0.00047214353163361664,
            "pseudo_tarantula_susp": 0.0004210526315789474,
            "pseudo_op2_susp": 0.00047214353163361664,
            "pseudo_barinel_susp": 0.0004210526315789474
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_argument#433",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_argument(self, name: str, default: Union[None, str, _ArgDefaultMarker]=_ARG_DEFAULT, strip: bool=True)",
        "snippet": "    def get_argument(  # noqa: F811\n        self,\n        name: str,\n        default: Union[None, str, _ArgDefaultMarker] = _ARG_DEFAULT,\n        strip: bool = True,\n    ) -> Optional[str]:\n        \"\"\"Returns the value of the argument with the given name.\n\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n\n        If the argument appears in the url more than once, we return the\n        last value.\n\n        The returned value is always unicode.\n        \"\"\"\n        return self._get_argument(name, default, self.request.arguments, strip)",
        "begin_line": 433,
        "end_line": 449,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048638132295719845,
            "pseudo_dstar_susp": 0.000481000481000481,
            "pseudo_tarantula_susp": 0.000946969696969697,
            "pseudo_op2_susp": 0.000481000481000481,
            "pseudo_barinel_susp": 0.000946969696969697
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_arguments#451",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_arguments(self, name: str, strip: bool=True)",
        "snippet": "    def get_arguments(self, name: str, strip: bool = True) -> List[str]:\n        \"\"\"Returns a list of the arguments with the given name.\n\n        If the argument is not present, returns an empty list.\n\n        The returned values are always unicode.\n        \"\"\"\n\n        # Make sure `get_arguments` isn't accidentally being called with a\n        # positional argument that's assumed to be a default (like in\n        # `get_argument`.)\n        assert isinstance(strip, bool)\n\n        return self._get_arguments(name, self.request.arguments, strip)",
        "begin_line": 451,
        "end_line": 464,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017885888034340904,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_body_argument#466",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_body_argument(self, name: str, default: Union[None, str, _ArgDefaultMarker]=_ARG_DEFAULT, strip: bool=True)",
        "snippet": "    def get_body_argument(\n        self,\n        name: str,\n        default: Union[None, str, _ArgDefaultMarker] = _ARG_DEFAULT,\n        strip: bool = True,\n    ) -> Optional[str]:\n        \"\"\"Returns the value of the argument with the given name\n        from the request body.\n\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n\n        If the argument appears in the url more than once, we return the\n        last value.\n\n        The returned value is always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_argument(name, default, self.request.body_arguments, strip)",
        "begin_line": 466,
        "end_line": 485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_body_arguments#487",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_body_arguments(self, name: str, strip: bool=True)",
        "snippet": "    def get_body_arguments(self, name: str, strip: bool = True) -> List[str]:\n        \"\"\"Returns a list of the body arguments with the given name.\n\n        If the argument is not present, returns an empty list.\n\n        The returned values are always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_arguments(name, self.request.body_arguments, strip)",
        "begin_line": 487,
        "end_line": 496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_query_argument#498",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_query_argument(self, name: str, default: Union[None, str, _ArgDefaultMarker]=_ARG_DEFAULT, strip: bool=True)",
        "snippet": "    def get_query_argument(\n        self,\n        name: str,\n        default: Union[None, str, _ArgDefaultMarker] = _ARG_DEFAULT,\n        strip: bool = True,\n    ) -> Optional[str]:\n        \"\"\"Returns the value of the argument with the given name\n        from the request query string.\n\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n\n        If the argument appears in the url more than once, we return the\n        last value.\n\n        The returned value is always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_argument(name, default, self.request.query_arguments, strip)",
        "begin_line": 498,
        "end_line": 517,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_query_arguments#519",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_query_arguments(self, name: str, strip: bool=True)",
        "snippet": "    def get_query_arguments(self, name: str, strip: bool = True) -> List[str]:\n        \"\"\"Returns a list of the query arguments with the given name.\n\n        If the argument is not present, returns an empty list.\n\n        The returned values are always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_arguments(name, self.request.query_arguments, strip)",
        "begin_line": 519,
        "end_line": 528,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler._get_argument#530",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._get_argument(self, name: str, default: Union[None, str, _ArgDefaultMarker], source: Dict[str, List[bytes]], strip: bool=True)",
        "snippet": "    def _get_argument(\n        self,\n        name: str,\n        default: Union[None, str, _ArgDefaultMarker],\n        source: Dict[str, List[bytes]],\n        strip: bool = True,\n    ) -> Optional[str]:\n        args = self._get_arguments(name, source, strip=strip)\n        if not args:\n            if isinstance(default, _ArgDefaultMarker):\n                raise MissingArgumentError(name)\n            return default\n        return args[-1]",
        "begin_line": 530,
        "end_line": 542,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006485084306095979,
            "pseudo_dstar_susp": 0.0004847309743092584,
            "pseudo_tarantula_susp": 0.0019083969465648854,
            "pseudo_op2_susp": 0.0004847309743092584,
            "pseudo_barinel_susp": 0.0019083969465648854
        }
    },
    {
        "name": "tornado.web.RequestHandler._get_arguments#544",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._get_arguments(self, name: str, source: Dict[str, List[bytes]], strip: bool=True)",
        "snippet": "    def _get_arguments(\n        self, name: str, source: Dict[str, List[bytes]], strip: bool = True\n    ) -> List[str]:\n        values = []\n        for v in source.get(name, []):\n            s = self.decode_argument(v, name=name)\n            if isinstance(s, unicode_type):\n                # Get rid of any weird control chars (unless decoding gave\n                # us bytes, in which case leave it alone)\n                s = RequestHandler._remove_control_chars_regex.sub(\" \", s)\n            if strip:\n                s = s.strip()\n            values.append(s)\n        return values",
        "begin_line": 544,
        "end_line": 557,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005970149253731343,
            "pseudo_dstar_susp": 0.000484027105517909,
            "pseudo_tarantula_susp": 0.0014245014245014246,
            "pseudo_op2_susp": 0.000484027105517909,
            "pseudo_barinel_susp": 0.001422475106685633
        }
    },
    {
        "name": "tornado.web.RequestHandler.decode_argument#559",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.decode_argument(self, value: bytes, name: str=None)",
        "snippet": "    def decode_argument(self, value: bytes, name: str = None) -> str:\n        \"\"\"Decodes an argument from the request.\n\n        The argument has been percent-decoded and is now a byte string.\n        By default, this method decodes the argument as utf-8 and returns\n        a unicode string, but this may be overridden in subclasses.\n\n        This method is used as a filter for both `get_argument()` and for\n        values extracted from the url and passed to `get()`/`post()`/etc.\n\n        The name of the argument is provided if known, but may be None\n        (e.g. for unnamed groups in the url regex).\n        \"\"\"\n        try:\n            return _unicode(value)\n        except UnicodeDecodeError:\n            raise HTTPError(\n                400, \"Invalid unicode in %s: %r\" % (name or \"url\", value[:40])\n            )",
        "begin_line": 559,
        "end_line": 577,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004764173415912339,
            "pseudo_dstar_susp": 0.00047709923664122136,
            "pseudo_tarantula_susp": 0.000691085003455425,
            "pseudo_op2_susp": 0.00047709923664122136,
            "pseudo_barinel_susp": 0.000691085003455425
        }
    },
    {
        "name": "tornado.web.RequestHandler.cookies#580",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.cookies(self)",
        "snippet": "    def cookies(self) -> Dict[str, http.cookies.Morsel]:\n        \"\"\"An alias for\n        `self.request.cookies <.httputil.HTTPServerRequest.cookies>`.\"\"\"\n        return self.request.cookies",
        "begin_line": 580,
        "end_line": 583,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_cookie#585",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_cookie(self, name: str, default: str=None)",
        "snippet": "    def get_cookie(self, name: str, default: str = None) -> Optional[str]:\n        \"\"\"Returns the value of the request cookie with the given name.\n\n        If the named cookie is not present, returns ``default``.\n\n        This method only returns cookies that were present in the request.\n        It does not see the outgoing cookies set by `set_cookie` in this\n        handler.\n        \"\"\"\n        if self.request.cookies is not None and name in self.request.cookies:\n            return self.request.cookies[name].value\n        return default",
        "begin_line": 585,
        "end_line": 596,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016526194017517766,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.set_cookie#598",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.set_cookie(self, name: str, value: Union[str, bytes], domain: str=None, expires: Union[float, Tuple, datetime.datetime]=None, path: str='/', expires_days: int=None, **kwargs: Any)",
        "snippet": "    def set_cookie(\n        self,\n        name: str,\n        value: Union[str, bytes],\n        domain: str = None,\n        expires: Union[float, Tuple, datetime.datetime] = None,\n        path: str = \"/\",\n        expires_days: int = None,\n        **kwargs: Any\n    ) -> None:\n        \"\"\"Sets an outgoing cookie name/value with the given options.\n\n        Newly-set cookies are not immediately visible via `get_cookie`;\n        they are not present until the next request.\n\n        expires may be a numeric timestamp as returned by `time.time`,\n        a time tuple as returned by `time.gmtime`, or a\n        `datetime.datetime` object.\n\n        Additional keyword arguments are set on the cookies.Morsel\n        directly.\n        See https://docs.python.org/3/library/http.cookies.html#http.cookies.Morsel\n        for available attributes.\n        \"\"\"\n        # The cookie library only accepts type str, in both python 2 and 3\n        name = escape.native_str(name)\n        value = escape.native_str(value)\n        if re.search(r\"[\\x00-\\x20]\", name + value):\n            # Don't let us accidentally inject bad stuff\n            raise ValueError(\"Invalid cookie %r: %r\" % (name, value))\n        if not hasattr(self, \"_new_cookie\"):\n            self._new_cookie = http.cookies.SimpleCookie()\n        if name in self._new_cookie:\n            del self._new_cookie[name]\n        self._new_cookie[name] = value\n        morsel = self._new_cookie[name]\n        if domain:\n            morsel[\"domain\"] = domain\n        if expires_days is not None and not expires:\n            expires = datetime.datetime.utcnow() + datetime.timedelta(days=expires_days)\n        if expires:\n            morsel[\"expires\"] = httputil.format_timestamp(expires)\n        if path:\n            morsel[\"path\"] = path\n        for k, v in kwargs.items():\n            if k == \"max_age\":\n                k = \"max-age\"\n\n            # skip falsy values for httponly and secure flags because\n            # SimpleCookie sets them regardless\n            if k in [\"httponly\", \"secure\"] and not v:\n                continue\n\n            morsel[k] = v",
        "begin_line": 598,
        "end_line": 651,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.clear_cookie#653",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.clear_cookie(self, name: str, path: str='/', domain: str=None)",
        "snippet": "    def clear_cookie(self, name: str, path: str = \"/\", domain: str = None) -> None:\n        \"\"\"Deletes the cookie with the given name.\n\n        Due to limitations of the cookie protocol, you must pass the same\n        path and domain to clear a cookie as were used when that cookie\n        was set (but there is no way to find out on the server side\n        which values were used for a given cookie).\n\n        Similar to `set_cookie`, the effect of this method will not be\n        seen until the following request.\n        \"\"\"\n        expires = datetime.datetime.utcnow() - datetime.timedelta(days=365)\n        self.set_cookie(name, value=\"\", path=path, expires=expires, domain=domain)",
        "begin_line": 653,
        "end_line": 665,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.clear_all_cookies#667",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.clear_all_cookies(self, path: str='/', domain: str=None)",
        "snippet": "    def clear_all_cookies(self, path: str = \"/\", domain: str = None) -> None:\n        \"\"\"Deletes all the cookies the user sent with this request.\n\n        See `clear_cookie` for more information on the path and domain\n        parameters.\n\n        Similar to `set_cookie`, the effect of this method will not be\n        seen until the following request.\n\n        .. versionchanged:: 3.2\n\n           Added the ``path`` and ``domain`` parameters.\n        \"\"\"\n        for name in self.request.cookies:\n            self.clear_cookie(name, path=path, domain=domain)",
        "begin_line": 667,
        "end_line": 681,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.set_secure_cookie#683",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.set_secure_cookie(self, name: str, value: Union[str, bytes], expires_days: int=30, version: int=None, **kwargs: Any)",
        "snippet": "    def set_secure_cookie(\n        self,\n        name: str,\n        value: Union[str, bytes],\n        expires_days: int = 30,\n        version: int = None,\n        **kwargs: Any\n    ) -> None:\n        \"\"\"Signs and timestamps a cookie so it cannot be forged.\n\n        You must specify the ``cookie_secret`` setting in your Application\n        to use this method. It should be a long, random sequence of bytes\n        to be used as the HMAC secret for the signature.\n\n        To read a cookie set with this method, use `get_secure_cookie()`.\n\n        Note that the ``expires_days`` parameter sets the lifetime of the\n        cookie in the browser, but is independent of the ``max_age_days``\n        parameter to `get_secure_cookie`.\n\n        Secure cookies may contain arbitrary byte values, not just unicode\n        strings (unlike regular cookies)\n\n        Similar to `set_cookie`, the effect of this method will not be\n        seen until the following request.\n\n        .. versionchanged:: 3.2.1\n\n           Added the ``version`` argument.  Introduced cookie version 2\n           and made it the default.\n        \"\"\"\n        self.set_cookie(\n            name,\n            self.create_signed_value(name, value, version=version),\n            expires_days=expires_days,\n            **kwargs\n        )",
        "begin_line": 683,
        "end_line": 719,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.create_signed_value#721",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.create_signed_value(self, name: str, value: Union[str, bytes], version: int=None)",
        "snippet": "    def create_signed_value(\n        self, name: str, value: Union[str, bytes], version: int = None\n    ) -> bytes:\n        \"\"\"Signs and timestamps a string so it cannot be forged.\n\n        Normally used via set_secure_cookie, but provided as a separate\n        method for non-cookie uses.  To decode a value not stored\n        as a cookie use the optional value argument to get_secure_cookie.\n\n        .. versionchanged:: 3.2.1\n\n           Added the ``version`` argument.  Introduced cookie version 2\n           and made it the default.\n        \"\"\"\n        self.require_setting(\"cookie_secret\", \"secure cookies\")\n        secret = self.application.settings[\"cookie_secret\"]\n        key_version = None\n        if isinstance(secret, dict):\n            if self.application.settings.get(\"key_version\") is None:\n                raise Exception(\"key_version setting must be used for secret_key dicts\")\n            key_version = self.application.settings[\"key_version\"]\n\n        return create_signed_value(\n            secret, name, value, version=version, key_version=key_version\n        )",
        "begin_line": 721,
        "end_line": 745,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_secure_cookie#747",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_secure_cookie(self, name: str, value: str=None, max_age_days: int=31, min_version: int=None)",
        "snippet": "    def get_secure_cookie(\n        self,\n        name: str,\n        value: str = None,\n        max_age_days: int = 31,\n        min_version: int = None,\n    ) -> Optional[bytes]:\n        \"\"\"Returns the given signed cookie if it validates, or None.\n\n        The decoded cookie value is returned as a byte string (unlike\n        `get_cookie`).\n\n        Similar to `get_cookie`, this method only returns cookies that\n        were present in the request. It does not see outgoing cookies set by\n        `set_secure_cookie` in this handler.\n\n        .. versionchanged:: 3.2.1\n\n           Added the ``min_version`` argument.  Introduced cookie version 2;\n           both versions 1 and 2 are accepted by default.\n        \"\"\"\n        self.require_setting(\"cookie_secret\", \"secure cookies\")\n        if value is None:\n            value = self.get_cookie(name)\n        return decode_signed_value(\n            self.application.settings[\"cookie_secret\"],\n            name,\n            value,\n            max_age_days=max_age_days,\n            min_version=min_version,\n        )",
        "begin_line": 747,
        "end_line": 777,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018135654697134566,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.redirect#793",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.redirect(self, url: str, permanent: bool=False, status: int=None)",
        "snippet": "    def redirect(self, url: str, permanent: bool = False, status: int = None) -> None:\n        \"\"\"Sends a redirect to the given (optionally relative) URL.\n\n        If the ``status`` argument is specified, that value is used as the\n        HTTP status code; otherwise either 301 (permanent) or 302\n        (temporary) is chosen based on the ``permanent`` argument.\n        The default is 302 (temporary).\n        \"\"\"\n        if self._headers_written:\n            raise Exception(\"Cannot redirect after headers have been written\")\n        if status is None:\n            status = 301 if permanent else 302\n        else:\n            assert isinstance(status, int) and 300 <= status <= 399\n        self.set_status(status)\n        self.set_header(\"Location\", utf8(url))\n        self.finish()",
        "begin_line": 793,
        "end_line": 809,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.write#811",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.write(self, chunk: Union[str, bytes, dict])",
        "snippet": "    def write(self, chunk: Union[str, bytes, dict]) -> None:\n        \"\"\"Writes the given chunk to the output buffer.\n\n        To write the output to the network, use the flush() method below.\n\n        If the given chunk is a dictionary, we write it as JSON and set\n        the Content-Type of the response to be ``application/json``.\n        (if you want to send JSON as a different ``Content-Type``, call\n        set_header *after* calling write()).\n\n        Note that lists are not converted to JSON because of a potential\n        cross-site security vulnerability.  All JSON output should be\n        wrapped in a dictionary.  More details at\n        http://haacked.com/archive/2009/06/25/json-hijacking.aspx/ and\n        https://github.com/facebook/tornado/issues/1009\n        \"\"\"\n        if self._finished:\n            raise RuntimeError(\"Cannot write() after finish()\")\n        if not isinstance(chunk, (bytes, unicode_type, dict)):\n            message = \"write() only accepts bytes, unicode, and dict objects\"\n            if isinstance(chunk, list):\n                message += (\n                    \". Lists not accepted for security reasons; see \"\n                    + \"http://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.write\"  # noqa: E501\n                )\n            raise TypeError(message)\n        if isinstance(chunk, dict):\n            chunk = escape.json_encode(chunk)\n            self.set_header(\"Content-Type\", \"application/json; charset=UTF-8\")\n        chunk = utf8(chunk)\n        self._write_buffer.append(chunk)",
        "begin_line": 811,
        "end_line": 841,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000444247001332741,
            "pseudo_dstar_susp": 0.0004743833017077799,
            "pseudo_tarantula_susp": 0.000423908435777872,
            "pseudo_op2_susp": 0.0004743833017077799,
            "pseudo_barinel_susp": 0.000423908435777872
        }
    },
    {
        "name": "tornado.web.RequestHandler.render#843",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.render(self, template_name: str, **kwargs: Any)",
        "snippet": "    def render(self, template_name: str, **kwargs: Any) -> \"Future[None]\":\n        \"\"\"Renders the template with the given arguments as the response.\n\n        ``render()`` calls ``finish()``, so no other output methods can be called\n        after it.\n\n        Returns a `.Future` with the same semantics as the one returned by `finish`.\n        Awaiting this `.Future` is optional.\n\n        .. versionchanged:: 5.1\n\n           Now returns a `.Future` instead of ``None``.\n        \"\"\"\n        if self._finished:\n            raise RuntimeError(\"Cannot render() after finish()\")\n        html = self.render_string(template_name, **kwargs)\n\n        # Insert the additional JS and CSS added by the modules on the page\n        js_embed = []\n        js_files = []\n        css_embed = []\n        css_files = []\n        html_heads = []\n        html_bodies = []\n        for module in getattr(self, \"_active_modules\", {}).values():\n            embed_part = module.embedded_javascript()\n            if embed_part:\n                js_embed.append(utf8(embed_part))\n            file_part = module.javascript_files()\n            if file_part:\n                if isinstance(file_part, (unicode_type, bytes)):\n                    js_files.append(_unicode(file_part))\n                else:\n                    js_files.extend(file_part)\n            embed_part = module.embedded_css()\n            if embed_part:\n                css_embed.append(utf8(embed_part))\n            file_part = module.css_files()\n            if file_part:\n                if isinstance(file_part, (unicode_type, bytes)):\n                    css_files.append(_unicode(file_part))\n                else:\n                    css_files.extend(file_part)\n            head_part = module.html_head()\n            if head_part:\n                html_heads.append(utf8(head_part))\n            body_part = module.html_body()\n            if body_part:\n                html_bodies.append(utf8(body_part))\n\n        if js_files:\n            # Maintain order of JavaScript files given by modules\n            js = self.render_linked_js(js_files)\n            sloc = html.rindex(b\"</body>\")\n            html = html[:sloc] + utf8(js) + b\"\\n\" + html[sloc:]\n        if js_embed:\n            js_bytes = self.render_embed_js(js_embed)\n            sloc = html.rindex(b\"</body>\")\n            html = html[:sloc] + js_bytes + b\"\\n\" + html[sloc:]\n        if css_files:\n            css = self.render_linked_css(css_files)\n            hloc = html.index(b\"</head>\")\n            html = html[:hloc] + utf8(css) + b\"\\n\" + html[hloc:]\n        if css_embed:\n            css_bytes = self.render_embed_css(css_embed)\n            hloc = html.index(b\"</head>\")\n            html = html[:hloc] + css_bytes + b\"\\n\" + html[hloc:]\n        if html_heads:\n            hloc = html.index(b\"</head>\")\n            html = html[:hloc] + b\"\".join(html_heads) + b\"\\n\" + html[hloc:]\n        if html_bodies:\n            hloc = html.index(b\"</body>\")\n            html = html[:hloc] + b\"\".join(html_bodies) + b\"\\n\" + html[hloc:]\n        return self.finish(html)",
        "begin_line": 843,
        "end_line": 916,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.render_linked_js#918",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.render_linked_js(self, js_files: Iterable[str])",
        "snippet": "    def render_linked_js(self, js_files: Iterable[str]) -> str:\n        \"\"\"Default method used to render the final js links for the\n        rendered webpage.\n\n        Override this method in a sub-classed controller to change the output.\n        \"\"\"\n        paths = []\n        unique_paths = set()  # type: Set[str]\n\n        for path in js_files:\n            if not is_absolute(path):\n                path = self.static_url(path)\n            if path not in unique_paths:\n                paths.append(path)\n                unique_paths.add(path)\n\n        return \"\".join(\n            '<script src=\"'\n            + escape.xhtml_escape(p)\n            + '\" type=\"text/javascript\"></script>'\n            for p in paths\n        )",
        "begin_line": 918,
        "end_line": 939,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.render_embed_js#941",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.render_embed_js(self, js_embed: Iterable[bytes])",
        "snippet": "    def render_embed_js(self, js_embed: Iterable[bytes]) -> bytes:\n        \"\"\"Default method used to render the final embedded js for the\n        rendered webpage.\n\n        Override this method in a sub-classed controller to change the output.\n        \"\"\"\n        return (\n            b'<script type=\"text/javascript\">\\n//<![CDATA[\\n'\n            + b\"\\n\".join(js_embed)\n            + b\"\\n//]]>\\n</script>\"\n        )",
        "begin_line": 941,
        "end_line": 951,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.render_linked_css#953",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.render_linked_css(self, css_files: Iterable[str])",
        "snippet": "    def render_linked_css(self, css_files: Iterable[str]) -> str:\n        \"\"\"Default method used to render the final css links for the\n        rendered webpage.\n\n        Override this method in a sub-classed controller to change the output.\n        \"\"\"\n        paths = []\n        unique_paths = set()  # type: Set[str]\n\n        for path in css_files:\n            if not is_absolute(path):\n                path = self.static_url(path)\n            if path not in unique_paths:\n                paths.append(path)\n                unique_paths.add(path)\n\n        return \"\".join(\n            '<link href=\"' + escape.xhtml_escape(p) + '\" '\n            'type=\"text/css\" rel=\"stylesheet\"/>'\n            for p in paths\n        )",
        "begin_line": 953,
        "end_line": 973,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.render_embed_css#975",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.render_embed_css(self, css_embed: Iterable[bytes])",
        "snippet": "    def render_embed_css(self, css_embed: Iterable[bytes]) -> bytes:\n        \"\"\"Default method used to render the final embedded css for the\n        rendered webpage.\n\n        Override this method in a sub-classed controller to change the output.\n        \"\"\"\n        return b'<style type=\"text/css\">\\n' + b\"\\n\".join(css_embed) + b\"\\n</style>\"",
        "begin_line": 975,
        "end_line": 981,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.render_string#983",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.render_string(self, template_name: str, **kwargs: Any)",
        "snippet": "    def render_string(self, template_name: str, **kwargs: Any) -> bytes:\n        \"\"\"Generate the given template with the given arguments.\n\n        We return the generated byte string (in utf8). To generate and\n        write a template as a response, use render() above.\n        \"\"\"\n        # If no template_path is specified, use the path of the calling file\n        template_path = self.get_template_path()\n        if not template_path:\n            frame = sys._getframe(0)\n            web_file = frame.f_code.co_filename\n            while frame.f_code.co_filename == web_file:\n                frame = frame.f_back\n            assert frame.f_code.co_filename is not None\n            template_path = os.path.dirname(frame.f_code.co_filename)\n        with RequestHandler._template_loader_lock:\n            if template_path not in RequestHandler._template_loaders:\n                loader = self.create_template_loader(template_path)\n                RequestHandler._template_loaders[template_path] = loader\n            else:\n                loader = RequestHandler._template_loaders[template_path]\n        t = loader.load(template_name)\n        namespace = self.get_template_namespace()\n        namespace.update(kwargs)\n        return t.generate(**namespace)",
        "begin_line": 983,
        "end_line": 1007,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_template_namespace#1009",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_template_namespace(self)",
        "snippet": "    def get_template_namespace(self) -> Dict[str, Any]:\n        \"\"\"Returns a dictionary to be used as the default template namespace.\n\n        May be overridden by subclasses to add or modify values.\n\n        The results of this method will be combined with additional\n        defaults in the `tornado.template` module and keyword arguments\n        to `render` or `render_string`.\n        \"\"\"\n        namespace = dict(\n            handler=self,\n            request=self.request,\n            current_user=self.current_user,\n            locale=self.locale,\n            _=self.locale.translate,\n            pgettext=self.locale.pgettext,\n            static_url=self.static_url,\n            xsrf_form_html=self.xsrf_form_html,\n            reverse_url=self.reverse_url,\n        )\n        namespace.update(self.ui)\n        return namespace",
        "begin_line": 1009,
        "end_line": 1030,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019334880123743234,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.create_template_loader#1032",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.create_template_loader(self, template_path: str)",
        "snippet": "    def create_template_loader(self, template_path: str) -> template.BaseLoader:\n        \"\"\"Returns a new template loader for the given path.\n\n        May be overridden by subclasses.  By default returns a\n        directory-based loader on the given path, using the\n        ``autoescape`` and ``template_whitespace`` application\n        settings.  If a ``template_loader`` application setting is\n        supplied, uses that instead.\n        \"\"\"\n        settings = self.application.settings\n        if \"template_loader\" in settings:\n            return settings[\"template_loader\"]\n        kwargs = {}\n        if \"autoescape\" in settings:\n            # autoescape=None means \"no escaping\", so we have to be sure\n            # to only pass this kwarg if the user asked for it.\n            kwargs[\"autoescape\"] = settings[\"autoescape\"]\n        if \"template_whitespace\" in settings:\n            kwargs[\"whitespace\"] = settings[\"template_whitespace\"]\n        return template.Loader(template_path, **kwargs)",
        "begin_line": 1032,
        "end_line": 1051,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001892863903085368,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.flush#1053",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.flush(self, include_footers: bool=False)",
        "snippet": "    def flush(self, include_footers: bool = False) -> \"Future[None]\":\n        \"\"\"Flushes the current output buffer to the network.\n\n        The ``callback`` argument, if given, can be used for flow control:\n        it will be run when all flushed data has been written to the socket.\n        Note that only one flush callback can be outstanding at a time;\n        if another flush occurs before the previous flush's callback\n        has been run, the previous callback will be discarded.\n\n        .. versionchanged:: 4.0\n           Now returns a `.Future` if no callback is given.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed.\n        \"\"\"\n        assert self.request.connection is not None\n        chunk = b\"\".join(self._write_buffer)\n        self._write_buffer = []\n        if not self._headers_written:\n            self._headers_written = True\n            for transform in self._transforms:\n                assert chunk is not None\n                self._status_code, self._headers, chunk = transform.transform_first_chunk(\n                    self._status_code, self._headers, chunk, include_footers\n                )\n            # Ignore the chunk and only write the headers for HEAD requests\n            if self.request.method == \"HEAD\":\n                chunk = b\"\"\n\n            # Finalize the cookie headers (which have been stored in a side\n            # object so an outgoing cookie could be overwritten before it\n            # is sent).\n            if hasattr(self, \"_new_cookie\"):\n                for cookie in self._new_cookie.values():\n                    self.add_header(\"Set-Cookie\", cookie.OutputString(None))\n\n            start_line = httputil.ResponseStartLine(\"\", self._status_code, self._reason)\n            return self.request.connection.write_headers(\n                start_line, self._headers, chunk\n            )\n        else:\n            for transform in self._transforms:\n                chunk = transform.transform_chunk(chunk, include_footers)\n            # Ignore the chunk and only write the headers for HEAD requests\n            if self.request.method != \"HEAD\":\n                return self.request.connection.write(chunk)\n            else:\n                future = Future()  # type: Future[None]\n                future.set_result(None)\n                return future",
        "begin_line": 1053,
        "end_line": 1103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043122035360068997,
            "pseudo_dstar_susp": 0.0004631773969430292,
            "pseudo_tarantula_susp": 0.0004127115146512588,
            "pseudo_op2_susp": 0.0004631773969430292,
            "pseudo_barinel_susp": 0.0004127115146512588
        }
    },
    {
        "name": "tornado.web.RequestHandler.finish#1105",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.finish(self, chunk: Union[str, bytes, dict]=None)",
        "snippet": "    def finish(self, chunk: Union[str, bytes, dict] = None) -> \"Future[None]\":\n        \"\"\"Finishes this response, ending the HTTP request.\n\n        Passing a ``chunk`` to ``finish()`` is equivalent to passing that\n        chunk to ``write()`` and then calling ``finish()`` with no arguments.\n\n        Returns a `.Future` which may optionally be awaited to track the sending\n        of the response to the client. This `.Future` resolves when all the response\n        data has been sent, and raises an error if the connection is closed before all\n        data can be sent.\n\n        .. versionchanged:: 5.1\n\n           Now returns a `.Future` instead of ``None``.\n        \"\"\"\n        if self._finished:\n            raise RuntimeError(\"finish() called twice\")\n\n        if chunk is not None:\n            self.write(chunk)\n\n        # Automatically support ETags and add the Content-Length header if\n        # we have not flushed any content yet.\n        if not self._headers_written:\n            if (\n                self._status_code == 200\n                and self.request.method in (\"GET\", \"HEAD\")\n                and \"Etag\" not in self._headers\n            ):\n                self.set_etag_header()\n                if self.check_etag_header():\n                    self._write_buffer = []\n                    self.set_status(304)\n            if self._status_code in (204, 304) or (\n                self._status_code >= 100 and self._status_code < 200\n            ):\n                assert not self._write_buffer, (\n                    \"Cannot send body with %s\" % self._status_code\n                )\n                self._clear_headers_for_304()\n            elif \"Content-Length\" not in self._headers:\n                content_length = sum(len(part) for part in self._write_buffer)\n                self.set_header(\"Content-Length\", content_length)\n\n        assert self.request.connection is not None\n        # Now that the request is finished, clear the callback we\n        # set on the HTTPConnection (which would otherwise prevent the\n        # garbage collection of the RequestHandler when there\n        # are keepalive connections)\n        self.request.connection.set_close_callback(None)  # type: ignore\n\n        future = self.flush(include_footers=True)\n        self.request.connection.finish()\n        self._log()\n        self._finished = True\n        self.on_finish()\n        self._break_cycles()\n        return future",
        "begin_line": 1105,
        "end_line": 1162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004633920296570899,
            "pseudo_dstar_susp": 0.0005350454788657035,
            "pseudo_tarantula_susp": 0.000429000429000429,
            "pseudo_op2_susp": 0.0005350454788657035,
            "pseudo_barinel_susp": 0.000429000429000429
        }
    },
    {
        "name": "tornado.web.RequestHandler.detach#1164",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.detach(self)",
        "snippet": "    def detach(self) -> iostream.IOStream:\n        \"\"\"Take control of the underlying stream.\n\n        Returns the underlying `.IOStream` object and stops all\n        further HTTP processing. Intended for implementing protocols\n        like websockets that tunnel over an HTTP handshake.\n\n        This method is only supported when HTTP/1.1 is used.\n\n        .. versionadded:: 5.1\n        \"\"\"\n        self._finished = True\n        # TODO: add detach to HTTPConnection?\n        return self.request.connection.detach()  # type: ignore",
        "begin_line": 1164,
        "end_line": 1177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00047036688617121356,
            "pseudo_dstar_susp": 0.00043840420868040335,
            "pseudo_tarantula_susp": 0.0011185682326621924,
            "pseudo_op2_susp": 0.00043840420868040335,
            "pseudo_barinel_susp": 0.0011185682326621924
        }
    },
    {
        "name": "tornado.web.RequestHandler._break_cycles#1179",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._break_cycles(self)",
        "snippet": "    def _break_cycles(self) -> None:\n        # Break up a reference cycle between this handler and the\n        # _ui_module closures to allow for faster GC on CPython.\n        self.ui = None  # type: ignore",
        "begin_line": 1179,
        "end_line": 1182,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043591979075850045,
            "pseudo_dstar_susp": 0.000468384074941452,
            "pseudo_tarantula_susp": 0.00041684035014589413,
            "pseudo_op2_susp": 0.000468384074941452,
            "pseudo_barinel_susp": 0.00041684035014589413
        }
    },
    {
        "name": "tornado.web.RequestHandler.send_error#1184",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.send_error(self, status_code: int=500, **kwargs: Any)",
        "snippet": "    def send_error(self, status_code: int = 500, **kwargs: Any) -> None:\n        \"\"\"Sends the given HTTP error code to the browser.\n\n        If `flush()` has already been called, it is not possible to send\n        an error, so this method will simply terminate the response.\n        If output has been written but not yet flushed, it will be discarded\n        and replaced with the error page.\n\n        Override `write_error()` to customize the error page that is returned.\n        Additional keyword arguments are passed through to `write_error`.\n        \"\"\"\n        if self._headers_written:\n            gen_log.error(\"Cannot send error response after headers written\")\n            if not self._finished:\n                # If we get an error between writing headers and finishing,\n                # we are unlikely to be able to finish due to a\n                # Content-Length mismatch. Try anyway to release the\n                # socket.\n                try:\n                    self.finish()\n                except Exception:\n                    gen_log.error(\"Failed to flush partial response\", exc_info=True)\n            return\n        self.clear()\n\n        reason = kwargs.get(\"reason\")\n        if \"exc_info\" in kwargs:\n            exception = kwargs[\"exc_info\"][1]\n            if isinstance(exception, HTTPError) and exception.reason:\n                reason = exception.reason\n        self.set_status(status_code, reason=reason)\n        try:\n            self.write_error(status_code, **kwargs)\n        except Exception:\n            app_log.error(\"Uncaught exception in write_error\", exc_info=True)\n        if not self._finished:\n            self.finish()",
        "begin_line": 1184,
        "end_line": 1220,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.write_error#1222",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.write_error(self, status_code: int, **kwargs: Any)",
        "snippet": "    def write_error(self, status_code: int, **kwargs: Any) -> None:\n        \"\"\"Override to implement custom error pages.\n\n        ``write_error`` may call `write`, `render`, `set_header`, etc\n        to produce output as usual.\n\n        If this error was caused by an uncaught exception (including\n        HTTPError), an ``exc_info`` triple will be available as\n        ``kwargs[\"exc_info\"]``.  Note that this exception may not be\n        the \"current\" exception for purposes of methods like\n        ``sys.exc_info()`` or ``traceback.format_exc``.\n        \"\"\"\n        if self.settings.get(\"serve_traceback\") and \"exc_info\" in kwargs:\n            # in debug mode, try to send a traceback\n            self.set_header(\"Content-Type\", \"text/plain\")\n            for line in traceback.format_exception(*kwargs[\"exc_info\"]):\n                self.write(line)\n            self.finish()\n        else:\n            self.finish(\n                \"<html><title>%(code)d: %(message)s</title>\"\n                \"<body>%(code)d: %(message)s</body></html>\"\n                % {\"code\": status_code, \"message\": self._reason}\n            )",
        "begin_line": 1222,
        "end_line": 1245,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014654161781946072,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.locale#1248",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.locale(self)",
        "snippet": "    def locale(self) -> tornado.locale.Locale:\n        \"\"\"The locale for the current session.\n\n        Determined by either `get_user_locale`, which you can override to\n        set the locale based on, e.g., a user preference stored in a\n        database, or `get_browser_locale`, which uses the ``Accept-Language``\n        header.\n\n        .. versionchanged: 4.1\n           Added a property setter.\n        \"\"\"\n        if not hasattr(self, \"_locale\"):\n            loc = self.get_user_locale()\n            if loc is not None:\n                self._locale = loc\n            else:\n                self._locale = self.get_browser_locale()\n                assert self._locale\n        return self._locale",
        "begin_line": 1248,
        "end_line": 1266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.locale#1269",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.locale(self, value: tornado.locale.Locale)",
        "snippet": "    def locale(self, value: tornado.locale.Locale) -> None:\n        self._locale = value",
        "begin_line": 1269,
        "end_line": 1270,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_user_locale#1272",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_user_locale(self)",
        "snippet": "    def get_user_locale(self) -> Optional[tornado.locale.Locale]:\n        \"\"\"Override to determine the locale from the authenticated user.\n\n        If None is returned, we fall back to `get_browser_locale()`.\n\n        This method should return a `tornado.locale.Locale` object,\n        most likely obtained via a call like ``tornado.locale.get(\"en\")``\n        \"\"\"\n        return None",
        "begin_line": 1272,
        "end_line": 1280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_browser_locale#1282",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_browser_locale(self, default: str='en_US')",
        "snippet": "    def get_browser_locale(self, default: str = \"en_US\") -> tornado.locale.Locale:\n        \"\"\"Determines the user's locale from ``Accept-Language`` header.\n\n        See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4\n        \"\"\"\n        if \"Accept-Language\" in self.request.headers:\n            languages = self.request.headers[\"Accept-Language\"].split(\",\")\n            locales = []\n            for language in languages:\n                parts = language.strip().split(\";\")\n                if len(parts) > 1 and parts[1].startswith(\"q=\"):\n                    try:\n                        score = float(parts[1][2:])\n                    except (ValueError, TypeError):\n                        score = 0.0\n                else:\n                    score = 1.0\n                locales.append((parts[0], score))\n            if locales:\n                locales.sort(key=lambda pair: pair[1], reverse=True)\n                codes = [l[0] for l in locales]\n                return locale.get(*codes)\n        return locale.get(default)",
        "begin_line": 1282,
        "end_line": 1304,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.current_user#1307",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.current_user(self)",
        "snippet": "    def current_user(self) -> Any:\n        \"\"\"The authenticated user for this request.\n\n        This is set in one of two ways:\n\n        * A subclass may override `get_current_user()`, which will be called\n          automatically the first time ``self.current_user`` is accessed.\n          `get_current_user()` will only be called once per request,\n          and is cached for future access::\n\n              def get_current_user(self):\n                  user_cookie = self.get_secure_cookie(\"user\")\n                  if user_cookie:\n                      return json.loads(user_cookie)\n                  return None\n\n        * It may be set as a normal variable, typically from an overridden\n          `prepare()`::\n\n              @gen.coroutine\n              def prepare(self):\n                  user_id_cookie = self.get_secure_cookie(\"user_id\")\n                  if user_id_cookie:\n                      self.current_user = yield load_user(user_id_cookie)\n\n        Note that `prepare()` may be a coroutine while `get_current_user()`\n        may not, so the latter form is necessary if loading the user requires\n        asynchronous operations.\n\n        The user object may be any type of the application's choosing.\n        \"\"\"\n        if not hasattr(self, \"_current_user\"):\n            self._current_user = self.get_current_user()\n        return self._current_user",
        "begin_line": 1307,
        "end_line": 1340,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016144656118824668,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.current_user#1343",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.current_user(self, value: Any)",
        "snippet": "    def current_user(self, value: Any) -> None:\n        self._current_user = value",
        "begin_line": 1343,
        "end_line": 1344,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_current_user#1346",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_current_user(self)",
        "snippet": "    def get_current_user(self) -> Any:\n        \"\"\"Override to determine the current user from, e.g., a cookie.\n\n        This method may not be a coroutine.\n        \"\"\"\n        return None",
        "begin_line": 1346,
        "end_line": 1351,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016220600162206002,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_template_path#1361",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_template_path(self)",
        "snippet": "    def get_template_path(self) -> Optional[str]:\n        \"\"\"Override to customize template path for each handler.\n\n        By default, we use the ``template_path`` application setting.\n        Return None to load templates relative to the calling file.\n        \"\"\"\n        return self.application.settings.get(\"template_path\")",
        "begin_line": 1361,
        "end_line": 1367,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.xsrf_token#1370",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.xsrf_token(self)",
        "snippet": "    def xsrf_token(self) -> bytes:\n        \"\"\"The XSRF-prevention token for the current user/session.\n\n        To prevent cross-site request forgery, we set an '_xsrf' cookie\n        and include the same '_xsrf' value as an argument with all POST\n        requests. If the two do not match, we reject the form submission\n        as a potential forgery.\n\n        See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n\n        This property is of type `bytes`, but it contains only ASCII\n        characters. If a character string is required, there is no\n        need to base64-encode it; just decode the byte string as\n        UTF-8.\n\n        .. versionchanged:: 3.2.2\n           The xsrf token will now be have a random mask applied in every\n           request, which makes it safe to include the token in pages\n           that are compressed.  See http://breachattack.com for more\n           information on the issue fixed by this change.  Old (version 1)\n           cookies will be converted to version 2 when this method is called\n           unless the ``xsrf_cookie_version`` `Application` setting is\n           set to 1.\n\n        .. versionchanged:: 4.3\n           The ``xsrf_cookie_kwargs`` `Application` setting may be\n           used to supply additional cookie options (which will be\n           passed directly to `set_cookie`). For example,\n           ``xsrf_cookie_kwargs=dict(httponly=True, secure=True)``\n           will set the ``secure`` and ``httponly`` flags on the\n           ``_xsrf`` cookie.\n        \"\"\"\n        if not hasattr(self, \"_xsrf_token\"):\n            version, token, timestamp = self._get_raw_xsrf_token()\n            output_version = self.settings.get(\"xsrf_cookie_version\", 2)\n            cookie_kwargs = self.settings.get(\"xsrf_cookie_kwargs\", {})\n            if output_version == 1:\n                self._xsrf_token = binascii.b2a_hex(token)\n            elif output_version == 2:\n                mask = os.urandom(4)\n                self._xsrf_token = b\"|\".join(\n                    [\n                        b\"2\",\n                        binascii.b2a_hex(mask),\n                        binascii.b2a_hex(_websocket_mask(mask, token)),\n                        utf8(str(int(timestamp))),\n                    ]\n                )\n            else:\n                raise ValueError(\"unknown xsrf cookie version %d\", output_version)\n            if version is None:\n                if self.current_user and \"expires_days\" not in cookie_kwargs:\n                    cookie_kwargs[\"expires_days\"] = 30\n                self.set_cookie(\"_xsrf\", self._xsrf_token, **cookie_kwargs)\n        return self._xsrf_token",
        "begin_line": 1370,
        "end_line": 1424,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler._get_raw_xsrf_token#1426",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._get_raw_xsrf_token(self)",
        "snippet": "    def _get_raw_xsrf_token(self) -> Tuple[Optional[int], bytes, float]:\n        \"\"\"Read or generate the xsrf token in its raw form.\n\n        The raw_xsrf_token is a tuple containing:\n\n        * version: the version of the cookie from which this token was read,\n          or None if we generated a new token in this request.\n        * token: the raw token data; random (non-ascii) bytes.\n        * timestamp: the time this token was generated (will not be accurate\n          for version 1 cookies)\n        \"\"\"\n        if not hasattr(self, \"_raw_xsrf_token\"):\n            cookie = self.get_cookie(\"_xsrf\")\n            if cookie:\n                version, token, timestamp = self._decode_xsrf_token(cookie)\n            else:\n                version, token, timestamp = None, None, None\n            if token is None:\n                version = None\n                token = os.urandom(16)\n                timestamp = time.time()\n            assert token is not None\n            assert timestamp is not None\n            self._raw_xsrf_token = (version, token, timestamp)\n        return self._raw_xsrf_token",
        "begin_line": 1426,
        "end_line": 1450,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017885888034340904,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler._decode_xsrf_token#1452",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._decode_xsrf_token(self, cookie: str)",
        "snippet": "    def _decode_xsrf_token(\n        self, cookie: str\n    ) -> Tuple[Optional[int], Optional[bytes], Optional[float]]:\n        \"\"\"Convert a cookie string into a the tuple form returned by\n        _get_raw_xsrf_token.\n        \"\"\"\n\n        try:\n            m = _signed_value_version_re.match(utf8(cookie))\n\n            if m:\n                version = int(m.group(1))\n                if version == 2:\n                    _, mask_str, masked_token, timestamp_str = cookie.split(\"|\")\n\n                    mask = binascii.a2b_hex(utf8(mask_str))\n                    token = _websocket_mask(mask, binascii.a2b_hex(utf8(masked_token)))\n                    timestamp = int(timestamp_str)\n                    return version, token, timestamp\n                else:\n                    # Treat unknown versions as not present instead of failing.\n                    raise Exception(\"Unknown xsrf cookie version\")\n            else:\n                version = 1\n                try:\n                    token = binascii.a2b_hex(utf8(cookie))\n                except (binascii.Error, TypeError):\n                    token = utf8(cookie)\n                # We don't have a usable timestamp in older versions.\n                timestamp = int(time.time())\n                return (version, token, timestamp)\n        except Exception:\n            # Catch exceptions and return nothing instead of failing.\n            gen_log.debug(\"Uncaught exception in _decode_xsrf_token\", exc_info=True)\n            return None, None, None",
        "begin_line": 1452,
        "end_line": 1486,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.check_xsrf_cookie#1488",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.check_xsrf_cookie(self)",
        "snippet": "    def check_xsrf_cookie(self) -> None:\n        \"\"\"Verifies that the ``_xsrf`` cookie matches the ``_xsrf`` argument.\n\n        To prevent cross-site request forgery, we set an ``_xsrf``\n        cookie and include the same value as a non-cookie\n        field with all ``POST`` requests. If the two do not match, we\n        reject the form submission as a potential forgery.\n\n        The ``_xsrf`` value may be set as either a form field named ``_xsrf``\n        or in a custom HTTP header named ``X-XSRFToken`` or ``X-CSRFToken``\n        (the latter is accepted for compatibility with Django).\n\n        See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n\n        Prior to release 1.1.1, this check was ignored if the HTTP header\n        ``X-Requested-With: XMLHTTPRequest`` was present.  This exception\n        has been shown to be insecure and has been removed.  For more\n        information please see\n        http://www.djangoproject.com/weblog/2011/feb/08/security/\n        http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails\n\n        .. versionchanged:: 3.2.2\n           Added support for cookie version 2.  Both versions 1 and 2 are\n           supported.\n        \"\"\"\n        token = (\n            self.get_argument(\"_xsrf\", None)\n            or self.request.headers.get(\"X-Xsrftoken\")\n            or self.request.headers.get(\"X-Csrftoken\")\n        )\n        if not token:\n            raise HTTPError(403, \"'_xsrf' argument missing from POST\")\n        _, token, _ = self._decode_xsrf_token(token)\n        _, expected_token, _ = self._get_raw_xsrf_token()\n        if not token:\n            raise HTTPError(403, \"'_xsrf' argument has invalid format\")\n        if not hmac.compare_digest(utf8(token), utf8(expected_token)):\n            raise HTTPError(403, \"XSRF cookie does not match POST argument\")",
        "begin_line": 1488,
        "end_line": 1525,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.xsrf_form_html#1527",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.xsrf_form_html(self)",
        "snippet": "    def xsrf_form_html(self) -> str:\n        \"\"\"An HTML ``<input/>`` element to be included with all POST forms.\n\n        It defines the ``_xsrf`` input value, which we check on all POST\n        requests to prevent cross-site request forgery. If you have set\n        the ``xsrf_cookies`` application setting, you must include this\n        HTML within all of your HTML forms.\n\n        In a template, this method should be called with ``{% module\n        xsrf_form_html() %}``\n\n        See `check_xsrf_cookie()` above for more information.\n        \"\"\"\n        return (\n            '<input type=\"hidden\" name=\"_xsrf\" value=\"'\n            + escape.xhtml_escape(self.xsrf_token)\n            + '\"/>'\n        )",
        "begin_line": 1527,
        "end_line": 1544,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.static_url#1546",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.static_url(self, path: str, include_host: bool=None, **kwargs: Any)",
        "snippet": "    def static_url(self, path: str, include_host: bool = None, **kwargs: Any) -> str:\n        \"\"\"Returns a static URL for the given relative static file path.\n\n        This method requires you set the ``static_path`` setting in your\n        application (which specifies the root directory of your static\n        files).\n\n        This method returns a versioned url (by default appending\n        ``?v=<signature>``), which allows the static files to be\n        cached indefinitely.  This can be disabled by passing\n        ``include_version=False`` (in the default implementation;\n        other static file implementations are not required to support\n        this, but they may support other options).\n\n        By default this method returns URLs relative to the current\n        host, but if ``include_host`` is true the URL returned will be\n        absolute.  If this handler has an ``include_host`` attribute,\n        that value will be used as the default for all `static_url`\n        calls that do not pass ``include_host`` as a keyword argument.\n\n        \"\"\"\n        self.require_setting(\"static_path\", \"static_url\")\n        get_url = self.settings.get(\n            \"static_handler_class\", StaticFileHandler\n        ).make_static_url\n\n        if include_host is None:\n            include_host = getattr(self, \"include_host\", False)\n\n        if include_host:\n            base = self.request.protocol + \"://\" + self.request.host\n        else:\n            base = \"\"\n\n        return base + get_url(self.settings, path, **kwargs)",
        "begin_line": 1546,
        "end_line": 1580,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.require_setting#1582",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.require_setting(self, name: str, feature: str='this feature')",
        "snippet": "    def require_setting(self, name: str, feature: str = \"this feature\") -> None:\n        \"\"\"Raises an exception if the given app setting is not defined.\"\"\"\n        if not self.application.settings.get(name):\n            raise Exception(\n                \"You must define the '%s' setting in your \"\n                \"application to use %s\" % (name, feature)\n            )",
        "begin_line": 1582,
        "end_line": 1588,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001633453119895459,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.reverse_url#1590",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.reverse_url(self, name: str, *args: Any)",
        "snippet": "    def reverse_url(self, name: str, *args: Any) -> str:\n        \"\"\"Alias for `Application.reverse_url`.\"\"\"\n        return self.application.reverse_url(name, *args)",
        "begin_line": 1590,
        "end_line": 1592,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017885888034340904,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.compute_etag#1594",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.compute_etag(self)",
        "snippet": "    def compute_etag(self) -> Optional[str]:\n        \"\"\"Computes the etag header to be used for this request.\n\n        By default uses a hash of the content written so far.\n\n        May be overridden to provide custom etag implementations,\n        or may return None to disable tornado's default etag support.\n        \"\"\"\n        hasher = hashlib.sha1()\n        for part in self._write_buffer:\n            hasher.update(part)\n        return '\"%s\"' % hasher.hexdigest()",
        "begin_line": 1594,
        "end_line": 1605,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004426737494466578,
            "pseudo_dstar_susp": 0.0004514672686230248,
            "pseudo_tarantula_susp": 0.0004366812227074236,
            "pseudo_op2_susp": 0.0004514672686230248,
            "pseudo_barinel_susp": 0.0004366812227074236
        }
    },
    {
        "name": "tornado.web.RequestHandler.set_etag_header#1607",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.set_etag_header(self)",
        "snippet": "    def set_etag_header(self) -> None:\n        \"\"\"Sets the response's Etag header using ``self.compute_etag()``.\n\n        Note: no header will be set if ``compute_etag()`` returns ``None``.\n\n        This method is called automatically when the request is finished.\n        \"\"\"\n        etag = self.compute_etag()\n        if etag is not None:\n            self.set_header(\"Etag\", etag)",
        "begin_line": 1607,
        "end_line": 1616,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004222972972972973,
            "pseudo_dstar_susp": 0.0004484304932735426,
            "pseudo_tarantula_susp": 0.00042301184433164127,
            "pseudo_op2_susp": 0.0004484304932735426,
            "pseudo_barinel_susp": 0.00042301184433164127
        }
    },
    {
        "name": "tornado.web.RequestHandler.check_etag_header#1618",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.check_etag_header(self)",
        "snippet": "    def check_etag_header(self) -> bool:\n        \"\"\"Checks the ``Etag`` header against requests's ``If-None-Match``.\n\n        Returns ``True`` if the request's Etag matches and a 304 should be\n        returned. For example::\n\n            self.set_etag_header()\n            if self.check_etag_header():\n                self.set_status(304)\n                return\n\n        This method is called automatically when the request is finished,\n        but may be called earlier for applications that override\n        `compute_etag` and want to do an early check for ``If-None-Match``\n        before completing the request.  The ``Etag`` header should be set\n        (perhaps with `set_etag_header`) before calling this method.\n        \"\"\"\n        computed_etag = utf8(self._headers.get(\"Etag\", \"\"))\n        # Find all weak and strong etag values from If-None-Match header\n        # because RFC 7232 allows multiple etag values in a single header.\n        etags = re.findall(\n            br'\\*|(?:W/)?\"[^\"]*\"', utf8(self.request.headers.get(\"If-None-Match\", \"\"))\n        )\n        if not computed_etag or not etags:\n            return False\n\n        match = False\n        if etags[0] == b\"*\":\n            match = True\n        else:\n            # Use a weak comparison when comparing entity-tags.\n            def val(x: bytes) -> bytes:\n                return x[2:] if x.startswith(b\"W/\") else x\n\n            for etag in etags:\n                if val(etag) == val(computed_etag):\n                    match = True\n                    break\n        return match",
        "begin_line": 1618,
        "end_line": 1656,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00044014084507042255,
            "pseudo_dstar_susp": 0.0004508566275924256,
            "pseudo_tarantula_susp": 0.00043084877208099956,
            "pseudo_op2_susp": 0.0004508566275924256,
            "pseudo_barinel_susp": 0.00043084877208099956
        }
    },
    {
        "name": "tornado.web.RequestHandler.val#1649",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.val(x: bytes)",
        "snippet": "            def val(x: bytes) -> bytes:\n                return x[2:] if x.startswith(b\"W/\") else x",
        "begin_line": 1649,
        "end_line": 1650,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017373175816539263,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler._execute#1658",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._execute(self, transforms: List['OutputTransform'], *args: bytes, **kwargs: bytes)",
        "snippet": "    async def _execute(\n        self, transforms: List[\"OutputTransform\"], *args: bytes, **kwargs: bytes\n    ) -> None:\n        \"\"\"Executes this request with the given output transforms.\"\"\"\n        self._transforms = transforms\n        try:\n            if self.request.method not in self.SUPPORTED_METHODS:\n                raise HTTPError(405)\n            self.path_args = [self.decode_argument(arg) for arg in args]\n            self.path_kwargs = dict(\n                (k, self.decode_argument(v, name=k)) for (k, v) in kwargs.items()\n            )\n            # If XSRF cookies are turned on, reject form submissions without\n            # the proper cookie\n            if self.request.method not in (\n                \"GET\",\n                \"HEAD\",\n                \"OPTIONS\",\n            ) and self.application.settings.get(\"xsrf_cookies\"):\n                self.check_xsrf_cookie()\n\n            result = self.prepare()\n            if result is not None:\n                result = await result\n            if self._prepared_future is not None:\n                # Tell the Application we've finished with prepare()\n                # and are ready for the body to arrive.\n                future_set_result_unless_cancelled(self._prepared_future, None)\n            if self._finished:\n                return\n\n            if _has_stream_request_body(self.__class__):\n                # In streaming mode request.body is a Future that signals\n                # the body has been completely received.  The Future has no\n                # result; the data has been passed to self.data_received\n                # instead.\n                try:\n                    await self.request._body_future\n                except iostream.StreamClosedError:\n                    return\n\n            method = getattr(self, self.request.method.lower())\n            result = method(*self.path_args, **self.path_kwargs)\n            if result is not None:\n                result = await result\n            if self._auto_finish and not self._finished:\n                self.finish()\n        except Exception as e:\n            try:\n                self._handle_request_exception(e)\n            except Exception:\n                app_log.error(\"Exception in exception handler\", exc_info=True)\n            finally:\n                # Unset result to avoid circular references\n                result = None\n            if self._prepared_future is not None and not self._prepared_future.done():\n                # In case we failed before setting _prepared_future, do it\n                # now (to unblock the HTTP server).  Note that this is not\n                # in a finally block to avoid GC issues prior to Python 3.4.\n                self._prepared_future.set_result(None)",
        "begin_line": 1658,
        "end_line": 1717,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006944444444444444,
            "pseudo_dstar_susp": 0.0015060240963855422,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.0015060240963855422,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "tornado.web.RequestHandler._log#1726",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._log(self)",
        "snippet": "    def _log(self) -> None:\n        \"\"\"Logs the current request.\n\n        Sort of deprecated since this functionality was moved to the\n        Application, but left in place for the benefit of existing apps\n        that have overridden this method.\n        \"\"\"\n        self.application.log_request(self)",
        "begin_line": 1726,
        "end_line": 1733,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043122035360068997,
            "pseudo_dstar_susp": 0.0004631773969430292,
            "pseudo_tarantula_susp": 0.0004127115146512588,
            "pseudo_op2_susp": 0.0004631773969430292,
            "pseudo_barinel_susp": 0.0004127115146512588
        }
    },
    {
        "name": "tornado.web.RequestHandler._request_summary#1735",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._request_summary(self)",
        "snippet": "    def _request_summary(self) -> str:\n        return \"%s %s (%s)\" % (\n            self.request.method,\n            self.request.uri,\n            self.request.remote_ip,\n        )",
        "begin_line": 1735,
        "end_line": 1740,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043122035360068997,
            "pseudo_dstar_susp": 0.0004631773969430292,
            "pseudo_tarantula_susp": 0.0004127115146512588,
            "pseudo_op2_susp": 0.0004631773969430292,
            "pseudo_barinel_susp": 0.0004127115146512588
        }
    },
    {
        "name": "tornado.web.RequestHandler._handle_request_exception#1742",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._handle_request_exception(self, e: BaseException)",
        "snippet": "    def _handle_request_exception(self, e: BaseException) -> None:\n        if isinstance(e, Finish):\n            # Not an error; just finish the request without logging.\n            if not self._finished:\n                self.finish(*e.args)\n            return\n        try:\n            self.log_exception(*sys.exc_info())\n        except Exception:\n            # An error here should still get a best-effort send_error()\n            # to avoid leaking the connection.\n            app_log.error(\"Error in exception logger\", exc_info=True)\n        if self._finished:\n            # Extra errors after the request has been finished should\n            # be logged, but there is no reason to continue to try and\n            # send a response.\n            return\n        if isinstance(e, HTTPError):\n            self.send_error(e.status_code, exc_info=sys.exc_info())\n        else:\n            self.send_error(500, exc_info=sys.exc_info())",
        "begin_line": 1742,
        "end_line": 1762,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.log_exception#1764",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.log_exception(self, typ: Optional[Type[BaseException]], value: Optional[BaseException], tb: Optional[TracebackType])",
        "snippet": "    def log_exception(\n        self,\n        typ: Optional[Type[BaseException]],\n        value: Optional[BaseException],\n        tb: Optional[TracebackType],\n    ) -> None:\n        \"\"\"Override to customize logging of uncaught exceptions.\n\n        By default logs instances of `HTTPError` as warnings without\n        stack traces (on the ``tornado.general`` logger), and all\n        other exceptions as errors with stack traces (on the\n        ``tornado.application`` logger).\n\n        .. versionadded:: 3.1\n        \"\"\"\n        if isinstance(value, HTTPError):\n            if value.log_message:\n                format = \"%d %s: \" + value.log_message\n                args = [value.status_code, self._request_summary()] + list(value.args)\n                gen_log.warning(format, *args)\n        else:\n            app_log.error(  # type: ignore\n                \"Uncaught exception %s\\n%r\",\n                self._request_summary(),\n                self.request,\n                exc_info=(typ, value, tb),\n            )",
        "begin_line": 1764,
        "end_line": 1790,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler._ui_module#1792",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._ui_module(self, name: str, module: Type['UIModule'])",
        "snippet": "    def _ui_module(self, name: str, module: Type[\"UIModule\"]) -> Callable[..., str]:\n        def render(*args, **kwargs) -> str:  # type: ignore\n            if not hasattr(self, \"_active_modules\"):\n                self._active_modules = {}  # type: Dict[str, UIModule]\n            if name not in self._active_modules:\n                self._active_modules[name] = module(self)\n            rendered = self._active_modules[name].render(*args, **kwargs)\n            return rendered\n\n        return render",
        "begin_line": 1792,
        "end_line": 1801,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler.render#1793",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.render(*args, **kwargs)",
        "snippet": "        def render(*args, **kwargs) -> str:  # type: ignore\n            if not hasattr(self, \"_active_modules\"):\n                self._active_modules = {}  # type: Dict[str, UIModule]\n            if name not in self._active_modules:\n                self._active_modules[name] = module(self)\n            rendered = self._active_modules[name].render(*args, **kwargs)\n            return rendered",
        "begin_line": 1793,
        "end_line": 1799,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler._ui_method#1803",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._ui_method(self, method: Callable[..., str])",
        "snippet": "    def _ui_method(self, method: Callable[..., str]) -> Callable[..., str]:\n        return lambda *args, **kwargs: method(self, *args, **kwargs)",
        "begin_line": 1803,
        "end_line": 1804,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RequestHandler._clear_headers_for_304#1806",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._clear_headers_for_304(self)",
        "snippet": "    def _clear_headers_for_304(self) -> None:\n        # 304 responses should not contain entity headers (defined in\n        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.1)\n        # not explicitly allowed by\n        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5\n        headers = [\n            \"Allow\",\n            \"Content-Encoding\",\n            \"Content-Language\",\n            \"Content-Length\",\n            \"Content-MD5\",\n            \"Content-Range\",\n            \"Content-Type\",\n            \"Last-Modified\",\n        ]\n        for h in headers:\n            self.clear_header(h)",
        "begin_line": 1806,
        "end_line": 1822,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014332807797047442,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.stream_request_body#1825",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.stream_request_body(cls: Type[RequestHandler])",
        "snippet": "def stream_request_body(cls: Type[RequestHandler]) -> Type[RequestHandler]:\n    \"\"\"Apply to `RequestHandler` subclasses to enable streaming body support.\n\n    This decorator implies the following changes:\n\n    * `.HTTPServerRequest.body` is undefined, and body arguments will not\n      be included in `RequestHandler.get_argument`.\n    * `RequestHandler.prepare` is called when the request headers have been\n      read instead of after the entire body has been read.\n    * The subclass must define a method ``data_received(self, data):``, which\n      will be called zero or more times as data is available.  Note that\n      if the request has an empty body, ``data_received`` may not be called.\n    * ``prepare`` and ``data_received`` may return Futures (such as via\n      ``@gen.coroutine``, in which case the next method will not be called\n      until those futures have completed.\n    * The regular HTTP method (``post``, ``put``, etc) will be called after\n      the entire body has been read.\n\n    See the `file receiver demo <https://github.com/tornadoweb/tornado/tree/master/demos/file_upload/>`_\n    for example usage.\n    \"\"\"  # noqa: E501\n    if not issubclass(cls, RequestHandler):\n        raise TypeError(\"expected subclass of RequestHandler, got %r\", cls)\n    cls._stream_request_body = True\n    return cls",
        "begin_line": 1825,
        "end_line": 1849,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0031545741324921135,
            "pseudo_dstar_susp": 0.0005302226935312832,
            "pseudo_tarantula_susp": 0.009615384615384616,
            "pseudo_op2_susp": 0.0005302226935312832,
            "pseudo_barinel_susp": 0.009615384615384616
        }
    },
    {
        "name": "tornado.web._has_stream_request_body#1852",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._has_stream_request_body(cls: Type[RequestHandler])",
        "snippet": "def _has_stream_request_body(cls: Type[RequestHandler]) -> bool:\n    if not issubclass(cls, RequestHandler):\n        raise TypeError(\"expected subclass of RequestHandler, got %r\", cls)\n    return cls._stream_request_body",
        "begin_line": 1852,
        "end_line": 1855,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006747638326585695,
            "pseudo_dstar_susp": 0.0007776049766718507,
            "pseudo_tarantula_susp": 0.0006215040397762585,
            "pseudo_op2_susp": 0.0007776049766718507,
            "pseudo_barinel_susp": 0.0006215040397762585
        }
    },
    {
        "name": "tornado.web.removeslash#1858",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.removeslash(method: Callable[..., Optional[Awaitable[None]]])",
        "snippet": "def removeslash(\n    method: Callable[..., Optional[Awaitable[None]]]\n) -> Callable[..., Optional[Awaitable[None]]]:\n    \"\"\"Use this decorator to remove trailing slashes from the request path.\n\n    For example, a request to ``/foo/`` would redirect to ``/foo`` with this\n    decorator. Your request handler mapping should use a regular expression\n    like ``r'/foo/*'`` in conjunction with using the decorator.\n    \"\"\"\n\n    @functools.wraps(method)\n    def wrapper(  # type: ignore\n        self: RequestHandler, *args, **kwargs\n    ) -> Optional[Awaitable[None]]:\n        if self.request.path.endswith(\"/\"):\n            if self.request.method in (\"GET\", \"HEAD\"):\n                uri = self.request.path.rstrip(\"/\")\n                if uri:  # don't try to redirect '/' to ''\n                    if self.request.query:\n                        uri += \"?\" + self.request.query\n                    self.redirect(uri, permanent=True)\n                    return None\n            else:\n                raise HTTPError(404)\n        return method(self, *args, **kwargs)\n\n    return wrapper",
        "begin_line": 1858,
        "end_line": 1884,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.wrapper#1869",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.wrapper(self: RequestHandler, *args, **kwargs)",
        "snippet": "    def wrapper(  # type: ignore\n        self: RequestHandler, *args, **kwargs\n    ) -> Optional[Awaitable[None]]:\n        if self.request.path.endswith(\"/\"):\n            if self.request.method in (\"GET\", \"HEAD\"):\n                uri = self.request.path.rstrip(\"/\")\n                if uri:  # don't try to redirect '/' to ''\n                    if self.request.query:\n                        uri += \"?\" + self.request.query\n                    self.redirect(uri, permanent=True)\n                    return None\n            else:\n                raise HTTPError(404)\n        return method(self, *args, **kwargs)",
        "begin_line": 1869,
        "end_line": 1882,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.addslash#1887",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.addslash(method: Callable[..., Optional[Awaitable[None]]])",
        "snippet": "def addslash(\n    method: Callable[..., Optional[Awaitable[None]]]\n) -> Callable[..., Optional[Awaitable[None]]]:\n    \"\"\"Use this decorator to add a missing trailing slash to the request path.\n\n    For example, a request to ``/foo`` would redirect to ``/foo/`` with this\n    decorator. Your request handler mapping should use a regular expression\n    like ``r'/foo/?'`` in conjunction with using the decorator.\n    \"\"\"\n\n    @functools.wraps(method)\n    def wrapper(  # type: ignore\n        self: RequestHandler, *args, **kwargs\n    ) -> Optional[Awaitable[None]]:\n        if not self.request.path.endswith(\"/\"):\n            if self.request.method in (\"GET\", \"HEAD\"):\n                uri = self.request.path + \"/\"\n                if self.request.query:\n                    uri += \"?\" + self.request.query\n                self.redirect(uri, permanent=True)\n                return None\n            raise HTTPError(404)\n        return method(self, *args, **kwargs)\n\n    return wrapper",
        "begin_line": 1887,
        "end_line": 1911,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.wrapper#1898",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.wrapper(self: RequestHandler, *args, **kwargs)",
        "snippet": "    def wrapper(  # type: ignore\n        self: RequestHandler, *args, **kwargs\n    ) -> Optional[Awaitable[None]]:\n        if not self.request.path.endswith(\"/\"):\n            if self.request.method in (\"GET\", \"HEAD\"):\n                uri = self.request.path + \"/\"\n                if self.request.query:\n                    uri += \"?\" + self.request.query\n                self.redirect(uri, permanent=True)\n                return None\n            raise HTTPError(404)\n        return method(self, *args, **kwargs)",
        "begin_line": 1898,
        "end_line": 1909,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web._ApplicationRouter.__init__#1925",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._ApplicationRouter",
        "signature": "tornado.web._ApplicationRouter.__init__(self, application: 'Application', rules: _RuleList=None)",
        "snippet": "    def __init__(self, application: \"Application\", rules: _RuleList = None) -> None:\n        assert isinstance(application, Application)\n        self.application = application\n        super(_ApplicationRouter, self).__init__(rules)",
        "begin_line": 1925,
        "end_line": 1928,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008326394671107411,
            "pseudo_dstar_susp": 0.001072961373390558,
            "pseudo_tarantula_susp": 0.0007518796992481203,
            "pseudo_op2_susp": 0.001072961373390558,
            "pseudo_barinel_susp": 0.0007518796992481203
        }
    },
    {
        "name": "tornado.web._ApplicationRouter.process_rule#1930",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._ApplicationRouter",
        "signature": "tornado.web._ApplicationRouter.process_rule(self, rule: Rule)",
        "snippet": "    def process_rule(self, rule: Rule) -> Rule:\n        rule = super(_ApplicationRouter, self).process_rule(rule)\n\n        if isinstance(rule.target, (list, tuple)):\n            rule.target = _ApplicationRouter(  # type: ignore\n                self.application, rule.target\n            )\n\n        return rule",
        "begin_line": 1930,
        "end_line": 1938,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008326394671107411,
            "pseudo_dstar_susp": 0.001072961373390558,
            "pseudo_tarantula_susp": 0.0007518796992481203,
            "pseudo_op2_susp": 0.001072961373390558,
            "pseudo_barinel_susp": 0.0007518796992481203
        }
    },
    {
        "name": "tornado.web._ApplicationRouter.get_target_delegate#1940",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._ApplicationRouter",
        "signature": "tornado.web._ApplicationRouter.get_target_delegate(self, target: Any, request: httputil.HTTPServerRequest, **target_params: Any)",
        "snippet": "    def get_target_delegate(\n        self, target: Any, request: httputil.HTTPServerRequest, **target_params: Any\n    ) -> Optional[httputil.HTTPMessageDelegate]:\n        if isclass(target) and issubclass(target, RequestHandler):\n            return self.application.get_handler_delegate(\n                request, target, **target_params\n            )\n\n        return super(_ApplicationRouter, self).get_target_delegate(\n            target, request, **target_params\n        )",
        "begin_line": 1940,
        "end_line": 1950,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006915629322268327,
            "pseudo_dstar_susp": 0.0008,
            "pseudo_tarantula_susp": 0.0006381620931716656,
            "pseudo_op2_susp": 0.0008,
            "pseudo_barinel_susp": 0.0006381620931716656
        }
    },
    {
        "name": "tornado.web.Application.__init__#2037",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application.__init__(self, handlers: _RuleList=None, default_host: str=None, transforms: List[Type['OutputTransform']]=None, **settings: Any)",
        "snippet": "    def __init__(\n        self,\n        handlers: _RuleList = None,\n        default_host: str = None,\n        transforms: List[Type[\"OutputTransform\"]] = None,\n        **settings: Any\n    ) -> None:\n        if transforms is None:\n            self.transforms = []  # type: List[Type[OutputTransform]]\n            if settings.get(\"compress_response\") or settings.get(\"gzip\"):\n                self.transforms.append(GZipContentEncoding)\n        else:\n            self.transforms = transforms\n        self.default_host = default_host\n        self.settings = settings\n        self.ui_modules = {\n            \"linkify\": _linkify,\n            \"xsrf_form_html\": _xsrf_form_html,\n            \"Template\": TemplateModule,\n        }\n        self.ui_methods = {}  # type: Dict[str, Callable[..., str]]\n        self._load_ui_modules(settings.get(\"ui_modules\", {}))\n        self._load_ui_methods(settings.get(\"ui_methods\", {}))\n        if self.settings.get(\"static_path\"):\n            path = self.settings[\"static_path\"]\n            handlers = list(handlers or [])\n            static_url_prefix = settings.get(\"static_url_prefix\", \"/static/\")\n            static_handler_class = settings.get(\n                \"static_handler_class\", StaticFileHandler\n            )\n            static_handler_args = settings.get(\"static_handler_args\", {})\n            static_handler_args[\"path\"] = path\n            for pattern in [\n                re.escape(static_url_prefix) + r\"(.*)\",\n                r\"/(favicon\\.ico)\",\n                r\"/(robots\\.txt)\",\n            ]:\n                handlers.insert(0, (pattern, static_handler_class, static_handler_args))\n\n        if self.settings.get(\"debug\"):\n            self.settings.setdefault(\"autoreload\", True)\n            self.settings.setdefault(\"compiled_template_cache\", False)\n            self.settings.setdefault(\"static_hash_cache\", False)\n            self.settings.setdefault(\"serve_traceback\", True)\n\n        self.wildcard_router = _ApplicationRouter(self, handlers)\n        self.default_router = _ApplicationRouter(\n            self, [Rule(AnyMatches(), self.wildcard_router)]\n        )\n\n        # Automatically reload modified modules\n        if self.settings.get(\"autoreload\"):\n            from tornado import autoreload\n\n            autoreload.start()",
        "begin_line": 2037,
        "end_line": 2091,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008326394671107411,
            "pseudo_dstar_susp": 0.001072961373390558,
            "pseudo_tarantula_susp": 0.0007518796992481203,
            "pseudo_op2_susp": 0.001072961373390558,
            "pseudo_barinel_susp": 0.0007518796992481203
        }
    },
    {
        "name": "tornado.web.Application.listen#2093",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application.listen(self, port: int, address: str='', **kwargs: Any)",
        "snippet": "    def listen(self, port: int, address: str = \"\", **kwargs: Any) -> HTTPServer:\n        \"\"\"Starts an HTTP server for this application on the given port.\n\n        This is a convenience alias for creating an `.HTTPServer`\n        object and calling its listen method.  Keyword arguments not\n        supported by `HTTPServer.listen <.TCPServer.listen>` are passed to the\n        `.HTTPServer` constructor.  For advanced uses\n        (e.g. multi-process mode), do not use this method; create an\n        `.HTTPServer` and call its\n        `.TCPServer.bind`/`.TCPServer.start` methods directly.\n\n        Note that after calling this method you still need to call\n        ``IOLoop.current().start()`` to start the server.\n\n        Returns the `.HTTPServer` object.\n\n        .. versionchanged:: 4.3\n           Now returns the `.HTTPServer` object.\n        \"\"\"\n        server = HTTPServer(self, **kwargs)\n        server.listen(port, address)\n        return server",
        "begin_line": 2093,
        "end_line": 2114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.Application.add_handlers#2116",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application.add_handlers(self, host_pattern: str, host_handlers: _RuleList)",
        "snippet": "    def add_handlers(self, host_pattern: str, host_handlers: _RuleList) -> None:\n        \"\"\"Appends the given handlers to our handler list.\n\n        Host patterns are processed sequentially in the order they were\n        added. All matching patterns will be considered.\n        \"\"\"\n        host_matcher = HostMatches(host_pattern)\n        rule = Rule(host_matcher, _ApplicationRouter(self, host_handlers))\n\n        self.default_router.rules.insert(-1, rule)\n\n        if self.default_host is not None:\n            self.wildcard_router.add_rules(\n                [(DefaultHostMatches(self, host_matcher.host_pattern), host_handlers)]\n            )",
        "begin_line": 2116,
        "end_line": 2130,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.Application._load_ui_methods#2135",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application._load_ui_methods(self, methods: Any)",
        "snippet": "    def _load_ui_methods(self, methods: Any) -> None:\n        if isinstance(methods, types.ModuleType):\n            self._load_ui_methods(dict((n, getattr(methods, n)) for n in dir(methods)))\n        elif isinstance(methods, list):\n            for m in methods:\n                self._load_ui_methods(m)\n        else:\n            for name, fn in methods.items():\n                if (\n                    not name.startswith(\"_\")\n                    and hasattr(fn, \"__call__\")\n                    and name[0].lower() == name[0]\n                ):\n                    self.ui_methods[name] = fn",
        "begin_line": 2135,
        "end_line": 2148,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008326394671107411,
            "pseudo_dstar_susp": 0.001072961373390558,
            "pseudo_tarantula_susp": 0.0007518796992481203,
            "pseudo_op2_susp": 0.001072961373390558,
            "pseudo_barinel_susp": 0.0007518796992481203
        }
    },
    {
        "name": "tornado.web.Application._load_ui_modules#2150",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application._load_ui_modules(self, modules: Any)",
        "snippet": "    def _load_ui_modules(self, modules: Any) -> None:\n        if isinstance(modules, types.ModuleType):\n            self._load_ui_modules(dict((n, getattr(modules, n)) for n in dir(modules)))\n        elif isinstance(modules, list):\n            for m in modules:\n                self._load_ui_modules(m)\n        else:\n            assert isinstance(modules, dict)\n            for name, cls in modules.items():\n                try:\n                    if issubclass(cls, UIModule):\n                        self.ui_modules[name] = cls\n                except TypeError:\n                    pass",
        "begin_line": 2150,
        "end_line": 2163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008326394671107411,
            "pseudo_dstar_susp": 0.001072961373390558,
            "pseudo_tarantula_susp": 0.0007518796992481203,
            "pseudo_op2_susp": 0.001072961373390558,
            "pseudo_barinel_susp": 0.0007518796992481203
        }
    },
    {
        "name": "tornado.web.Application.find_handler#2172",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application.find_handler(self, request: httputil.HTTPServerRequest, **kwargs: Any)",
        "snippet": "    def find_handler(\n        self, request: httputil.HTTPServerRequest, **kwargs: Any\n    ) -> \"_HandlerDelegate\":\n        route = self.default_router.find_handler(request)\n        if route is not None:\n            return cast(\"_HandlerDelegate\", route)\n\n        if self.settings.get(\"default_handler_class\"):\n            return self.get_handler_delegate(\n                request,\n                self.settings[\"default_handler_class\"],\n                self.settings.get(\"default_handler_args\", {}),\n            )\n\n        return self.get_handler_delegate(request, ErrorHandler, {\"status_code\": 404})",
        "begin_line": 2172,
        "end_line": 2186,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006915629322268327,
            "pseudo_dstar_susp": 0.0008,
            "pseudo_tarantula_susp": 0.0006381620931716656,
            "pseudo_op2_susp": 0.0008,
            "pseudo_barinel_susp": 0.0006381620931716656
        }
    },
    {
        "name": "tornado.web.Application.get_handler_delegate#2188",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application.get_handler_delegate(self, request: httputil.HTTPServerRequest, target_class: Type[RequestHandler], target_kwargs: Dict[str, Any]=None, path_args: List[bytes]=None, path_kwargs: Dict[str, bytes]=None)",
        "snippet": "    def get_handler_delegate(\n        self,\n        request: httputil.HTTPServerRequest,\n        target_class: Type[RequestHandler],\n        target_kwargs: Dict[str, Any] = None,\n        path_args: List[bytes] = None,\n        path_kwargs: Dict[str, bytes] = None,\n    ) -> \"_HandlerDelegate\":\n        \"\"\"Returns `~.httputil.HTTPMessageDelegate` that can serve a request\n        for application and `RequestHandler` subclass.\n\n        :arg httputil.HTTPServerRequest request: current HTTP request.\n        :arg RequestHandler target_class: a `RequestHandler` class.\n        :arg dict target_kwargs: keyword arguments for ``target_class`` constructor.\n        :arg list path_args: positional arguments for ``target_class`` HTTP method that\n            will be executed while handling a request (``get``, ``post`` or any other).\n        :arg dict path_kwargs: keyword arguments for ``target_class`` HTTP method.\n        \"\"\"\n        return _HandlerDelegate(\n            self, request, target_class, target_kwargs, path_args, path_kwargs\n        )",
        "begin_line": 2188,
        "end_line": 2208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006747638326585695,
            "pseudo_dstar_susp": 0.0007776049766718507,
            "pseudo_tarantula_susp": 0.0006215040397762585,
            "pseudo_op2_susp": 0.0007776049766718507,
            "pseudo_barinel_susp": 0.0006215040397762585
        }
    },
    {
        "name": "tornado.web.Application.reverse_url#2210",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application.reverse_url(self, name: str, *args: Any)",
        "snippet": "    def reverse_url(self, name: str, *args: Any) -> str:\n        \"\"\"Returns a URL path for handler named ``name``\n\n        The handler must be added to the application as a named `URLSpec`.\n\n        Args will be substituted for capturing groups in the `URLSpec` regex.\n        They will be converted to strings if necessary, encoded as utf8,\n        and url-escaped.\n        \"\"\"\n        reversed_url = self.default_router.reverse_url(name, *args)\n        if reversed_url is not None:\n            return reversed_url\n\n        raise KeyError(\"%s not found in named urls\" % name)",
        "begin_line": 2210,
        "end_line": 2223,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017885888034340904,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.Application.log_request#2225",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application.log_request(self, handler: RequestHandler)",
        "snippet": "    def log_request(self, handler: RequestHandler) -> None:\n        \"\"\"Writes a completed HTTP request to the logs.\n\n        By default writes to the python root logger.  To change\n        this behavior either subclass Application and override this method,\n        or pass a function in the application settings dictionary as\n        ``log_function``.\n        \"\"\"\n        if \"log_function\" in self.settings:\n            self.settings[\"log_function\"](handler)\n            return\n        if handler.get_status() < 400:\n            log_method = access_log.info\n        elif handler.get_status() < 500:\n            log_method = access_log.warning\n        else:\n            log_method = access_log.error\n        request_time = 1000.0 * handler.request.request_time()\n        log_method(\n            \"%d %s %.2fms\",\n            handler.get_status(),\n            handler._request_summary(),\n            request_time,\n        )",
        "begin_line": 2225,
        "end_line": 2248,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00044072278536800354,
            "pseudo_dstar_susp": 0.000471253534401508,
            "pseudo_tarantula_susp": 0.0004201680672268908,
            "pseudo_op2_susp": 0.000471253534401508,
            "pseudo_barinel_susp": 0.0004201680672268908
        }
    },
    {
        "name": "tornado.web._HandlerDelegate.__init__#2252",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._HandlerDelegate",
        "signature": "tornado.web._HandlerDelegate.__init__(self, application: Application, request: httputil.HTTPServerRequest, handler_class: Type[RequestHandler], handler_kwargs: Optional[Dict[str, Any]], path_args: Optional[List[bytes]], path_kwargs: Optional[Dict[str, bytes]])",
        "snippet": "    def __init__(\n        self,\n        application: Application,\n        request: httputil.HTTPServerRequest,\n        handler_class: Type[RequestHandler],\n        handler_kwargs: Optional[Dict[str, Any]],\n        path_args: Optional[List[bytes]],\n        path_kwargs: Optional[Dict[str, bytes]],\n    ) -> None:\n        self.application = application\n        self.connection = request.connection\n        self.request = request\n        self.handler_class = handler_class\n        self.handler_kwargs = handler_kwargs or {}\n        self.path_args = path_args or []\n        self.path_kwargs = path_kwargs or {}\n        self.chunks = []  # type: List[bytes]\n        self.stream_request_body = _has_stream_request_body(self.handler_class)",
        "begin_line": 2252,
        "end_line": 2269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006747638326585695,
            "pseudo_dstar_susp": 0.0007776049766718507,
            "pseudo_tarantula_susp": 0.0006215040397762585,
            "pseudo_op2_susp": 0.0007776049766718507,
            "pseudo_barinel_susp": 0.0006215040397762585
        }
    },
    {
        "name": "tornado.web._HandlerDelegate.headers_received#2271",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._HandlerDelegate",
        "signature": "tornado.web._HandlerDelegate.headers_received(self, start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine], headers: httputil.HTTPHeaders)",
        "snippet": "    def headers_received(\n        self,\n        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],\n        headers: httputil.HTTPHeaders,\n    ) -> Optional[Awaitable[None]]:\n        if self.stream_request_body:\n            self.request._body_future = Future()\n            return self.execute()\n        return None",
        "begin_line": 2271,
        "end_line": 2279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011013215859030838,
            "pseudo_dstar_susp": 0.0007776049766718507,
            "pseudo_tarantula_susp": 0.005128205128205128,
            "pseudo_op2_susp": 0.0007776049766718507,
            "pseudo_barinel_susp": 0.005128205128205128
        }
    },
    {
        "name": "tornado.web._HandlerDelegate.data_received#2281",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._HandlerDelegate",
        "signature": "tornado.web._HandlerDelegate.data_received(self, data: bytes)",
        "snippet": "    def data_received(self, data: bytes) -> Optional[Awaitable[None]]:\n        if self.stream_request_body:\n            return self.handler.data_received(data)\n        else:\n            self.chunks.append(data)\n            return None",
        "begin_line": 2281,
        "end_line": 2286,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00045641259698767686,
            "pseudo_dstar_susp": 0.00041597337770382697,
            "pseudo_tarantula_susp": 0.002386634844868735,
            "pseudo_op2_susp": 0.00041597337770382697,
            "pseudo_barinel_susp": 0.002386634844868735
        }
    },
    {
        "name": "tornado.web._HandlerDelegate.finish#2288",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._HandlerDelegate",
        "signature": "tornado.web._HandlerDelegate.finish(self)",
        "snippet": "    def finish(self) -> None:\n        if self.stream_request_body:\n            future_set_result_unless_cancelled(self.request._body_future, None)\n        else:\n            self.request.body = b\"\".join(self.chunks)\n            self.request._parse_body()\n            self.execute()",
        "begin_line": 2288,
        "end_line": 2294,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004578754578754579,
            "pseudo_dstar_susp": 0.000501002004008016,
            "pseudo_tarantula_susp": 0.002386634844868735,
            "pseudo_op2_susp": 0.000501002004008016,
            "pseudo_barinel_susp": 0.002386634844868735
        }
    },
    {
        "name": "tornado.web._HandlerDelegate.on_connection_close#2296",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._HandlerDelegate",
        "signature": "tornado.web._HandlerDelegate.on_connection_close(self)",
        "snippet": "    def on_connection_close(self) -> None:\n        if self.stream_request_body:\n            self.handler.on_connection_close()\n        else:\n            self.chunks = None  # type: ignore",
        "begin_line": 2296,
        "end_line": 2300,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009900990099009901,
            "pseudo_dstar_susp": 0.0005341880341880342,
            "pseudo_tarantula_susp": 0.05,
            "pseudo_op2_susp": 0.0005341880341880342,
            "pseudo_barinel_susp": 0.05
        }
    },
    {
        "name": "tornado.web._HandlerDelegate.execute#2302",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._HandlerDelegate",
        "signature": "tornado.web._HandlerDelegate.execute(self)",
        "snippet": "    def execute(self) -> Optional[Awaitable[None]]:\n        # If template cache is disabled (usually in the debug mode),\n        # re-compile templates and reload static files on every\n        # request so you don't need to restart to see changes\n        if not self.application.settings.get(\"compiled_template_cache\", True):\n            with RequestHandler._template_loader_lock:\n                for loader in RequestHandler._template_loaders.values():\n                    loader.reset()\n        if not self.application.settings.get(\"static_hash_cache\", True):\n            StaticFileHandler.reset()\n\n        self.handler = self.handler_class(\n            self.application, self.request, **self.handler_kwargs\n        )\n        transforms = [t(self.request) for t in self.application.transforms]\n\n        if self.stream_request_body:\n            self.handler._prepared_future = Future()\n        # Note that if an exception escapes handler._execute it will be\n        # trapped in the Future it returns (which we are ignoring here,\n        # leaving it to be logged when the Future is GC'd).\n        # However, that shouldn't happen because _execute has a blanket\n        # except handler, and we cannot easily access the IOLoop here to\n        # call add_future (because of the requirement to remain compatible\n        # with WSGI)\n        fut = gen.convert_yielded(\n            self.handler._execute(transforms, *self.path_args, **self.path_kwargs)\n        )\n        fut.add_done_callback(lambda f: f.result())\n        # If we are streaming the request body, then execute() is finished\n        # when the handler has prepared to receive the body.  If not,\n        # it doesn't matter when execute() finishes (so we return None)\n        return self.handler._prepared_future",
        "begin_line": 2302,
        "end_line": 2334,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011013215859030838,
            "pseudo_dstar_susp": 0.0014992503748125937,
            "pseudo_tarantula_susp": 0.005128205128205128,
            "pseudo_op2_susp": 0.0014992503748125937,
            "pseudo_barinel_susp": 0.005128205128205128
        }
    },
    {
        "name": "tornado.web.HTTPError.__init__#2360",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.HTTPError",
        "signature": "tornado.web.HTTPError.__init__(self, status_code: int=500, log_message: str=None, *args: Any, **kwargs: Any)",
        "snippet": "    def __init__(\n        self, status_code: int = 500, log_message: str = None, *args: Any, **kwargs: Any\n    ) -> None:\n        self.status_code = status_code\n        self.log_message = log_message\n        self.args = args\n        self.reason = kwargs.get(\"reason\", None)\n        if log_message and not args:\n            self.log_message = log_message.replace(\"%\", \"%%\")",
        "begin_line": 2360,
        "end_line": 2368,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017885888034340904,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.HTTPError.__str__#2370",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.HTTPError",
        "signature": "tornado.web.HTTPError.__str__(self)",
        "snippet": "    def __str__(self) -> str:\n        message = \"HTTP %d: %s\" % (\n            self.status_code,\n            self.reason or httputil.responses.get(self.status_code, \"Unknown\"),\n        )\n        if self.log_message:\n            return message + \" (\" + (self.log_message % self.args) + \")\"\n        else:\n            return message",
        "begin_line": 2370,
        "end_line": 2378,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.MissingArgumentError.__init__#2418",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.MissingArgumentError",
        "signature": "tornado.web.MissingArgumentError.__init__(self, arg_name: str)",
        "snippet": "    def __init__(self, arg_name: str) -> None:\n        super(MissingArgumentError, self).__init__(\n            400, \"Missing argument %s\" % arg_name\n        )\n        self.arg_name = arg_name",
        "begin_line": 2418,
        "end_line": 2422,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.ErrorHandler.initialize#2428",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.ErrorHandler",
        "signature": "tornado.web.ErrorHandler.initialize(self, status_code: int)",
        "snippet": "    def initialize(self, status_code: int) -> None:\n        self.set_status(status_code)",
        "begin_line": 2428,
        "end_line": 2429,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016903313049357674,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.ErrorHandler.prepare#2431",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.ErrorHandler",
        "signature": "tornado.web.ErrorHandler.prepare(self)",
        "snippet": "    def prepare(self) -> None:\n        raise HTTPError(self._status_code)",
        "begin_line": 2431,
        "end_line": 2432,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016903313049357674,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.ErrorHandler.check_xsrf_cookie#2434",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.ErrorHandler",
        "signature": "tornado.web.ErrorHandler.check_xsrf_cookie(self)",
        "snippet": "    def check_xsrf_cookie(self) -> None:\n        # POSTs to an ErrorHandler don't actually have side effects,\n        # so we don't need to check the xsrf token.  This allows POSTs\n        # to the wrong url to return a 404 instead of 403.\n        pass",
        "begin_line": 2434,
        "end_line": 2438,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RedirectHandler.initialize#2474",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RedirectHandler",
        "signature": "tornado.web.RedirectHandler.initialize(self, url: str, permanent: bool=True)",
        "snippet": "    def initialize(self, url: str, permanent: bool = True) -> None:\n        self._url = url\n        self._permanent = permanent",
        "begin_line": 2474,
        "end_line": 2476,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019334880123743234,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.RedirectHandler.get#2478",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RedirectHandler",
        "signature": "tornado.web.RedirectHandler.get(self, *args: Any)",
        "snippet": "    def get(self, *args: Any) -> None:\n        to_url = self._url.format(*args)\n        if self.request.query_arguments:\n            # TODO: figure out typing for the next line.\n            to_url = httputil.url_concat(\n                to_url,\n                list(httputil.qs_to_qsl(self.request.query_arguments)),  # type: ignore\n            )\n        self.redirect(to_url, permanent=self._permanent)",
        "begin_line": 2478,
        "end_line": 2486,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.initialize#2561",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.initialize(self, path: str, default_filename: str=None)",
        "snippet": "    def initialize(self, path: str, default_filename: str = None) -> None:\n        self.root = path\n        self.default_filename = default_filename",
        "begin_line": 2561,
        "end_line": 2563,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015508684863523573,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.head#2570",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.head(self, path: str)",
        "snippet": "    def head(self, path: str) -> Awaitable[None]:\n        return self.get(path, include_body=False)",
        "begin_line": 2570,
        "end_line": 2571,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016220600162206002,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get#2573",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get(self, path: str, include_body: bool=True)",
        "snippet": "    async def get(self, path: str, include_body: bool = True) -> None:\n        # Set up our path instance variables.\n        self.path = self.parse_url_path(path)\n        del path  # make sure we don't refer to path instead of self.path again\n        absolute_path = self.get_absolute_path(self.root, self.path)\n        self.absolute_path = self.validate_absolute_path(self.root, absolute_path)\n        if self.absolute_path is None:\n            return\n\n        self.modified = self.get_modified_time()\n        self.set_headers()\n\n        if self.should_return_304():\n            self.set_status(304)\n            return\n\n        request_range = None\n        range_header = self.request.headers.get(\"Range\")\n        if range_header:\n            # As per RFC 2616 14.16, if an invalid Range header is specified,\n            # the request will be treated as if the header didn't exist.\n            request_range = httputil._parse_request_range(range_header)\n\n        size = self.get_content_size()\n        if request_range:\n            start, end = request_range\n            if start is not None and start < 0:\n                start += size\n                if start < 0:\n                    start = 0\n            if (\n                start is not None\n                and (start >= size or (end is not None and start >= end))\n            ) or end == 0:\n                # As per RFC 2616 14.35.1, a range is not satisfiable only: if\n                # the first requested byte is equal to or greater than the\n                # content, or when a suffix with length 0 is specified.\n                # https://tools.ietf.org/html/rfc7233#section-2.1\n                # A byte-range-spec is invalid if the last-byte-pos value is present\n                # and less than the first-byte-pos.\n                self.set_status(416)  # Range Not Satisfiable\n                self.set_header(\"Content-Type\", \"text/plain\")\n                self.set_header(\"Content-Range\", \"bytes */%s\" % (size,))\n                return\n            if end is not None and end > size:\n                # Clients sometimes blindly use a large range to limit their\n                # download size; cap the endpoint at the actual file size.\n                end = size\n            # Note: only return HTTP 206 if less than the entire range has been\n            # requested. Not only is this semantically correct, but Chrome\n            # refuses to play audio if it gets an HTTP 206 in response to\n            # ``Range: bytes=0-``.\n            if size != (end or size) - (start or 0):\n                self.set_status(206)  # Partial Content\n                self.set_header(\n                    \"Content-Range\", httputil._get_content_range(start, end, size)\n                )\n        else:\n            start = end = None\n\n        if start is not None and end is not None:\n            content_length = end - start\n        elif end is not None:\n            content_length = end\n        elif start is not None:\n            content_length = size - start\n        else:\n            content_length = size\n        self.set_header(\"Content-Length\", content_length)\n\n        if include_body:\n            content = self.get_content(self.absolute_path, start, end)\n            if isinstance(content, bytes):\n                content = [content]\n            for chunk in content:\n                try:\n                    self.write(chunk)\n                    await self.flush()\n                except iostream.StreamClosedError:\n                    return\n        else:\n            assert self.request.method == \"HEAD\"",
        "begin_line": 2573,
        "end_line": 2654,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.compute_etag#2656",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.compute_etag(self)",
        "snippet": "    def compute_etag(self) -> Optional[str]:\n        \"\"\"Sets the ``Etag`` header based on static url version.\n\n        This allows efficient ``If-None-Match`` checks against cached\n        versions, and sends the correct ``Etag`` for a partial response\n        (i.e. the same ``Etag`` as the full file).\n\n        .. versionadded:: 3.1\n        \"\"\"\n        assert self.absolute_path is not None\n        version_hash = self._get_cached_version(self.absolute_path)\n        if not version_hash:\n            return None\n        return '\"%s\"' % (version_hash,)",
        "begin_line": 2656,
        "end_line": 2669,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001588057805304113,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.set_headers#2671",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.set_headers(self)",
        "snippet": "    def set_headers(self) -> None:\n        \"\"\"Sets the content and caching headers on the response.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        self.set_header(\"Accept-Ranges\", \"bytes\")\n        self.set_etag_header()\n\n        if self.modified is not None:\n            self.set_header(\"Last-Modified\", self.modified)\n\n        content_type = self.get_content_type()\n        if content_type:\n            self.set_header(\"Content-Type\", content_type)\n\n        cache_time = self.get_cache_time(self.path, self.modified, content_type)\n        if cache_time > 0:\n            self.set_header(\n                \"Expires\",\n                datetime.datetime.utcnow() + datetime.timedelta(seconds=cache_time),\n            )\n            self.set_header(\"Cache-Control\", \"max-age=\" + str(cache_time))\n\n        self.set_extra_headers(self.path)",
        "begin_line": 2671,
        "end_line": 2694,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016074586079408456,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.should_return_304#2696",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.should_return_304(self)",
        "snippet": "    def should_return_304(self) -> bool:\n        \"\"\"Returns True if the headers indicate that we should return 304.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        # If client sent If-None-Match, use it, ignore If-Modified-Since\n        if self.request.headers.get(\"If-None-Match\"):\n            return self.check_etag_header()\n\n        # Check the If-Modified-Since, and don't send the result if the\n        # content has not been modified\n        ims_value = self.request.headers.get(\"If-Modified-Since\")\n        if ims_value is not None:\n            date_tuple = email.utils.parsedate(ims_value)\n            if date_tuple is not None:\n                if_since = datetime.datetime(*date_tuple[:6])\n                assert self.modified is not None\n                if if_since >= self.modified:\n                    return True\n\n        return False",
        "begin_line": 2696,
        "end_line": 2716,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_absolute_path#2719",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_absolute_path(cls, root: str, path: str)",
        "snippet": "    def get_absolute_path(cls, root: str, path: str) -> str:\n        \"\"\"Returns the absolute location of ``path`` relative to ``root``.\n\n        ``root`` is the path configured for this `StaticFileHandler`\n        (in most cases the ``static_path`` `Application` setting).\n\n        This class method may be overridden in subclasses.  By default\n        it returns a filesystem path, but other strings may be used\n        as long as they are unique and understood by the subclass's\n        overridden `get_content`.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        abspath = os.path.abspath(os.path.join(root, path))\n        return abspath",
        "begin_line": 2719,
        "end_line": 2733,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015382248884786957,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.validate_absolute_path#2735",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.validate_absolute_path(self, root: str, absolute_path: str)",
        "snippet": "    def validate_absolute_path(self, root: str, absolute_path: str) -> Optional[str]:\n        \"\"\"Validate and return the absolute path.\n\n        ``root`` is the configured path for the `StaticFileHandler`,\n        and ``path`` is the result of `get_absolute_path`\n\n        This is an instance method called during request processing,\n        so it may raise `HTTPError` or use methods like\n        `RequestHandler.redirect` (return None after redirecting to\n        halt further processing).  This is where 404 errors for missing files\n        are generated.\n\n        This method may modify the path before returning it, but note that\n        any such modifications will not be understood by `make_static_url`.\n\n        In instance methods, this method's result is available as\n        ``self.absolute_path``.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        # os.path.abspath strips a trailing /.\n        # We must add it back to `root` so that we only match files\n        # in a directory named `root` instead of files starting with\n        # that prefix.\n        root = os.path.abspath(root)\n        if not root.endswith(os.path.sep):\n            # abspath always removes a trailing slash, except when\n            # root is '/'. This is an unusual case, but several projects\n            # have independently discovered this technique to disable\n            # Tornado's path validation and (hopefully) do their own,\n            # so we need to support it.\n            root += os.path.sep\n        # The trailing slash also needs to be temporarily added back\n        # the requested path so a request to root/ will match.\n        if not (absolute_path + os.path.sep).startswith(root):\n            raise HTTPError(403, \"%s is not in root static directory\", self.path)\n        if os.path.isdir(absolute_path) and self.default_filename is not None:\n            # need to look at the request.path here for when path is empty\n            # but there is some prefix to the path that was already\n            # trimmed by the routing\n            if not self.request.path.endswith(\"/\"):\n                self.redirect(self.request.path + \"/\", permanent=True)\n                return None\n            absolute_path = os.path.join(absolute_path, self.default_filename)\n        if not os.path.exists(absolute_path):\n            raise HTTPError(404)\n        if not os.path.isfile(absolute_path):\n            raise HTTPError(403, \"%s is not a file\", self.path)\n        return absolute_path",
        "begin_line": 2735,
        "end_line": 2783,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_content#2786",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_content(cls, abspath: str, start: int=None, end: int=None)",
        "snippet": "    def get_content(\n        cls, abspath: str, start: int = None, end: int = None\n    ) -> Generator[bytes, None, None]:\n        \"\"\"Retrieve the content of the requested resource which is located\n        at the given absolute path.\n\n        This class method may be overridden by subclasses.  Note that its\n        signature is different from other overridable class methods\n        (no ``settings`` argument); this is deliberate to ensure that\n        ``abspath`` is able to stand on its own as a cache key.\n\n        This method should either return a byte string or an iterator\n        of byte strings.  The latter is preferred for large files\n        as it helps reduce memory fragmentation.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        with open(abspath, \"rb\") as file:\n            if start is not None:\n                file.seek(start)\n            if end is not None:\n                remaining = end - (start or 0)  # type: Optional[int]\n            else:\n                remaining = None\n            while True:\n                chunk_size = 64 * 1024\n                if remaining is not None and remaining < chunk_size:\n                    chunk_size = remaining\n                chunk = file.read(chunk_size)\n                if chunk:\n                    if remaining is not None:\n                        remaining -= len(chunk)\n                    yield chunk\n                else:\n                    if remaining is not None:\n                        assert remaining == 0\n                    return",
        "begin_line": 2786,
        "end_line": 2822,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_content_version#2825",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_content_version(cls, abspath: str)",
        "snippet": "    def get_content_version(cls, abspath: str) -> str:\n        \"\"\"Returns a version string for the resource at the given path.\n\n        This class method may be overridden by subclasses.  The\n        default implementation is a hash of the file's contents.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        data = cls.get_content(abspath)\n        hasher = hashlib.md5()\n        if isinstance(data, bytes):\n            hasher.update(data)\n        else:\n            for chunk in data:\n                hasher.update(chunk)\n        return hasher.hexdigest()",
        "begin_line": 2825,
        "end_line": 2840,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler._stat#2842",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler._stat(self)",
        "snippet": "    def _stat(self) -> os.stat_result:\n        assert self.absolute_path is not None\n        if not hasattr(self, \"_stat_result\"):\n            self._stat_result = os.stat(self.absolute_path)\n        return self._stat_result",
        "begin_line": 2842,
        "end_line": 2846,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016074586079408456,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_content_size#2848",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_content_size(self)",
        "snippet": "    def get_content_size(self) -> int:\n        \"\"\"Retrieve the total size of the resource at the given path.\n\n        This method may be overridden by subclasses.\n\n        .. versionadded:: 3.1\n\n        .. versionchanged:: 4.0\n           This method is now always called, instead of only when\n           partial results are requested.\n        \"\"\"\n        stat_result = self._stat()\n        return stat_result.st_size",
        "begin_line": 2848,
        "end_line": 2860,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016144656118824668,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_modified_time#2862",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_modified_time(self)",
        "snippet": "    def get_modified_time(self) -> Optional[datetime.datetime]:\n        \"\"\"Returns the time that ``self.absolute_path`` was last modified.\n\n        May be overridden in subclasses.  Should return a `~datetime.datetime`\n        object or None.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        stat_result = self._stat()\n        # NOTE: Historically, this used stat_result[stat.ST_MTIME],\n        # which truncates the fractional portion of the timestamp. It\n        # was changed from that form to stat_result.st_mtime to\n        # satisfy mypy (which disallows the bracket operator), but the\n        # latter form returns a float instead of an int. For\n        # consistency with the past (and because we have a unit test\n        # that relies on this), we truncate the float here, although\n        # I'm not sure that's the right thing to do.\n        modified = datetime.datetime.utcfromtimestamp(int(stat_result.st_mtime))\n        return modified",
        "begin_line": 2862,
        "end_line": 2880,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016074586079408456,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_content_type#2882",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_content_type(self)",
        "snippet": "    def get_content_type(self) -> str:\n        \"\"\"Returns the ``Content-Type`` header to be used for this request.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        assert self.absolute_path is not None\n        mime_type, encoding = mimetypes.guess_type(self.absolute_path)\n        # per RFC 6713, use the appropriate type for a gzip compressed file\n        if encoding == \"gzip\":\n            return \"application/gzip\"\n        # As of 2015-07-21 there is no bzip2 encoding defined at\n        # http://www.iana.org/assignments/media-types/media-types.xhtml\n        # So for that (and any other encoding), use octet-stream.\n        elif encoding is not None:\n            return \"application/octet-stream\"\n        elif mime_type is not None:\n            return mime_type\n        # if mime_type not detected, use application/octet-stream\n        else:\n            return \"application/octet-stream\"",
        "begin_line": 2882,
        "end_line": 2901,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.set_extra_headers#2903",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.set_extra_headers(self, path: str)",
        "snippet": "    def set_extra_headers(self, path: str) -> None:\n        \"\"\"For subclass to add extra headers to the response\"\"\"\n        pass",
        "begin_line": 2903,
        "end_line": 2905,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001588057805304113,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_cache_time#2907",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_cache_time(self, path: str, modified: Optional[datetime.datetime], mime_type: str)",
        "snippet": "    def get_cache_time(\n        self, path: str, modified: Optional[datetime.datetime], mime_type: str\n    ) -> int:\n        \"\"\"Override to customize cache control behavior.\n\n        Return a positive number of seconds to make the result\n        cacheable for that amount of time or 0 to mark resource as\n        cacheable for an unspecified amount of time (subject to\n        browser heuristics).\n\n        By default returns cache expiry of 10 years for resources requested\n        with ``v`` argument.\n        \"\"\"\n        return self.CACHE_MAX_AGE if \"v\" in self.request.arguments else 0",
        "begin_line": 2907,
        "end_line": 2920,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001588057805304113,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.make_static_url#2923",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.make_static_url(cls, settings: Dict[str, Any], path: str, include_version: bool=True)",
        "snippet": "    def make_static_url(\n        cls, settings: Dict[str, Any], path: str, include_version: bool = True\n    ) -> str:\n        \"\"\"Constructs a versioned url for the given path.\n\n        This method may be overridden in subclasses (but note that it\n        is a class method rather than an instance method).  Subclasses\n        are only required to implement the signature\n        ``make_static_url(cls, settings, path)``; other keyword\n        arguments may be passed through `~RequestHandler.static_url`\n        but are not standard.\n\n        ``settings`` is the `Application.settings` dictionary.  ``path``\n        is the static path being requested.  The url returned should be\n        relative to the current host.\n\n        ``include_version`` determines whether the generated URL should\n        include the query string containing the version hash of the\n        file corresponding to the given ``path``.\n\n        \"\"\"\n        url = settings.get(\"static_url_prefix\", \"/static/\") + path\n        if not include_version:\n            return url\n\n        version_hash = cls.get_version(settings, path)\n        if not version_hash:\n            return url\n\n        return \"%s?v=%s\" % (url, version_hash)",
        "begin_line": 2923,
        "end_line": 2952,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.parse_url_path#2954",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.parse_url_path(self, url_path: str)",
        "snippet": "    def parse_url_path(self, url_path: str) -> str:\n        \"\"\"Converts a static URL path into a filesystem path.\n\n        ``url_path`` is the path component of the URL with\n        ``static_url_prefix`` removed.  The return value should be\n        filesystem path relative to ``static_path``.\n\n        This is the inverse of `make_static_url`.\n        \"\"\"\n        if os.path.sep != \"/\":\n            url_path = url_path.replace(\"/\", os.path.sep)\n        return url_path",
        "begin_line": 2954,
        "end_line": 2965,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015603058199407084,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_version#2968",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_version(cls, settings: Dict[str, Any], path: str)",
        "snippet": "    def get_version(cls, settings: Dict[str, Any], path: str) -> Optional[str]:\n        \"\"\"Generate the version string to be used in static URLs.\n\n        ``settings`` is the `Application.settings` dictionary and ``path``\n        is the relative location of the requested asset on the filesystem.\n        The returned value should be a string, or ``None`` if no version\n        could be determined.\n\n        .. versionchanged:: 3.1\n           This method was previously recommended for subclasses to override;\n           `get_content_version` is now preferred as it allows the base\n           class to handle caching of the result.\n        \"\"\"\n        abs_path = cls.get_absolute_path(settings[\"static_path\"], path)\n        return cls._get_cached_version(abs_path)",
        "begin_line": 2968,
        "end_line": 2982,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.StaticFileHandler._get_cached_version#2985",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler._get_cached_version(cls, abs_path: str)",
        "snippet": "    def _get_cached_version(cls, abs_path: str) -> Optional[str]:\n        with cls._lock:\n            hashes = cls._static_hashes\n            if abs_path not in hashes:\n                try:\n                    hashes[abs_path] = cls.get_content_version(abs_path)\n                except Exception:\n                    gen_log.error(\"Could not open static file %r\", abs_path)\n                    hashes[abs_path] = None\n            hsh = hashes.get(abs_path)\n            if hsh:\n                return hsh\n        return None",
        "begin_line": 2985,
        "end_line": 2997,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.GZipContentEncoding.__init__#3087",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.GZipContentEncoding",
        "signature": "tornado.web.GZipContentEncoding.__init__(self, request: httputil.HTTPServerRequest)",
        "snippet": "    def __init__(self, request: httputil.HTTPServerRequest) -> None:\n        self._gzipping = \"gzip\" in request.headers.get(\"Accept-Encoding\", \"\")",
        "begin_line": 3087,
        "end_line": 3088,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042176296921130323,
            "pseudo_dstar_susp": 0.0004310344827586207,
            "pseudo_tarantula_susp": 0.000449842555105713,
            "pseudo_op2_susp": 0.0004310344827586207,
            "pseudo_barinel_susp": 0.000449842555105713
        }
    },
    {
        "name": "tornado.web.GZipContentEncoding._compressible_type#3090",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.GZipContentEncoding",
        "signature": "tornado.web.GZipContentEncoding._compressible_type(self, ctype: str)",
        "snippet": "    def _compressible_type(self, ctype: str) -> bool:\n        return ctype.startswith(\"text/\") or ctype in self.CONTENT_TYPES",
        "begin_line": 3090,
        "end_line": 3091,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00013914011409489355,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.GZipContentEncoding.transform_first_chunk#3093",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.GZipContentEncoding",
        "signature": "tornado.web.GZipContentEncoding.transform_first_chunk(self, status_code: int, headers: httputil.HTTPHeaders, chunk: bytes, finishing: bool)",
        "snippet": "    def transform_first_chunk(\n        self,\n        status_code: int,\n        headers: httputil.HTTPHeaders,\n        chunk: bytes,\n        finishing: bool,\n    ) -> Tuple[int, httputil.HTTPHeaders, bytes]:\n        # TODO: can/should this type be inherited from the superclass?\n        if \"Vary\" in headers:\n            headers[\"Vary\"] += \", Accept-Encoding\"\n        else:\n            headers[\"Vary\"] = \"Accept-Encoding\"\n        if self._gzipping:\n            ctype = _unicode(headers.get(\"Content-Type\", \"\")).split(\";\")[0]\n            self._gzipping = (\n                self._compressible_type(ctype)\n                and (not finishing or len(chunk) >= self.MIN_LENGTH)\n                and (\"Content-Encoding\" not in headers)\n            )\n        if self._gzipping:\n            headers[\"Content-Encoding\"] = \"gzip\"\n            self._gzip_value = BytesIO()\n            self._gzip_file = gzip.GzipFile(\n                mode=\"w\", fileobj=self._gzip_value, compresslevel=self.GZIP_LEVEL\n            )\n            chunk = self.transform_chunk(chunk, finishing)\n            if \"Content-Length\" in headers:\n                # The original content length is no longer correct.\n                # If this is the last (and only) chunk, we can set the new\n                # content-length; otherwise we remove it and fall back to\n                # chunked encoding.\n                if finishing:\n                    headers[\"Content-Length\"] = str(len(chunk))\n                else:\n                    del headers[\"Content-Length\"]\n        return status_code, headers, chunk",
        "begin_line": 3093,
        "end_line": 3128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.GZipContentEncoding.transform_chunk#3130",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.GZipContentEncoding",
        "signature": "tornado.web.GZipContentEncoding.transform_chunk(self, chunk: bytes, finishing: bool)",
        "snippet": "    def transform_chunk(self, chunk: bytes, finishing: bool) -> bytes:\n        if self._gzipping:\n            self._gzip_file.write(chunk)\n            if finishing:\n                self._gzip_file.close()\n            else:\n                self._gzip_file.flush()\n            chunk = self._gzip_value.getvalue()\n            self._gzip_value.truncate(0)\n            self._gzip_value.seek(0)\n        return chunk",
        "begin_line": 3130,
        "end_line": 3140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001892863903085368,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.authenticated#3143",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.authenticated(method: Callable[..., Optional[Awaitable[None]]])",
        "snippet": "def authenticated(\n    method: Callable[..., Optional[Awaitable[None]]]\n) -> Callable[..., Optional[Awaitable[None]]]:\n    \"\"\"Decorate methods with this to require that the user be logged in.\n\n    If the user is not logged in, they will be redirected to the configured\n    `login url <RequestHandler.get_login_url>`.\n\n    If you configure a login url with a query parameter, Tornado will\n    assume you know what you're doing and use it as-is.  If not, it\n    will add a `next` parameter so the login page knows where to send\n    you once you're logged in.\n    \"\"\"\n\n    @functools.wraps(method)\n    def wrapper(  # type: ignore\n        self: RequestHandler, *args, **kwargs\n    ) -> Optional[Awaitable[None]]:\n        if not self.current_user:\n            if self.request.method in (\"GET\", \"HEAD\"):\n                url = self.get_login_url()\n                if \"?\" not in url:\n                    if urllib.parse.urlsplit(url).scheme:\n                        # if login url is absolute, make next absolute too\n                        next_url = self.request.full_url()\n                    else:\n                        assert self.request.uri is not None\n                        next_url = self.request.uri\n                    url += \"?\" + urlencode(dict(next=next_url))\n                self.redirect(url)\n                return None\n            raise HTTPError(403)\n        return method(self, *args, **kwargs)\n\n    return wrapper",
        "begin_line": 3143,
        "end_line": 3177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.wrapper#3158",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.wrapper(self: RequestHandler, *args, **kwargs)",
        "snippet": "    def wrapper(  # type: ignore\n        self: RequestHandler, *args, **kwargs\n    ) -> Optional[Awaitable[None]]:\n        if not self.current_user:\n            if self.request.method in (\"GET\", \"HEAD\"):\n                url = self.get_login_url()\n                if \"?\" not in url:\n                    if urllib.parse.urlsplit(url).scheme:\n                        # if login url is absolute, make next absolute too\n                        next_url = self.request.full_url()\n                    else:\n                        assert self.request.uri is not None\n                        next_url = self.request.uri\n                    url += \"?\" + urlencode(dict(next=next_url))\n                self.redirect(url)\n                return None\n            raise HTTPError(403)\n        return method(self, *args, **kwargs)",
        "begin_line": 3158,
        "end_line": 3175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.UIModule.__init__#3190",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.__init__(self, handler: RequestHandler)",
        "snippet": "    def __init__(self, handler: RequestHandler) -> None:\n        self.handler = handler\n        self.request = handler.request\n        self.ui = handler.ui\n        self.locale = handler.locale",
        "begin_line": 3190,
        "end_line": 3194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.UIModule.current_user#3197",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.current_user(self)",
        "snippet": "    def current_user(self) -> Any:\n        return self.handler.current_user",
        "begin_line": 3197,
        "end_line": 3198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.UIModule.embedded_javascript#3204",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.embedded_javascript(self)",
        "snippet": "    def embedded_javascript(self) -> Optional[str]:\n        \"\"\"Override to return a JavaScript string\n        to be embedded in the page.\"\"\"\n        return None",
        "begin_line": 3204,
        "end_line": 3207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.UIModule.javascript_files#3209",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.javascript_files(self)",
        "snippet": "    def javascript_files(self) -> Optional[Iterable[str]]:\n        \"\"\"Override to return a list of JavaScript files needed by this module.\n\n        If the return values are relative paths, they will be passed to\n        `RequestHandler.static_url`; otherwise they will be used as-is.\n        \"\"\"\n        return None",
        "begin_line": 3209,
        "end_line": 3215,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.UIModule.embedded_css#3217",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.embedded_css(self)",
        "snippet": "    def embedded_css(self) -> Optional[str]:\n        \"\"\"Override to return a CSS string\n        that will be embedded in the page.\"\"\"\n        return None",
        "begin_line": 3217,
        "end_line": 3220,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.UIModule.css_files#3222",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.css_files(self)",
        "snippet": "    def css_files(self) -> Optional[Iterable[str]]:\n        \"\"\"Override to returns a list of CSS files required by this module.\n\n        If the return values are relative paths, they will be passed to\n        `RequestHandler.static_url`; otherwise they will be used as-is.\n        \"\"\"\n        return None",
        "begin_line": 3222,
        "end_line": 3228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.UIModule.html_head#3230",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.html_head(self)",
        "snippet": "    def html_head(self) -> Optional[str]:\n        \"\"\"Override to return an HTML string that will be put in the <head/>\n        element.\n        \"\"\"\n        return None",
        "begin_line": 3230,
        "end_line": 3234,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.UIModule.html_body#3236",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.html_body(self)",
        "snippet": "    def html_body(self) -> Optional[str]:\n        \"\"\"Override to return an HTML string that will be put at the end of\n        the <body/> element.\n        \"\"\"\n        return None",
        "begin_line": 3236,
        "end_line": 3240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.UIModule.render_string#3242",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.render_string(self, path: str, **kwargs: Any)",
        "snippet": "    def render_string(self, path: str, **kwargs: Any) -> bytes:\n        \"\"\"Renders a template and returns it as a string.\"\"\"\n        return self.handler.render_string(path, **kwargs)",
        "begin_line": 3242,
        "end_line": 3244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web._linkify.render#3248",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._linkify",
        "signature": "tornado.web._linkify.render(self, text: str, **kwargs: Any)",
        "snippet": "    def render(self, text: str, **kwargs: Any) -> str:  # type: ignore\n        return escape.linkify(text, **kwargs)",
        "begin_line": 3248,
        "end_line": 3249,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.TemplateModule.__init__#3273",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.__init__(self, handler: RequestHandler)",
        "snippet": "    def __init__(self, handler: RequestHandler) -> None:\n        super(TemplateModule, self).__init__(handler)\n        # keep resources in both a list and a dict to preserve order\n        self._resource_list = []  # type: List[Dict[str, Any]]\n        self._resource_dict = {}  # type: Dict[str, Dict[str, Any]]",
        "begin_line": 3273,
        "end_line": 3277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.TemplateModule.render#3279",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.render(self, path: str, **kwargs: Any)",
        "snippet": "    def render(self, path: str, **kwargs: Any) -> bytes:  # type: ignore\n        def set_resources(**kwargs) -> str:  # type: ignore\n            if path not in self._resource_dict:\n                self._resource_list.append(kwargs)\n                self._resource_dict[path] = kwargs\n            else:\n                if self._resource_dict[path] != kwargs:\n                    raise ValueError(\n                        \"set_resources called with different \"\n                        \"resources for the same template\"\n                    )\n            return \"\"\n\n        return self.render_string(path, set_resources=set_resources, **kwargs)",
        "begin_line": 3279,
        "end_line": 3292,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.TemplateModule.set_resources#3280",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.set_resources(**kwargs)",
        "snippet": "        def set_resources(**kwargs) -> str:  # type: ignore\n            if path not in self._resource_dict:\n                self._resource_list.append(kwargs)\n                self._resource_dict[path] = kwargs\n            else:\n                if self._resource_dict[path] != kwargs:\n                    raise ValueError(\n                        \"set_resources called with different \"\n                        \"resources for the same template\"\n                    )\n            return \"\"",
        "begin_line": 3280,
        "end_line": 3290,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.TemplateModule._get_resources#3294",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule._get_resources(self, key: str)",
        "snippet": "    def _get_resources(self, key: str) -> Iterable[str]:\n        return (r[key] for r in self._resource_list if key in r)",
        "begin_line": 3294,
        "end_line": 3295,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.TemplateModule.embedded_javascript#3297",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.embedded_javascript(self)",
        "snippet": "    def embedded_javascript(self) -> str:\n        return \"\\n\".join(self._get_resources(\"embedded_javascript\"))",
        "begin_line": 3297,
        "end_line": 3298,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.TemplateModule.javascript_files#3300",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.javascript_files(self)",
        "snippet": "    def javascript_files(self) -> Iterable[str]:\n        result = []\n        for f in self._get_resources(\"javascript_files\"):\n            if isinstance(f, (unicode_type, bytes)):\n                result.append(f)\n            else:\n                result.extend(f)\n        return result",
        "begin_line": 3300,
        "end_line": 3307,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.TemplateModule.embedded_css#3309",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.embedded_css(self)",
        "snippet": "    def embedded_css(self) -> str:\n        return \"\\n\".join(self._get_resources(\"embedded_css\"))",
        "begin_line": 3309,
        "end_line": 3310,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.TemplateModule.css_files#3312",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.css_files(self)",
        "snippet": "    def css_files(self) -> Iterable[str]:\n        result = []\n        for f in self._get_resources(\"css_files\"):\n            if isinstance(f, (unicode_type, bytes)):\n                result.append(f)\n            else:\n                result.extend(f)\n        return result",
        "begin_line": 3312,
        "end_line": 3319,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.TemplateModule.html_head#3321",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.html_head(self)",
        "snippet": "    def html_head(self) -> str:\n        return \"\".join(self._get_resources(\"html_head\"))",
        "begin_line": 3321,
        "end_line": 3322,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.TemplateModule.html_body#3324",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.html_body(self)",
        "snippet": "    def html_body(self) -> str:\n        return \"\".join(self._get_resources(\"html_body\"))",
        "begin_line": 3324,
        "end_line": 3325,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web._UIModuleNamespace.__init__#3331",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._UIModuleNamespace",
        "signature": "tornado.web._UIModuleNamespace.__init__(self, handler: RequestHandler, ui_modules: Dict[str, Type[UIModule]])",
        "snippet": "    def __init__(\n        self, handler: RequestHandler, ui_modules: Dict[str, Type[UIModule]]\n    ) -> None:\n        self.handler = handler\n        self.ui_modules = ui_modules",
        "begin_line": 3331,
        "end_line": 3335,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000496031746031746,
            "pseudo_dstar_susp": 0.0005491488193300384,
            "pseudo_tarantula_susp": 0.0004597701149425287,
            "pseudo_op2_susp": 0.0005491488193300384,
            "pseudo_barinel_susp": 0.0004597701149425287
        }
    },
    {
        "name": "tornado.web._UIModuleNamespace.__getitem__#3337",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._UIModuleNamespace",
        "signature": "tornado.web._UIModuleNamespace.__getitem__(self, key: str)",
        "snippet": "    def __getitem__(self, key: str) -> Callable[..., str]:\n        return self.handler._ui_module(key, self.ui_modules[key])",
        "begin_line": 3337,
        "end_line": 3338,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web._UIModuleNamespace.__getattr__#3340",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._UIModuleNamespace",
        "signature": "tornado.web._UIModuleNamespace.__getattr__(self, key: str)",
        "snippet": "    def __getattr__(self, key: str) -> Callable[..., str]:\n        try:\n            return self[key]\n        except KeyError as e:\n            raise AttributeError(str(e))",
        "begin_line": 3340,
        "end_line": 3344,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.create_signed_value#3347",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.create_signed_value(secret: _CookieSecretTypes, name: str, value: Union[str, bytes], version: int=None, clock: Callable[[], float]=None, key_version: int=None)",
        "snippet": "def create_signed_value(\n    secret: _CookieSecretTypes,\n    name: str,\n    value: Union[str, bytes],\n    version: int = None,\n    clock: Callable[[], float] = None,\n    key_version: int = None,\n) -> bytes:\n    if version is None:\n        version = DEFAULT_SIGNED_VALUE_VERSION\n    if clock is None:\n        clock = time.time\n\n    timestamp = utf8(str(int(clock())))\n    value = base64.b64encode(utf8(value))\n    if version == 1:\n        assert not isinstance(secret, dict)\n        signature = _create_signature_v1(secret, name, value, timestamp)\n        value = b\"|\".join([value, timestamp, signature])\n        return value\n    elif version == 2:\n        # The v2 format consists of a version number and a series of\n        # length-prefixed fields \"%d:%s\", the last of which is a\n        # signature, all separated by pipes.  All numbers are in\n        # decimal format with no leading zeros.  The signature is an\n        # HMAC-SHA256 of the whole string up to that point, including\n        # the final pipe.\n        #\n        # The fields are:\n        # - format version (i.e. 2; no length prefix)\n        # - key version (integer, default is 0)\n        # - timestamp (integer seconds since epoch)\n        # - name (not encoded; assumed to be ~alphanumeric)\n        # - value (base64-encoded)\n        # - signature (hex-encoded; no length prefix)\n        def format_field(s: Union[str, bytes]) -> bytes:\n            return utf8(\"%d:\" % len(s)) + utf8(s)\n\n        to_sign = b\"|\".join(\n            [\n                b\"2\",\n                format_field(str(key_version or 0)),\n                format_field(timestamp),\n                format_field(name),\n                format_field(value),\n                b\"\",\n            ]\n        )\n\n        if isinstance(secret, dict):\n            assert (\n                key_version is not None\n            ), \"Key version must be set when sign key dict is used\"\n            assert version >= 2, \"Version must be at least 2 for key version support\"\n            secret = secret[key_version]\n\n        signature = _create_signature_v2(secret, to_sign)\n        return to_sign + signature\n    else:\n        raise ValueError(\"Unsupported version %d\" % version)",
        "begin_line": 3347,
        "end_line": 3406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.format_field#3382",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.format_field(s: Union[str, bytes])",
        "snippet": "        def format_field(s: Union[str, bytes]) -> bytes:\n            return utf8(\"%d:\" % len(s)) + utf8(s)",
        "begin_line": 3382,
        "end_line": 3383,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017029972752043596,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web._get_version#3414",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._get_version(value: bytes)",
        "snippet": "def _get_version(value: bytes) -> int:\n    # Figures out what version value is.  Version 1 did not include an\n    # explicit version field and started with arbitrary base64 data,\n    # which makes this tricky.\n    m = _signed_value_version_re.match(value)\n    if m is None:\n        version = 1\n    else:\n        try:\n            version = int(m.group(1))\n            if version > 999:\n                # Certain payloads from the version-less v1 format may\n                # be parsed as valid integers.  Due to base64 padding\n                # restrictions, this can only happen for numbers whose\n                # length is a multiple of 4, so we can treat all\n                # numbers up to 999 as versions, and for the rest we\n                # fall back to v1 format.\n                version = 1\n        except ValueError:\n            version = 1\n    return version",
        "begin_line": 3414,
        "end_line": 3434,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.decode_signed_value#3437",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.decode_signed_value(secret: _CookieSecretTypes, name: str, value: Union[None, str, bytes], max_age_days: int=31, clock: Callable[[], float]=None, min_version: int=None)",
        "snippet": "def decode_signed_value(\n    secret: _CookieSecretTypes,\n    name: str,\n    value: Union[None, str, bytes],\n    max_age_days: int = 31,\n    clock: Callable[[], float] = None,\n    min_version: int = None,\n) -> Optional[bytes]:\n    if clock is None:\n        clock = time.time\n    if min_version is None:\n        min_version = DEFAULT_SIGNED_VALUE_MIN_VERSION\n    if min_version > 2:\n        raise ValueError(\"Unsupported min_version %d\" % min_version)\n    if not value:\n        return None\n\n    value = utf8(value)\n    version = _get_version(value)\n\n    if version < min_version:\n        return None\n    if version == 1:\n        assert not isinstance(secret, dict)\n        return _decode_signed_value_v1(secret, name, value, max_age_days, clock)\n    elif version == 2:\n        return _decode_signed_value_v2(secret, name, value, max_age_days, clock)\n    else:\n        return None",
        "begin_line": 3437,
        "end_line": 3465,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web._decode_signed_value_v1#3468",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._decode_signed_value_v1(secret: Union[str, bytes], name: str, value: bytes, max_age_days: int, clock: Callable[[], float])",
        "snippet": "def _decode_signed_value_v1(\n    secret: Union[str, bytes],\n    name: str,\n    value: bytes,\n    max_age_days: int,\n    clock: Callable[[], float],\n) -> Optional[bytes]:\n    parts = utf8(value).split(b\"|\")\n    if len(parts) != 3:\n        return None\n    signature = _create_signature_v1(secret, name, parts[0], parts[1])\n    if not hmac.compare_digest(parts[2], signature):\n        gen_log.warning(\"Invalid cookie signature %r\", value)\n        return None\n    timestamp = int(parts[1])\n    if timestamp < clock() - max_age_days * 86400:\n        gen_log.warning(\"Expired cookie %r\", value)\n        return None\n    if timestamp > clock() + 31 * 86400:\n        # _cookie_signature does not hash a delimiter between the\n        # parts of the cookie, so an attacker could transfer trailing\n        # digits from the payload to the timestamp without altering the\n        # signature.  For backwards compatibility, sanity-check timestamp\n        # here instead of modifying _cookie_signature.\n        gen_log.warning(\"Cookie timestamp in future; possible tampering %r\", value)\n        return None\n    if parts[1].startswith(b\"0\"):\n        gen_log.warning(\"Tampered cookie %r\", value)\n        return None\n    try:\n        return base64.b64decode(parts[0])\n    except Exception:\n        return None",
        "begin_line": 3468,
        "end_line": 3500,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web._decode_fields_v2#3503",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._decode_fields_v2(value: bytes)",
        "snippet": "def _decode_fields_v2(value: bytes) -> Tuple[int, bytes, bytes, bytes, bytes]:\n    def _consume_field(s: bytes) -> Tuple[bytes, bytes]:\n        length, _, rest = s.partition(b\":\")\n        n = int(length)\n        field_value = rest[:n]\n        # In python 3, indexing bytes returns small integers; we must\n        # use a slice to get a byte string as in python 2.\n        if rest[n : n + 1] != b\"|\":\n            raise ValueError(\"malformed v2 signed value field\")\n        rest = rest[n + 1 :]\n        return field_value, rest\n\n    rest = value[2:]  # remove version number\n    key_version, rest = _consume_field(rest)\n    timestamp, rest = _consume_field(rest)\n    name_field, rest = _consume_field(rest)\n    value_field, passed_sig = _consume_field(rest)\n    return int(key_version), timestamp, name_field, value_field, passed_sig",
        "begin_line": 3503,
        "end_line": 3520,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016700066800267202,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web._consume_field#3504",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._consume_field(s: bytes)",
        "snippet": "    def _consume_field(s: bytes) -> Tuple[bytes, bytes]:\n        length, _, rest = s.partition(b\":\")\n        n = int(length)\n        field_value = rest[:n]\n        # In python 3, indexing bytes returns small integers; we must\n        # use a slice to get a byte string as in python 2.\n        if rest[n : n + 1] != b\"|\":\n            raise ValueError(\"malformed v2 signed value field\")\n        rest = rest[n + 1 :]\n        return field_value, rest",
        "begin_line": 3504,
        "end_line": 3513,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web._decode_signed_value_v2#3523",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._decode_signed_value_v2(secret: _CookieSecretTypes, name: str, value: bytes, max_age_days: int, clock: Callable[[], float])",
        "snippet": "def _decode_signed_value_v2(\n    secret: _CookieSecretTypes,\n    name: str,\n    value: bytes,\n    max_age_days: int,\n    clock: Callable[[], float],\n) -> Optional[bytes]:\n    try:\n        key_version, timestamp_bytes, name_field, value_field, passed_sig = _decode_fields_v2(\n            value\n        )\n    except ValueError:\n        return None\n    signed_string = value[: -len(passed_sig)]\n\n    if isinstance(secret, dict):\n        try:\n            secret = secret[key_version]\n        except KeyError:\n            return None\n\n    expected_sig = _create_signature_v2(secret, signed_string)\n    if not hmac.compare_digest(passed_sig, expected_sig):\n        return None\n    if name_field != utf8(name):\n        return None\n    timestamp = int(timestamp_bytes)\n    if timestamp < clock() - max_age_days * 86400:\n        # The signature has expired.\n        return None\n    try:\n        return base64.b64decode(value_field)\n    except Exception:\n        return None",
        "begin_line": 3523,
        "end_line": 3556,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.get_signature_key_version#3559",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.get_signature_key_version(value: Union[str, bytes])",
        "snippet": "def get_signature_key_version(value: Union[str, bytes]) -> Optional[int]:\n    value = utf8(value)\n    version = _get_version(value)\n    if version < 2:\n        return None\n    try:\n        key_version, _, _, _, _ = _decode_fields_v2(value)\n    except ValueError:\n        return None\n\n    return key_version",
        "begin_line": 3559,
        "end_line": 3569,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web._create_signature_v1#3572",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._create_signature_v1(secret: Union[str, bytes], *parts: Union[str, bytes])",
        "snippet": "def _create_signature_v1(secret: Union[str, bytes], *parts: Union[str, bytes]) -> bytes:\n    hash = hmac.new(utf8(secret), digestmod=hashlib.sha1)\n    for part in parts:\n        hash.update(utf8(part))\n    return utf8(hash.hexdigest())",
        "begin_line": 3572,
        "end_line": 3576,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web._create_signature_v2#3579",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._create_signature_v2(secret: Union[str, bytes], s: bytes)",
        "snippet": "def _create_signature_v2(secret: Union[str, bytes], s: bytes) -> bytes:\n    hash = hmac.new(utf8(secret), digestmod=hashlib.sha256)\n    hash.update(utf8(s))\n    return utf8(hash.hexdigest())",
        "begin_line": 3579,
        "end_line": 3582,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016700066800267202,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.web.is_absolute#3585",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.is_absolute(path: str)",
        "snippet": "def is_absolute(path: str) -> bool:\n    return any(path.startswith(x) for x in [\"/\", \"http:\", \"https:\"])",
        "begin_line": 3585,
        "end_line": 3586,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.wsgi.to_wsgi_str#50",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi",
        "signature": "tornado.wsgi.to_wsgi_str(s: bytes)",
        "snippet": "def to_wsgi_str(s: bytes) -> str:\n    assert isinstance(s, bytes)\n    return s.decode(\"latin1\")",
        "begin_line": 50,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.wsgi.WSGIContainer.__init__#90",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi.WSGIContainer",
        "signature": "tornado.wsgi.WSGIContainer.__init__(self, wsgi_application: 'WSGIAppType')",
        "snippet": "    def __init__(self, wsgi_application: \"WSGIAppType\") -> None:\n        self.wsgi_application = wsgi_application",
        "begin_line": 90,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.wsgi.WSGIContainer.__call__#93",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi.WSGIContainer",
        "signature": "tornado.wsgi.WSGIContainer.__call__(self, request: httputil.HTTPServerRequest)",
        "snippet": "    def __call__(self, request: httputil.HTTPServerRequest) -> None:\n        data = {}  # type: Dict[str, Any]\n        response = []  # type: List[bytes]\n\n        def start_response(\n            status: str,\n            headers: List[Tuple[str, str]],\n            exc_info: Optional[\n                Tuple[\n                    Optional[Type[BaseException]],\n                    Optional[BaseException],\n                    Optional[TracebackType],\n                ]\n            ] = None,\n        ) -> Callable[[bytes], Any]:\n            data[\"status\"] = status\n            data[\"headers\"] = headers\n            return response.append\n\n        app_response = self.wsgi_application(\n            WSGIContainer.environ(request), start_response\n        )\n        try:\n            response.extend(app_response)\n            body = b\"\".join(response)\n        finally:\n            if hasattr(app_response, \"close\"):\n                app_response.close()  # type: ignore\n        if not data:\n            raise Exception(\"WSGI app did not call start_response\")\n\n        status_code_str, reason = data[\"status\"].split(\" \", 1)\n        status_code = int(status_code_str)\n        headers = data[\"headers\"]  # type: List[Tuple[str, str]]\n        header_set = set(k.lower() for (k, v) in headers)\n        body = escape.utf8(body)\n        if status_code != 304:\n            if \"content-length\" not in header_set:\n                headers.append((\"Content-Length\", str(len(body))))\n            if \"content-type\" not in header_set:\n                headers.append((\"Content-Type\", \"text/html; charset=UTF-8\"))\n        if \"server\" not in header_set:\n            headers.append((\"Server\", \"TornadoServer/%s\" % tornado.version))\n\n        start_line = httputil.ResponseStartLine(\"HTTP/1.1\", status_code, reason)\n        header_obj = httputil.HTTPHeaders()\n        for key, value in headers:\n            header_obj.add(key, value)\n        assert request.connection is not None\n        request.connection.write_headers(start_line, header_obj, chunk=body)\n        request.connection.finish()\n        self._log(status_code, request)",
        "begin_line": 93,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.wsgi.WSGIContainer.start_response#97",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi.WSGIContainer",
        "signature": "tornado.wsgi.WSGIContainer.start_response(status: str, headers: List[Tuple[str, str]], exc_info: Optional[Tuple[Optional[Type[BaseException]], Optional[BaseException], Optional[TracebackType]]]=None)",
        "snippet": "        def start_response(\n            status: str,\n            headers: List[Tuple[str, str]],\n            exc_info: Optional[\n                Tuple[\n                    Optional[Type[BaseException]],\n                    Optional[BaseException],\n                    Optional[TracebackType],\n                ]\n            ] = None,\n        ) -> Callable[[bytes], Any]:\n            data[\"status\"] = status\n            data[\"headers\"] = headers\n            return response.append",
        "begin_line": 97,
        "end_line": 110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.wsgi.WSGIContainer.environ#147",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi.WSGIContainer",
        "signature": "tornado.wsgi.WSGIContainer.environ(request: httputil.HTTPServerRequest)",
        "snippet": "    def environ(request: httputil.HTTPServerRequest) -> Dict[Text, Any]:\n        \"\"\"Converts a `tornado.httputil.HTTPServerRequest` to a WSGI environment.\n        \"\"\"\n        hostport = request.host.split(\":\")\n        if len(hostport) == 2:\n            host = hostport[0]\n            port = int(hostport[1])\n        else:\n            host = request.host\n            port = 443 if request.protocol == \"https\" else 80\n        environ = {\n            \"REQUEST_METHOD\": request.method,\n            \"SCRIPT_NAME\": \"\",\n            \"PATH_INFO\": to_wsgi_str(\n                escape.url_unescape(request.path, encoding=None, plus=False)\n            ),\n            \"QUERY_STRING\": request.query,\n            \"REMOTE_ADDR\": request.remote_ip,\n            \"SERVER_NAME\": host,\n            \"SERVER_PORT\": str(port),\n            \"SERVER_PROTOCOL\": request.version,\n            \"wsgi.version\": (1, 0),\n            \"wsgi.url_scheme\": request.protocol,\n            \"wsgi.input\": BytesIO(escape.utf8(request.body)),\n            \"wsgi.errors\": sys.stderr,\n            \"wsgi.multithread\": False,\n            \"wsgi.multiprocess\": True,\n            \"wsgi.run_once\": False,\n        }\n        if \"Content-Type\" in request.headers:\n            environ[\"CONTENT_TYPE\"] = request.headers.pop(\"Content-Type\")\n        if \"Content-Length\" in request.headers:\n            environ[\"CONTENT_LENGTH\"] = request.headers.pop(\"Content-Length\")\n        for key, value in request.headers.items():\n            environ[\"HTTP_\" + key.replace(\"-\", \"_\").upper()] = value\n        return environ",
        "begin_line": 147,
        "end_line": 182,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.wsgi.WSGIContainer._log#184",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi.WSGIContainer",
        "signature": "tornado.wsgi.WSGIContainer._log(self, status_code: int, request: httputil.HTTPServerRequest)",
        "snippet": "    def _log(self, status_code: int, request: httputil.HTTPServerRequest) -> None:\n        if status_code < 400:\n            log_method = access_log.info\n        elif status_code < 500:\n            log_method = access_log.warning\n        else:\n            log_method = access_log.error\n        request_time = 1000.0 * request.request_time()\n        assert request.method is not None\n        assert request.uri is not None\n        summary = request.method + \" \" + request.uri + \" (\" + request.remote_ip + \")\"\n        log_method(\"%d %s %.2fms\", status_code, summary, request_time)",
        "begin_line": 184,
        "end_line": 195,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.log._safe_unicode#74",
        "src_path": "tornado/log.py",
        "class_name": "tornado.log",
        "signature": "tornado.log._safe_unicode(s: Any)",
        "snippet": "def _safe_unicode(s: Any) -> str:\n    try:\n        return _unicode(s)\n    except UnicodeDecodeError:\n        return repr(s)",
        "begin_line": 74,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017590149516270889,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.log.LogFormatter.__init__#115",
        "src_path": "tornado/log.py",
        "class_name": "tornado.log.LogFormatter",
        "signature": "tornado.log.LogFormatter.__init__(self, fmt: str=DEFAULT_FORMAT, datefmt: str=DEFAULT_DATE_FORMAT, style: str='%', color: bool=True, colors: Dict[int, int]=DEFAULT_COLORS)",
        "snippet": "    def __init__(\n        self,\n        fmt: str = DEFAULT_FORMAT,\n        datefmt: str = DEFAULT_DATE_FORMAT,\n        style: str = \"%\",\n        color: bool = True,\n        colors: Dict[int, int] = DEFAULT_COLORS,\n    ) -> None:\n        r\"\"\"\n        :arg bool color: Enables color support.\n        :arg str fmt: Log message format.\n          It will be applied to the attributes dict of log records. The\n          text between ``%(color)s`` and ``%(end_color)s`` will be colored\n          depending on the level if color support is on.\n        :arg dict colors: color mappings from logging level to terminal color\n          code\n        :arg str datefmt: Datetime format.\n          Used for formatting ``(asctime)`` placeholder in ``prefix_fmt``.\n\n        .. versionchanged:: 3.2\n\n           Added ``fmt`` and ``datefmt`` arguments.\n        \"\"\"\n        logging.Formatter.__init__(self, datefmt=datefmt)\n        self._fmt = fmt\n\n        self._colors = {}  # type: Dict[int, str]\n        if color and _stderr_supports_color():\n            if curses is not None:\n                fg_color = curses.tigetstr(\"setaf\") or curses.tigetstr(\"setf\") or b\"\"\n\n                for levelno, code in colors.items():\n                    # Convert the terminal control characters from\n                    # bytes to unicode strings for easier use with the\n                    # logging module.\n                    self._colors[levelno] = unicode_type(\n                        curses.tparm(fg_color, code), \"ascii\"\n                    )\n                self._normal = unicode_type(curses.tigetstr(\"sgr0\"), \"ascii\")\n            else:\n                # If curses is not present (currently we'll only get here for\n                # colorama on windows), assume hard-coded ANSI color codes.\n                for levelno, code in colors.items():\n                    self._colors[levelno] = \"\\033[2;3%dm\" % code\n                self._normal = \"\\033[0m\"\n        else:\n            self._normal = \"\"",
        "begin_line": 115,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017590149516270889,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.log.LogFormatter.format#163",
        "src_path": "tornado/log.py",
        "class_name": "tornado.log.LogFormatter",
        "signature": "tornado.log.LogFormatter.format(self, record: Any)",
        "snippet": "    def format(self, record: Any) -> str:\n        try:\n            message = record.getMessage()\n            assert isinstance(message, basestring_type)  # guaranteed by logging\n            # Encoding notes:  The logging module prefers to work with character\n            # strings, but only enforces that log messages are instances of\n            # basestring.  In python 2, non-ascii bytestrings will make\n            # their way through the logging framework until they blow up with\n            # an unhelpful decoding error (with this formatter it happens\n            # when we attach the prefix, but there are other opportunities for\n            # exceptions further along in the framework).\n            #\n            # If a byte string makes it this far, convert it to unicode to\n            # ensure it will make it out to the logs.  Use repr() as a fallback\n            # to ensure that all byte strings can be converted successfully,\n            # but don't do it by default so we don't add extra quotes to ascii\n            # bytestrings.  This is a bit of a hacky place to do this, but\n            # it's worth it since the encoding errors that would otherwise\n            # result are so useless (and tornado is fond of using utf8-encoded\n            # byte strings wherever possible).\n            record.message = _safe_unicode(message)\n        except Exception as e:\n            record.message = \"Bad message (%r): %r\" % (e, record.__dict__)\n\n        record.asctime = self.formatTime(record, cast(str, self.datefmt))\n\n        if record.levelno in self._colors:\n            record.color = self._colors[record.levelno]\n            record.end_color = self._normal\n        else:\n            record.color = record.end_color = \"\"\n\n        formatted = self._fmt % record.__dict__\n\n        if record.exc_info:\n            if not record.exc_text:\n                record.exc_text = self.formatException(record.exc_info)\n        if record.exc_text:\n            # exc_text contains multiple lines.  We need to _safe_unicode\n            # each line separately so that non-utf8 bytes don't cause\n            # all the newlines to turn into '\\n'.\n            lines = [formatted.rstrip()]\n            lines.extend(_safe_unicode(ln) for ln in record.exc_text.split(\"\\n\"))\n            formatted = \"\\n\".join(lines)\n        return formatted.replace(\"\\n\", \"\\n    \")",
        "begin_line": 163,
        "end_line": 207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.log.enable_pretty_logging#210",
        "src_path": "tornado/log.py",
        "class_name": "tornado.log",
        "signature": "tornado.log.enable_pretty_logging(options: Any=None, logger: logging.Logger=None)",
        "snippet": "def enable_pretty_logging(options: Any = None, logger: logging.Logger = None) -> None:\n    \"\"\"Turns on formatted logging output as configured.\n\n    This is called automatically by `tornado.options.parse_command_line`\n    and `tornado.options.parse_config_file`.\n    \"\"\"\n    if options is None:\n        import tornado.options\n\n        options = tornado.options.options\n    if options.logging is None or options.logging.lower() == \"none\":\n        return\n    if logger is None:\n        logger = logging.getLogger()\n    logger.setLevel(getattr(logging, options.logging.upper()))\n    if options.log_file_prefix:\n        rotate_mode = options.log_rotate_mode\n        if rotate_mode == \"size\":\n            channel = logging.handlers.RotatingFileHandler(\n                filename=options.log_file_prefix,\n                maxBytes=options.log_file_max_size,\n                backupCount=options.log_file_num_backups,\n                encoding=\"utf-8\",\n            )  # type: logging.Handler\n        elif rotate_mode == \"time\":\n            channel = logging.handlers.TimedRotatingFileHandler(\n                filename=options.log_file_prefix,\n                when=options.log_rotate_when,\n                interval=options.log_rotate_interval,\n                backupCount=options.log_file_num_backups,\n                encoding=\"utf-8\",\n            )\n        else:\n            error_message = (\n                \"The value of log_rotate_mode option should be \"\n                + '\"size\" or \"time\", not \"%s\".' % rotate_mode\n            )\n            raise ValueError(error_message)\n        channel.setFormatter(LogFormatter(color=False))\n        logger.addHandler(channel)\n\n    if options.log_to_stderr or (options.log_to_stderr is None and not logger.handlers):\n        # Set up color if we are in a tty and curses is installed\n        channel = logging.StreamHandler()\n        channel.setFormatter(LogFormatter())\n        logger.addHandler(channel)",
        "begin_line": 210,
        "end_line": 255,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.log.define_logging_options#258",
        "src_path": "tornado/log.py",
        "class_name": "tornado.log",
        "signature": "tornado.log.define_logging_options(options: Any=None)",
        "snippet": "def define_logging_options(options: Any = None) -> None:\n    \"\"\"Add logging-related flags to ``options``.\n\n    These options are present automatically on the default options instance;\n    this method is only necessary if you have created your own `.OptionParser`.\n\n    .. versionadded:: 4.2\n        This function existed in prior versions but was broken and undocumented until 4.2.\n    \"\"\"\n    if options is None:\n        # late import to prevent cycle\n        import tornado.options\n\n        options = tornado.options.options\n    options.define(\n        \"logging\",\n        default=\"info\",\n        help=(\n            \"Set the Python log level. If 'none', tornado won't touch the \"\n            \"logging configuration.\"\n        ),\n        metavar=\"debug|info|warning|error|none\",\n    )\n    options.define(\n        \"log_to_stderr\",\n        type=bool,\n        default=None,\n        help=(\n            \"Send log output to stderr (colorized if possible). \"\n            \"By default use stderr if --log_file_prefix is not set and \"\n            \"no other logging is configured.\"\n        ),\n    )\n    options.define(\n        \"log_file_prefix\",\n        type=str,\n        default=None,\n        metavar=\"PATH\",\n        help=(\n            \"Path prefix for log files. \"\n            \"Note that if you are running multiple tornado processes, \"\n            \"log_file_prefix must be different for each of them (e.g. \"\n            \"include the port number)\"\n        ),\n    )\n    options.define(\n        \"log_file_max_size\",\n        type=int,\n        default=100 * 1000 * 1000,\n        help=\"max size of log files before rollover\",\n    )\n    options.define(\n        \"log_file_num_backups\", type=int, default=10, help=\"number of log files to keep\"\n    )\n\n    options.define(\n        \"log_rotate_when\",\n        type=str,\n        default=\"midnight\",\n        help=(\n            \"specify the type of TimedRotatingFileHandler interval \"\n            \"other options:('S', 'M', 'H', 'D', 'W0'-'W6')\"\n        ),\n    )\n    options.define(\n        \"log_rotate_interval\",\n        type=int,\n        default=1,\n        help=\"The interval value of timed rotating\",\n    )\n\n    options.define(\n        \"log_rotate_mode\",\n        type=str,\n        default=\"size\",\n        help=\"The mode of rotating files(time or size)\",\n    )\n\n    options.add_parse_callback(lambda: enable_pretty_logging(options))",
        "begin_line": 258,
        "end_line": 336,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.tcpserver.TCPServer.__init__#108",
        "src_path": "tornado/tcpserver.py",
        "class_name": "tornado.tcpserver.TCPServer",
        "signature": "tornado.tcpserver.TCPServer.__init__(self, ssl_options: Union[Dict[str, Any], ssl.SSLContext]=None, max_buffer_size: int=None, read_chunk_size: int=None)",
        "snippet": "    def __init__(\n        self,\n        ssl_options: Union[Dict[str, Any], ssl.SSLContext] = None,\n        max_buffer_size: int = None,\n        read_chunk_size: int = None,\n    ) -> None:\n        self.ssl_options = ssl_options\n        self._sockets = {}  # type: Dict[int, socket.socket]\n        self._handlers = {}  # type: Dict[int, Callable[[], None]]\n        self._pending_sockets = []  # type: List[socket.socket]\n        self._started = False\n        self._stopped = False\n        self.max_buffer_size = max_buffer_size\n        self.read_chunk_size = read_chunk_size\n\n        # Verify the SSL options. Otherwise we don't get errors until clients\n        # connect. This doesn't verify that the keys are legitimate, but\n        # the SSL module doesn't do that until there is a connected socket\n        # which seems like too much work\n        if self.ssl_options is not None and isinstance(self.ssl_options, dict):\n            # Only certfile is required: it can contain both keys\n            if \"certfile\" not in self.ssl_options:\n                raise KeyError('missing key \"certfile\" in ssl_options')\n\n            if not os.path.exists(self.ssl_options[\"certfile\"]):\n                raise ValueError(\n                    'certfile \"%s\" does not exist' % self.ssl_options[\"certfile\"]\n                )\n            if \"keyfile\" in self.ssl_options and not os.path.exists(\n                self.ssl_options[\"keyfile\"]\n            ):\n                raise ValueError(\n                    'keyfile \"%s\" does not exist' % self.ssl_options[\"keyfile\"]\n                )",
        "begin_line": 108,
        "end_line": 141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008960573476702509,
            "pseudo_dstar_susp": 0.0011947431302270011,
            "pseudo_tarantula_susp": 0.0007704160246533128,
            "pseudo_op2_susp": 0.0011947431302270011,
            "pseudo_barinel_susp": 0.0007704160246533128
        }
    },
    {
        "name": "tornado.tcpserver.TCPServer.listen#143",
        "src_path": "tornado/tcpserver.py",
        "class_name": "tornado.tcpserver.TCPServer",
        "signature": "tornado.tcpserver.TCPServer.listen(self, port: int, address: str='')",
        "snippet": "    def listen(self, port: int, address: str = \"\") -> None:\n        \"\"\"Starts accepting connections on the given port.\n\n        This method may be called more than once to listen on multiple ports.\n        `listen` takes effect immediately; it is not necessary to call\n        `TCPServer.start` afterwards.  It is, however, necessary to start\n        the `.IOLoop`.\n        \"\"\"\n        sockets = bind_sockets(port, address=address)\n        self.add_sockets(sockets)",
        "begin_line": 143,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.tcpserver.TCPServer.add_sockets#154",
        "src_path": "tornado/tcpserver.py",
        "class_name": "tornado.tcpserver.TCPServer",
        "signature": "tornado.tcpserver.TCPServer.add_sockets(self, sockets: Iterable[socket.socket])",
        "snippet": "    def add_sockets(self, sockets: Iterable[socket.socket]) -> None:\n        \"\"\"Makes this server start accepting connections on the given sockets.\n\n        The ``sockets`` parameter is a list of socket objects such as\n        those returned by `~tornado.netutil.bind_sockets`.\n        `add_sockets` is typically used in combination with that\n        method and `tornado.process.fork_processes` to provide greater\n        control over the initialization of a multi-process server.\n        \"\"\"\n        for sock in sockets:\n            self._sockets[sock.fileno()] = sock\n            self._handlers[sock.fileno()] = add_accept_handler(\n                sock, self._handle_connection\n            )",
        "begin_line": 154,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009057971014492754,
            "pseudo_dstar_susp": 0.0012121212121212121,
            "pseudo_tarantula_susp": 0.000779423226812159,
            "pseudo_op2_susp": 0.0012121212121212121,
            "pseudo_barinel_susp": 0.000779423226812159
        }
    },
    {
        "name": "tornado.tcpserver.TCPServer.add_socket#169",
        "src_path": "tornado/tcpserver.py",
        "class_name": "tornado.tcpserver.TCPServer",
        "signature": "tornado.tcpserver.TCPServer.add_socket(self, socket: socket.socket)",
        "snippet": "    def add_socket(self, socket: socket.socket) -> None:\n        \"\"\"Singular version of `add_sockets`.  Takes a single socket object.\"\"\"\n        self.add_sockets([socket])",
        "begin_line": 169,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00045413260672116256,
            "pseudo_dstar_susp": 0.00041562759767248546,
            "pseudo_tarantula_susp": 0.0016025641025641025,
            "pseudo_op2_susp": 0.00041562759767248546,
            "pseudo_barinel_susp": 0.0015923566878980893
        }
    },
    {
        "name": "tornado.tcpserver.TCPServer.stop#240",
        "src_path": "tornado/tcpserver.py",
        "class_name": "tornado.tcpserver.TCPServer",
        "signature": "tornado.tcpserver.TCPServer.stop(self)",
        "snippet": "    def stop(self) -> None:\n        \"\"\"Stops listening for new connections.\n\n        Requests currently in progress may still continue after the\n        server is stopped.\n        \"\"\"\n        if self._stopped:\n            return\n        self._stopped = True\n        for fd, sock in self._sockets.items():\n            assert sock.fileno() == fd\n            # Unregister socket from IOLoop\n            self._handlers.pop(fd)()\n            sock.close()",
        "begin_line": 240,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009057971014492754,
            "pseudo_dstar_susp": 0.0012121212121212121,
            "pseudo_tarantula_susp": 0.000779423226812159,
            "pseudo_op2_susp": 0.0012121212121212121,
            "pseudo_barinel_susp": 0.000779423226812159
        }
    },
    {
        "name": "tornado.tcpserver.TCPServer._handle_connection#274",
        "src_path": "tornado/tcpserver.py",
        "class_name": "tornado.tcpserver.TCPServer",
        "signature": "tornado.tcpserver.TCPServer._handle_connection(self, connection: socket.socket, address: Any)",
        "snippet": "    def _handle_connection(self, connection: socket.socket, address: Any) -> None:\n        if self.ssl_options is not None:\n            assert ssl, \"Python 2.6+ and OpenSSL required for SSL\"\n            try:\n                connection = ssl_wrap_socket(\n                    connection,\n                    self.ssl_options,\n                    server_side=True,\n                    do_handshake_on_connect=False,\n                )\n            except ssl.SSLError as err:\n                if err.args[0] == ssl.SSL_ERROR_EOF:\n                    return connection.close()\n                else:\n                    raise\n            except socket.error as err:\n                # If the connection is closed immediately after it is created\n                # (as in a port scan), we can get one of several errors.\n                # wrap_socket makes an internal call to getpeername,\n                # which may return either EINVAL (Mac OS X) or ENOTCONN\n                # (Linux).  If it returns ENOTCONN, this error is\n                # silently swallowed by the ssl module, so we need to\n                # catch another error later on (AttributeError in\n                # SSLIOStream._do_ssl_handshake).\n                # To test this behavior, try nmap with the -sT flag.\n                # https://github.com/tornadoweb/tornado/pull/750\n                if errno_from_exception(err) in (errno.ECONNABORTED, errno.EINVAL):\n                    return connection.close()\n                else:\n                    raise\n        try:\n            if self.ssl_options is not None:\n                stream = SSLIOStream(\n                    connection,\n                    max_buffer_size=self.max_buffer_size,\n                    read_chunk_size=self.read_chunk_size,\n                )  # type: IOStream\n            else:\n                stream = IOStream(\n                    connection,\n                    max_buffer_size=self.max_buffer_size,\n                    read_chunk_size=self.read_chunk_size,\n                )\n\n            future = self.handle_stream(stream, address)\n            if future is not None:\n                IOLoop.current().add_future(\n                    gen.convert_yielded(future), lambda f: f.result()\n                )\n        except Exception:\n            app_log.error(\"Error in connection callback\", exc_info=True)",
        "begin_line": 274,
        "end_line": 324,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009746588693957114,
            "pseudo_dstar_susp": 0.0012970168612191958,
            "pseudo_tarantula_susp": 0.0009319664492078285,
            "pseudo_op2_susp": 0.0012970168612191958,
            "pseudo_barinel_susp": 0.0009319664492078285
        }
    },
    {
        "name": "tornado.concurrent.is_future#52",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.is_future(x: Any)",
        "snippet": "def is_future(x: Any) -> bool:\n    return isinstance(x, FUTURES)",
        "begin_line": 52,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0021691973969631237,
            "pseudo_dstar_susp": 0.00425531914893617,
            "pseudo_tarantula_susp": 0.0011337868480725624,
            "pseudo_op2_susp": 0.00425531914893617,
            "pseudo_barinel_susp": 0.0011337868480725624
        }
    },
    {
        "name": "tornado.concurrent.DummyExecutor.submit#57",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent.DummyExecutor",
        "signature": "tornado.concurrent.DummyExecutor.submit(self, fn: Callable[..., _T], *args: Any, **kwargs: Any)",
        "snippet": "    def submit(\n        self, fn: Callable[..., _T], *args: Any, **kwargs: Any\n    ) -> \"futures.Future[_T]\":\n        future = futures.Future()  # type: futures.Future[_T]\n        try:\n            future_set_result_unless_cancelled(future, fn(*args, **kwargs))\n        except Exception:\n            future_set_exc_info(future, sys.exc_info())\n        return future",
        "begin_line": 57,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.concurrent.run_on_executor#74",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.run_on_executor(*args: Any, **kwargs: Any)",
        "snippet": "def run_on_executor(*args: Any, **kwargs: Any) -> Callable:\n    \"\"\"Decorator to run a synchronous method asynchronously on an executor.\n\n    The decorated method may be called with a ``callback`` keyword\n    argument and returns a future.\n\n    The executor to be used is determined by the ``executor``\n    attributes of ``self``. To use a different attribute name, pass a\n    keyword argument to the decorator::\n\n        @run_on_executor(executor='_thread_pool')\n        def foo(self):\n            pass\n\n    This decorator should not be confused with the similarly-named\n    `.IOLoop.run_in_executor`. In general, using ``run_in_executor``\n    when *calling* a blocking method is recommended instead of using\n    this decorator when *defining* a method. If compatibility with older\n    versions of Tornado is required, consider defining an executor\n    and using ``executor.submit()`` at the call site.\n\n    .. versionchanged:: 4.2\n       Added keyword arguments to use alternative attributes.\n\n    .. versionchanged:: 5.0\n       Always uses the current IOLoop instead of ``self.io_loop``.\n\n    .. versionchanged:: 5.1\n       Returns a `.Future` compatible with ``await`` instead of a\n       `concurrent.futures.Future`.\n\n    .. deprecated:: 5.1\n\n       The ``callback`` argument is deprecated and will be removed in\n       6.0. The decorator itself is discouraged in new code but will\n       not be removed in 6.0.\n\n    .. versionchanged:: 6.0\n\n       The ``callback`` argument was removed.\n    \"\"\"\n    # Fully type-checking decorators is tricky, and this one is\n    # discouraged anyway so it doesn't have all the generic magic.\n    def run_on_executor_decorator(fn: Callable) -> Callable[..., Future]:\n        executor = kwargs.get(\"executor\", \"executor\")\n\n        @functools.wraps(fn)\n        def wrapper(self: Any, *args: Any, **kwargs: Any) -> Future:\n            async_future = Future()  # type: Future\n            conc_future = getattr(self, executor).submit(fn, self, *args, **kwargs)\n            chain_future(conc_future, async_future)\n            return async_future\n\n        return wrapper\n\n    if args and kwargs:\n        raise ValueError(\"cannot combine positional and keyword args\")\n    if len(args) == 1:\n        return run_on_executor_decorator(args[0])\n    elif len(args) != 0:\n        raise ValueError(\"expected 1 argument, got %d\", len(args))\n    return run_on_executor_decorator",
        "begin_line": 74,
        "end_line": 135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.concurrent.run_on_executor_decorator#117",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.run_on_executor_decorator(fn: Callable)",
        "snippet": "    def run_on_executor_decorator(fn: Callable) -> Callable[..., Future]:\n        executor = kwargs.get(\"executor\", \"executor\")\n\n        @functools.wraps(fn)\n        def wrapper(self: Any, *args: Any, **kwargs: Any) -> Future:\n            async_future = Future()  # type: Future\n            conc_future = getattr(self, executor).submit(fn, self, *args, **kwargs)\n            chain_future(conc_future, async_future)\n            return async_future\n\n        return wrapper",
        "begin_line": 117,
        "end_line": 127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.concurrent.wrapper#121",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.wrapper(self: Any, *args: Any, **kwargs: Any)",
        "snippet": "        def wrapper(self: Any, *args: Any, **kwargs: Any) -> Future:\n            async_future = Future()  # type: Future\n            conc_future = getattr(self, executor).submit(fn, self, *args, **kwargs)\n            chain_future(conc_future, async_future)\n            return async_future",
        "begin_line": 121,
        "end_line": 125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.concurrent.chain_future#141",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.chain_future(a: 'Future[_T]', b: 'Future[_T]')",
        "snippet": "def chain_future(a: \"Future[_T]\", b: \"Future[_T]\") -> None:\n    \"\"\"Chain two futures together so that when one completes, so does the other.\n\n    The result (success or failure) of ``a`` will be copied to ``b``, unless\n    ``b`` has already been completed or cancelled by the time ``a`` finishes.\n\n    .. versionchanged:: 5.0\n\n       Now accepts both Tornado/asyncio `Future` objects and\n       `concurrent.futures.Future`.\n\n    \"\"\"\n\n    def copy(future: \"Future[_T]\") -> None:\n        assert future is a\n        if b.done():\n            return\n        if hasattr(a, \"exc_info\") and a.exc_info() is not None:  # type: ignore\n            future_set_exc_info(b, a.exc_info())  # type: ignore\n        elif a.exception() is not None:\n            b.set_exception(a.exception())\n        else:\n            b.set_result(a.result())\n\n    if isinstance(a, Future):\n        future_add_done_callback(a, copy)\n    else:\n        # concurrent.futures.Future\n        from tornado.ioloop import IOLoop\n\n        IOLoop.current().add_future(a, copy)",
        "begin_line": 141,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009407337723424271,
            "pseudo_dstar_susp": 0.0012658227848101266,
            "pseudo_tarantula_susp": 0.0008244023083264633,
            "pseudo_op2_susp": 0.0012658227848101266,
            "pseudo_barinel_susp": 0.0008244023083264633
        }
    },
    {
        "name": "tornado.concurrent.copy#154",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.copy(future: 'Future[_T]')",
        "snippet": "    def copy(future: \"Future[_T]\") -> None:\n        assert future is a\n        if b.done():\n            return\n        if hasattr(a, \"exc_info\") and a.exc_info() is not None:  # type: ignore\n            future_set_exc_info(b, a.exc_info())  # type: ignore\n        elif a.exception() is not None:\n            b.set_exception(a.exception())\n        else:\n            b.set_result(a.result())",
        "begin_line": 154,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012254901960784314,
            "pseudo_dstar_susp": 0.0022172949002217295,
            "pseudo_tarantula_susp": 0.002793296089385475,
            "pseudo_op2_susp": 0.0022172949002217295,
            "pseudo_barinel_susp": 0.002793296089385475
        }
    },
    {
        "name": "tornado.concurrent.future_set_result_unless_cancelled#174",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.future_set_result_unless_cancelled(future: Union['futures.Future[_T]', 'Future[_T]'], value: _T)",
        "snippet": "def future_set_result_unless_cancelled(\n    future: Union[\"futures.Future[_T]\", \"Future[_T]\"], value: _T\n) -> None:\n    \"\"\"Set the given ``value`` as the `Future`'s result, if not cancelled.\n\n    Avoids asyncio.InvalidStateError when calling set_result() on\n    a cancelled `asyncio.Future`.\n\n    .. versionadded:: 5.0\n    \"\"\"\n    if not future.cancelled():\n        future.set_result(value)",
        "begin_line": 174,
        "end_line": 185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0025906735751295338,
            "pseudo_dstar_susp": 0.0049504950495049506,
            "pseudo_tarantula_susp": 0.0011918951132300357,
            "pseudo_op2_susp": 0.0049504950495049506,
            "pseudo_barinel_susp": 0.0011918951132300357
        }
    },
    {
        "name": "tornado.concurrent.future_set_exc_info#188",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.future_set_exc_info(future: Union['futures.Future[_T]', 'Future[_T]'], exc_info: Tuple[Optional[type], Optional[BaseException], Optional[types.TracebackType]])",
        "snippet": "def future_set_exc_info(\n    future: Union[\"futures.Future[_T]\", \"Future[_T]\"],\n    exc_info: Tuple[\n        Optional[type], Optional[BaseException], Optional[types.TracebackType]\n    ],\n) -> None:\n    \"\"\"Set the given ``exc_info`` as the `Future`'s exception.\n\n    Understands both `asyncio.Future` and Tornado's extensions to\n    enable better tracebacks on Python 2.\n\n    .. versionadded:: 5.0\n    \"\"\"\n    if hasattr(future, \"set_exc_info\"):\n        # Tornado's Future\n        future.set_exc_info(exc_info)  # type: ignore\n    else:\n        # asyncio.Future\n        if exc_info[1] is None:\n            raise Exception(\"future_set_exc_info called with no exception\")\n        future.set_exception(exc_info[1])",
        "begin_line": 188,
        "end_line": 208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.029411764705882353,
            "pseudo_dstar_susp": 0.0019267822736030828,
            "pseudo_tarantula_susp": 0.01,
            "pseudo_op2_susp": 0.0019267822736030828,
            "pseudo_barinel_susp": 0.01
        }
    },
    {
        "name": "tornado.concurrent.future_add_done_callback#225",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.future_add_done_callback(future: Union['futures.Future[_T]', 'Future[_T]'], callback: Callable[..., None])",
        "snippet": "def future_add_done_callback(  # noqa: F811\n    future: Union[\"futures.Future[_T]\", \"Future[_T]\"], callback: Callable[..., None]\n) -> None:\n    \"\"\"Arrange to call ``callback`` when ``future`` is complete.\n\n    ``callback`` is invoked with one argument, the ``future``.\n\n    If ``future`` is already done, ``callback`` is invoked immediately.\n    This may differ from the behavior of ``Future.add_done_callback``,\n    which makes no such guarantee.\n\n    .. versionadded:: 5.0\n    \"\"\"\n    if future.done():\n        callback(future)\n    else:\n        future.add_done_callback(callback)",
        "begin_line": 225,
        "end_line": 241,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022988505747126436,
            "pseudo_dstar_susp": 0.004132231404958678,
            "pseudo_tarantula_susp": 0.0011862396204033216,
            "pseudo_op2_susp": 0.004132231404958678,
            "pseudo_barinel_susp": 0.0011862396204033216
        }
    },
    {
        "name": "tornado.process._pipe_cloexec#78",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process",
        "signature": "tornado.process._pipe_cloexec()",
        "snippet": "def _pipe_cloexec() -> Tuple[int, int]:\n    r, w = os.pipe()\n    set_close_exec(r)\n    set_close_exec(w)\n    return r, w",
        "begin_line": 78,
        "end_line": 82,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.process.fork_processes#88",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process",
        "signature": "tornado.process.fork_processes(num_processes: Optional[int], max_restarts: int=None)",
        "snippet": "def fork_processes(num_processes: Optional[int], max_restarts: int = None) -> int:\n    \"\"\"Starts multiple worker processes.\n\n    If ``num_processes`` is None or <= 0, we detect the number of cores\n    available on this machine and fork that number of child\n    processes. If ``num_processes`` is given and > 0, we fork that\n    specific number of sub-processes.\n\n    Since we use processes and not threads, there is no shared memory\n    between any server code.\n\n    Note that multiple processes are not compatible with the autoreload\n    module (or the ``autoreload=True`` option to `tornado.web.Application`\n    which defaults to True when ``debug=True``).\n    When using multiple processes, no IOLoops can be created or\n    referenced until after the call to ``fork_processes``.\n\n    In each child process, ``fork_processes`` returns its *task id*, a\n    number between 0 and ``num_processes``.  Processes that exit\n    abnormally (due to a signal or non-zero exit status) are restarted\n    with the same id (up to ``max_restarts`` times).  In the parent\n    process, ``fork_processes`` returns None if all child processes\n    have exited normally, but will otherwise only exit by throwing an\n    exception.\n\n    max_restarts defaults to 100.\n    \"\"\"\n    if max_restarts is None:\n        max_restarts = 100\n\n    global _task_id\n    assert _task_id is None\n    if num_processes is None or num_processes <= 0:\n        num_processes = cpu_count()\n    gen_log.info(\"Starting %d processes\", num_processes)\n    children = {}\n\n    def start_child(i: int) -> Optional[int]:\n        pid = os.fork()\n        if pid == 0:\n            # child process\n            _reseed_random()\n            global _task_id\n            _task_id = i\n            return i\n        else:\n            children[pid] = i\n            return None\n\n    for i in range(num_processes):\n        id = start_child(i)\n        if id is not None:\n            return id\n    num_restarts = 0\n    while children:\n        try:\n            pid, status = os.wait()\n        except OSError as e:\n            if errno_from_exception(e) == errno.EINTR:\n                continue\n            raise\n        if pid not in children:\n            continue\n        id = children.pop(pid)\n        if os.WIFSIGNALED(status):\n            gen_log.warning(\n                \"child %d (pid %d) killed by signal %d, restarting\",\n                id,\n                pid,\n                os.WTERMSIG(status),\n            )\n        elif os.WEXITSTATUS(status) != 0:\n            gen_log.warning(\n                \"child %d (pid %d) exited with status %d, restarting\",\n                id,\n                pid,\n                os.WEXITSTATUS(status),\n            )\n        else:\n            gen_log.info(\"child %d (pid %d) exited normally\", id, pid)\n            continue\n        num_restarts += 1\n        if num_restarts > max_restarts:\n            raise RuntimeError(\"Too many child restarts, giving up\")\n        new_id = start_child(id)\n        if new_id is not None:\n            return new_id\n    # All child processes exited cleanly, so exit the master process\n    # instead of just returning to right after the call to\n    # fork_processes (which will probably just start up another IOLoop\n    # unless the caller checks the return value).\n    sys.exit(0)",
        "begin_line": 88,
        "end_line": 179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.process.start_child#125",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process",
        "signature": "tornado.process.start_child(i: int)",
        "snippet": "    def start_child(i: int) -> Optional[int]:\n        pid = os.fork()\n        if pid == 0:\n            # child process\n            _reseed_random()\n            global _task_id\n            _task_id = i\n            return i\n        else:\n            children[pid] = i\n            return None",
        "begin_line": 125,
        "end_line": 135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.process.task_id#182",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process",
        "signature": "tornado.process.task_id()",
        "snippet": "def task_id() -> Optional[int]:\n    \"\"\"Returns the current task id, if any.\n\n    Returns None if this process was not created by `fork_processes`.\n    \"\"\"\n    global _task_id\n    return _task_id",
        "begin_line": 182,
        "end_line": 188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.process.Subprocess.__init__#219",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess.__init__(self, *args: Any, **kwargs: Any)",
        "snippet": "    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        self.io_loop = ioloop.IOLoop.current()\n        # All FDs we create should be closed on error; those in to_close\n        # should be closed in the parent process on success.\n        pipe_fds = []  # type: List[int]\n        to_close = []  # type: List[int]\n        if kwargs.get(\"stdin\") is Subprocess.STREAM:\n            in_r, in_w = _pipe_cloexec()\n            kwargs[\"stdin\"] = in_r\n            pipe_fds.extend((in_r, in_w))\n            to_close.append(in_r)\n            self.stdin = PipeIOStream(in_w)\n        if kwargs.get(\"stdout\") is Subprocess.STREAM:\n            out_r, out_w = _pipe_cloexec()\n            kwargs[\"stdout\"] = out_w\n            pipe_fds.extend((out_r, out_w))\n            to_close.append(out_w)\n            self.stdout = PipeIOStream(out_r)\n        if kwargs.get(\"stderr\") is Subprocess.STREAM:\n            err_r, err_w = _pipe_cloexec()\n            kwargs[\"stderr\"] = err_w\n            pipe_fds.extend((err_r, err_w))\n            to_close.append(err_w)\n            self.stderr = PipeIOStream(err_r)\n        try:\n            self.proc = subprocess.Popen(*args, **kwargs)\n        except:\n            for fd in pipe_fds:\n                os.close(fd)\n            raise\n        for fd in to_close:\n            os.close(fd)\n        self.pid = self.proc.pid\n        for attr in [\"stdin\", \"stdout\", \"stderr\"]:\n            if not hasattr(self, attr):  # don't clobber streams set above\n                setattr(self, attr, getattr(self.proc, attr))\n        self._exit_callback = None  # type: Optional[Callable[[int], None]]\n        self.returncode = None  # type: Optional[int]",
        "begin_line": 219,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.process.Subprocess.set_exit_callback#258",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess.set_exit_callback(self, callback: Callable[[int], None])",
        "snippet": "    def set_exit_callback(self, callback: Callable[[int], None]) -> None:\n        \"\"\"Runs ``callback`` when this process exits.\n\n        The callback takes one argument, the return code of the process.\n\n        This method uses a ``SIGCHLD`` handler, which is a global setting\n        and may conflict if you have other libraries trying to handle the\n        same signal.  If you are using more than one ``IOLoop`` it may\n        be necessary to call `Subprocess.initialize` first to designate\n        one ``IOLoop`` to run the signal handlers.\n\n        In many cases a close callback on the stdout or stderr streams\n        can be used as an alternative to an exit callback if the\n        signal handler is causing a problem.\n        \"\"\"\n        self._exit_callback = callback\n        Subprocess.initialize()\n        Subprocess._waiting[self.pid] = self\n        Subprocess._try_cleanup_process(self.pid)",
        "begin_line": 258,
        "end_line": 276,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.process.Subprocess.wait_for_exit#278",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess.wait_for_exit(self, raise_error: bool=True)",
        "snippet": "    def wait_for_exit(self, raise_error: bool = True) -> \"Future[int]\":\n        \"\"\"Returns a `.Future` which resolves when the process exits.\n\n        Usage::\n\n            ret = yield proc.wait_for_exit()\n\n        This is a coroutine-friendly alternative to `set_exit_callback`\n        (and a replacement for the blocking `subprocess.Popen.wait`).\n\n        By default, raises `subprocess.CalledProcessError` if the process\n        has a non-zero exit status. Use ``wait_for_exit(raise_error=False)``\n        to suppress this behavior and return the exit status without raising.\n\n        .. versionadded:: 4.2\n        \"\"\"\n        future = Future()  # type: Future[int]\n\n        def callback(ret: int) -> None:\n            if ret != 0 and raise_error:\n                # Unfortunately we don't have the original args any more.\n                future.set_exception(CalledProcessError(ret, \"unknown\"))\n            else:\n                future_set_result_unless_cancelled(future, ret)\n\n        self.set_exit_callback(callback)\n        return future",
        "begin_line": 278,
        "end_line": 304,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.process.Subprocess.callback#296",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess.callback(ret: int)",
        "snippet": "        def callback(ret: int) -> None:\n            if ret != 0 and raise_error:\n                # Unfortunately we don't have the original args any more.\n                future.set_exception(CalledProcessError(ret, \"unknown\"))\n            else:\n                future_set_result_unless_cancelled(future, ret)",
        "begin_line": 296,
        "end_line": 301,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.process.Subprocess.initialize#307",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess.initialize(cls)",
        "snippet": "    def initialize(cls) -> None:\n        \"\"\"Initializes the ``SIGCHLD`` handler.\n\n        The signal handler is run on an `.IOLoop` to avoid locking issues.\n        Note that the `.IOLoop` used for signal handling need not be the\n        same one used by individual Subprocess objects (as long as the\n        ``IOLoops`` are each running in separate threads).\n\n        .. versionchanged:: 5.0\n           The ``io_loop`` argument (deprecated since version 4.1) has been\n           removed.\n        \"\"\"\n        if cls._initialized:\n            return\n        io_loop = ioloop.IOLoop.current()\n        cls._old_sigchld = signal.signal(\n            signal.SIGCHLD,\n            lambda sig, frame: io_loop.add_callback_from_signal(cls._cleanup),\n        )\n        cls._initialized = True",
        "begin_line": 307,
        "end_line": 326,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.process.Subprocess.uninitialize#329",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess.uninitialize(cls)",
        "snippet": "    def uninitialize(cls) -> None:\n        \"\"\"Removes the ``SIGCHLD`` handler.\"\"\"\n        if not cls._initialized:\n            return\n        signal.signal(signal.SIGCHLD, cls._old_sigchld)\n        cls._initialized = False",
        "begin_line": 329,
        "end_line": 334,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017211703958691911,
            "pseudo_dstar_susp": 0.003787878787878788,
            "pseudo_tarantula_susp": 0.0010672358591248667,
            "pseudo_op2_susp": 0.003787878787878788,
            "pseudo_barinel_susp": 0.0010672358591248667
        }
    },
    {
        "name": "tornado.process.Subprocess._cleanup#337",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess._cleanup(cls)",
        "snippet": "    def _cleanup(cls) -> None:\n        for pid in list(cls._waiting.keys()):  # make a copy\n            cls._try_cleanup_process(pid)",
        "begin_line": 337,
        "end_line": 339,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.process.Subprocess._try_cleanup_process#342",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess._try_cleanup_process(cls, pid: int)",
        "snippet": "    def _try_cleanup_process(cls, pid: int) -> None:\n        try:\n            ret_pid, status = os.waitpid(pid, os.WNOHANG)\n        except OSError as e:\n            if errno_from_exception(e) == errno.ECHILD:\n                return\n        if ret_pid == 0:\n            return\n        assert ret_pid == pid\n        subproc = cls._waiting.pop(pid)\n        subproc.io_loop.add_callback_from_signal(subproc._set_returncode, status)",
        "begin_line": 342,
        "end_line": 352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.process.Subprocess._set_returncode#354",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess._set_returncode(self, status: int)",
        "snippet": "    def _set_returncode(self, status: int) -> None:\n        if os.WIFSIGNALED(status):\n            self.returncode = -os.WTERMSIG(status)\n        else:\n            assert os.WIFEXITED(status)\n            self.returncode = os.WEXITSTATUS(status)\n        # We've taken over wait() duty from the subprocess.Popen\n        # object. If we don't inform it of the process's return code,\n        # it will log a warning at destruction in python 3.6+.\n        self.proc.returncode = self.returncode\n        if self._exit_callback:\n            callback = self._exit_callback\n            self._exit_callback = None\n            callback(self.returncode)",
        "begin_line": 354,
        "end_line": 367,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.current#247",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.current(instance: bool=True)",
        "snippet": "    def current(instance: bool = True) -> Optional[\"IOLoop\"]:\n        \"\"\"Returns the current thread's `IOLoop`.\n\n        If an `IOLoop` is currently running or has been marked as\n        current by `make_current`, returns that instance.  If there is\n        no current `IOLoop` and ``instance`` is true, creates one.\n\n        .. versionchanged:: 4.1\n           Added ``instance`` argument to control the fallback to\n           `IOLoop.instance()`.\n        .. versionchanged:: 5.0\n           On Python 3, control of the current `IOLoop` is delegated\n           to `asyncio`, with this and other methods as pass-through accessors.\n           The ``instance`` argument now controls whether an `IOLoop`\n           is created automatically when there is none, instead of\n           whether we fall back to `IOLoop.instance()` (which is now\n           an alias for this method). ``instance=False`` is deprecated,\n           since even if we do not create an `IOLoop`, this method\n           may initialize the asyncio loop.\n        \"\"\"\n        try:\n            loop = asyncio.get_event_loop()\n        except (RuntimeError, AssertionError):\n            if not instance:\n                return None\n            raise\n        try:\n            return IOLoop._ioloop_for_asyncio[loop]\n        except KeyError:\n            if instance:\n                from tornado.platform.asyncio import AsyncIOMainLoop\n\n                current = AsyncIOMainLoop(make_current=True)  # type: Optional[IOLoop]\n            else:\n                current = None\n        return current",
        "begin_line": 247,
        "end_line": 282,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001557632398753894,
            "pseudo_dstar_susp": 0.0034129692832764505,
            "pseudo_tarantula_susp": 0.0010309278350515464,
            "pseudo_op2_susp": 0.0034129692832764505,
            "pseudo_barinel_susp": 0.0010309278350515464
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.clear_current#304",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.clear_current()",
        "snippet": "    def clear_current() -> None:\n        \"\"\"Clears the `IOLoop` for the current thread.\n\n        Intended primarily for use by test frameworks in between tests.\n\n        .. versionchanged:: 5.0\n           This method also clears the current `asyncio` event loop.\n        \"\"\"\n        old = IOLoop.current(instance=False)\n        if old is not None:\n            old._clear_current_hook()\n        if asyncio is None:\n            IOLoop._current.instance = None",
        "begin_line": 304,
        "end_line": 316,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001557632398753894,
            "pseudo_dstar_susp": 0.0034129692832764505,
            "pseudo_tarantula_susp": 0.0010309278350515464,
            "pseudo_op2_susp": 0.0034129692832764505,
            "pseudo_barinel_susp": 0.0010309278350515464
        }
    },
    {
        "name": "tornado.ioloop.IOLoop._clear_current_hook#318",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop._clear_current_hook(self)",
        "snippet": "    def _clear_current_hook(self) -> None:\n        \"\"\"Instance method called when an IOLoop ceases to be current.\n\n        May be overridden by subclasses as a counterpart to make_current.\n        \"\"\"\n        pass",
        "begin_line": 318,
        "end_line": 323,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.configurable_base#326",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.configurable_base(cls)",
        "snippet": "    def configurable_base(cls) -> Type[Configurable]:\n        return IOLoop",
        "begin_line": 326,
        "end_line": 327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015313935681470138,
            "pseudo_dstar_susp": 0.003289473684210526,
            "pseudo_tarantula_susp": 0.0010090817356205853,
            "pseudo_op2_susp": 0.003289473684210526,
            "pseudo_barinel_susp": 0.0010090817356205853
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.configurable_default#330",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.configurable_default(cls)",
        "snippet": "    def configurable_default(cls) -> Type[Configurable]:\n        from tornado.platform.asyncio import AsyncIOLoop\n\n        return AsyncIOLoop",
        "begin_line": 330,
        "end_line": 333,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.initialize#335",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.initialize(self, make_current: bool=None)",
        "snippet": "    def initialize(self, make_current: bool = None) -> None:\n        if make_current is None:\n            if IOLoop.current(instance=False) is None:\n                self.make_current()\n        elif make_current:\n            current = IOLoop.current(instance=False)\n            # AsyncIO loops can already be current by this point.\n            if current is not None and current is not self:\n                raise RuntimeError(\"current IOLoop already exists\")\n            self.make_current()",
        "begin_line": 335,
        "end_line": 344,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015625,
            "pseudo_dstar_susp": 0.003436426116838488,
            "pseudo_tarantula_susp": 0.0010330578512396695,
            "pseudo_op2_susp": 0.003436426116838488,
            "pseudo_barinel_susp": 0.0010330578512396695
        }
    },
    {
        "name": "tornado.ioloop.IOLoop._setup_logging#430",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop._setup_logging(self)",
        "snippet": "    def _setup_logging(self) -> None:\n        \"\"\"The IOLoop catches and logs exceptions, so it's\n        important that log output be visible.  However, python's\n        default behavior for non-root loggers (prior to python\n        3.2) is to print an unhelpful \"no handlers could be\n        found\" message rather than the actual log entry, so we\n        must explicitly configure logging if we've made it this\n        far without anything.\n\n        This method should be called from start() in subclasses.\n        \"\"\"\n        if not any(\n            [\n                logging.getLogger().handlers,\n                logging.getLogger(\"tornado\").handlers,\n                logging.getLogger(\"tornado.application\").handlers,\n            ]\n        ):\n            logging.basicConfig()",
        "begin_line": 430,
        "end_line": 448,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018975332068311196,
            "pseudo_dstar_susp": 0.004032258064516129,
            "pseudo_tarantula_susp": 0.0011049723756906078,
            "pseudo_op2_susp": 0.004032258064516129,
            "pseudo_barinel_susp": 0.0011049723756906078
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.run_sync#463",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.run_sync(self, func: Callable, timeout: float=None)",
        "snippet": "    def run_sync(self, func: Callable, timeout: float = None) -> Any:\n        \"\"\"Starts the `IOLoop`, runs the given function, and stops the loop.\n\n        The function must return either an awaitable object or\n        ``None``. If the function returns an awaitable object, the\n        `IOLoop` will run until the awaitable is resolved (and\n        `run_sync()` will return the awaitable's result). If it raises\n        an exception, the `IOLoop` will stop and the exception will be\n        re-raised to the caller.\n\n        The keyword-only argument ``timeout`` may be used to set\n        a maximum duration for the function.  If the timeout expires,\n        a `tornado.util.TimeoutError` is raised.\n\n        This method is useful to allow asynchronous calls in a\n        ``main()`` function::\n\n            async def main():\n                # do stuff...\n\n            if __name__ == '__main__':\n                IOLoop.current().run_sync(main)\n\n        .. versionchanged:: 4.3\n           Returning a non-``None``, non-awaitable value is now an error.\n\n        .. versionchanged:: 5.0\n           If a timeout occurs, the ``func`` coroutine will be cancelled.\n\n        \"\"\"\n        future_cell = [None]  # type: List[Optional[Future]]\n\n        def run() -> None:\n            try:\n                result = func()\n                if result is not None:\n                    from tornado.gen import convert_yielded\n\n                    result = convert_yielded(result)\n            except Exception:\n                fut = Future()  # type: Future[Any]\n                future_cell[0] = fut\n                future_set_exc_info(fut, sys.exc_info())\n            else:\n                if is_future(result):\n                    future_cell[0] = result\n                else:\n                    fut = Future()\n                    future_cell[0] = fut\n                    fut.set_result(result)\n            assert future_cell[0] is not None\n            self.add_future(future_cell[0], lambda future: self.stop())\n\n        self.add_callback(run)\n        if timeout is not None:\n\n            def timeout_callback() -> None:\n                # If we can cancel the future, do so and wait on it. If not,\n                # Just stop the loop and return with the task still pending.\n                # (If we neither cancel nor wait for the task, a warning\n                # will be logged).\n                assert future_cell[0] is not None\n                if not future_cell[0].cancel():\n                    self.stop()\n\n            timeout_handle = self.add_timeout(self.time() + timeout, timeout_callback)\n        self.start()\n        if timeout is not None:\n            self.remove_timeout(timeout_handle)\n        assert future_cell[0] is not None\n        if future_cell[0].cancelled() or not future_cell[0].done():\n            raise TimeoutError(\"Operation timed out after %s seconds\" % timeout)\n        return future_cell[0].result()",
        "begin_line": 463,
        "end_line": 535,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028328611898017,
            "pseudo_dstar_susp": 0.005050505050505051,
            "pseudo_tarantula_susp": 0.0012062726176115801,
            "pseudo_op2_susp": 0.005050505050505051,
            "pseudo_barinel_susp": 0.0012062726176115801
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.run#495",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.run()",
        "snippet": "        def run() -> None:\n            try:\n                result = func()\n                if result is not None:\n                    from tornado.gen import convert_yielded\n\n                    result = convert_yielded(result)\n            except Exception:\n                fut = Future()  # type: Future[Any]\n                future_cell[0] = fut\n                future_set_exc_info(fut, sys.exc_info())\n            else:\n                if is_future(result):\n                    future_cell[0] = result\n                else:\n                    fut = Future()\n                    future_cell[0] = fut\n                    fut.set_result(result)\n            assert future_cell[0] is not None\n            self.add_future(future_cell[0], lambda future: self.stop())",
        "begin_line": 495,
        "end_line": 514,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012987012987012988,
            "pseudo_dstar_susp": 0.14285714285714285,
            "pseudo_tarantula_susp": 0.001177856301531213,
            "pseudo_op2_susp": 0.14285714285714285,
            "pseudo_barinel_susp": 0.001177856301531213
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.timeout_callback#519",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.timeout_callback()",
        "snippet": "            def timeout_callback() -> None:\n                # If we can cancel the future, do so and wait on it. If not,\n                # Just stop the loop and return with the task still pending.\n                # (If we neither cancel nor wait for the task, a warning\n                # will be logged).\n                assert future_cell[0] is not None\n                if not future_cell[0].cancel():\n                    self.stop()",
        "begin_line": 519,
        "end_line": 526,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028089887640449437,
            "pseudo_dstar_susp": 0.005,
            "pseudo_tarantula_susp": 0.0012033694344163659,
            "pseudo_op2_susp": 0.005,
            "pseudo_barinel_susp": 0.0012033694344163659
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.time#537",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.time(self)",
        "snippet": "    def time(self) -> float:\n        \"\"\"Returns the current time according to the `IOLoop`'s clock.\n\n        The return value is a floating-point number relative to an\n        unspecified time in the past.\n\n        By default, the `IOLoop`'s time function is `time.time`.  However,\n        it may be configured to use e.g. `time.monotonic` instead.\n        Calls to `add_timeout` that pass a number instead of a\n        `datetime.timedelta` should use this function to compute the\n        appropriate time, so they can work no matter what time function\n        is chosen.\n        \"\"\"\n        return time.time()",
        "begin_line": 537,
        "end_line": 550,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002044989775051125,
            "pseudo_dstar_susp": 0.004166666666666667,
            "pseudo_tarantula_susp": 0.0011261261261261261,
            "pseudo_op2_susp": 0.004166666666666667,
            "pseudo_barinel_susp": 0.0011261261261261261
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.add_timeout#552",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.add_timeout(self, deadline: Union[float, datetime.timedelta], callback: Callable[..., None], *args: Any, **kwargs: Any)",
        "snippet": "    def add_timeout(\n        self,\n        deadline: Union[float, datetime.timedelta],\n        callback: Callable[..., None],\n        *args: Any,\n        **kwargs: Any\n    ) -> object:\n        \"\"\"Runs the ``callback`` at the time ``deadline`` from the I/O loop.\n\n        Returns an opaque handle that may be passed to\n        `remove_timeout` to cancel.\n\n        ``deadline`` may be a number denoting a time (on the same\n        scale as `IOLoop.time`, normally `time.time`), or a\n        `datetime.timedelta` object for a deadline relative to the\n        current time.  Since Tornado 4.0, `call_later` is a more\n        convenient alternative for the relative case since it does not\n        require a timedelta object.\n\n        Note that it is not safe to call `add_timeout` from other threads.\n        Instead, you must use `add_callback` to transfer control to the\n        `IOLoop`'s thread, and then call `add_timeout` from there.\n\n        Subclasses of IOLoop must implement either `add_timeout` or\n        `call_at`; the default implementations of each will call\n        the other.  `call_at` is usually easier to implement, but\n        subclasses that wish to maintain compatibility with Tornado\n        versions prior to 4.0 must use `add_timeout` instead.\n\n        .. versionchanged:: 4.0\n           Now passes through ``*args`` and ``**kwargs`` to the callback.\n        \"\"\"\n        if isinstance(deadline, numbers.Real):\n            return self.call_at(deadline, callback, *args, **kwargs)\n        elif isinstance(deadline, datetime.timedelta):\n            return self.call_at(\n                self.time() + deadline.total_seconds(), callback, *args, **kwargs\n            )\n        else:\n            raise TypeError(\"Unsupported deadline %r\" % deadline)",
        "begin_line": 552,
        "end_line": 591,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020964360587002098,
            "pseudo_dstar_susp": 0.004219409282700422,
            "pseudo_tarantula_susp": 0.0011312217194570137,
            "pseudo_op2_susp": 0.004219409282700422,
            "pseudo_barinel_susp": 0.0011312217194570137
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.call_later#593",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.call_later(self, delay: float, callback: Callable[..., None], *args: Any, **kwargs: Any)",
        "snippet": "    def call_later(\n        self, delay: float, callback: Callable[..., None], *args: Any, **kwargs: Any\n    ) -> object:\n        \"\"\"Runs the ``callback`` after ``delay`` seconds have passed.\n\n        Returns an opaque handle that may be passed to `remove_timeout`\n        to cancel.  Note that unlike the `asyncio` method of the same\n        name, the returned object does not have a ``cancel()`` method.\n\n        See `add_timeout` for comments on thread-safety and subclassing.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        return self.call_at(self.time() + delay, callback, *args, **kwargs)",
        "begin_line": 593,
        "end_line": 606,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014064697609001407,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.spawn_callback#660",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.spawn_callback(self, callback: Callable, *args: Any, **kwargs: Any)",
        "snippet": "    def spawn_callback(self, callback: Callable, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Calls the given callback on the next IOLoop iteration.\n\n        As of Tornado 6.0, this method is equivalent to `add_callback`.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        self.add_callback(callback, *args, **kwargs)",
        "begin_line": 660,
        "end_line": 667,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011441647597254005,
            "pseudo_dstar_susp": 0.0004428697962798937,
            "pseudo_tarantula_susp": 0.011235955056179775,
            "pseudo_op2_susp": 0.0004428697962798937,
            "pseudo_barinel_susp": 0.011235955056179775
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.add_future#669",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.add_future(self, future: Union['Future[_T]', 'concurrent.futures.Future[_T]'], callback: Callable[['Future[_T]'], None])",
        "snippet": "    def add_future(\n        self,\n        future: Union[\"Future[_T]\", \"concurrent.futures.Future[_T]\"],\n        callback: Callable[[\"Future[_T]\"], None],\n    ) -> None:\n        \"\"\"Schedules a callback on the ``IOLoop`` when the given\n        `.Future` is finished.\n\n        The callback is invoked with one argument, the\n        `.Future`.\n\n        This method only accepts `.Future` objects and not other\n        awaitables (unlike most of Tornado where the two are\n        interchangeable).\n        \"\"\"\n        assert is_future(future)\n        future_add_done_callback(\n            future, lambda future: self.add_callback(callback, future)\n        )",
        "begin_line": 669,
        "end_line": 687,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012658227848101266,
            "pseudo_dstar_susp": 0.1111111111111111,
            "pseudo_tarantula_susp": 0.0011389521640091116,
            "pseudo_op2_susp": 0.1111111111111111,
            "pseudo_barinel_susp": 0.0011389521640091116
        }
    },
    {
        "name": "tornado.ioloop.IOLoop._run_callback#724",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop._run_callback(self, callback: Callable[[], Any])",
        "snippet": "    def _run_callback(self, callback: Callable[[], Any]) -> None:\n        \"\"\"Runs a callback with error handling.\n\n        For use in subclasses.\n        \"\"\"\n        try:\n            ret = callback()\n            if ret is not None:\n                from tornado import gen\n\n                # Functions that return Futures typically swallow all\n                # exceptions and store them in the Future.  If a Future\n                # makes it out to the IOLoop, ensure its exception (if any)\n                # gets logged too.\n                try:\n                    ret = gen.convert_yielded(ret)\n                except gen.BadYieldError:\n                    # It's not unusual for add_callback to be used with\n                    # methods returning a non-None and non-yieldable\n                    # result, which should just be ignored.\n                    pass\n                else:\n                    self.add_future(ret, self._discard_future_result)\n        except Exception:\n            app_log.error(\"Exception in callback %r\", callback, exc_info=True)",
        "begin_line": 724,
        "end_line": 748,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018975332068311196,
            "pseudo_dstar_susp": 0.004032258064516129,
            "pseudo_tarantula_susp": 0.0011049723756906078,
            "pseudo_op2_susp": 0.004032258064516129,
            "pseudo_barinel_susp": 0.0011049723756906078
        }
    },
    {
        "name": "tornado.ioloop.IOLoop._discard_future_result#750",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop._discard_future_result(self, future: Future)",
        "snippet": "    def _discard_future_result(self, future: Future) -> None:\n        \"\"\"Avoid unhandled-exception warnings from spawned coroutines.\"\"\"\n        future.result()",
        "begin_line": 750,
        "end_line": 752,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004710315591144607,
            "pseudo_dstar_susp": 0.0004389815627743635,
            "pseudo_tarantula_susp": 0.001148105625717566,
            "pseudo_op2_susp": 0.0004389815627743635,
            "pseudo_barinel_susp": 0.001148105625717566
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.split_fd#754",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.split_fd(self, fd: Union[int, _Selectable])",
        "snippet": "    def split_fd(\n        self, fd: Union[int, _Selectable]\n    ) -> Tuple[int, Union[int, _Selectable]]:\n        \"\"\"Returns an (fd, obj) pair from an ``fd`` parameter.\n\n        We accept both raw file descriptors and file-like objects as\n        input to `add_handler` and related methods.  When a file-like\n        object is passed, we must retain the object itself so we can\n        close it correctly when the `IOLoop` shuts down, but the\n        poller interfaces favor file descriptors (they will accept\n        file-like objects and call ``fileno()`` for you, but they\n        always return the descriptor itself).\n\n        This method is provided for use by `IOLoop` subclasses and should\n        not generally be used by application code.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        if isinstance(fd, int):\n            return fd, fd\n        return fd.fileno(), fd",
        "begin_line": 754,
        "end_line": 774,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.013333333333333334,
            "pseudo_dstar_susp": 0.00510204081632653,
            "pseudo_tarantula_susp": 0.005050505050505051,
            "pseudo_op2_susp": 0.00510204081632653,
            "pseudo_barinel_susp": 0.005050505050505051
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.close_fd#776",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.close_fd(self, fd: Union[int, _Selectable])",
        "snippet": "    def close_fd(self, fd: Union[int, _Selectable]) -> None:\n        \"\"\"Utility method to close an ``fd``.\n\n        If ``fd`` is a file-like object, we close it directly; otherwise\n        we use `os.close`.\n\n        This method is provided for use by `IOLoop` subclasses (in\n        implementations of ``IOLoop.close(all_fds=True)`` and should\n        not generally be used by application code.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        try:\n            if isinstance(fd, int):\n                os.close(fd)\n            else:\n                fd.close()\n        except OSError:\n            pass",
        "begin_line": 776,
        "end_line": 794,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018135654697134566,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.ioloop.PeriodicCallback.__init__#853",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.PeriodicCallback",
        "signature": "tornado.ioloop.PeriodicCallback.__init__(self, callback: Callable[[], None], callback_time: float, jitter: float=0)",
        "snippet": "    def __init__(\n        self, callback: Callable[[], None], callback_time: float, jitter: float = 0\n    ) -> None:\n        self.callback = callback\n        if callback_time <= 0:\n            raise ValueError(\"Periodic callback must have a positive callback_time\")\n        self.callback_time = callback_time\n        self.jitter = jitter\n        self._running = False\n        self._timeout = None  # type: object",
        "begin_line": 853,
        "end_line": 862,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019334880123743234,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.ioloop.PeriodicCallback.start#864",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.PeriodicCallback",
        "signature": "tornado.ioloop.PeriodicCallback.start(self)",
        "snippet": "    def start(self) -> None:\n        \"\"\"Starts the timer.\"\"\"\n        # Looking up the IOLoop here allows to first instantiate the\n        # PeriodicCallback in another thread, then start it using\n        # IOLoop.add_callback().\n        self.io_loop = IOLoop.current()\n        self._running = True\n        self._next_timeout = self.io_loop.time()\n        self._schedule_next()",
        "begin_line": 864,
        "end_line": 872,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.ioloop.PeriodicCallback._run#888",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.PeriodicCallback",
        "signature": "tornado.ioloop.PeriodicCallback._run(self)",
        "snippet": "    def _run(self) -> None:\n        if not self._running:\n            return\n        try:\n            return self.callback()\n        except Exception:\n            app_log.error(\"Exception in callback %r\", self.callback, exc_info=True)\n        finally:\n            self._schedule_next()",
        "begin_line": 888,
        "end_line": 896,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.ioloop.PeriodicCallback._schedule_next#898",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.PeriodicCallback",
        "signature": "tornado.ioloop.PeriodicCallback._schedule_next(self)",
        "snippet": "    def _schedule_next(self) -> None:\n        if self._running:\n            self._update_next(self.io_loop.time())\n            self._timeout = self.io_loop.add_timeout(self._next_timeout, self._run)",
        "begin_line": 898,
        "end_line": 901,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.ioloop.PeriodicCallback._update_next#903",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.PeriodicCallback",
        "signature": "tornado.ioloop.PeriodicCallback._update_next(self, current_time: float)",
        "snippet": "    def _update_next(self, current_time: float) -> None:\n        callback_time_sec = self.callback_time / 1000.0\n        if self.jitter:\n            # apply jitter fraction\n            callback_time_sec *= 1 + (self.jitter * (random.random() - 0.5))\n        if self._next_timeout <= current_time:\n            # The period should be measured from the start of one call\n            # to the start of the next. If one call takes too long,\n            # skip cycles to get back to a multiple of the original\n            # schedule.\n            self._next_timeout += (\n                math.floor((current_time - self._next_timeout) / callback_time_sec) + 1\n            ) * callback_time_sec\n        else:\n            # If the clock moved backwards, ensure we advance the next\n            # timeout instead of recomputing the same value again.\n            # This may result in long gaps between callbacks if the\n            # clock jumps backwards by a lot, but the far more common\n            # scenario is a small NTP adjustment that should just be\n            # ignored.\n            #\n            # Note that on some systems if time.time() runs slower\n            # than time.monotonic() (most common on windows), we\n            # effectively experience a small backwards time jump on\n            # every iteration because PeriodicCallback uses\n            # time.time() while asyncio schedules callbacks using\n            # time.monotonic().\n            # https://github.com/tornadoweb/tornado/issues/2333\n            self._next_timeout += callback_time_sec",
        "begin_line": 903,
        "end_line": 931,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OpenIdMixin.authenticate_redirect#88",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OpenIdMixin",
        "signature": "tornado.auth.OpenIdMixin.authenticate_redirect(self, callback_uri: str=None, ax_attrs: List[str]=['name', 'email', 'language', 'username'])",
        "snippet": "    def authenticate_redirect(\n        self,\n        callback_uri: str = None,\n        ax_attrs: List[str] = [\"name\", \"email\", \"language\", \"username\"],\n    ) -> None:\n        \"\"\"Redirects to the authentication URL for this service.\n\n        After authentication, the service will redirect back to the given\n        callback URI with additional parameters including ``openid.mode``.\n\n        We request the given attributes for the authenticated user by\n        default (name, email, language, and username). If you don't need\n        all those attributes for your app, you can request fewer with\n        the ax_attrs keyword argument.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed and this method no\n            longer returns an awaitable object. It is now an ordinary\n            synchronous function.\n        \"\"\"\n        handler = cast(RequestHandler, self)\n        callback_uri = callback_uri or handler.request.uri\n        assert callback_uri is not None\n        args = self._openid_args(callback_uri, ax_attrs=ax_attrs)\n        endpoint = self._OPENID_ENDPOINT  # type: ignore\n        handler.redirect(endpoint + \"?\" + urllib.parse.urlencode(args))",
        "begin_line": 88,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OpenIdMixin.get_authenticated_user#116",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OpenIdMixin",
        "signature": "tornado.auth.OpenIdMixin.get_authenticated_user(self, http_client: httpclient.AsyncHTTPClient=None)",
        "snippet": "    async def get_authenticated_user(\n        self, http_client: httpclient.AsyncHTTPClient = None\n    ) -> Dict[str, Any]:\n        \"\"\"Fetches the authenticated user data upon redirect.\n\n        This method should be called by the handler that receives the\n        redirect from the `authenticate_redirect()` method (which is\n        often the same as the one that calls it; in that case you would\n        call `get_authenticated_user` if the ``openid.mode`` parameter\n        is present and `authenticate_redirect` if it is not).\n\n        The result of this method will generally be used to set a cookie.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned\n            awaitable object instead.\n        \"\"\"\n        handler = cast(RequestHandler, self)\n        # Verify the OpenID response via direct request to the OP\n        args = dict(\n            (k, v[-1]) for k, v in handler.request.arguments.items()\n        )  # type: Dict[str, Union[str, bytes]]\n        args[\"openid.mode\"] = u\"check_authentication\"\n        url = self._OPENID_ENDPOINT  # type: ignore\n        if http_client is None:\n            http_client = self.get_auth_http_client()\n        resp = await http_client.fetch(\n            url, method=\"POST\", body=urllib.parse.urlencode(args)\n        )\n        return self._on_authentication_verified(resp)",
        "begin_line": 116,
        "end_line": 146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OpenIdMixin._openid_args#148",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OpenIdMixin",
        "signature": "tornado.auth.OpenIdMixin._openid_args(self, callback_uri: str, ax_attrs: Iterable[str]=[], oauth_scope: str=None)",
        "snippet": "    def _openid_args(\n        self, callback_uri: str, ax_attrs: Iterable[str] = [], oauth_scope: str = None\n    ) -> Dict[str, str]:\n        handler = cast(RequestHandler, self)\n        url = urllib.parse.urljoin(handler.request.full_url(), callback_uri)\n        args = {\n            \"openid.ns\": \"http://specs.openid.net/auth/2.0\",\n            \"openid.claimed_id\": \"http://specs.openid.net/auth/2.0/identifier_select\",\n            \"openid.identity\": \"http://specs.openid.net/auth/2.0/identifier_select\",\n            \"openid.return_to\": url,\n            \"openid.realm\": urllib.parse.urljoin(url, \"/\"),\n            \"openid.mode\": \"checkid_setup\",\n        }\n        if ax_attrs:\n            args.update(\n                {\n                    \"openid.ns.ax\": \"http://openid.net/srv/ax/1.0\",\n                    \"openid.ax.mode\": \"fetch_request\",\n                }\n            )\n            ax_attrs = set(ax_attrs)\n            required = []  # type: List[str]\n            if \"name\" in ax_attrs:\n                ax_attrs -= set([\"name\", \"firstname\", \"fullname\", \"lastname\"])\n                required += [\"firstname\", \"fullname\", \"lastname\"]\n                args.update(\n                    {\n                        \"openid.ax.type.firstname\": \"http://axschema.org/namePerson/first\",\n                        \"openid.ax.type.fullname\": \"http://axschema.org/namePerson\",\n                        \"openid.ax.type.lastname\": \"http://axschema.org/namePerson/last\",\n                    }\n                )\n            known_attrs = {\n                \"email\": \"http://axschema.org/contact/email\",\n                \"language\": \"http://axschema.org/pref/language\",\n                \"username\": \"http://axschema.org/namePerson/friendly\",\n            }\n            for name in ax_attrs:\n                args[\"openid.ax.type.\" + name] = known_attrs[name]\n                required.append(name)\n            args[\"openid.ax.required\"] = \",\".join(required)\n        if oauth_scope:\n            args.update(\n                {\n                    \"openid.ns.oauth\": \"http://specs.openid.net/extensions/oauth/1.0\",\n                    \"openid.oauth.consumer\": handler.request.host.split(\":\")[0],\n                    \"openid.oauth.scope\": oauth_scope,\n                }\n            )\n        return args",
        "begin_line": 148,
        "end_line": 197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OpenIdMixin._on_authentication_verified#199",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OpenIdMixin",
        "signature": "tornado.auth.OpenIdMixin._on_authentication_verified(self, response: httpclient.HTTPResponse)",
        "snippet": "    def _on_authentication_verified(\n        self, response: httpclient.HTTPResponse\n    ) -> Dict[str, Any]:\n        handler = cast(RequestHandler, self)\n        if b\"is_valid:true\" not in response.body:\n            raise AuthError(\"Invalid OpenID response: %s\" % response.body)\n\n        # Make sure we got back at least an email from attribute exchange\n        ax_ns = None\n        for key in handler.request.arguments:\n            if (\n                key.startswith(\"openid.ns.\")\n                and handler.get_argument(key) == u\"http://openid.net/srv/ax/1.0\"\n            ):\n                ax_ns = key[10:]\n                break\n\n        def get_ax_arg(uri: str) -> str:\n            if not ax_ns:\n                return u\"\"\n            prefix = \"openid.\" + ax_ns + \".type.\"\n            ax_name = None\n            for name in handler.request.arguments.keys():\n                if handler.get_argument(name) == uri and name.startswith(prefix):\n                    part = name[len(prefix) :]\n                    ax_name = \"openid.\" + ax_ns + \".value.\" + part\n                    break\n            if not ax_name:\n                return u\"\"\n            return handler.get_argument(ax_name, u\"\")\n\n        email = get_ax_arg(\"http://axschema.org/contact/email\")\n        name = get_ax_arg(\"http://axschema.org/namePerson\")\n        first_name = get_ax_arg(\"http://axschema.org/namePerson/first\")\n        last_name = get_ax_arg(\"http://axschema.org/namePerson/last\")\n        username = get_ax_arg(\"http://axschema.org/namePerson/friendly\")\n        locale = get_ax_arg(\"http://axschema.org/pref/language\").lower()\n        user = dict()\n        name_parts = []\n        if first_name:\n            user[\"first_name\"] = first_name\n            name_parts.append(first_name)\n        if last_name:\n            user[\"last_name\"] = last_name\n            name_parts.append(last_name)\n        if name:\n            user[\"name\"] = name\n        elif name_parts:\n            user[\"name\"] = u\" \".join(name_parts)\n        elif email:\n            user[\"name\"] = email.split(\"@\")[0]\n        if email:\n            user[\"email\"] = email\n        if locale:\n            user[\"locale\"] = locale\n        if username:\n            user[\"username\"] = username\n        claimed_id = handler.get_argument(\"openid.claimed_id\", None)\n        if claimed_id:\n            user[\"claimed_id\"] = claimed_id\n        return user",
        "begin_line": 199,
        "end_line": 259,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OpenIdMixin.get_ax_arg#216",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OpenIdMixin",
        "signature": "tornado.auth.OpenIdMixin.get_ax_arg(uri: str)",
        "snippet": "        def get_ax_arg(uri: str) -> str:\n            if not ax_ns:\n                return u\"\"\n            prefix = \"openid.\" + ax_ns + \".type.\"\n            ax_name = None\n            for name in handler.request.arguments.keys():\n                if handler.get_argument(name) == uri and name.startswith(prefix):\n                    part = name[len(prefix) :]\n                    ax_name = \"openid.\" + ax_ns + \".value.\" + part\n                    break\n            if not ax_name:\n                return u\"\"\n            return handler.get_argument(ax_name, u\"\")",
        "begin_line": 216,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OAuthMixin.authorize_redirect#287",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin.authorize_redirect(self, callback_uri: str=None, extra_params: Dict[str, Any]=None, http_client: httpclient.AsyncHTTPClient=None)",
        "snippet": "    async def authorize_redirect(\n        self,\n        callback_uri: str = None,\n        extra_params: Dict[str, Any] = None,\n        http_client: httpclient.AsyncHTTPClient = None,\n    ) -> None:\n        \"\"\"Redirects the user to obtain OAuth authorization for this service.\n\n        The ``callback_uri`` may be omitted if you have previously\n        registered a callback URI with the third-party service. For\n        some services, you must use a previously-registered callback\n        URI and cannot specify a callback via this method.\n\n        This method sets a cookie called ``_oauth_request_token`` which is\n        subsequently used (and cleared) in `get_authenticated_user` for\n        security purposes.\n\n        This method is asynchronous and must be called with ``await``\n        or ``yield`` (This is different from other ``auth*_redirect``\n        methods defined in this module). It calls\n        `.RequestHandler.finish` for you so you should not write any\n        other response after it returns.\n\n        .. versionchanged:: 3.1\n           Now returns a `.Future` and takes an optional callback, for\n           compatibility with `.gen.coroutine`.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned\n           awaitable object instead.\n\n        \"\"\"\n        if callback_uri and getattr(self, \"_OAUTH_NO_CALLBACKS\", False):\n            raise Exception(\"This service does not support oauth_callback\")\n        if http_client is None:\n            http_client = self.get_auth_http_client()\n        assert http_client is not None\n        if getattr(self, \"_OAUTH_VERSION\", \"1.0a\") == \"1.0a\":\n            response = await http_client.fetch(\n                self._oauth_request_token_url(\n                    callback_uri=callback_uri, extra_params=extra_params\n                )\n            )\n        else:\n            response = await http_client.fetch(self._oauth_request_token_url())\n        url = self._OAUTH_AUTHORIZE_URL  # type: ignore\n        self._on_request_token(url, callback_uri, response)",
        "begin_line": 287,
        "end_line": 334,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OAuthMixin.get_authenticated_user#336",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin.get_authenticated_user(self, http_client: httpclient.AsyncHTTPClient=None)",
        "snippet": "    async def get_authenticated_user(\n        self, http_client: httpclient.AsyncHTTPClient = None\n    ) -> Dict[str, Any]:\n        \"\"\"Gets the OAuth authorized user and access token.\n\n        This method should be called from the handler for your\n        OAuth callback URL to complete the registration process. We run the\n        callback with the authenticated user dictionary.  This dictionary\n        will contain an ``access_key`` which can be used to make authorized\n        requests to this service on behalf of the user.  The dictionary will\n        also contain other fields such as ``name``, depending on the service\n        used.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned\n           awaitable object instead.\n        \"\"\"\n        handler = cast(RequestHandler, self)\n        request_key = escape.utf8(handler.get_argument(\"oauth_token\"))\n        oauth_verifier = handler.get_argument(\"oauth_verifier\", None)\n        request_cookie = handler.get_cookie(\"_oauth_request_token\")\n        if not request_cookie:\n            raise AuthError(\"Missing OAuth request token cookie\")\n        handler.clear_cookie(\"_oauth_request_token\")\n        cookie_key, cookie_secret = [\n            base64.b64decode(escape.utf8(i)) for i in request_cookie.split(\"|\")\n        ]\n        if cookie_key != request_key:\n            raise AuthError(\"Request token does not match cookie\")\n        token = dict(\n            key=cookie_key, secret=cookie_secret\n        )  # type: Dict[str, Union[str, bytes]]\n        if oauth_verifier:\n            token[\"verifier\"] = oauth_verifier\n        if http_client is None:\n            http_client = self.get_auth_http_client()\n        assert http_client is not None\n        response = await http_client.fetch(self._oauth_access_token_url(token))\n        access_token = _oauth_parse_response(response.body)\n        user = await self._oauth_get_user_future(access_token)\n        if not user:\n            raise AuthError(\"Error getting user\")\n        user[\"access_token\"] = access_token\n        return user",
        "begin_line": 336,
        "end_line": 380,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OAuthMixin._oauth_request_token_url#382",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin._oauth_request_token_url(self, callback_uri: str=None, extra_params: Dict[str, Any]=None)",
        "snippet": "    def _oauth_request_token_url(\n        self, callback_uri: str = None, extra_params: Dict[str, Any] = None\n    ) -> str:\n        handler = cast(RequestHandler, self)\n        consumer_token = self._oauth_consumer_token()\n        url = self._OAUTH_REQUEST_TOKEN_URL  # type: ignore\n        args = dict(\n            oauth_consumer_key=escape.to_basestring(consumer_token[\"key\"]),\n            oauth_signature_method=\"HMAC-SHA1\",\n            oauth_timestamp=str(int(time.time())),\n            oauth_nonce=escape.to_basestring(binascii.b2a_hex(uuid.uuid4().bytes)),\n            oauth_version=\"1.0\",\n        )\n        if getattr(self, \"_OAUTH_VERSION\", \"1.0a\") == \"1.0a\":\n            if callback_uri == \"oob\":\n                args[\"oauth_callback\"] = \"oob\"\n            elif callback_uri:\n                args[\"oauth_callback\"] = urllib.parse.urljoin(\n                    handler.request.full_url(), callback_uri\n                )\n            if extra_params:\n                args.update(extra_params)\n            signature = _oauth10a_signature(consumer_token, \"GET\", url, args)\n        else:\n            signature = _oauth_signature(consumer_token, \"GET\", url, args)\n\n        args[\"oauth_signature\"] = signature\n        return url + \"?\" + urllib.parse.urlencode(args)",
        "begin_line": 382,
        "end_line": 409,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OAuthMixin._on_request_token#411",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin._on_request_token(self, authorize_url: str, callback_uri: Optional[str], response: httpclient.HTTPResponse)",
        "snippet": "    def _on_request_token(\n        self,\n        authorize_url: str,\n        callback_uri: Optional[str],\n        response: httpclient.HTTPResponse,\n    ) -> None:\n        handler = cast(RequestHandler, self)\n        request_token = _oauth_parse_response(response.body)\n        data = (\n            base64.b64encode(escape.utf8(request_token[\"key\"]))\n            + b\"|\"\n            + base64.b64encode(escape.utf8(request_token[\"secret\"]))\n        )\n        handler.set_cookie(\"_oauth_request_token\", data)\n        args = dict(oauth_token=request_token[\"key\"])\n        if callback_uri == \"oob\":\n            handler.finish(authorize_url + \"?\" + urllib.parse.urlencode(args))\n            return\n        elif callback_uri:\n            args[\"oauth_callback\"] = urllib.parse.urljoin(\n                handler.request.full_url(), callback_uri\n            )\n        handler.redirect(authorize_url + \"?\" + urllib.parse.urlencode(args))",
        "begin_line": 411,
        "end_line": 433,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OAuthMixin._oauth_access_token_url#435",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin._oauth_access_token_url(self, request_token: Dict[str, Any])",
        "snippet": "    def _oauth_access_token_url(self, request_token: Dict[str, Any]) -> str:\n        consumer_token = self._oauth_consumer_token()\n        url = self._OAUTH_ACCESS_TOKEN_URL  # type: ignore\n        args = dict(\n            oauth_consumer_key=escape.to_basestring(consumer_token[\"key\"]),\n            oauth_token=escape.to_basestring(request_token[\"key\"]),\n            oauth_signature_method=\"HMAC-SHA1\",\n            oauth_timestamp=str(int(time.time())),\n            oauth_nonce=escape.to_basestring(binascii.b2a_hex(uuid.uuid4().bytes)),\n            oauth_version=\"1.0\",\n        )\n        if \"verifier\" in request_token:\n            args[\"oauth_verifier\"] = request_token[\"verifier\"]\n\n        if getattr(self, \"_OAUTH_VERSION\", \"1.0a\") == \"1.0a\":\n            signature = _oauth10a_signature(\n                consumer_token, \"GET\", url, args, request_token\n            )\n        else:\n            signature = _oauth_signature(\n                consumer_token, \"GET\", url, args, request_token\n            )\n\n        args[\"oauth_signature\"] = signature\n        return url + \"?\" + urllib.parse.urlencode(args)",
        "begin_line": 435,
        "end_line": 459,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OAuthMixin._oauth_request_parameters#492",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin._oauth_request_parameters(self, url: str, access_token: Dict[str, Any], parameters: Dict[str, Any]={}, method: str='GET')",
        "snippet": "    def _oauth_request_parameters(\n        self,\n        url: str,\n        access_token: Dict[str, Any],\n        parameters: Dict[str, Any] = {},\n        method: str = \"GET\",\n    ) -> Dict[str, Any]:\n        \"\"\"Returns the OAuth parameters as a dict for the given request.\n\n        parameters should include all POST arguments and query string arguments\n        that will be sent with the request.\n        \"\"\"\n        consumer_token = self._oauth_consumer_token()\n        base_args = dict(\n            oauth_consumer_key=escape.to_basestring(consumer_token[\"key\"]),\n            oauth_token=escape.to_basestring(access_token[\"key\"]),\n            oauth_signature_method=\"HMAC-SHA1\",\n            oauth_timestamp=str(int(time.time())),\n            oauth_nonce=escape.to_basestring(binascii.b2a_hex(uuid.uuid4().bytes)),\n            oauth_version=\"1.0\",\n        )\n        args = {}\n        args.update(base_args)\n        args.update(parameters)\n        if getattr(self, \"_OAUTH_VERSION\", \"1.0a\") == \"1.0a\":\n            signature = _oauth10a_signature(\n                consumer_token, method, url, args, access_token\n            )\n        else:\n            signature = _oauth_signature(\n                consumer_token, method, url, args, access_token\n            )\n        base_args[\"oauth_signature\"] = escape.to_basestring(signature)\n        return base_args",
        "begin_line": 492,
        "end_line": 525,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OAuthMixin.get_auth_http_client#527",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin.get_auth_http_client(self)",
        "snippet": "    def get_auth_http_client(self) -> httpclient.AsyncHTTPClient:\n        \"\"\"Returns the `.AsyncHTTPClient` instance to be used for auth requests.\n\n        May be overridden by subclasses to use an HTTP client other than\n        the default.\n        \"\"\"\n        return httpclient.AsyncHTTPClient()",
        "begin_line": 527,
        "end_line": 533,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OAuth2Mixin.authorize_redirect#548",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuth2Mixin",
        "signature": "tornado.auth.OAuth2Mixin.authorize_redirect(self, redirect_uri: str=None, client_id: str=None, client_secret: str=None, extra_params: Dict[str, Any]=None, scope: str=None, response_type: str='code')",
        "snippet": "    def authorize_redirect(\n        self,\n        redirect_uri: str = None,\n        client_id: str = None,\n        client_secret: str = None,\n        extra_params: Dict[str, Any] = None,\n        scope: str = None,\n        response_type: str = \"code\",\n    ) -> None:\n        \"\"\"Redirects the user to obtain OAuth authorization for this service.\n\n        Some providers require that you register a redirect URL with\n        your application instead of passing one via this method. You\n        should call this method to log the user in, and then call\n        ``get_authenticated_user`` in the handler for your\n        redirect URL to complete the authorization process.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument and returned awaitable were removed;\n           this is now an ordinary synchronous function.\n        \"\"\"\n        handler = cast(RequestHandler, self)\n        args = {\"response_type\": response_type}\n        if redirect_uri is not None:\n            args[\"redirect_uri\"] = redirect_uri\n        if client_id is not None:\n            args[\"client_id\"] = client_id\n        if extra_params:\n            args.update(extra_params)\n        if scope:\n            args[\"scope\"] = \" \".join(scope)\n        url = self._OAUTH_AUTHORIZE_URL  # type: ignore\n        handler.redirect(url_concat(url, args))",
        "begin_line": 548,
        "end_line": 581,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OAuth2Mixin._oauth_request_token_url#583",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuth2Mixin",
        "signature": "tornado.auth.OAuth2Mixin._oauth_request_token_url(self, redirect_uri: str=None, client_id: str=None, client_secret: str=None, code: str=None, extra_params: Dict[str, Any]=None)",
        "snippet": "    def _oauth_request_token_url(\n        self,\n        redirect_uri: str = None,\n        client_id: str = None,\n        client_secret: str = None,\n        code: str = None,\n        extra_params: Dict[str, Any] = None,\n    ) -> str:\n        url = self._OAUTH_ACCESS_TOKEN_URL  # type: ignore\n        args = {}  # type: Dict[str, str]\n        if redirect_uri is not None:\n            args[\"redirect_uri\"] = redirect_uri\n        if code is not None:\n            args[\"code\"] = code\n        if client_id is not None:\n            args[\"client_id\"] = client_id\n        if client_secret is not None:\n            args[\"client_secret\"] = client_secret\n        if extra_params:\n            args.update(extra_params)\n        return url_concat(url, args)",
        "begin_line": 583,
        "end_line": 603,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OAuth2Mixin.oauth2_request#605",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuth2Mixin",
        "signature": "tornado.auth.OAuth2Mixin.oauth2_request(self, url: str, access_token: str=None, post_args: Dict[str, Any]=None, **args: Any)",
        "snippet": "    async def oauth2_request(\n        self,\n        url: str,\n        access_token: str = None,\n        post_args: Dict[str, Any] = None,\n        **args: Any\n    ) -> Any:\n        \"\"\"Fetches the given URL auth an OAuth2 access token.\n\n        If the request is a POST, ``post_args`` should be provided. Query\n        string arguments should be given as keyword arguments.\n\n        Example usage:\n\n        ..testcode::\n\n            class MainHandler(tornado.web.RequestHandler,\n                              tornado.auth.FacebookGraphMixin):\n                @tornado.web.authenticated\n                async def get(self):\n                    new_entry = await self.oauth2_request(\n                        \"https://graph.facebook.com/me/feed\",\n                        post_args={\"message\": \"I am posting from my Tornado application!\"},\n                        access_token=self.current_user[\"access_token\"])\n\n                    if not new_entry:\n                        # Call failed; perhaps missing permission?\n                        await self.authorize_redirect()\n                        return\n                    self.finish(\"Posted a message!\")\n\n        .. testoutput::\n           :hide:\n\n        .. versionadded:: 4.3\n\n        .. versionchanged::: 6.0\n\n           The ``callback`` argument was removed. Use the returned awaitable object instead.\n        \"\"\"\n        all_args = {}\n        if access_token:\n            all_args[\"access_token\"] = access_token\n            all_args.update(args)\n\n        if all_args:\n            url += \"?\" + urllib.parse.urlencode(all_args)\n        http = self.get_auth_http_client()\n        if post_args is not None:\n            response = await http.fetch(\n                url, method=\"POST\", body=urllib.parse.urlencode(post_args)\n            )\n        else:\n            response = await http.fetch(url)\n        return escape.json_decode(response.body)",
        "begin_line": 605,
        "end_line": 659,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.OAuth2Mixin.get_auth_http_client#661",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuth2Mixin",
        "signature": "tornado.auth.OAuth2Mixin.get_auth_http_client(self)",
        "snippet": "    def get_auth_http_client(self) -> httpclient.AsyncHTTPClient:\n        \"\"\"Returns the `.AsyncHTTPClient` instance to be used for auth requests.\n\n        May be overridden by subclasses to use an HTTP client other than\n        the default.\n\n        .. versionadded:: 4.3\n        \"\"\"\n        return httpclient.AsyncHTTPClient()",
        "begin_line": 661,
        "end_line": 669,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.TwitterMixin.authenticate_redirect#712",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.TwitterMixin",
        "signature": "tornado.auth.TwitterMixin.authenticate_redirect(self, callback_uri: str=None)",
        "snippet": "    async def authenticate_redirect(self, callback_uri: str = None) -> None:\n        \"\"\"Just like `~OAuthMixin.authorize_redirect`, but\n        auto-redirects if authorized.\n\n        This is generally the right interface to use if you are using\n        Twitter for single-sign on.\n\n        .. versionchanged:: 3.1\n           Now returns a `.Future` and takes an optional callback, for\n           compatibility with `.gen.coroutine`.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned\n           awaitable object instead.\n        \"\"\"\n        http = self.get_auth_http_client()\n        response = await http.fetch(\n            self._oauth_request_token_url(callback_uri=callback_uri)\n        )\n        self._on_request_token(self._OAUTH_AUTHENTICATE_URL, None, response)",
        "begin_line": 712,
        "end_line": 732,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.TwitterMixin.twitter_request#734",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.TwitterMixin",
        "signature": "tornado.auth.TwitterMixin.twitter_request(self, path: str, access_token: Dict[str, Any], post_args: Dict[str, Any]=None, **args: Any)",
        "snippet": "    async def twitter_request(\n        self,\n        path: str,\n        access_token: Dict[str, Any],\n        post_args: Dict[str, Any] = None,\n        **args: Any\n    ) -> Any:\n        \"\"\"Fetches the given API path, e.g., ``statuses/user_timeline/btaylor``\n\n        The path should not include the format or API version number.\n        (we automatically use JSON format and API version 1).\n\n        If the request is a POST, ``post_args`` should be provided. Query\n        string arguments should be given as keyword arguments.\n\n        All the Twitter methods are documented at http://dev.twitter.com/\n\n        Many methods require an OAuth access token which you can\n        obtain through `~OAuthMixin.authorize_redirect` and\n        `~OAuthMixin.get_authenticated_user`. The user returned through that\n        process includes an 'access_token' attribute that can be used\n        to make authenticated requests via this method. Example\n        usage:\n\n        .. testcode::\n\n            class MainHandler(tornado.web.RequestHandler,\n                              tornado.auth.TwitterMixin):\n                @tornado.web.authenticated\n                async def get(self):\n                    new_entry = await self.twitter_request(\n                        \"/statuses/update\",\n                        post_args={\"status\": \"Testing Tornado Web Server\"},\n                        access_token=self.current_user[\"access_token\"])\n                    if not new_entry:\n                        # Call failed; perhaps missing permission?\n                        yield self.authorize_redirect()\n                        return\n                    self.finish(\"Posted a message!\")\n\n        .. testoutput::\n           :hide:\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned\n           awaitable object instead.\n        \"\"\"\n        if path.startswith(\"http:\") or path.startswith(\"https:\"):\n            # Raw urls are useful for e.g. search which doesn't follow the\n            # usual pattern: http://search.twitter.com/search.json\n            url = path\n        else:\n            url = self._TWITTER_BASE_URL + path + \".json\"\n        # Add the OAuth resource request signature if we have credentials\n        if access_token:\n            all_args = {}\n            all_args.update(args)\n            all_args.update(post_args or {})\n            method = \"POST\" if post_args is not None else \"GET\"\n            oauth = self._oauth_request_parameters(\n                url, access_token, all_args, method=method\n            )\n            args.update(oauth)\n        if args:\n            url += \"?\" + urllib.parse.urlencode(args)\n        http = self.get_auth_http_client()\n        if post_args is not None:\n            response = await http.fetch(\n                url, method=\"POST\", body=urllib.parse.urlencode(post_args)\n            )\n        else:\n            response = await http.fetch(url)\n        return escape.json_decode(response.body)",
        "begin_line": 734,
        "end_line": 807,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.TwitterMixin._oauth_consumer_token#809",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.TwitterMixin",
        "signature": "tornado.auth.TwitterMixin._oauth_consumer_token(self)",
        "snippet": "    def _oauth_consumer_token(self) -> Dict[str, Any]:\n        handler = cast(RequestHandler, self)\n        handler.require_setting(\"twitter_consumer_key\", \"Twitter OAuth\")\n        handler.require_setting(\"twitter_consumer_secret\", \"Twitter OAuth\")\n        return dict(\n            key=handler.settings[\"twitter_consumer_key\"],\n            secret=handler.settings[\"twitter_consumer_secret\"],\n        )",
        "begin_line": 809,
        "end_line": 816,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019334880123743234,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.TwitterMixin._oauth_get_user_future#818",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.TwitterMixin",
        "signature": "tornado.auth.TwitterMixin._oauth_get_user_future(self, access_token: Dict[str, Any])",
        "snippet": "    async def _oauth_get_user_future(\n        self, access_token: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        user = await self.twitter_request(\n            \"/account/verify_credentials\", access_token=access_token\n        )\n        if user:\n            user[\"username\"] = user[\"screen_name\"]\n        return user",
        "begin_line": 818,
        "end_line": 826,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.GoogleOAuth2Mixin.get_authenticated_user#854",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.GoogleOAuth2Mixin",
        "signature": "tornado.auth.GoogleOAuth2Mixin.get_authenticated_user(self, redirect_uri: str, code: str)",
        "snippet": "    async def get_authenticated_user(\n        self, redirect_uri: str, code: str\n    ) -> Dict[str, Any]:\n        \"\"\"Handles the login for the Google user, returning an access token.\n\n        The result is a dictionary containing an ``access_token`` field\n        ([among others](https://developers.google.com/identity/protocols/OAuth2WebServer#handlingtheresponse)).\n        Unlike other ``get_authenticated_user`` methods in this package,\n        this method does not return any additional information about the user.\n        The returned access token can be used with `OAuth2Mixin.oauth2_request`\n        to request additional information (perhaps from\n        ``https://www.googleapis.com/oauth2/v2/userinfo``)\n\n        Example usage:\n\n        .. testcode::\n\n            class GoogleOAuth2LoginHandler(tornado.web.RequestHandler,\n                                           tornado.auth.GoogleOAuth2Mixin):\n                async def get(self):\n                    if self.get_argument('code', False):\n                        access = await self.get_authenticated_user(\n                            redirect_uri='http://your.site.com/auth/google',\n                            code=self.get_argument('code'))\n                        user = await self.oauth2_request(\n                            \"https://www.googleapis.com/oauth2/v1/userinfo\",\n                            access_token=access[\"access_token\"])\n                        # Save the user and access token with\n                        # e.g. set_secure_cookie.\n                    else:\n                        await self.authorize_redirect(\n                            redirect_uri='http://your.site.com/auth/google',\n                            client_id=self.settings['google_oauth']['key'],\n                            scope=['profile', 'email'],\n                            response_type='code',\n                            extra_params={'approval_prompt': 'auto'})\n\n        .. testoutput::\n           :hide:\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned awaitable object instead.\n        \"\"\"  # noqa: E501\n        handler = cast(RequestHandler, self)\n        http = self.get_auth_http_client()\n        body = urllib.parse.urlencode(\n            {\n                \"redirect_uri\": redirect_uri,\n                \"code\": code,\n                \"client_id\": handler.settings[self._OAUTH_SETTINGS_KEY][\"key\"],\n                \"client_secret\": handler.settings[self._OAUTH_SETTINGS_KEY][\"secret\"],\n                \"grant_type\": \"authorization_code\",\n            }\n        )\n\n        response = await http.fetch(\n            self._OAUTH_ACCESS_TOKEN_URL,\n            method=\"POST\",\n            headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n            body=body,\n        )\n        return escape.json_decode(response.body)",
        "begin_line": 854,
        "end_line": 916,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.FacebookGraphMixin.get_authenticated_user#927",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.FacebookGraphMixin",
        "signature": "tornado.auth.FacebookGraphMixin.get_authenticated_user(self, redirect_uri: str, client_id: str, client_secret: str, code: str, extra_fields: Dict[str, Any]=None)",
        "snippet": "    async def get_authenticated_user(\n        self,\n        redirect_uri: str,\n        client_id: str,\n        client_secret: str,\n        code: str,\n        extra_fields: Dict[str, Any] = None,\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"Handles the login for the Facebook user, returning a user object.\n\n        Example usage:\n\n        .. testcode::\n\n            class FacebookGraphLoginHandler(tornado.web.RequestHandler,\n                                            tornado.auth.FacebookGraphMixin):\n              async def get(self):\n                  if self.get_argument(\"code\", False):\n                      user = await self.get_authenticated_user(\n                          redirect_uri='/auth/facebookgraph/',\n                          client_id=self.settings[\"facebook_api_key\"],\n                          client_secret=self.settings[\"facebook_secret\"],\n                          code=self.get_argument(\"code\"))\n                      # Save the user with e.g. set_secure_cookie\n                  else:\n                      await self.authorize_redirect(\n                          redirect_uri='/auth/facebookgraph/',\n                          client_id=self.settings[\"facebook_api_key\"],\n                          extra_params={\"scope\": \"read_stream,offline_access\"})\n\n        .. testoutput::\n           :hide:\n\n        This method returns a dictionary which may contain the following fields:\n\n        * ``access_token``, a string which may be passed to `facebook_request`\n        * ``session_expires``, an integer encoded as a string representing\n          the time until the access token expires in seconds. This field should\n          be used like ``int(user['session_expires'])``; in a future version of\n          Tornado it will change from a string to an integer.\n        * ``id``, ``name``, ``first_name``, ``last_name``, ``locale``, ``picture``,\n          ``link``, plus any fields named in the ``extra_fields`` argument. These\n          fields are copied from the Facebook graph API\n          `user object <https://developers.facebook.com/docs/graph-api/reference/user>`_\n\n        .. versionchanged:: 4.5\n           The ``session_expires`` field was updated to support changes made to the\n           Facebook API in March 2017.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned awaitable object instead.\n        \"\"\"\n        http = self.get_auth_http_client()\n        args = {\n            \"redirect_uri\": redirect_uri,\n            \"code\": code,\n            \"client_id\": client_id,\n            \"client_secret\": client_secret,\n        }\n\n        fields = set(\n            [\"id\", \"name\", \"first_name\", \"last_name\", \"locale\", \"picture\", \"link\"]\n        )\n        if extra_fields:\n            fields.update(extra_fields)\n\n        response = await http.fetch(\n            self._oauth_request_token_url(**args)  # type: ignore\n        )\n        args = escape.json_decode(response.body)\n        session = {\n            \"access_token\": args.get(\"access_token\"),\n            \"expires_in\": args.get(\"expires_in\"),\n        }\n        assert session[\"access_token\"] is not None\n\n        user = await self.facebook_request(\n            path=\"/me\",\n            access_token=session[\"access_token\"],\n            appsecret_proof=hmac.new(\n                key=client_secret.encode(\"utf8\"),\n                msg=session[\"access_token\"].encode(\"utf8\"),\n                digestmod=hashlib.sha256,\n            ).hexdigest(),\n            fields=\",\".join(fields),\n        )\n\n        if user is None:\n            return None\n\n        fieldmap = {}\n        for field in fields:\n            fieldmap[field] = user.get(field)\n\n        # session_expires is converted to str for compatibility with\n        # older versions in which the server used url-encoding and\n        # this code simply returned the string verbatim.\n        # This should change in Tornado 5.0.\n        fieldmap.update(\n            {\n                \"access_token\": session[\"access_token\"],\n                \"session_expires\": str(session.get(\"expires_in\")),\n            }\n        )\n        return fieldmap",
        "begin_line": 927,
        "end_line": 1032,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth.FacebookGraphMixin.facebook_request#1034",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.FacebookGraphMixin",
        "signature": "tornado.auth.FacebookGraphMixin.facebook_request(self, path: str, access_token: str=None, post_args: Dict[str, Any]=None, **args: Any)",
        "snippet": "    async def facebook_request(\n        self,\n        path: str,\n        access_token: str = None,\n        post_args: Dict[str, Any] = None,\n        **args: Any\n    ) -> Any:\n        \"\"\"Fetches the given relative API path, e.g., \"/btaylor/picture\"\n\n        If the request is a POST, ``post_args`` should be provided. Query\n        string arguments should be given as keyword arguments.\n\n        An introduction to the Facebook Graph API can be found at\n        http://developers.facebook.com/docs/api\n\n        Many methods require an OAuth access token which you can\n        obtain through `~OAuth2Mixin.authorize_redirect` and\n        `get_authenticated_user`. The user returned through that\n        process includes an ``access_token`` attribute that can be\n        used to make authenticated requests via this method.\n\n        Example usage:\n\n        .. testcode::\n\n            class MainHandler(tornado.web.RequestHandler,\n                              tornado.auth.FacebookGraphMixin):\n                @tornado.web.authenticated\n                async def get(self):\n                    new_entry = await self.facebook_request(\n                        \"/me/feed\",\n                        post_args={\"message\": \"I am posting from my Tornado application!\"},\n                        access_token=self.current_user[\"access_token\"])\n\n                    if not new_entry:\n                        # Call failed; perhaps missing permission?\n                        yield self.authorize_redirect()\n                        return\n                    self.finish(\"Posted a message!\")\n\n        .. testoutput::\n           :hide:\n\n        The given path is relative to ``self._FACEBOOK_BASE_URL``,\n        by default \"https://graph.facebook.com\".\n\n        This method is a wrapper around `OAuth2Mixin.oauth2_request`;\n        the only difference is that this method takes a relative path,\n        while ``oauth2_request`` takes a complete url.\n\n        .. versionchanged:: 3.1\n           Added the ability to override ``self._FACEBOOK_BASE_URL``.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned awaitable object instead.\n        \"\"\"\n        url = self._FACEBOOK_BASE_URL + path\n        return await self.oauth2_request(\n            url, access_token=access_token, post_args=post_args, **args\n        )",
        "begin_line": 1034,
        "end_line": 1094,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth._oauth_signature#1097",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth",
        "signature": "tornado.auth._oauth_signature(consumer_token: Dict[str, Any], method: str, url: str, parameters: Dict[str, Any]={}, token: Dict[str, Any]=None)",
        "snippet": "def _oauth_signature(\n    consumer_token: Dict[str, Any],\n    method: str,\n    url: str,\n    parameters: Dict[str, Any] = {},\n    token: Dict[str, Any] = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth signature for the given request.\n\n    See http://oauth.net/core/1.0/#signing_process\n    \"\"\"\n    parts = urllib.parse.urlparse(url)\n    scheme, netloc, path = parts[:3]\n    normalized_url = scheme.lower() + \"://\" + netloc.lower() + path\n\n    base_elems = []\n    base_elems.append(method.upper())\n    base_elems.append(normalized_url)\n    base_elems.append(\n        \"&\".join(\n            \"%s=%s\" % (k, _oauth_escape(str(v))) for k, v in sorted(parameters.items())\n        )\n    )\n    base_string = \"&\".join(_oauth_escape(e) for e in base_elems)\n\n    key_elems = [escape.utf8(consumer_token[\"secret\"])]\n    key_elems.append(escape.utf8(token[\"secret\"] if token else \"\"))\n    key = b\"&\".join(key_elems)\n\n    hash = hmac.new(key, escape.utf8(base_string), hashlib.sha1)\n    return binascii.b2a_base64(hash.digest())[:-1]",
        "begin_line": 1097,
        "end_line": 1127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth._oauth10a_signature#1130",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth",
        "signature": "tornado.auth._oauth10a_signature(consumer_token: Dict[str, Any], method: str, url: str, parameters: Dict[str, Any]={}, token: Dict[str, Any]=None)",
        "snippet": "def _oauth10a_signature(\n    consumer_token: Dict[str, Any],\n    method: str,\n    url: str,\n    parameters: Dict[str, Any] = {},\n    token: Dict[str, Any] = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth 1.0a signature for the given request.\n\n    See http://oauth.net/core/1.0a/#signing_process\n    \"\"\"\n    parts = urllib.parse.urlparse(url)\n    scheme, netloc, path = parts[:3]\n    normalized_url = scheme.lower() + \"://\" + netloc.lower() + path\n\n    base_elems = []\n    base_elems.append(method.upper())\n    base_elems.append(normalized_url)\n    base_elems.append(\n        \"&\".join(\n            \"%s=%s\" % (k, _oauth_escape(str(v))) for k, v in sorted(parameters.items())\n        )\n    )\n\n    base_string = \"&\".join(_oauth_escape(e) for e in base_elems)\n    key_elems = [escape.utf8(urllib.parse.quote(consumer_token[\"secret\"], safe=\"~\"))]\n    key_elems.append(\n        escape.utf8(urllib.parse.quote(token[\"secret\"], safe=\"~\") if token else \"\")\n    )\n    key = b\"&\".join(key_elems)\n\n    hash = hmac.new(key, escape.utf8(base_string), hashlib.sha1)\n    return binascii.b2a_base64(hash.digest())[:-1]",
        "begin_line": 1130,
        "end_line": 1162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017590149516270889,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth._oauth_escape#1165",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth",
        "signature": "tornado.auth._oauth_escape(val: Union[str, bytes])",
        "snippet": "def _oauth_escape(val: Union[str, bytes]) -> str:\n    if isinstance(val, unicode_type):\n        val = val.encode(\"utf-8\")\n    return urllib.parse.quote(val, safe=\"~\")",
        "begin_line": 1165,
        "end_line": 1168,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017029972752043596,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.auth._oauth_parse_response#1171",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth",
        "signature": "tornado.auth._oauth_parse_response(body: bytes)",
        "snippet": "def _oauth_parse_response(body: bytes) -> Dict[str, Any]:\n    # I can't find an officially-defined encoding for oauth responses and\n    # have never seen anyone use non-ascii.  Leave the response in a byte\n    # string for python 2, and use utf8 on python 3.\n    body_str = escape.native_str(body)\n    p = urllib.parse.parse_qs(body_str, keep_blank_values=False)\n    token = dict(key=p[\"oauth_token\"][0], secret=p[\"oauth_token_secret\"][0])\n\n    # Add the extra parameters the Provider included to the token\n    special = (\"oauth_token\", \"oauth_token_secret\")\n    token.update((k, p[k][0]) for k in p if k not in special)\n    return token",
        "begin_line": 1171,
        "end_line": 1182,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018135654697134566,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.__init__#144",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.__init__(self, *args: Any, **kwargs: Any)",
        "snippet": "    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        # Ignore args to __init__; real initialization belongs in\n        # initialize since we're Configurable. (there's something\n        # weird in initialization order between this class,\n        # Configurable, and TCPServer so we can't leave __init__ out\n        # completely)\n        pass",
        "begin_line": 144,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009578544061302681,
            "pseudo_dstar_susp": 0.0012970168612191958,
            "pseudo_tarantula_susp": 0.0008375209380234506,
            "pseudo_op2_susp": 0.0012970168612191958,
            "pseudo_barinel_susp": 0.0008375209380234506
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.initialize#152",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.initialize(self, request_callback: Union[httputil.HTTPServerConnectionDelegate, Callable[[httputil.HTTPServerRequest], None]], no_keep_alive: bool=False, xheaders: bool=False, ssl_options: Union[Dict[str, Any], ssl.SSLContext]=None, protocol: str=None, decompress_request: bool=False, chunk_size: int=None, max_header_size: int=None, idle_connection_timeout: float=None, body_timeout: float=None, max_body_size: int=None, max_buffer_size: int=None, trusted_downstream: List[str]=None)",
        "snippet": "    def initialize(\n        self,\n        request_callback: Union[\n            httputil.HTTPServerConnectionDelegate,\n            Callable[[httputil.HTTPServerRequest], None],\n        ],\n        no_keep_alive: bool = False,\n        xheaders: bool = False,\n        ssl_options: Union[Dict[str, Any], ssl.SSLContext] = None,\n        protocol: str = None,\n        decompress_request: bool = False,\n        chunk_size: int = None,\n        max_header_size: int = None,\n        idle_connection_timeout: float = None,\n        body_timeout: float = None,\n        max_body_size: int = None,\n        max_buffer_size: int = None,\n        trusted_downstream: List[str] = None,\n    ) -> None:\n        self.request_callback = request_callback\n        self.xheaders = xheaders\n        self.protocol = protocol\n        self.conn_params = HTTP1ConnectionParameters(\n            decompress=decompress_request,\n            chunk_size=chunk_size,\n            max_header_size=max_header_size,\n            header_timeout=idle_connection_timeout or 3600,\n            max_body_size=max_body_size,\n            body_timeout=body_timeout,\n            no_keep_alive=no_keep_alive,\n        )\n        TCPServer.__init__(\n            self,\n            ssl_options=ssl_options,\n            max_buffer_size=max_buffer_size,\n            read_chunk_size=chunk_size,\n        )\n        self._connections = set()  # type: Set[HTTP1ServerConnection]\n        self.trusted_downstream = trusted_downstream",
        "begin_line": 152,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009578544061302681,
            "pseudo_dstar_susp": 0.0012970168612191958,
            "pseudo_tarantula_susp": 0.0008375209380234506,
            "pseudo_op2_susp": 0.0012970168612191958,
            "pseudo_barinel_susp": 0.0008375209380234506
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.configurable_base#193",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.configurable_base(cls)",
        "snippet": "    def configurable_base(cls) -> Type[Configurable]:\n        return HTTPServer",
        "begin_line": 193,
        "end_line": 194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009407337723424271,
            "pseudo_dstar_susp": 0.0012658227848101266,
            "pseudo_tarantula_susp": 0.0008244023083264633,
            "pseudo_op2_susp": 0.0012658227848101266,
            "pseudo_barinel_susp": 0.0008244023083264633
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.configurable_default#197",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.configurable_default(cls)",
        "snippet": "    def configurable_default(cls) -> Type[Configurable]:\n        return HTTPServer",
        "begin_line": 197,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.close_all_connections#200",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.close_all_connections(self)",
        "snippet": "    async def close_all_connections(self) -> None:\n        while self._connections:\n            # Peek at an arbitrary element of the set\n            conn = next(iter(self._connections))\n            await conn.close()",
        "begin_line": 200,
        "end_line": 204,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009718172983479105,
            "pseudo_dstar_susp": 0.0013089005235602095,
            "pseudo_tarantula_susp": 0.0008445945945945946,
            "pseudo_op2_susp": 0.0013089005235602095,
            "pseudo_barinel_susp": 0.0008445945945945946
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.handle_stream#206",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.handle_stream(self, stream: iostream.IOStream, address: Tuple)",
        "snippet": "    def handle_stream(self, stream: iostream.IOStream, address: Tuple) -> None:\n        context = _HTTPRequestContext(\n            stream, address, self.protocol, self.trusted_downstream\n        )\n        conn = HTTP1ServerConnection(stream, self.conn_params, context)\n        self._connections.add(conn)\n        conn.start_serving(self)",
        "begin_line": 206,
        "end_line": 212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010395010395010396,
            "pseudo_dstar_susp": 0.0014265335235378032,
            "pseudo_tarantula_susp": 0.0008984725965858042,
            "pseudo_op2_susp": 0.0014265335235378032,
            "pseudo_barinel_susp": 0.0008984725965858042
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.start_request#214",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.start_request(self, server_conn: object, request_conn: httputil.HTTPConnection)",
        "snippet": "    def start_request(\n        self, server_conn: object, request_conn: httputil.HTTPConnection\n    ) -> httputil.HTTPMessageDelegate:\n        if isinstance(self.request_callback, httputil.HTTPServerConnectionDelegate):\n            delegate = self.request_callback.start_request(server_conn, request_conn)\n        else:\n            delegate = _CallableAdapter(self.request_callback, request_conn)\n\n        if self.xheaders:\n            delegate = _ProxyAdapter(delegate, request_conn)\n\n        return delegate",
        "begin_line": 214,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010395010395010396,
            "pseudo_dstar_susp": 0.0014265335235378032,
            "pseudo_tarantula_susp": 0.005025125628140704,
            "pseudo_op2_susp": 0.0014265335235378032,
            "pseudo_barinel_susp": 0.005025125628140704
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.on_close#227",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.on_close(self, server_conn: object)",
        "snippet": "    def on_close(self, server_conn: object) -> None:\n        self._connections.remove(typing.cast(HTTP1ServerConnection, server_conn))",
        "begin_line": 227,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010395010395010396,
            "pseudo_dstar_susp": 0.0014265335235378032,
            "pseudo_tarantula_susp": 0.0008984725965858042,
            "pseudo_op2_susp": 0.0014265335235378032,
            "pseudo_barinel_susp": 0.0008984725965858042
        }
    },
    {
        "name": "tornado.httpserver._CallableAdapter.__init__#232",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._CallableAdapter",
        "signature": "tornado.httpserver._CallableAdapter.__init__(self, request_callback: Callable[[httputil.HTTPServerRequest], None], request_conn: httputil.HTTPConnection)",
        "snippet": "    def __init__(\n        self,\n        request_callback: Callable[[httputil.HTTPServerRequest], None],\n        request_conn: httputil.HTTPConnection,\n    ) -> None:\n        self.connection = request_conn\n        self.request_callback = request_callback\n        self.request = None  # type: Optional[httputil.HTTPServerRequest]\n        self.delegate = None\n        self._chunks = []  # type: List[bytes]",
        "begin_line": 232,
        "end_line": 241,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048007681228996637,
            "pseudo_dstar_susp": 0.0004187604690117253,
            "pseudo_tarantula_susp": 0.003194888178913738,
            "pseudo_op2_susp": 0.0004187604690117253,
            "pseudo_barinel_susp": 0.003194888178913738
        }
    },
    {
        "name": "tornado.httpserver._CallableAdapter.headers_received#243",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._CallableAdapter",
        "signature": "tornado.httpserver._CallableAdapter.headers_received(self, start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine], headers: httputil.HTTPHeaders)",
        "snippet": "    def headers_received(\n        self,\n        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],\n        headers: httputil.HTTPHeaders,\n    ) -> Optional[Awaitable[None]]:\n        self.request = httputil.HTTPServerRequest(\n            connection=self.connection,\n            start_line=typing.cast(httputil.RequestStartLine, start_line),\n            headers=headers,\n        )\n        return None",
        "begin_line": 243,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048007681228996637,
            "pseudo_dstar_susp": 0.0004187604690117253,
            "pseudo_tarantula_susp": 0.003194888178913738,
            "pseudo_op2_susp": 0.0004187604690117253,
            "pseudo_barinel_susp": 0.003194888178913738
        }
    },
    {
        "name": "tornado.httpserver._CallableAdapter.finish#259",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._CallableAdapter",
        "signature": "tornado.httpserver._CallableAdapter.finish(self)",
        "snippet": "    def finish(self) -> None:\n        assert self.request is not None\n        self.request.body = b\"\".join(self._chunks)\n        self.request._parse_body()\n        self.request_callback(self.request)",
        "begin_line": 259,
        "end_line": 263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048007681228996637,
            "pseudo_dstar_susp": 0.0004187604690117253,
            "pseudo_tarantula_susp": 0.003194888178913738,
            "pseudo_op2_susp": 0.0004187604690117253,
            "pseudo_barinel_susp": 0.003194888178913738
        }
    },
    {
        "name": "tornado.httpserver._HTTPRequestContext.__init__#270",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._HTTPRequestContext",
        "signature": "tornado.httpserver._HTTPRequestContext.__init__(self, stream: iostream.IOStream, address: Tuple, protocol: Optional[str], trusted_downstream: List[str]=None)",
        "snippet": "    def __init__(\n        self,\n        stream: iostream.IOStream,\n        address: Tuple,\n        protocol: Optional[str],\n        trusted_downstream: List[str] = None,\n    ) -> None:\n        self.address = address\n        # Save the socket's address family now so we know how to\n        # interpret self.address even after the stream is closed\n        # and its socket attribute replaced with None.\n        if stream.socket is not None:\n            self.address_family = stream.socket.family\n        else:\n            self.address_family = None\n        # In HTTPServerRequest we want an IP, not a full socket address.\n        if (\n            self.address_family in (socket.AF_INET, socket.AF_INET6)\n            and address is not None\n        ):\n            self.remote_ip = address[0]\n        else:\n            # Unix (or other) socket; fake the remote address.\n            self.remote_ip = \"0.0.0.0\"\n        if protocol:\n            self.protocol = protocol\n        elif isinstance(stream, iostream.SSLIOStream):\n            self.protocol = \"https\"\n        else:\n            self.protocol = \"http\"\n        self._orig_remote_ip = self.remote_ip\n        self._orig_protocol = self.protocol\n        self.trusted_downstream = set(trusted_downstream or [])",
        "begin_line": 270,
        "end_line": 302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010718113612004287,
            "pseudo_dstar_susp": 0.0014792899408284023,
            "pseudo_tarantula_susp": 0.011235955056179775,
            "pseudo_op2_susp": 0.0014792899408284023,
            "pseudo_barinel_susp": 0.011235955056179775
        }
    },
    {
        "name": "tornado.httpserver._HTTPRequestContext._apply_xheaders#315",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._HTTPRequestContext",
        "signature": "tornado.httpserver._HTTPRequestContext._apply_xheaders(self, headers: httputil.HTTPHeaders)",
        "snippet": "    def _apply_xheaders(self, headers: httputil.HTTPHeaders) -> None:\n        \"\"\"Rewrite the ``remote_ip`` and ``protocol`` fields.\"\"\"\n        # Squid uses X-Forwarded-For, others use X-Real-Ip\n        ip = headers.get(\"X-Forwarded-For\", self.remote_ip)\n        # Skip trusted downstream hosts in X-Forwarded-For list\n        for ip in (cand.strip() for cand in reversed(ip.split(\",\"))):\n            if ip not in self.trusted_downstream:\n                break\n        ip = headers.get(\"X-Real-Ip\", ip)\n        if netutil.is_valid_ip(ip):\n            self.remote_ip = ip\n        # AWS uses X-Forwarded-Proto\n        proto_header = headers.get(\n            \"X-Scheme\", headers.get(\"X-Forwarded-Proto\", self.protocol)\n        )\n        if proto_header:\n            # use only the last proto entry if there is more than one\n            # TODO: support trusting mutiple layers of proxied protocol\n            proto_header = proto_header.split(\",\")[-1].strip()\n        if proto_header in (\"http\", \"https\"):\n            self.protocol = proto_header",
        "begin_line": 315,
        "end_line": 335,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpserver._HTTPRequestContext._unapply_xheaders#337",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._HTTPRequestContext",
        "signature": "tornado.httpserver._HTTPRequestContext._unapply_xheaders(self)",
        "snippet": "    def _unapply_xheaders(self) -> None:\n        \"\"\"Undo changes from `_apply_xheaders`.\n\n        Xheaders are per-request so they should not leak to the next\n        request on the same connection.\n        \"\"\"\n        self.remote_ip = self._orig_remote_ip\n        self.protocol = self._orig_protocol",
        "begin_line": 337,
        "end_line": 344,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpserver._ProxyAdapter.__init__#348",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._ProxyAdapter",
        "signature": "tornado.httpserver._ProxyAdapter.__init__(self, delegate: httputil.HTTPMessageDelegate, request_conn: httputil.HTTPConnection)",
        "snippet": "    def __init__(\n        self,\n        delegate: httputil.HTTPMessageDelegate,\n        request_conn: httputil.HTTPConnection,\n    ) -> None:\n        self.connection = request_conn\n        self.delegate = delegate",
        "begin_line": 348,
        "end_line": 354,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpserver._ProxyAdapter.headers_received#356",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._ProxyAdapter",
        "signature": "tornado.httpserver._ProxyAdapter.headers_received(self, start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine], headers: httputil.HTTPHeaders)",
        "snippet": "    def headers_received(\n        self,\n        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],\n        headers: httputil.HTTPHeaders,\n    ) -> Optional[Awaitable[None]]:\n        # TODO: either make context an official part of the\n        # HTTPConnection interface or figure out some other way to do this.\n        self.connection.context._apply_xheaders(headers)  # type: ignore\n        return self.delegate.headers_received(start_line, headers)",
        "begin_line": 356,
        "end_line": 364,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpserver._ProxyAdapter.finish#369",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._ProxyAdapter",
        "signature": "tornado.httpserver._ProxyAdapter.finish(self)",
        "snippet": "    def finish(self) -> None:\n        self.delegate.finish()\n        self._cleanup()",
        "begin_line": 369,
        "end_line": 371,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpserver._ProxyAdapter._cleanup#377",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._ProxyAdapter",
        "signature": "tornado.httpserver._ProxyAdapter._cleanup(self)",
        "snippet": "    def _cleanup(self) -> None:\n        self.connection.context._unapply_xheaders()  # type: ignore",
        "begin_line": 377,
        "end_line": 378,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.filter_whitespace#226",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template",
        "signature": "tornado.template.filter_whitespace(mode: str, text: str)",
        "snippet": "def filter_whitespace(mode: str, text: str) -> str:\n    \"\"\"Transform whitespace in ``text`` according to ``mode``.\n\n    Available modes are:\n\n    * ``all``: Return all whitespace unmodified.\n    * ``single``: Collapse consecutive whitespace with a single whitespace\n      character, preserving newlines.\n    * ``oneline``: Collapse all runs of whitespace into a single space\n      character, removing all newlines in the process.\n\n    .. versionadded:: 4.3\n    \"\"\"\n    if mode == \"all\":\n        return text\n    elif mode == \"single\":\n        text = re.sub(r\"([\\t ]+)\", \" \", text)\n        text = re.sub(r\"(\\s*\\n\\s*)\", \"\\n\", text)\n        return text\n    elif mode == \"oneline\":\n        return re.sub(r\"(\\s+)\", \" \", text)\n    else:\n        raise Exception(\"invalid whitespace mode %s\" % mode)",
        "begin_line": 226,
        "end_line": 248,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.Template.__init__#261",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Template",
        "signature": "tornado.template.Template.__init__(self, template_string: Union[str, bytes], name: str='<string>', loader: 'BaseLoader'=None, compress_whitespace: Union[bool, _UnsetMarker]=_UNSET, autoescape: Union[str, _UnsetMarker]=_UNSET, whitespace: str=None)",
        "snippet": "    def __init__(\n        self,\n        template_string: Union[str, bytes],\n        name: str = \"<string>\",\n        loader: \"BaseLoader\" = None,\n        compress_whitespace: Union[bool, _UnsetMarker] = _UNSET,\n        autoescape: Union[str, _UnsetMarker] = _UNSET,\n        whitespace: str = None,\n    ) -> None:\n        \"\"\"Construct a Template.\n\n        :arg str template_string: the contents of the template file.\n        :arg str name: the filename from which the template was loaded\n            (used for error message).\n        :arg tornado.template.BaseLoader loader: the `~tornado.template.BaseLoader` responsible\n            for this template, used to resolve ``{% include %}`` and ``{% extend %}`` directives.\n        :arg bool compress_whitespace: Deprecated since Tornado 4.3.\n            Equivalent to ``whitespace=\"single\"`` if true and\n            ``whitespace=\"all\"`` if false.\n        :arg str autoescape: The name of a function in the template\n            namespace, or ``None`` to disable escaping by default.\n        :arg str whitespace: A string specifying treatment of whitespace;\n            see `filter_whitespace` for options.\n\n        .. versionchanged:: 4.3\n           Added ``whitespace`` parameter; deprecated ``compress_whitespace``.\n        \"\"\"\n        self.name = escape.native_str(name)\n\n        if compress_whitespace is not _UNSET:\n            # Convert deprecated compress_whitespace (bool) to whitespace (str).\n            if whitespace is not None:\n                raise Exception(\"cannot set both whitespace and compress_whitespace\")\n            whitespace = \"single\" if compress_whitespace else \"all\"\n        if whitespace is None:\n            if loader and loader.whitespace:\n                whitespace = loader.whitespace\n            else:\n                # Whitespace defaults by filename.\n                if name.endswith(\".html\") or name.endswith(\".js\"):\n                    whitespace = \"single\"\n                else:\n                    whitespace = \"all\"\n        # Validate the whitespace setting.\n        assert whitespace is not None\n        filter_whitespace(whitespace, \"\")\n\n        if not isinstance(autoescape, _UnsetMarker):\n            self.autoescape = autoescape  # type: Optional[str]\n        elif loader:\n            self.autoescape = loader.autoescape\n        else:\n            self.autoescape = _DEFAULT_AUTOESCAPE\n\n        self.namespace = loader.namespace if loader else {}\n        reader = _TemplateReader(name, escape.native_str(template_string), whitespace)\n        self.file = _File(self, _parse(reader, self))\n        self.code = self._generate_python(loader)\n        self.loader = loader\n        try:\n            # Under python2.5, the fake filename used here must match\n            # the module name used in __name__ below.\n            # The dont_inherit flag prevents template.py's future imports\n            # from being applied to the generated code.\n            self.compiled = compile(\n                escape.to_unicode(self.code),\n                \"%s.generated.py\" % self.name.replace(\".\", \"_\"),\n                \"exec\",\n                dont_inherit=True,\n            )\n        except Exception:\n            formatted_code = _format_code(self.code).rstrip()\n            app_log.error(\"%s code:\\n%s\", self.name, formatted_code)\n            raise",
        "begin_line": 261,
        "end_line": 334,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.Template.generate#336",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Template",
        "signature": "tornado.template.Template.generate(self, **kwargs: Any)",
        "snippet": "    def generate(self, **kwargs: Any) -> bytes:\n        \"\"\"Generate this template with the given arguments.\"\"\"\n        namespace = {\n            \"escape\": escape.xhtml_escape,\n            \"xhtml_escape\": escape.xhtml_escape,\n            \"url_escape\": escape.url_escape,\n            \"json_encode\": escape.json_encode,\n            \"squeeze\": escape.squeeze,\n            \"linkify\": escape.linkify,\n            \"datetime\": datetime,\n            \"_tt_utf8\": escape.utf8,  # for internal use\n            \"_tt_string_types\": (unicode_type, bytes),\n            # __name__ and __loader__ allow the traceback mechanism to find\n            # the generated source code.\n            \"__name__\": self.name.replace(\".\", \"_\"),\n            \"__loader__\": ObjectDict(get_source=lambda name: self.code),\n        }\n        namespace.update(self.namespace)\n        namespace.update(kwargs)\n        exec_in(self.compiled, namespace)\n        execute = typing.cast(Callable[[], bytes], namespace[\"_tt_execute\"])\n        # Clear the traceback module's cache of source data now that\n        # we've generated a new template (mainly for this module's\n        # unittests, where different tests reuse the same name).\n        linecache.clearcache()\n        return execute()",
        "begin_line": 336,
        "end_line": 361,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014457134595923088,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.Template._generate_python#363",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Template",
        "signature": "tornado.template.Template._generate_python(self, loader: Optional['BaseLoader'])",
        "snippet": "    def _generate_python(self, loader: Optional[\"BaseLoader\"]) -> str:\n        buffer = StringIO()\n        try:\n            # named_blocks maps from names to _NamedBlock objects\n            named_blocks = {}  # type: Dict[str, _NamedBlock]\n            ancestors = self._get_ancestors(loader)\n            ancestors.reverse()\n            for ancestor in ancestors:\n                ancestor.find_named_blocks(loader, named_blocks)\n            writer = _CodeWriter(buffer, named_blocks, loader, ancestors[0].template)\n            ancestors[0].generate(writer)\n            return buffer.getvalue()\n        finally:\n            buffer.close()",
        "begin_line": 363,
        "end_line": 376,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014457134595923088,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.Template._get_ancestors#378",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Template",
        "signature": "tornado.template.Template._get_ancestors(self, loader: Optional['BaseLoader'])",
        "snippet": "    def _get_ancestors(self, loader: Optional[\"BaseLoader\"]) -> List[\"_File\"]:\n        ancestors = [self.file]\n        for chunk in self.file.body.chunks:\n            if isinstance(chunk, _ExtendsBlock):\n                if not loader:\n                    raise ParseError(\n                        \"{% extends %} block found, but no \" \"template loader\"\n                    )\n                template = loader.load(chunk.name, self.name)\n                ancestors.extend(template._get_ancestors(loader))\n        return ancestors",
        "begin_line": 378,
        "end_line": 388,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.BaseLoader.__init__#399",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.BaseLoader",
        "signature": "tornado.template.BaseLoader.__init__(self, autoescape: str=_DEFAULT_AUTOESCAPE, namespace: Dict[str, Any]=None, whitespace: str=None)",
        "snippet": "    def __init__(\n        self,\n        autoescape: str = _DEFAULT_AUTOESCAPE,\n        namespace: Dict[str, Any] = None,\n        whitespace: str = None,\n    ) -> None:\n        \"\"\"Construct a template loader.\n\n        :arg str autoescape: The name of a function in the template\n            namespace, such as \"xhtml_escape\", or ``None`` to disable\n            autoescaping by default.\n        :arg dict namespace: A dictionary to be added to the default template\n            namespace, or ``None``.\n        :arg str whitespace: A string specifying default behavior for\n            whitespace in templates; see `filter_whitespace` for options.\n            Default is \"single\" for files ending in \".html\" and \".js\" and\n            \"all\" for other files.\n\n        .. versionchanged:: 4.3\n           Added ``whitespace`` parameter.\n        \"\"\"\n        self.autoescape = autoescape\n        self.namespace = namespace or {}\n        self.whitespace = whitespace\n        self.templates = {}  # type: Dict[str, Template]\n        # self.lock protects self.templates.  It's a reentrant lock\n        # because templates may load other templates via `include` or\n        # `extends`.  Note that thanks to the GIL this code would be safe\n        # even without the lock, but could lead to wasted work as multiple\n        # threads tried to compile the same template simultaneously.\n        self.lock = threading.RLock()",
        "begin_line": 399,
        "end_line": 429,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00013970382788488405,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.BaseLoader.load#440",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.BaseLoader",
        "signature": "tornado.template.BaseLoader.load(self, name: str, parent_path: str=None)",
        "snippet": "    def load(self, name: str, parent_path: str = None) -> Template:\n        \"\"\"Loads a template.\"\"\"\n        name = self.resolve_path(name, parent_path=parent_path)\n        with self.lock:\n            if name not in self.templates:\n                self.templates[name] = self._create_template(name)\n            return self.templates[name]",
        "begin_line": 440,
        "end_line": 446,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001543924656476764,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.Loader.__init__#456",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Loader",
        "signature": "tornado.template.Loader.__init__(self, root_directory: str, **kwargs: Any)",
        "snippet": "    def __init__(self, root_directory: str, **kwargs: Any) -> None:\n        super(Loader, self).__init__(**kwargs)\n        self.root = os.path.abspath(root_directory)",
        "begin_line": 456,
        "end_line": 458,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.Loader.resolve_path#460",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Loader",
        "signature": "tornado.template.Loader.resolve_path(self, name: str, parent_path: str=None)",
        "snippet": "    def resolve_path(self, name: str, parent_path: str = None) -> str:\n        if (\n            parent_path\n            and not parent_path.startswith(\"<\")\n            and not parent_path.startswith(\"/\")\n            and not name.startswith(\"/\")\n        ):\n            current_path = os.path.join(self.root, parent_path)\n            file_dir = os.path.dirname(os.path.abspath(current_path))\n            relative_path = os.path.abspath(os.path.join(file_dir, name))\n            if relative_path.startswith(self.root):\n                name = relative_path[len(self.root) + 1 :]\n        return name",
        "begin_line": 460,
        "end_line": 472,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.Loader._create_template#474",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Loader",
        "signature": "tornado.template.Loader._create_template(self, name: str)",
        "snippet": "    def _create_template(self, name: str) -> Template:\n        path = os.path.join(self.root, name)\n        with open(path, \"rb\") as f:\n            template = Template(f.read(), name=name, loader=self)\n            return template",
        "begin_line": 474,
        "end_line": 478,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.DictLoader.__init__#484",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.DictLoader",
        "signature": "tornado.template.DictLoader.__init__(self, dict: Dict[str, str], **kwargs: Any)",
        "snippet": "    def __init__(self, dict: Dict[str, str], **kwargs: Any) -> None:\n        super(DictLoader, self).__init__(**kwargs)\n        self.dict = dict",
        "begin_line": 484,
        "end_line": 486,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00013984058173682003,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.DictLoader.resolve_path#488",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.DictLoader",
        "signature": "tornado.template.DictLoader.resolve_path(self, name: str, parent_path: str=None)",
        "snippet": "    def resolve_path(self, name: str, parent_path: str = None) -> str:\n        if (\n            parent_path\n            and not parent_path.startswith(\"<\")\n            and not parent_path.startswith(\"/\")\n            and not name.startswith(\"/\")\n        ):\n            file_dir = posixpath.dirname(parent_path)\n            name = posixpath.normpath(posixpath.join(file_dir, name))\n        return name",
        "begin_line": 488,
        "end_line": 497,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017590149516270889,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.DictLoader._create_template#499",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.DictLoader",
        "signature": "tornado.template.DictLoader._create_template(self, name: str)",
        "snippet": "    def _create_template(self, name: str) -> Template:\n        return Template(self.dict[name], name=name, loader=self)",
        "begin_line": 499,
        "end_line": 500,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001543924656476764,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._Node.each_child#504",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Node",
        "signature": "tornado.template._Node.each_child(self)",
        "snippet": "    def each_child(self) -> Iterable[\"_Node\"]:\n        return ()",
        "begin_line": 504,
        "end_line": 505,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014457134595923088,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._Node.find_named_blocks#510",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Node",
        "signature": "tornado.template._Node.find_named_blocks(self, loader: Optional[BaseLoader], named_blocks: Dict[str, '_NamedBlock'])",
        "snippet": "    def find_named_blocks(\n        self, loader: Optional[BaseLoader], named_blocks: Dict[str, \"_NamedBlock\"]\n    ) -> None:\n        for child in self.each_child():\n            child.find_named_blocks(loader, named_blocks)",
        "begin_line": 510,
        "end_line": 514,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014457134595923088,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._File.__init__#518",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._File",
        "signature": "tornado.template._File.__init__(self, template: Template, body: '_ChunkList')",
        "snippet": "    def __init__(self, template: Template, body: \"_ChunkList\") -> None:\n        self.template = template\n        self.body = body\n        self.line = 0",
        "begin_line": 518,
        "end_line": 521,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014457134595923088,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._File.generate#523",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._File",
        "signature": "tornado.template._File.generate(self, writer: '_CodeWriter')",
        "snippet": "    def generate(self, writer: \"_CodeWriter\") -> None:\n        writer.write_line(\"def _tt_execute():\", self.line)\n        with writer.indent():\n            writer.write_line(\"_tt_buffer = []\", self.line)\n            writer.write_line(\"_tt_append = _tt_buffer.append\", self.line)\n            self.body.generate(writer)\n            writer.write_line(\"return _tt_utf8('').join(_tt_buffer)\", self.line)",
        "begin_line": 523,
        "end_line": 529,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014457134595923088,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._File.each_child#531",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._File",
        "signature": "tornado.template._File.each_child(self)",
        "snippet": "    def each_child(self) -> Iterable[\"_Node\"]:\n        return (self.body,)",
        "begin_line": 531,
        "end_line": 532,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014457134595923088,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._ChunkList.__init__#536",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ChunkList",
        "signature": "tornado.template._ChunkList.__init__(self, chunks: List[_Node])",
        "snippet": "    def __init__(self, chunks: List[_Node]) -> None:\n        self.chunks = chunks",
        "begin_line": 536,
        "end_line": 537,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001422879908935686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._ChunkList.generate#539",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ChunkList",
        "signature": "tornado.template._ChunkList.generate(self, writer: '_CodeWriter')",
        "snippet": "    def generate(self, writer: \"_CodeWriter\") -> None:\n        for chunk in self.chunks:\n            chunk.generate(writer)",
        "begin_line": 539,
        "end_line": 541,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014457134595923088,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._ChunkList.each_child#543",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ChunkList",
        "signature": "tornado.template._ChunkList.each_child(self)",
        "snippet": "    def each_child(self) -> Iterable[\"_Node\"]:\n        return self.chunks",
        "begin_line": 543,
        "end_line": 544,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014457134595923088,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._NamedBlock.__init__#548",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._NamedBlock",
        "signature": "tornado.template._NamedBlock.__init__(self, name: str, body: _Node, template: Template, line: int)",
        "snippet": "    def __init__(self, name: str, body: _Node, template: Template, line: int) -> None:\n        self.name = name\n        self.body = body\n        self.template = template\n        self.line = line",
        "begin_line": 548,
        "end_line": 552,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._NamedBlock.each_child#554",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._NamedBlock",
        "signature": "tornado.template._NamedBlock.each_child(self)",
        "snippet": "    def each_child(self) -> Iterable[\"_Node\"]:\n        return (self.body,)",
        "begin_line": 554,
        "end_line": 555,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._NamedBlock.generate#557",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._NamedBlock",
        "signature": "tornado.template._NamedBlock.generate(self, writer: '_CodeWriter')",
        "snippet": "    def generate(self, writer: \"_CodeWriter\") -> None:\n        block = writer.named_blocks[self.name]\n        with writer.include(block.template, self.line):\n            block.body.generate(writer)",
        "begin_line": 557,
        "end_line": 560,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._NamedBlock.find_named_blocks#562",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._NamedBlock",
        "signature": "tornado.template._NamedBlock.find_named_blocks(self, loader: Optional[BaseLoader], named_blocks: Dict[str, '_NamedBlock'])",
        "snippet": "    def find_named_blocks(\n        self, loader: Optional[BaseLoader], named_blocks: Dict[str, \"_NamedBlock\"]\n    ) -> None:\n        named_blocks[self.name] = self\n        _Node.find_named_blocks(self, loader, named_blocks)",
        "begin_line": 562,
        "end_line": 566,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._ExtendsBlock.__init__#570",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ExtendsBlock",
        "signature": "tornado.template._ExtendsBlock.__init__(self, name: str)",
        "snippet": "    def __init__(self, name: str) -> None:\n        self.name = name",
        "begin_line": 570,
        "end_line": 571,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._IncludeBlock.__init__#575",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._IncludeBlock",
        "signature": "tornado.template._IncludeBlock.__init__(self, name: str, reader: '_TemplateReader', line: int)",
        "snippet": "    def __init__(self, name: str, reader: \"_TemplateReader\", line: int) -> None:\n        self.name = name\n        self.template_name = reader.name\n        self.line = line",
        "begin_line": 575,
        "end_line": 578,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001892863903085368,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._IncludeBlock.find_named_blocks#580",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._IncludeBlock",
        "signature": "tornado.template._IncludeBlock.find_named_blocks(self, loader: Optional[BaseLoader], named_blocks: Dict[str, _NamedBlock])",
        "snippet": "    def find_named_blocks(\n        self, loader: Optional[BaseLoader], named_blocks: Dict[str, _NamedBlock]\n    ) -> None:\n        assert loader is not None\n        included = loader.load(self.name, self.template_name)\n        included.file.find_named_blocks(loader, named_blocks)",
        "begin_line": 580,
        "end_line": 585,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001892863903085368,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._IncludeBlock.generate#587",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._IncludeBlock",
        "signature": "tornado.template._IncludeBlock.generate(self, writer: '_CodeWriter')",
        "snippet": "    def generate(self, writer: \"_CodeWriter\") -> None:\n        assert writer.loader is not None\n        included = writer.loader.load(self.name, self.template_name)\n        with writer.include(included, self.line):\n            included.file.body.generate(writer)",
        "begin_line": 587,
        "end_line": 591,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001892863903085368,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._ApplyBlock.__init__#595",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ApplyBlock",
        "signature": "tornado.template._ApplyBlock.__init__(self, method: str, line: int, body: _Node)",
        "snippet": "    def __init__(self, method: str, line: int, body: _Node) -> None:\n        self.method = method\n        self.line = line\n        self.body = body",
        "begin_line": 595,
        "end_line": 598,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._ApplyBlock.each_child#600",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ApplyBlock",
        "signature": "tornado.template._ApplyBlock.each_child(self)",
        "snippet": "    def each_child(self) -> Iterable[\"_Node\"]:\n        return (self.body,)",
        "begin_line": 600,
        "end_line": 601,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._ApplyBlock.generate#603",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ApplyBlock",
        "signature": "tornado.template._ApplyBlock.generate(self, writer: '_CodeWriter')",
        "snippet": "    def generate(self, writer: \"_CodeWriter\") -> None:\n        method_name = \"_tt_apply%d\" % writer.apply_counter\n        writer.apply_counter += 1\n        writer.write_line(\"def %s():\" % method_name, self.line)\n        with writer.indent():\n            writer.write_line(\"_tt_buffer = []\", self.line)\n            writer.write_line(\"_tt_append = _tt_buffer.append\", self.line)\n            self.body.generate(writer)\n            writer.write_line(\"return _tt_utf8('').join(_tt_buffer)\", self.line)\n        writer.write_line(\n            \"_tt_append(_tt_utf8(%s(%s())))\" % (self.method, method_name), self.line\n        )",
        "begin_line": 603,
        "end_line": 614,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._ControlBlock.__init__#618",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ControlBlock",
        "signature": "tornado.template._ControlBlock.__init__(self, statement: str, line: int, body: _Node)",
        "snippet": "    def __init__(self, statement: str, line: int, body: _Node) -> None:\n        self.statement = statement\n        self.line = line\n        self.body = body",
        "begin_line": 618,
        "end_line": 621,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._ControlBlock.each_child#623",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ControlBlock",
        "signature": "tornado.template._ControlBlock.each_child(self)",
        "snippet": "    def each_child(self) -> Iterable[_Node]:\n        return (self.body,)",
        "begin_line": 623,
        "end_line": 624,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._ControlBlock.generate#626",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ControlBlock",
        "signature": "tornado.template._ControlBlock.generate(self, writer: '_CodeWriter')",
        "snippet": "    def generate(self, writer: \"_CodeWriter\") -> None:\n        writer.write_line(\"%s:\" % self.statement, self.line)\n        with writer.indent():\n            self.body.generate(writer)\n            # Just in case the body was empty\n            writer.write_line(\"pass\", self.line)",
        "begin_line": 626,
        "end_line": 631,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._IntermediateControlBlock.__init__#635",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._IntermediateControlBlock",
        "signature": "tornado.template._IntermediateControlBlock.__init__(self, statement: str, line: int)",
        "snippet": "    def __init__(self, statement: str, line: int) -> None:\n        self.statement = statement\n        self.line = line",
        "begin_line": 635,
        "end_line": 637,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._IntermediateControlBlock.generate#639",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._IntermediateControlBlock",
        "signature": "tornado.template._IntermediateControlBlock.generate(self, writer: '_CodeWriter')",
        "snippet": "    def generate(self, writer: \"_CodeWriter\") -> None:\n        # In case the previous block was empty\n        writer.write_line(\"pass\", self.line)\n        writer.write_line(\"%s:\" % self.statement, self.line, writer.indent_size() - 1)",
        "begin_line": 639,
        "end_line": 642,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._Statement.__init__#646",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Statement",
        "signature": "tornado.template._Statement.__init__(self, statement: str, line: int)",
        "snippet": "    def __init__(self, statement: str, line: int) -> None:\n        self.statement = statement\n        self.line = line",
        "begin_line": 646,
        "end_line": 648,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._Statement.generate#650",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Statement",
        "signature": "tornado.template._Statement.generate(self, writer: '_CodeWriter')",
        "snippet": "    def generate(self, writer: \"_CodeWriter\") -> None:\n        writer.write_line(self.statement, self.line)",
        "begin_line": 650,
        "end_line": 651,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._Expression.__init__#655",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Expression",
        "signature": "tornado.template._Expression.__init__(self, expression: str, line: int, raw: bool=False)",
        "snippet": "    def __init__(self, expression: str, line: int, raw: bool = False) -> None:\n        self.expression = expression\n        self.line = line\n        self.raw = raw",
        "begin_line": 655,
        "end_line": 658,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015603058199407084,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._Expression.generate#660",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Expression",
        "signature": "tornado.template._Expression.generate(self, writer: '_CodeWriter')",
        "snippet": "    def generate(self, writer: \"_CodeWriter\") -> None:\n        writer.write_line(\"_tt_tmp = %s\" % self.expression, self.line)\n        writer.write_line(\n            \"if isinstance(_tt_tmp, _tt_string_types):\" \" _tt_tmp = _tt_utf8(_tt_tmp)\",\n            self.line,\n        )\n        writer.write_line(\"else: _tt_tmp = _tt_utf8(str(_tt_tmp))\", self.line)\n        if not self.raw and writer.current_template.autoescape is not None:\n            # In python3 functions like xhtml_escape return unicode,\n            # so we have to convert to utf8 again.\n            writer.write_line(\n                \"_tt_tmp = _tt_utf8(%s(_tt_tmp))\" % writer.current_template.autoescape,\n                self.line,\n            )\n        writer.write_line(\"_tt_append(_tt_tmp)\", self.line)",
        "begin_line": 660,
        "end_line": 674,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016074586079408456,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._Module.__init__#678",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Module",
        "signature": "tornado.template._Module.__init__(self, expression: str, line: int)",
        "snippet": "    def __init__(self, expression: str, line: int) -> None:\n        super(_Module, self).__init__(\"_tt_modules.\" + expression, line, raw=True)",
        "begin_line": 678,
        "end_line": 679,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019334880123743234,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._Text.__init__#683",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Text",
        "signature": "tornado.template._Text.__init__(self, value: str, line: int, whitespace: str)",
        "snippet": "    def __init__(self, value: str, line: int, whitespace: str) -> None:\n        self.value = value\n        self.line = line\n        self.whitespace = whitespace",
        "begin_line": 683,
        "end_line": 686,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014332807797047442,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._Text.generate#688",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Text",
        "signature": "tornado.template._Text.generate(self, writer: '_CodeWriter')",
        "snippet": "    def generate(self, writer: \"_CodeWriter\") -> None:\n        value = self.value\n\n        # Compress whitespace if requested, with a crude heuristic to avoid\n        # altering preformatted whitespace.\n        if \"<pre>\" not in value:\n            value = filter_whitespace(self.whitespace, value)\n\n        if value:\n            writer.write_line(\"_tt_append(%r)\" % escape.utf8(value), self.line)",
        "begin_line": 688,
        "end_line": 697,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.000148720999405116,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.ParseError.__init__#710",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.ParseError",
        "signature": "tornado.template.ParseError.__init__(self, message: str, filename: str=None, lineno: int=0)",
        "snippet": "    def __init__(self, message: str, filename: str = None, lineno: int = 0) -> None:\n        self.message = message\n        # The names \"filename\" and \"lineno\" are chosen for consistency\n        # with python SyntaxError.\n        self.filename = filename\n        self.lineno = lineno",
        "begin_line": 710,
        "end_line": 715,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.ParseError.__str__#717",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.ParseError",
        "signature": "tornado.template.ParseError.__str__(self)",
        "snippet": "    def __str__(self) -> str:\n        return \"%s at %s:%d\" % (self.message, self.filename, self.lineno)",
        "begin_line": 717,
        "end_line": 718,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._CodeWriter.__init__#722",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._CodeWriter",
        "signature": "tornado.template._CodeWriter.__init__(self, file: TextIO, named_blocks: Dict[str, _NamedBlock], loader: Optional[BaseLoader], current_template: Template)",
        "snippet": "    def __init__(\n        self,\n        file: TextIO,\n        named_blocks: Dict[str, _NamedBlock],\n        loader: Optional[BaseLoader],\n        current_template: Template,\n    ) -> None:\n        self.file = file\n        self.named_blocks = named_blocks\n        self.loader = loader\n        self.current_template = current_template\n        self.apply_counter = 0\n        self.include_stack = []  # type: List[Tuple[Template, int]]\n        self._indent = 0",
        "begin_line": 722,
        "end_line": 735,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014457134595923088,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._CodeWriter.indent_size#737",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._CodeWriter",
        "signature": "tornado.template._CodeWriter.indent_size(self)",
        "snippet": "    def indent_size(self) -> int:\n        return self._indent",
        "begin_line": 737,
        "end_line": 738,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._CodeWriter.indent#740",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._CodeWriter",
        "signature": "tornado.template._CodeWriter.indent(self)",
        "snippet": "    def indent(self) -> \"ContextManager\":\n        class Indenter(object):\n            def __enter__(_) -> \"_CodeWriter\":\n                self._indent += 1\n                return self\n\n            def __exit__(_, *args: Any) -> None:\n                assert self._indent > 0\n                self._indent -= 1\n\n        return Indenter()",
        "begin_line": 740,
        "end_line": 750,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014457134595923088,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.Indenter.indent#740",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Indenter",
        "signature": "tornado.template.Indenter.indent(self)",
        "snippet": "    def indent(self) -> \"ContextManager\":\n        class Indenter(object):\n            def __enter__(_) -> \"_CodeWriter\":\n                self._indent += 1\n                return self\n\n            def __exit__(_, *args: Any) -> None:\n                assert self._indent > 0\n                self._indent -= 1\n\n        return Indenter()",
        "begin_line": 740,
        "end_line": 750,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001392563709789723,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.Indenter.__enter__#742",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Indenter",
        "signature": "tornado.template.Indenter.__enter__(_)",
        "snippet": "            def __enter__(_) -> \"_CodeWriter\":\n                self._indent += 1\n                return self",
        "begin_line": 742,
        "end_line": 744,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014457134595923088,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.Indenter.__exit__#746",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Indenter",
        "signature": "tornado.template.Indenter.__exit__(_, *args: Any)",
        "snippet": "            def __exit__(_, *args: Any) -> None:\n                assert self._indent > 0\n                self._indent -= 1",
        "begin_line": 746,
        "end_line": 748,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014457134595923088,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._CodeWriter.include#752",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._CodeWriter",
        "signature": "tornado.template._CodeWriter.include(self, template: Template, line: int)",
        "snippet": "    def include(self, template: Template, line: int) -> \"ContextManager\":\n        self.include_stack.append((self.current_template, line))\n        self.current_template = template\n\n        class IncludeTemplate(object):\n            def __enter__(_) -> \"_CodeWriter\":\n                return self\n\n            def __exit__(_, *args: Any) -> None:\n                self.current_template = self.include_stack.pop()[0]\n\n        return IncludeTemplate()",
        "begin_line": 752,
        "end_line": 763,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017590149516270889,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.IncludeTemplate.include#752",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.IncludeTemplate",
        "signature": "tornado.template.IncludeTemplate.include(self, template: Template, line: int)",
        "snippet": "    def include(self, template: Template, line: int) -> \"ContextManager\":\n        self.include_stack.append((self.current_template, line))\n        self.current_template = template\n\n        class IncludeTemplate(object):\n            def __enter__(_) -> \"_CodeWriter\":\n                return self\n\n            def __exit__(_, *args: Any) -> None:\n                self.current_template = self.include_stack.pop()[0]\n\n        return IncludeTemplate()",
        "begin_line": 752,
        "end_line": 763,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016270745200130165,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.IncludeTemplate.__enter__#757",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.IncludeTemplate",
        "signature": "tornado.template.IncludeTemplate.__enter__(_)",
        "snippet": "            def __enter__(_) -> \"_CodeWriter\":\n                return self",
        "begin_line": 757,
        "end_line": 758,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017590149516270889,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template.IncludeTemplate.__exit__#760",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.IncludeTemplate",
        "signature": "tornado.template.IncludeTemplate.__exit__(_, *args: Any)",
        "snippet": "            def __exit__(_, *args: Any) -> None:\n                self.current_template = self.include_stack.pop()[0]",
        "begin_line": 760,
        "end_line": 761,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017590149516270889,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._CodeWriter.write_line#765",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._CodeWriter",
        "signature": "tornado.template._CodeWriter.write_line(self, line: str, line_number: int, indent: int=None)",
        "snippet": "    def write_line(self, line: str, line_number: int, indent: int = None) -> None:\n        if indent is None:\n            indent = self._indent\n        line_comment = \"  # %s:%d\" % (self.current_template.name, line_number)\n        if self.include_stack:\n            ancestors = [\n                \"%s:%d\" % (tmpl.name, lineno) for (tmpl, lineno) in self.include_stack\n            ]\n            line_comment += \" (via %s)\" % \", \".join(reversed(ancestors))\n        print(\"    \" * indent + line + line_comment, file=self.file)",
        "begin_line": 765,
        "end_line": 774,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017590149516270889,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._TemplateReader.__init__#778",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._TemplateReader",
        "signature": "tornado.template._TemplateReader.__init__(self, name: str, text: str, whitespace: str)",
        "snippet": "    def __init__(self, name: str, text: str, whitespace: str) -> None:\n        self.name = name\n        self.text = text\n        self.whitespace = whitespace\n        self.line = 1\n        self.pos = 0",
        "begin_line": 778,
        "end_line": 783,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001422879908935686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._TemplateReader.find#785",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._TemplateReader",
        "signature": "tornado.template._TemplateReader.find(self, needle: str, start: int=0, end: int=None)",
        "snippet": "    def find(self, needle: str, start: int = 0, end: int = None) -> int:\n        assert start >= 0, start\n        pos = self.pos\n        start += pos\n        if end is None:\n            index = self.text.find(needle, start)\n        else:\n            end += pos\n            assert end >= start\n            index = self.text.find(needle, start, end)\n        if index != -1:\n            index -= pos\n        return index",
        "begin_line": 785,
        "end_line": 797,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014609203798392987,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._TemplateReader.consume#799",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._TemplateReader",
        "signature": "tornado.template._TemplateReader.consume(self, count: int=None)",
        "snippet": "    def consume(self, count: int = None) -> str:\n        if count is None:\n            count = len(self.text) - self.pos\n        newpos = self.pos + count\n        self.line += self.text.count(\"\\n\", self.pos, newpos)\n        s = self.text[self.pos : newpos]\n        self.pos = newpos\n        return s",
        "begin_line": 799,
        "end_line": 806,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014457134595923088,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._TemplateReader.remaining#808",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._TemplateReader",
        "signature": "tornado.template._TemplateReader.remaining(self)",
        "snippet": "    def remaining(self) -> int:\n        return len(self.text) - self.pos",
        "begin_line": 808,
        "end_line": 809,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014609203798392987,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._TemplateReader.__getitem__#814",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._TemplateReader",
        "signature": "tornado.template._TemplateReader.__getitem__(self, key: Union[int, slice])",
        "snippet": "    def __getitem__(self, key: Union[int, slice]) -> str:\n        if isinstance(key, slice):\n            size = len(self)\n            start, stop, step = key.indices(size)\n            if start is None:\n                start = self.pos\n            else:\n                start += self.pos\n            if stop is not None:\n                stop += self.pos\n            return self.text[slice(start, stop, step)]\n        elif key < 0:\n            return self.text[key]\n        else:\n            return self.text[self.pos + key]",
        "begin_line": 814,
        "end_line": 828,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014609203798392987,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._TemplateReader.raise_parse_error#833",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._TemplateReader",
        "signature": "tornado.template._TemplateReader.raise_parse_error(self, msg: str)",
        "snippet": "    def raise_parse_error(self, msg: str) -> None:\n        raise ParseError(msg, self.name, self.line)",
        "begin_line": 833,
        "end_line": 834,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.template._parse#843",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template",
        "signature": "tornado.template._parse(reader: _TemplateReader, template: Template, in_block: str=None, in_loop: str=None)",
        "snippet": "def _parse(\n    reader: _TemplateReader,\n    template: Template,\n    in_block: str = None,\n    in_loop: str = None,\n) -> _ChunkList:\n    body = _ChunkList([])\n    while True:\n        # Find next template directive\n        curly = 0\n        while True:\n            curly = reader.find(\"{\", curly)\n            if curly == -1 or curly + 1 == reader.remaining():\n                # EOF\n                if in_block:\n                    reader.raise_parse_error(\n                        \"Missing {%% end %%} block for %s\" % in_block\n                    )\n                body.chunks.append(\n                    _Text(reader.consume(), reader.line, reader.whitespace)\n                )\n                return body\n            # If the first curly brace is not the start of a special token,\n            # start searching from the character after it\n            if reader[curly + 1] not in (\"{\", \"%\", \"#\"):\n                curly += 1\n                continue\n            # When there are more than 2 curlies in a row, use the\n            # innermost ones.  This is useful when generating languages\n            # like latex where curlies are also meaningful\n            if (\n                curly + 2 < reader.remaining()\n                and reader[curly + 1] == \"{\"\n                and reader[curly + 2] == \"{\"\n            ):\n                curly += 1\n                continue\n            break\n\n        # Append any text before the special token\n        if curly > 0:\n            cons = reader.consume(curly)\n            body.chunks.append(_Text(cons, reader.line, reader.whitespace))\n\n        start_brace = reader.consume(2)\n        line = reader.line\n\n        # Template directives may be escaped as \"{{!\" or \"{%!\".\n        # In this case output the braces and consume the \"!\".\n        # This is especially useful in conjunction with jquery templates,\n        # which also use double braces.\n        if reader.remaining() and reader[0] == \"!\":\n            reader.consume(1)\n            body.chunks.append(_Text(start_brace, line, reader.whitespace))\n            continue\n\n        # Comment\n        if start_brace == \"{#\":\n            end = reader.find(\"#}\")\n            if end == -1:\n                reader.raise_parse_error(\"Missing end comment #}\")\n            contents = reader.consume(end).strip()\n            reader.consume(2)\n            continue\n\n        # Expression\n        if start_brace == \"{{\":\n            end = reader.find(\"}}\")\n            if end == -1:\n                reader.raise_parse_error(\"Missing end expression }}\")\n            contents = reader.consume(end).strip()\n            reader.consume(2)\n            if not contents:\n                reader.raise_parse_error(\"Empty expression\")\n            body.chunks.append(_Expression(contents, line))\n            continue\n\n        # Block\n        assert start_brace == \"{%\", start_brace\n        end = reader.find(\"%}\")\n        if end == -1:\n            reader.raise_parse_error(\"Missing end block %}\")\n        contents = reader.consume(end).strip()\n        reader.consume(2)\n        if not contents:\n            reader.raise_parse_error(\"Empty block tag ({% %})\")\n\n        operator, space, suffix = contents.partition(\" \")\n        suffix = suffix.strip()\n\n        # Intermediate (\"else\", \"elif\", etc) blocks\n        intermediate_blocks = {\n            \"else\": set([\"if\", \"for\", \"while\", \"try\"]),\n            \"elif\": set([\"if\"]),\n            \"except\": set([\"try\"]),\n            \"finally\": set([\"try\"]),\n        }\n        allowed_parents = intermediate_blocks.get(operator)\n        if allowed_parents is not None:\n            if not in_block:\n                reader.raise_parse_error(\n                    \"%s outside %s block\" % (operator, allowed_parents)\n                )\n            if in_block not in allowed_parents:\n                reader.raise_parse_error(\n                    \"%s block cannot be attached to %s block\" % (operator, in_block)\n                )\n            body.chunks.append(_IntermediateControlBlock(contents, line))\n            continue\n\n        # End tag\n        elif operator == \"end\":\n            if not in_block:\n                reader.raise_parse_error(\"Extra {% end %} block\")\n            return body\n\n        elif operator in (\n            \"extends\",\n            \"include\",\n            \"set\",\n            \"import\",\n            \"from\",\n            \"comment\",\n            \"autoescape\",\n            \"whitespace\",\n            \"raw\",\n            \"module\",\n        ):\n            if operator == \"comment\":\n                continue\n            if operator == \"extends\":\n                suffix = suffix.strip('\"').strip(\"'\")\n                if not suffix:\n                    reader.raise_parse_error(\"extends missing file path\")\n                block = _ExtendsBlock(suffix)  # type: _Node\n            elif operator in (\"import\", \"from\"):\n                if not suffix:\n                    reader.raise_parse_error(\"import missing statement\")\n                block = _Statement(contents, line)\n            elif operator == \"include\":\n                suffix = suffix.strip('\"').strip(\"'\")\n                if not suffix:\n                    reader.raise_parse_error(\"include missing file path\")\n                block = _IncludeBlock(suffix, reader, line)\n            elif operator == \"set\":\n                if not suffix:\n                    reader.raise_parse_error(\"set missing statement\")\n                block = _Statement(suffix, line)\n            elif operator == \"autoescape\":\n                fn = suffix.strip()  # type: Optional[str]\n                if fn == \"None\":\n                    fn = None\n                template.autoescape = fn\n                continue\n            elif operator == \"whitespace\":\n                mode = suffix.strip()\n                # Validate the selected mode\n                filter_whitespace(mode, \"\")\n                reader.whitespace = mode\n                continue\n            elif operator == \"raw\":\n                block = _Expression(suffix, line, raw=True)\n            elif operator == \"module\":\n                block = _Module(suffix, line)\n            body.chunks.append(block)\n            continue\n\n        elif operator in (\"apply\", \"block\", \"try\", \"if\", \"for\", \"while\"):\n            # parse inner body recursively\n            if operator in (\"for\", \"while\"):\n                block_body = _parse(reader, template, operator, operator)\n            elif operator == \"apply\":\n                # apply creates a nested function so syntactically it's not\n                # in the loop.\n                block_body = _parse(reader, template, operator, None)\n            else:\n                block_body = _parse(reader, template, operator, in_loop)\n\n            if operator == \"apply\":\n                if not suffix:\n                    reader.raise_parse_error(\"apply missing method name\")\n                block = _ApplyBlock(suffix, line, block_body)\n            elif operator == \"block\":\n                if not suffix:\n                    reader.raise_parse_error(\"block missing name\")\n                block = _NamedBlock(suffix, block_body, template, line)\n            else:\n                block = _ControlBlock(contents, line, block_body)\n            body.chunks.append(block)\n            continue\n\n        elif operator in (\"break\", \"continue\"):\n            if not in_loop:\n                reader.raise_parse_error(\n                    \"%s outside %s block\" % (operator, set([\"for\", \"while\"]))\n                )\n            body.chunks.append(_Statement(contents, line))\n            continue\n\n        else:\n            reader.raise_parse_error(\"unknown operator: %r\" % operator)",
        "begin_line": 843,
        "end_line": 1043,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.testing.bind_unused_port#47",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing",
        "signature": "tornado.testing.bind_unused_port(reuse_port: bool=False)",
        "snippet": "def bind_unused_port(reuse_port: bool = False) -> Tuple[socket.socket, int]:\n    \"\"\"Binds a server socket to an available port on localhost.\n\n    Returns a tuple (socket, port).\n\n    .. versionchanged:: 4.4\n       Always binds to ``127.0.0.1`` without resolving the name\n       ``localhost``.\n    \"\"\"\n    sock = netutil.bind_sockets(\n        0, \"127.0.0.1\", family=socket.AF_INET, reuse_port=reuse_port\n    )[0]\n    port = sock.getsockname()[1]\n    return sock, port",
        "begin_line": 47,
        "end_line": 60,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017699115044247787,
            "pseudo_dstar_susp": 0.002421307506053269,
            "pseudo_tarantula_susp": 0.0012658227848101266,
            "pseudo_op2_susp": 0.002421307506053269,
            "pseudo_barinel_susp": 0.0012658227848101266
        }
    },
    {
        "name": "tornado.testing.get_async_test_timeout#63",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing",
        "signature": "tornado.testing.get_async_test_timeout()",
        "snippet": "def get_async_test_timeout() -> float:\n    \"\"\"Get the global timeout setting for async tests.\n\n    Returns a float, the timeout in seconds.\n\n    .. versionadded:: 3.1\n    \"\"\"\n    env = os.environ.get(\"ASYNC_TEST_TIMEOUT\")\n    if env is not None:\n        try:\n            return float(env)\n        except ValueError:\n            pass\n    return 5",
        "begin_line": 63,
        "end_line": 76,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007524454477050414,
            "pseudo_dstar_susp": 0.000966183574879227,
            "pseudo_tarantula_susp": 0.0006775067750677507,
            "pseudo_op2_susp": 0.000966183574879227,
            "pseudo_barinel_susp": 0.0006775067750677507
        }
    },
    {
        "name": "tornado.testing._TestMethodWrapper.__init__#89",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing._TestMethodWrapper",
        "signature": "tornado.testing._TestMethodWrapper.__init__(self, orig_method: Callable)",
        "snippet": "    def __init__(self, orig_method: Callable) -> None:\n        self.orig_method = orig_method",
        "begin_line": 89,
        "end_line": 90,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015873015873015873,
            "pseudo_dstar_susp": 0.0035587188612099642,
            "pseudo_tarantula_susp": 0.0010482180293501049,
            "pseudo_op2_susp": 0.0035587188612099642,
            "pseudo_barinel_susp": 0.0010482180293501049
        }
    },
    {
        "name": "tornado.testing._TestMethodWrapper.__call__#92",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing._TestMethodWrapper",
        "signature": "tornado.testing._TestMethodWrapper.__call__(self, *args: Any, **kwargs: Any)",
        "snippet": "    def __call__(self, *args: Any, **kwargs: Any) -> None:\n        result = self.orig_method(*args, **kwargs)\n        if isinstance(result, Generator) or inspect.iscoroutine(result):\n            raise TypeError(\n                \"Generator and coroutine test methods should be\"\n                \" decorated with tornado.testing.gen_test\"\n            )\n        elif result is not None:\n            raise ValueError(\"Return value from test method ignored: %r\" % result)",
        "begin_line": 92,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017211703958691911,
            "pseudo_dstar_susp": 0.003787878787878788,
            "pseudo_tarantula_susp": 0.0010672358591248667,
            "pseudo_op2_susp": 0.003787878787878788,
            "pseudo_barinel_susp": 0.0010672358591248667
        }
    },
    {
        "name": "tornado.testing._TestMethodWrapper.__getattr__#102",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing._TestMethodWrapper",
        "signature": "tornado.testing._TestMethodWrapper.__getattr__(self, name: str)",
        "snippet": "    def __getattr__(self, name: str) -> Any:\n        \"\"\"Proxy all unknown attributes to the original method.\n\n        This is important for some of the decorators in the `unittest`\n        module, such as `unittest.skipIf`.\n        \"\"\"\n        return getattr(self.orig_method, name)",
        "begin_line": 102,
        "end_line": 108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015873015873015873,
            "pseudo_dstar_susp": 0.0035587188612099642,
            "pseudo_tarantula_susp": 0.0010482180293501049,
            "pseudo_op2_susp": 0.0035587188612099642,
            "pseudo_barinel_susp": 0.0010482180293501049
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.__init__#158",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.__init__(self, methodName: str='runTest')",
        "snippet": "    def __init__(self, methodName: str = \"runTest\") -> None:\n        super(AsyncTestCase, self).__init__(methodName)\n        self.__stopped = False\n        self.__running = False\n        self.__failure = None  # type: Optional[_ExcInfoTuple]\n        self.__stop_args = None  # type: Any\n        self.__timeout = None  # type: Optional[object]\n\n        # It's easy to forget the @gen_test decorator, but if you do\n        # the test will silently be ignored because nothing will consume\n        # the generator.  Replace the test method with a wrapper that will\n        # make sure it's not an undecorated generator.\n        setattr(self, methodName, _TestMethodWrapper(getattr(self, methodName)))\n\n        # Not used in this class itself, but used by @gen_test\n        self._test_generator = None  # type: Optional[Union[Generator, Coroutine]]",
        "begin_line": 158,
        "end_line": 173,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015873015873015873,
            "pseudo_dstar_susp": 0.0035587188612099642,
            "pseudo_tarantula_susp": 0.0010482180293501049,
            "pseudo_op2_susp": 0.0035587188612099642,
            "pseudo_barinel_susp": 0.0010482180293501049
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.setUp#175",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.setUp(self)",
        "snippet": "    def setUp(self) -> None:\n        super(AsyncTestCase, self).setUp()\n        self.io_loop = self.get_new_ioloop()\n        self.io_loop.make_current()",
        "begin_line": 175,
        "end_line": 178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017211703958691911,
            "pseudo_dstar_susp": 0.003787878787878788,
            "pseudo_tarantula_susp": 0.0010672358591248667,
            "pseudo_op2_susp": 0.003787878787878788,
            "pseudo_barinel_susp": 0.0010672358591248667
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.tearDown#180",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.tearDown(self)",
        "snippet": "    def tearDown(self) -> None:\n        # Clean up Subprocess, so it can be used again with a new ioloop.\n        Subprocess.uninitialize()\n        self.io_loop.clear_current()\n        if not isinstance(self.io_loop, _NON_OWNED_IOLOOPS):\n            # Try to clean up any file descriptors left open in the ioloop.\n            # This avoids leaks, especially when tests are run repeatedly\n            # in the same process with autoreload (because curl does not\n            # set FD_CLOEXEC on its file descriptors)\n            self.io_loop.close(all_fds=True)\n        super(AsyncTestCase, self).tearDown()\n        # In case an exception escaped or the StackContext caught an exception\n        # when there wasn't a wait() to re-raise it, do so here.\n        # This is our last chance to raise an exception in a way that the\n        # unittest machinery understands.\n        self.__rethrow()",
        "begin_line": 180,
        "end_line": 195,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017452006980802793,
            "pseudo_dstar_susp": 0.00390625,
            "pseudo_tarantula_susp": 0.001076426264800861,
            "pseudo_op2_susp": 0.00390625,
            "pseudo_barinel_susp": 0.001076426264800861
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.get_new_ioloop#197",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.get_new_ioloop(self)",
        "snippet": "    def get_new_ioloop(self) -> IOLoop:\n        \"\"\"Returns the `.IOLoop` to use for this test.\n\n        By default, a new `.IOLoop` is created for each test.\n        Subclasses may override this method to return\n        `.IOLoop.current()` if it is not appropriate to use a new\n        `.IOLoop` in each tests (for example, if there are global\n        singletons using the default `.IOLoop`) or if a per-test event\n        loop is being provided by another system (such as\n        ``pytest-asyncio``).\n        \"\"\"\n        return IOLoop()",
        "begin_line": 197,
        "end_line": 208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017513134851138354,
            "pseudo_dstar_susp": 0.003937007874015748,
            "pseudo_tarantula_susp": 0.0010787486515641855,
            "pseudo_op2_susp": 0.003937007874015748,
            "pseudo_barinel_susp": 0.0010787486515641855
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.__rethrow#222",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.__rethrow(self)",
        "snippet": "    def __rethrow(self) -> None:\n        if self.__failure is not None:\n            failure = self.__failure\n            self.__failure = None\n            raise_exc_info(failure)",
        "begin_line": 222,
        "end_line": 226,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015873015873015873,
            "pseudo_dstar_susp": 0.0035587188612099642,
            "pseudo_tarantula_susp": 0.0010482180293501049,
            "pseudo_op2_susp": 0.0035587188612099642,
            "pseudo_barinel_susp": 0.0010482180293501049
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.run#228",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.run(self, result: unittest.TestResult=None)",
        "snippet": "    def run(self, result: unittest.TestResult = None) -> unittest.TestCase:\n        ret = super(AsyncTestCase, self).run(result)\n        # As a last resort, if an exception escaped super.run() and wasn't\n        # re-raised in tearDown, raise it here.  This will cause the\n        # unittest run to fail messily, but that's better than silently\n        # ignoring an error.\n        self.__rethrow()\n        return ret",
        "begin_line": 228,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015873015873015873,
            "pseudo_dstar_susp": 0.0035587188612099642,
            "pseudo_tarantula_susp": 0.0010482180293501049,
            "pseudo_op2_susp": 0.0035587188612099642,
            "pseudo_barinel_susp": 0.0010482180293501049
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.stop#237",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.stop(self, _arg: Any=None, **kwargs: Any)",
        "snippet": "    def stop(self, _arg: Any = None, **kwargs: Any) -> None:\n        \"\"\"Stops the `.IOLoop`, causing one pending (or future) call to `wait()`\n        to return.\n\n        Keyword arguments or a single positional argument passed to `stop()` are\n        saved and will be returned by `wait()`.\n\n        .. deprecated:: 5.1\n\n           `stop` and `wait` are deprecated; use ``@gen_test`` instead.\n        \"\"\"\n        assert _arg is None or not kwargs\n        self.__stop_args = kwargs or _arg\n        if self.__running:\n            self.io_loop.stop()\n            self.__running = False\n        self.__stopped = True",
        "begin_line": 237,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004492362982929021,
            "pseudo_dstar_susp": 0.000434593654932638,
            "pseudo_tarantula_susp": 0.000671591672263264,
            "pseudo_op2_susp": 0.000434593654932638,
            "pseudo_barinel_susp": 0.000671591672263264
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.wait#255",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.wait(self, condition: Callable[..., bool]=None, timeout: float=None)",
        "snippet": "    def wait(\n        self, condition: Callable[..., bool] = None, timeout: float = None\n    ) -> None:\n        \"\"\"Runs the `.IOLoop` until stop is called or timeout has passed.\n\n        In the event of a timeout, an exception will be thrown. The\n        default timeout is 5 seconds; it may be overridden with a\n        ``timeout`` keyword argument or globally with the\n        ``ASYNC_TEST_TIMEOUT`` environment variable.\n\n        If ``condition`` is not None, the `.IOLoop` will be restarted\n        after `stop()` until ``condition()`` returns true.\n\n        .. versionchanged:: 3.1\n           Added the ``ASYNC_TEST_TIMEOUT`` environment variable.\n\n        .. deprecated:: 5.1\n\n           `stop` and `wait` are deprecated; use ``@gen_test`` instead.\n        \"\"\"\n        if timeout is None:\n            timeout = get_async_test_timeout()\n\n        if not self.__stopped:\n            if timeout:\n\n                def timeout_func() -> None:\n                    try:\n                        raise self.failureException(\n                            \"Async operation timed out after %s seconds\" % timeout\n                        )\n                    except Exception:\n                        self.__failure = sys.exc_info()\n                    self.stop()\n\n                self.__timeout = self.io_loop.add_timeout(\n                    self.io_loop.time() + timeout, timeout_func\n                )\n            while True:\n                self.__running = True\n                self.io_loop.start()\n                if self.__failure is not None or condition is None or condition():\n                    break\n            if self.__timeout is not None:\n                self.io_loop.remove_timeout(self.__timeout)\n                self.__timeout = None\n        assert self.__stopped\n        self.__stopped = False\n        self.__rethrow()\n        result = self.__stop_args\n        self.__stop_args = None\n        return result",
        "begin_line": 255,
        "end_line": 306,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004526935264825713,
            "pseudo_dstar_susp": 0.00043649061545176777,
            "pseudo_tarantula_susp": 0.0006891798759476223,
            "pseudo_op2_susp": 0.00043649061545176777,
            "pseudo_barinel_susp": 0.0006891798759476223
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.timeout_func#281",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.timeout_func()",
        "snippet": "                def timeout_func() -> None:\n                    try:\n                        raise self.failureException(\n                            \"Async operation timed out after %s seconds\" % timeout\n                        )\n                    except Exception:\n                        self.__failure = sys.exc_info()\n                    self.stop()",
        "begin_line": 281,
        "end_line": 288,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00044682752457551384,
            "pseudo_dstar_susp": 0.00043233895373973193,
            "pseudo_tarantula_susp": 0.0006657789613848203,
            "pseudo_op2_susp": 0.00043233895373973193,
            "pseudo_barinel_susp": 0.0006657789613848203
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.setUp#342",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.setUp(self)",
        "snippet": "    def setUp(self) -> None:\n        super(AsyncHTTPTestCase, self).setUp()\n        sock, port = bind_unused_port()\n        self.__port = port\n\n        self.http_client = self.get_http_client()\n        self._app = self.get_app()\n        self.http_server = self.get_http_server()\n        self.http_server.add_sockets([sock])",
        "begin_line": 342,
        "end_line": 350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008077544426494346,
            "pseudo_dstar_susp": 0.0010319917440660474,
            "pseudo_tarantula_susp": 0.000731528895391368,
            "pseudo_op2_susp": 0.0010319917440660474,
            "pseudo_barinel_susp": 0.000731528895391368
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.get_http_client#352",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.get_http_client(self)",
        "snippet": "    def get_http_client(self) -> AsyncHTTPClient:\n        return AsyncHTTPClient()",
        "begin_line": 352,
        "end_line": 353,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00047281323877068556,
            "pseudo_dstar_susp": 0.0005141388174807198,
            "pseudo_tarantula_susp": 0.0004506534474988734,
            "pseudo_op2_susp": 0.0005141388174807198,
            "pseudo_barinel_susp": 0.0004506534474988734
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.get_http_server#355",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.get_http_server(self)",
        "snippet": "    def get_http_server(self) -> HTTPServer:\n        return HTTPServer(self._app, **self.get_httpserver_options())",
        "begin_line": 355,
        "end_line": 356,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008077544426494346,
            "pseudo_dstar_susp": 0.0010319917440660474,
            "pseudo_tarantula_susp": 0.000731528895391368,
            "pseudo_op2_susp": 0.0010319917440660474,
            "pseudo_barinel_susp": 0.000731528895391368
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.fetch#364",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.fetch(self, path: str, raise_error: bool=False, **kwargs: Any)",
        "snippet": "    def fetch(\n        self, path: str, raise_error: bool = False, **kwargs: Any\n    ) -> HTTPResponse:\n        \"\"\"Convenience method to synchronously fetch a URL.\n\n        The given path will be appended to the local server's host and\n        port.  Any additional kwargs will be passed directly to\n        `.AsyncHTTPClient.fetch` (and so could be used to pass\n        ``method=\"POST\"``, ``body=\"...\"``, etc).\n\n        If the path begins with http:// or https://, it will be treated as a\n        full URL and will be fetched as-is.\n\n        If ``raise_error`` is True, a `tornado.httpclient.HTTPError` will\n        be raised if the response code is not 200. This is the same behavior\n        as the ``raise_error`` argument to `.AsyncHTTPClient.fetch`, but\n        the default is False here (it's True in `.AsyncHTTPClient`) because\n        tests often need to deal with non-200 response codes.\n\n        .. versionchanged:: 5.0\n           Added support for absolute URLs.\n\n        .. versionchanged:: 5.1\n\n           Added the ``raise_error`` argument.\n\n        .. deprecated:: 5.1\n\n           This method currently turns any exception into an\n           `.HTTPResponse` with status code 599. In Tornado 6.0,\n           errors other than `tornado.httpclient.HTTPError` will be\n           passed through, and ``raise_error=False`` will only\n           suppress errors that would be raised due to non-200\n           response codes.\n\n        \"\"\"\n        if path.lower().startswith((\"http://\", \"https://\")):\n            url = path\n        else:\n            url = self.get_url(path)\n        return self.io_loop.run_sync(\n            lambda: self.http_client.fetch(url, raise_error=raise_error, **kwargs),\n            timeout=get_async_test_timeout(),\n        )",
        "begin_line": 364,
        "end_line": 407,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008695652173913044,
            "pseudo_dstar_susp": 0.0016025641025641025,
            "pseudo_tarantula_susp": 0.0006635700066357001,
            "pseudo_op2_susp": 0.0016025641025641025,
            "pseudo_barinel_susp": 0.0006635700066357001
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.get_httpserver_options#409",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.get_httpserver_options(self)",
        "snippet": "    def get_httpserver_options(self) -> Dict[str, Any]:\n        \"\"\"May be overridden by subclasses to return additional\n        keyword arguments for the server.\n        \"\"\"\n        return {}",
        "begin_line": 409,
        "end_line": 413,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005068423720223011,
            "pseudo_dstar_susp": 0.0005602240896358543,
            "pseudo_tarantula_susp": 0.0005221932114882506,
            "pseudo_op2_susp": 0.0005602240896358543,
            "pseudo_barinel_susp": 0.0005221932114882506
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.get_http_port#415",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.get_http_port(self)",
        "snippet": "    def get_http_port(self) -> int:\n        \"\"\"Returns the port used by the server.\n\n        A new port is chosen for each test.\n        \"\"\"\n        return self.__port",
        "begin_line": 415,
        "end_line": 420,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008748906386701663,
            "pseudo_dstar_susp": 0.0011389521640091116,
            "pseudo_tarantula_susp": 0.0008045052292839903,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0008045052292839903
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.get_protocol#422",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.get_protocol(self)",
        "snippet": "    def get_protocol(self) -> str:\n        return \"http\"",
        "begin_line": 422,
        "end_line": 423,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005959475566150178,
            "pseudo_dstar_susp": 0.0005665722379603399,
            "pseudo_tarantula_susp": 0.0006176652254478073,
            "pseudo_op2_susp": 0.0005665722379603399,
            "pseudo_barinel_susp": 0.0006176652254478073
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.get_url#425",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.get_url(self, path: str)",
        "snippet": "    def get_url(self, path: str) -> str:\n        \"\"\"Returns an absolute url for the given path on the test server.\"\"\"\n        return \"%s://127.0.0.1:%s%s\" % (self.get_protocol(), self.get_http_port(), path)",
        "begin_line": 425,
        "end_line": 427,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000643915003219575,
            "pseudo_dstar_susp": 0.0007107320540156361,
            "pseudo_tarantula_susp": 0.0005952380952380953,
            "pseudo_op2_susp": 0.0007107320540156361,
            "pseudo_barinel_susp": 0.0005952380952380953
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.tearDown#429",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.tearDown(self)",
        "snippet": "    def tearDown(self) -> None:\n        self.http_server.stop()\n        self.io_loop.run_sync(\n            self.http_server.close_all_connections, timeout=get_async_test_timeout()\n        )\n        self.http_client.close()\n        super(AsyncHTTPTestCase, self).tearDown()",
        "begin_line": 429,
        "end_line": 435,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008077544426494346,
            "pseudo_dstar_susp": 0.0010319917440660474,
            "pseudo_tarantula_susp": 0.000731528895391368,
            "pseudo_op2_susp": 0.0010319917440660474,
            "pseudo_barinel_susp": 0.000731528895391368
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPSTestCase.get_http_client#444",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPSTestCase",
        "signature": "tornado.testing.AsyncHTTPSTestCase.get_http_client(self)",
        "snippet": "    def get_http_client(self) -> AsyncHTTPClient:\n        return AsyncHTTPClient(force_instance=True, defaults=dict(validate_cert=False))",
        "begin_line": 444,
        "end_line": 445,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004063388866314506,
            "pseudo_dstar_susp": 0.00040551500405515005,
            "pseudo_tarantula_susp": 0.00044682752457551384,
            "pseudo_op2_susp": 0.00040551500405515005,
            "pseudo_barinel_susp": 0.00044682752457551384
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPSTestCase.get_httpserver_options#447",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPSTestCase",
        "signature": "tornado.testing.AsyncHTTPSTestCase.get_httpserver_options(self)",
        "snippet": "    def get_httpserver_options(self) -> Dict[str, Any]:\n        return dict(ssl_options=self.get_ssl_options())",
        "begin_line": 447,
        "end_line": 448,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004063388866314506,
            "pseudo_dstar_susp": 0.00040551500405515005,
            "pseudo_tarantula_susp": 0.00044682752457551384,
            "pseudo_op2_susp": 0.00040551500405515005,
            "pseudo_barinel_susp": 0.00044682752457551384
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPSTestCase.get_ssl_options#450",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPSTestCase",
        "signature": "tornado.testing.AsyncHTTPSTestCase.get_ssl_options(self)",
        "snippet": "    def get_ssl_options(self) -> Dict[str, Any]:\n        \"\"\"May be overridden by subclasses to select SSL options.\n\n        By default includes a self-signed testing certificate.\n        \"\"\"\n        return AsyncHTTPSTestCase.default_ssl_options()",
        "begin_line": 450,
        "end_line": 455,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004063388866314506,
            "pseudo_dstar_susp": 0.00040551500405515005,
            "pseudo_tarantula_susp": 0.00044682752457551384,
            "pseudo_op2_susp": 0.00040551500405515005,
            "pseudo_barinel_susp": 0.00044682752457551384
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPSTestCase.default_ssl_options#458",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPSTestCase",
        "signature": "tornado.testing.AsyncHTTPSTestCase.default_ssl_options()",
        "snippet": "    def default_ssl_options() -> Dict[str, Any]:\n        # Testing keys were generated with:\n        # openssl req -new -keyout tornado/test/test.key \\\n        #                     -out tornado/test/test.crt -nodes -days 3650 -x509\n        module_dir = os.path.dirname(__file__)\n        return dict(\n            certfile=os.path.join(module_dir, \"test\", \"test.crt\"),\n            keyfile=os.path.join(module_dir, \"test\", \"test.key\"),\n        )",
        "begin_line": 458,
        "end_line": 466,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004063388866314506,
            "pseudo_dstar_susp": 0.00040551500405515005,
            "pseudo_tarantula_susp": 0.00044682752457551384,
            "pseudo_op2_susp": 0.00040551500405515005,
            "pseudo_barinel_susp": 0.00044682752457551384
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPSTestCase.get_protocol#468",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPSTestCase",
        "signature": "tornado.testing.AsyncHTTPSTestCase.get_protocol(self)",
        "snippet": "    def get_protocol(self) -> str:\n        return \"https\"",
        "begin_line": 468,
        "end_line": 469,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004088307440719542,
            "pseudo_dstar_susp": 0.00040716612377850165,
            "pseudo_tarantula_susp": 0.00045167118337850043,
            "pseudo_op2_susp": 0.00040716612377850165,
            "pseudo_barinel_susp": 0.00045167118337850043
        }
    },
    {
        "name": "tornado.testing.gen_test#484",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing",
        "signature": "tornado.testing.gen_test(func: Callable[..., Union[Generator, Coroutine]]=None, timeout: float=None)",
        "snippet": "def gen_test(  # noqa: F811\n    func: Callable[..., Union[Generator, Coroutine]] = None, timeout: float = None\n) -> Union[\n    Callable[..., None],\n    Callable[[Callable[..., Union[Generator, Coroutine]]], Callable[..., None]],\n]:\n    \"\"\"Testing equivalent of ``@gen.coroutine``, to be applied to test methods.\n\n    ``@gen.coroutine`` cannot be used on tests because the `.IOLoop` is not\n    already running.  ``@gen_test`` should be applied to test methods\n    on subclasses of `AsyncTestCase`.\n\n    Example::\n\n        class MyTest(AsyncHTTPTestCase):\n            @gen_test\n            def test_something(self):\n                response = yield self.http_client.fetch(self.get_url('/'))\n\n    By default, ``@gen_test`` times out after 5 seconds. The timeout may be\n    overridden globally with the ``ASYNC_TEST_TIMEOUT`` environment variable,\n    or for each test with the ``timeout`` keyword argument::\n\n        class MyTest(AsyncHTTPTestCase):\n            @gen_test(timeout=10)\n            def test_something_slow(self):\n                response = yield self.http_client.fetch(self.get_url('/'))\n\n    Note that ``@gen_test`` is incompatible with `AsyncTestCase.stop`,\n    `AsyncTestCase.wait`, and `AsyncHTTPTestCase.fetch`. Use ``yield\n    self.http_client.fetch(self.get_url())`` as shown above instead.\n\n    .. versionadded:: 3.1\n       The ``timeout`` argument and ``ASYNC_TEST_TIMEOUT`` environment\n       variable.\n\n    .. versionchanged:: 4.0\n       The wrapper now passes along ``*args, **kwargs`` so it can be used\n       on functions with arguments.\n\n    \"\"\"\n    if timeout is None:\n        timeout = get_async_test_timeout()\n\n    def wrap(f: Callable[..., Union[Generator, Coroutine]]) -> Callable[..., None]:\n        # Stack up several decorators to allow us to access the generator\n        # object itself.  In the innermost wrapper, we capture the generator\n        # and save it in an attribute of self.  Next, we run the wrapped\n        # function through @gen.coroutine.  Finally, the coroutine is\n        # wrapped again to make it synchronous with run_sync.\n        #\n        # This is a good case study arguing for either some sort of\n        # extensibility in the gen decorators or cancellation support.\n        @functools.wraps(f)\n        def pre_coroutine(self, *args, **kwargs):\n            # type: (AsyncTestCase, *Any, **Any) -> Union[Generator, Coroutine]\n            # Type comments used to avoid pypy3 bug.\n            result = f(self, *args, **kwargs)\n            if isinstance(result, Generator) or inspect.iscoroutine(result):\n                self._test_generator = result\n            else:\n                self._test_generator = None\n            return result\n\n        if inspect.iscoroutinefunction(f):\n            coro = pre_coroutine\n        else:\n            coro = gen.coroutine(pre_coroutine)\n\n        @functools.wraps(coro)\n        def post_coroutine(self, *args, **kwargs):\n            # type: (AsyncTestCase, *Any, **Any) -> None\n            try:\n                return self.io_loop.run_sync(\n                    functools.partial(coro, self, *args, **kwargs), timeout=timeout\n                )\n            except TimeoutError as e:\n                # run_sync raises an error with an unhelpful traceback.\n                # If the underlying generator is still running, we can throw the\n                # exception back into it so the stack trace is replaced by the\n                # point where the test is stopped. The only reason the generator\n                # would not be running would be if it were cancelled, which means\n                # a native coroutine, so we can rely on the cr_running attribute.\n                if self._test_generator is not None and getattr(\n                    self._test_generator, \"cr_running\", True\n                ):\n                    self._test_generator.throw(type(e), e)\n                    # In case the test contains an overly broad except\n                    # clause, we may get back here.\n                # Coroutine was stopped or didn't raise a useful stack trace,\n                # so re-raise the original exception which is better than nothing.\n                raise\n\n        return post_coroutine\n\n    if func is not None:\n        # Used like:\n        #     @gen_test\n        #     def f(self):\n        #         pass\n        return wrap(func)\n    else:\n        # Used like @gen_test(timeout=10)\n        return wrap",
        "begin_line": 484,
        "end_line": 587,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.testing.wrap#528",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing",
        "signature": "tornado.testing.wrap(f: Callable[..., Union[Generator, Coroutine]])",
        "snippet": "    def wrap(f: Callable[..., Union[Generator, Coroutine]]) -> Callable[..., None]:\n        # Stack up several decorators to allow us to access the generator\n        # object itself.  In the innermost wrapper, we capture the generator\n        # and save it in an attribute of self.  Next, we run the wrapped\n        # function through @gen.coroutine.  Finally, the coroutine is\n        # wrapped again to make it synchronous with run_sync.\n        #\n        # This is a good case study arguing for either some sort of\n        # extensibility in the gen decorators or cancellation support.\n        @functools.wraps(f)\n        def pre_coroutine(self, *args, **kwargs):\n            # type: (AsyncTestCase, *Any, **Any) -> Union[Generator, Coroutine]\n            # Type comments used to avoid pypy3 bug.\n            result = f(self, *args, **kwargs)\n            if isinstance(result, Generator) or inspect.iscoroutine(result):\n                self._test_generator = result\n            else:\n                self._test_generator = None\n            return result\n\n        if inspect.iscoroutinefunction(f):\n            coro = pre_coroutine\n        else:\n            coro = gen.coroutine(pre_coroutine)\n\n        @functools.wraps(coro)\n        def post_coroutine(self, *args, **kwargs):\n            # type: (AsyncTestCase, *Any, **Any) -> None\n            try:\n                return self.io_loop.run_sync(\n                    functools.partial(coro, self, *args, **kwargs), timeout=timeout\n                )\n            except TimeoutError as e:\n                # run_sync raises an error with an unhelpful traceback.\n                # If the underlying generator is still running, we can throw the\n                # exception back into it so the stack trace is replaced by the\n                # point where the test is stopped. The only reason the generator\n                # would not be running would be if it were cancelled, which means\n                # a native coroutine, so we can rely on the cr_running attribute.\n                if self._test_generator is not None and getattr(\n                    self._test_generator, \"cr_running\", True\n                ):\n                    self._test_generator.throw(type(e), e)\n                    # In case the test contains an overly broad except\n                    # clause, we may get back here.\n                # Coroutine was stopped or didn't raise a useful stack trace,\n                # so re-raise the original exception which is better than nothing.\n                raise\n\n        return post_coroutine",
        "begin_line": 528,
        "end_line": 577,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.125,
            "pseudo_dstar_susp": 0.25,
            "pseudo_tarantula_susp": 0.005076142131979695,
            "pseudo_op2_susp": 0.25,
            "pseudo_barinel_susp": 0.005076142131979695
        }
    },
    {
        "name": "tornado.testing.pre_coroutine#538",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing",
        "signature": "tornado.testing.pre_coroutine(self, *args, **kwargs)",
        "snippet": "        def pre_coroutine(self, *args, **kwargs):\n            # type: (AsyncTestCase, *Any, **Any) -> Union[Generator, Coroutine]\n            # Type comments used to avoid pypy3 bug.\n            result = f(self, *args, **kwargs)\n            if isinstance(result, Generator) or inspect.iscoroutine(result):\n                self._test_generator = result\n            else:\n                self._test_generator = None\n            return result",
        "begin_line": 538,
        "end_line": 546,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002577319587628866,
            "pseudo_dstar_susp": 0.0019120458891013384,
            "pseudo_tarantula_susp": 0.002331002331002331,
            "pseudo_op2_susp": 0.0019120458891013384,
            "pseudo_barinel_susp": 0.002331002331002331
        }
    },
    {
        "name": "tornado.testing.post_coroutine#554",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing",
        "signature": "tornado.testing.post_coroutine(self, *args, **kwargs)",
        "snippet": "        def post_coroutine(self, *args, **kwargs):\n            # type: (AsyncTestCase, *Any, **Any) -> None\n            try:\n                return self.io_loop.run_sync(\n                    functools.partial(coro, self, *args, **kwargs), timeout=timeout\n                )\n            except TimeoutError as e:\n                # run_sync raises an error with an unhelpful traceback.\n                # If the underlying generator is still running, we can throw the\n                # exception back into it so the stack trace is replaced by the\n                # point where the test is stopped. The only reason the generator\n                # would not be running would be if it were cancelled, which means\n                # a native coroutine, so we can rely on the cr_running attribute.\n                if self._test_generator is not None and getattr(\n                    self._test_generator, \"cr_running\", True\n                ):\n                    self._test_generator.throw(type(e), e)\n                    # In case the test contains an overly broad except\n                    # clause, we may get back here.\n                # Coroutine was stopped or didn't raise a useful stack trace,\n                # so re-raise the original exception which is better than nothing.\n                raise",
        "begin_line": 554,
        "end_line": 575,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 1.0,
            "pseudo_dstar_susp": 1.0,
            "pseudo_tarantula_susp": 0.023255813953488372,
            "pseudo_op2_susp": 1.0,
            "pseudo_barinel_susp": 0.023255813953488372
        }
    },
    {
        "name": "tornado.testing.ExpectLog.__init__#613",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.ExpectLog",
        "signature": "tornado.testing.ExpectLog.__init__(self, logger: Union[logging.Logger, basestring_type], regex: str, required: bool=True)",
        "snippet": "    def __init__(\n        self,\n        logger: Union[logging.Logger, basestring_type],\n        regex: str,\n        required: bool = True,\n    ) -> None:\n        \"\"\"Constructs an ExpectLog context manager.\n\n        :param logger: Logger object (or name of logger) to watch.  Pass\n            an empty string to watch the root logger.\n        :param regex: Regular expression to match.  Any log entries on\n            the specified logger that match this regex will be suppressed.\n        :param required: If true, an exception will be raised if the end of\n            the ``with`` statement is reached without matching any log entries.\n        \"\"\"\n        if isinstance(logger, basestring_type):\n            logger = logging.getLogger(logger)\n        self.logger = logger\n        self.regex = re.compile(regex)\n        self.required = required\n        self.matched = False\n        self.logged_stack = False",
        "begin_line": 613,
        "end_line": 634,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.047619047619047616,
            "pseudo_dstar_susp": 0.045454545454545456,
            "pseudo_tarantula_susp": 0.008333333333333333,
            "pseudo_op2_susp": 0.045454545454545456,
            "pseudo_barinel_susp": 0.008333333333333333
        }
    },
    {
        "name": "tornado.testing.ExpectLog.filter#636",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.ExpectLog",
        "signature": "tornado.testing.ExpectLog.filter(self, record: logging.LogRecord)",
        "snippet": "    def filter(self, record: logging.LogRecord) -> bool:\n        if record.exc_info:\n            self.logged_stack = True\n        message = record.getMessage()\n        if self.regex.match(message):\n            self.matched = True\n            return False\n        return True",
        "begin_line": 636,
        "end_line": 643,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016700066800267202,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.testing.ExpectLog.__enter__#645",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.ExpectLog",
        "signature": "tornado.testing.ExpectLog.__enter__(self)",
        "snippet": "    def __enter__(self) -> \"ExpectLog\":\n        self.logger.addFilter(self)\n        return self",
        "begin_line": 645,
        "end_line": 647,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.047619047619047616,
            "pseudo_dstar_susp": 0.045454545454545456,
            "pseudo_tarantula_susp": 0.008333333333333333,
            "pseudo_op2_susp": 0.045454545454545456,
            "pseudo_barinel_susp": 0.008333333333333333
        }
    },
    {
        "name": "tornado.testing.ExpectLog.__exit__#649",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.ExpectLog",
        "signature": "tornado.testing.ExpectLog.__exit__(self, typ: Optional[Type[BaseException]], value: Optional[BaseException], tb: Optional[TracebackType])",
        "snippet": "    def __exit__(\n        self,\n        typ: Optional[Type[BaseException]],\n        value: Optional[BaseException],\n        tb: Optional[TracebackType],\n    ) -> None:\n        self.logger.removeFilter(self)\n        if not typ and self.required and not self.matched:\n            raise Exception(\"did not get expected log message\")",
        "begin_line": 649,
        "end_line": 657,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.5,
            "pseudo_dstar_susp": 0.06666666666666667,
            "pseudo_tarantula_susp": 0.05,
            "pseudo_op2_susp": 0.06666666666666667,
            "pseudo_barinel_susp": 0.05
        }
    },
    {
        "name": "tornado.httpclient.HTTPClient.__init__#87",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPClient",
        "signature": "tornado.httpclient.HTTPClient.__init__(self, async_client_class: Type['AsyncHTTPClient']=None, **kwargs: Any)",
        "snippet": "    def __init__(\n        self, async_client_class: Type[\"AsyncHTTPClient\"] = None, **kwargs: Any\n    ) -> None:\n        # Initialize self._closed at the beginning of the constructor\n        # so that an exception raised here doesn't lead to confusing\n        # failures in __del__.\n        self._closed = True\n        self._io_loop = IOLoop(make_current=False)\n        if async_client_class is None:\n            async_client_class = AsyncHTTPClient\n\n        # Create the client while our IOLoop is \"current\", without\n        # clobbering the thread's real current IOLoop (if any).\n        async def make_client() -> \"AsyncHTTPClient\":\n            await gen.sleep(0)\n            assert async_client_class is not None\n            return async_client_class(**kwargs)\n\n        self._async_client = self._io_loop.run_sync(make_client)\n        self._closed = False",
        "begin_line": 87,
        "end_line": 106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpclient.HTTPClient.make_client#100",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPClient",
        "signature": "tornado.httpclient.HTTPClient.make_client()",
        "snippet": "        async def make_client() -> \"AsyncHTTPClient\":\n            await gen.sleep(0)\n            assert async_client_class is not None\n            return async_client_class(**kwargs)",
        "begin_line": 100,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpclient.HTTPClient.__del__#108",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPClient",
        "signature": "tornado.httpclient.HTTPClient.__del__(self)",
        "snippet": "    def __del__(self) -> None:\n        self.close()",
        "begin_line": 108,
        "end_line": 109,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpclient.HTTPClient.close#111",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPClient",
        "signature": "tornado.httpclient.HTTPClient.close(self)",
        "snippet": "    def close(self) -> None:\n        \"\"\"Closes the HTTPClient, freeing any resources used.\"\"\"\n        if not self._closed:\n            self._async_client.close()\n            self._io_loop.close()\n            self._closed = True",
        "begin_line": 111,
        "end_line": 116,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpclient.HTTPClient.fetch#118",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPClient",
        "signature": "tornado.httpclient.HTTPClient.fetch(self, request: Union['HTTPRequest', str], **kwargs: Any)",
        "snippet": "    def fetch(\n        self, request: Union[\"HTTPRequest\", str], **kwargs: Any\n    ) -> \"HTTPResponse\":\n        \"\"\"Executes a request, returning an `HTTPResponse`.\n\n        The request may be either a string URL or an `HTTPRequest` object.\n        If it is a string, we construct an `HTTPRequest` using any additional\n        kwargs: ``HTTPRequest(request, **kwargs)``\n\n        If an error occurs during the fetch, we raise an `HTTPError` unless\n        the ``raise_error`` keyword argument is set to False.\n        \"\"\"\n        response = self._io_loop.run_sync(\n            functools.partial(self._async_client.fetch, request, **kwargs)\n        )\n        return response",
        "begin_line": 118,
        "end_line": 133,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.configurable_base#178",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.configurable_base(cls)",
        "snippet": "    def configurable_base(cls) -> Type[Configurable]:\n        return AsyncHTTPClient",
        "begin_line": 178,
        "end_line": 179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00078125,
            "pseudo_dstar_susp": 0.000999000999000999,
            "pseudo_tarantula_susp": 0.0007092198581560284,
            "pseudo_op2_susp": 0.000999000999000999,
            "pseudo_barinel_susp": 0.0007092198581560284
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.configurable_default#182",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.configurable_default(cls)",
        "snippet": "    def configurable_default(cls) -> Type[Configurable]:\n        from tornado.simple_httpclient import SimpleAsyncHTTPClient\n\n        return SimpleAsyncHTTPClient",
        "begin_line": 182,
        "end_line": 185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient._async_clients#188",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient._async_clients(cls)",
        "snippet": "    def _async_clients(cls) -> Dict[IOLoop, \"AsyncHTTPClient\"]:\n        attr_name = \"_async_client_dict_\" + cls.__name__\n        if not hasattr(cls, attr_name):\n            setattr(cls, attr_name, weakref.WeakKeyDictionary())\n        return getattr(cls, attr_name)",
        "begin_line": 188,
        "end_line": 192,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009140767824497258,
            "pseudo_dstar_susp": 0.0009578544061302681,
            "pseudo_tarantula_susp": 0.0009372071227741331,
            "pseudo_op2_susp": 0.0009578544061302681,
            "pseudo_barinel_susp": 0.0009372071227741331
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.__new__#194",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.__new__(cls, force_instance: bool=False, **kwargs: Any)",
        "snippet": "    def __new__(cls, force_instance: bool = False, **kwargs: Any) -> \"AsyncHTTPClient\":\n        io_loop = IOLoop.current()\n        if force_instance:\n            instance_cache = None\n        else:\n            instance_cache = cls._async_clients()\n        if instance_cache is not None and io_loop in instance_cache:\n            return instance_cache[io_loop]\n        instance = super(AsyncHTTPClient, cls).__new__(cls, **kwargs)  # type: ignore\n        # Make sure the instance knows which cache to remove itself from.\n        # It can't simply call _async_clients() because we may be in\n        # __new__(AsyncHTTPClient) but instance.__class__ may be\n        # SimpleAsyncHTTPClient.\n        instance._instance_cache = instance_cache\n        if instance_cache is not None:\n            instance_cache[instance.io_loop] = instance\n        return instance",
        "begin_line": 194,
        "end_line": 210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009140767824497258,
            "pseudo_dstar_susp": 0.000999000999000999,
            "pseudo_tarantula_susp": 0.0009372071227741331,
            "pseudo_op2_susp": 0.000999000999000999,
            "pseudo_barinel_susp": 0.0009372071227741331
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.initialize#212",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.initialize(self, defaults: Dict[str, Any]=None)",
        "snippet": "    def initialize(self, defaults: Dict[str, Any] = None) -> None:\n        self.io_loop = IOLoop.current()\n        self.defaults = dict(HTTPRequest._DEFAULTS)\n        if defaults is not None:\n            self.defaults.update(defaults)\n        self._closed = False",
        "begin_line": 212,
        "end_line": 217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00078125,
            "pseudo_dstar_susp": 0.000999000999000999,
            "pseudo_tarantula_susp": 0.0007092198581560284,
            "pseudo_op2_susp": 0.000999000999000999,
            "pseudo_barinel_susp": 0.0007092198581560284
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.close#219",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.close(self)",
        "snippet": "    def close(self) -> None:\n        \"\"\"Destroys this HTTP client, freeing any file descriptors used.\n\n        This method is **not needed in normal use** due to the way\n        that `AsyncHTTPClient` objects are transparently reused.\n        ``close()`` is generally only necessary when either the\n        `.IOLoop` is also being closed, or the ``force_instance=True``\n        argument was used when creating the `AsyncHTTPClient`.\n\n        No other methods may be called on the `AsyncHTTPClient` after\n        ``close()``.\n\n        \"\"\"\n        if self._closed:\n            return\n        self._closed = True\n        if self._instance_cache is not None:\n            if self._instance_cache.get(self.io_loop) is not self:\n                raise RuntimeError(\"inconsistent AsyncHTTPClient cache\")\n            del self._instance_cache[self.io_loop]",
        "begin_line": 219,
        "end_line": 238,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.0008539709649871904,
            "pseudo_dstar_susp": 0.000999000999000999,
            "pseudo_tarantula_susp": 0.0009407337723424271,
            "pseudo_op2_susp": 0.000999000999000999,
            "pseudo_barinel_susp": 0.0009407337723424271
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.fetch#240",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.fetch(self, request: Union[str, 'HTTPRequest'], raise_error: bool=True, **kwargs: Any)",
        "snippet": "    def fetch(\n        self,\n        request: Union[str, \"HTTPRequest\"],\n        raise_error: bool = True,\n        **kwargs: Any\n    ) -> \"Future[HTTPResponse]\":\n        \"\"\"Executes a request, asynchronously returning an `HTTPResponse`.\n\n        The request may be either a string URL or an `HTTPRequest` object.\n        If it is a string, we construct an `HTTPRequest` using any additional\n        kwargs: ``HTTPRequest(request, **kwargs)``\n\n        This method returns a `.Future` whose result is an\n        `HTTPResponse`. By default, the ``Future`` will raise an\n        `HTTPError` if the request returned a non-200 response code\n        (other errors may also be raised if the server could not be\n        contacted). Instead, if ``raise_error`` is set to False, the\n        response will always be returned regardless of the response\n        code.\n\n        If a ``callback`` is given, it will be invoked with the `HTTPResponse`.\n        In the callback interface, `HTTPError` is not automatically raised.\n        Instead, you must check the response's ``error`` attribute or\n        call its `~HTTPResponse.rethrow` method.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned\n           `.Future` instead.\n\n           The ``raise_error=False`` argument only affects the\n           `HTTPError` raised when a non-200 response code is used,\n           instead of suppressing all errors.\n        \"\"\"\n        if self._closed:\n            raise RuntimeError(\"fetch() called on closed AsyncHTTPClient\")\n        if not isinstance(request, HTTPRequest):\n            request = HTTPRequest(url=request, **kwargs)\n        else:\n            if kwargs:\n                raise ValueError(\n                    \"kwargs can't be used if request is an HTTPRequest object\"\n                )\n        # We may modify this (to add Host, Accept-Encoding, etc),\n        # so make sure we don't modify the caller's object.  This is also\n        # where normal dicts get converted to HTTPHeaders objects.\n        request.headers = httputil.HTTPHeaders(request.headers)\n        request_proxy = _RequestProxy(request, self.defaults)\n        future = Future()  # type: Future[HTTPResponse]\n\n        def handle_response(response: \"HTTPResponse\") -> None:\n            if response.error:\n                if raise_error or not response._error_is_response_code:\n                    future.set_exception(response.error)\n                    return\n            future_set_result_unless_cancelled(future, response)\n\n        self.fetch_impl(cast(HTTPRequest, request_proxy), handle_response)\n        return future",
        "begin_line": 240,
        "end_line": 298,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006253908692933083,
            "pseudo_dstar_susp": 0.0007087172218284905,
            "pseudo_tarantula_susp": 0.0005920663114268798,
            "pseudo_op2_susp": 0.0007087172218284905,
            "pseudo_barinel_susp": 0.0005920663114268798
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.handle_response#290",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.handle_response(response: 'HTTPResponse')",
        "snippet": "        def handle_response(response: \"HTTPResponse\") -> None:\n            if response.error:\n                if raise_error or not response._error_is_response_code:\n                    future.set_exception(response.error)\n                    return\n            future_set_result_unless_cancelled(future, response)",
        "begin_line": 290,
        "end_line": 295,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010976948408342481,
            "pseudo_dstar_susp": 0.0016,
            "pseudo_tarantula_susp": 0.0030864197530864196,
            "pseudo_op2_susp": 0.0016,
            "pseudo_barinel_susp": 0.0030864197530864196
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.configure#306",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.configure(cls, impl: Union[None, str, Type[Configurable]], **kwargs: Any)",
        "snippet": "    def configure(\n        cls, impl: Union[None, str, Type[Configurable]], **kwargs: Any\n    ) -> None:\n        \"\"\"Configures the `AsyncHTTPClient` subclass to use.\n\n        ``AsyncHTTPClient()`` actually creates an instance of a subclass.\n        This method may be called with either a class object or the\n        fully-qualified name of such a class (or ``None`` to use the default,\n        ``SimpleAsyncHTTPClient``)\n\n        If additional keyword arguments are given, they will be passed\n        to the constructor of each subclass instance created.  The\n        keyword argument ``max_clients`` determines the maximum number\n        of simultaneous `~AsyncHTTPClient.fetch()` operations that can\n        execute in parallel on each `.IOLoop`.  Additional arguments\n        may be supported depending on the implementation class in use.\n\n        Example::\n\n           AsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\")\n        \"\"\"\n        super(AsyncHTTPClient, cls).configure(impl, **kwargs)",
        "begin_line": 306,
        "end_line": 327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.__init__#349",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.__init__(self, url: str, method: str='GET', headers: Union[Dict[str, str], httputil.HTTPHeaders]=None, body: Union[bytes, str]=None, auth_username: str=None, auth_password: str=None, auth_mode: str=None, connect_timeout: float=None, request_timeout: float=None, if_modified_since: Union[float, datetime.datetime]=None, follow_redirects: bool=None, max_redirects: int=None, user_agent: str=None, use_gzip: bool=None, network_interface: str=None, streaming_callback: Callable[[bytes], None]=None, header_callback: Callable[[str], None]=None, prepare_curl_callback: Callable[[Any], None]=None, proxy_host: str=None, proxy_port: int=None, proxy_username: str=None, proxy_password: str=None, proxy_auth_mode: str=None, allow_nonstandard_methods: bool=None, validate_cert: bool=None, ca_certs: str=None, allow_ipv6: bool=None, client_key: str=None, client_cert: str=None, body_producer: Callable[[Callable[[bytes], None]], 'Future[None]']=None, expect_100_continue: bool=False, decompress_response: bool=None, ssl_options: Union[Dict[str, Any], ssl.SSLContext]=None)",
        "snippet": "    def __init__(\n        self,\n        url: str,\n        method: str = \"GET\",\n        headers: Union[Dict[str, str], httputil.HTTPHeaders] = None,\n        body: Union[bytes, str] = None,\n        auth_username: str = None,\n        auth_password: str = None,\n        auth_mode: str = None,\n        connect_timeout: float = None,\n        request_timeout: float = None,\n        if_modified_since: Union[float, datetime.datetime] = None,\n        follow_redirects: bool = None,\n        max_redirects: int = None,\n        user_agent: str = None,\n        use_gzip: bool = None,\n        network_interface: str = None,\n        streaming_callback: Callable[[bytes], None] = None,\n        header_callback: Callable[[str], None] = None,\n        prepare_curl_callback: Callable[[Any], None] = None,\n        proxy_host: str = None,\n        proxy_port: int = None,\n        proxy_username: str = None,\n        proxy_password: str = None,\n        proxy_auth_mode: str = None,\n        allow_nonstandard_methods: bool = None,\n        validate_cert: bool = None,\n        ca_certs: str = None,\n        allow_ipv6: bool = None,\n        client_key: str = None,\n        client_cert: str = None,\n        body_producer: Callable[[Callable[[bytes], None]], \"Future[None]\"] = None,\n        expect_100_continue: bool = False,\n        decompress_response: bool = None,\n        ssl_options: Union[Dict[str, Any], ssl.SSLContext] = None,\n    ) -> None:\n        r\"\"\"All parameters except ``url`` are optional.\n\n        :arg str url: URL to fetch\n        :arg str method: HTTP method, e.g. \"GET\" or \"POST\"\n        :arg headers: Additional HTTP headers to pass on the request\n        :type headers: `~tornado.httputil.HTTPHeaders` or `dict`\n        :arg body: HTTP request body as a string (byte or unicode; if unicode\n           the utf-8 encoding will be used)\n        :arg body_producer: Callable used for lazy/asynchronous request bodies.\n           It is called with one argument, a ``write`` function, and should\n           return a `.Future`.  It should call the write function with new\n           data as it becomes available.  The write function returns a\n           `.Future` which can be used for flow control.\n           Only one of ``body`` and ``body_producer`` may\n           be specified.  ``body_producer`` is not supported on\n           ``curl_httpclient``.  When using ``body_producer`` it is recommended\n           to pass a ``Content-Length`` in the headers as otherwise chunked\n           encoding will be used, and many servers do not support chunked\n           encoding on requests.  New in Tornado 4.0\n        :arg str auth_username: Username for HTTP authentication\n        :arg str auth_password: Password for HTTP authentication\n        :arg str auth_mode: Authentication mode; default is \"basic\".\n           Allowed values are implementation-defined; ``curl_httpclient``\n           supports \"basic\" and \"digest\"; ``simple_httpclient`` only supports\n           \"basic\"\n        :arg float connect_timeout: Timeout for initial connection in seconds,\n           default 20 seconds\n        :arg float request_timeout: Timeout for entire request in seconds,\n           default 20 seconds\n        :arg if_modified_since: Timestamp for ``If-Modified-Since`` header\n        :type if_modified_since: `datetime` or `float`\n        :arg bool follow_redirects: Should redirects be followed automatically\n           or return the 3xx response? Default True.\n        :arg int max_redirects: Limit for ``follow_redirects``, default 5.\n        :arg str user_agent: String to send as ``User-Agent`` header\n        :arg bool decompress_response: Request a compressed response from\n           the server and decompress it after downloading.  Default is True.\n           New in Tornado 4.0.\n        :arg bool use_gzip: Deprecated alias for ``decompress_response``\n           since Tornado 4.0.\n        :arg str network_interface: Network interface or source IP to use for request.\n           See ``curl_httpclient`` note below.\n        :arg collections.abc.Callable streaming_callback: If set, ``streaming_callback`` will\n           be run with each chunk of data as it is received, and\n           ``HTTPResponse.body`` and ``HTTPResponse.buffer`` will be empty in\n           the final response.\n        :arg collections.abc.Callable header_callback: If set, ``header_callback`` will\n           be run with each header line as it is received (including the\n           first line, e.g. ``HTTP/1.0 200 OK\\r\\n``, and a final line\n           containing only ``\\r\\n``.  All lines include the trailing newline\n           characters).  ``HTTPResponse.headers`` will be empty in the final\n           response.  This is most useful in conjunction with\n           ``streaming_callback``, because it's the only way to get access to\n           header data while the request is in progress.\n        :arg collections.abc.Callable prepare_curl_callback: If set, will be called with\n           a ``pycurl.Curl`` object to allow the application to make additional\n           ``setopt`` calls.\n        :arg str proxy_host: HTTP proxy hostname.  To use proxies,\n           ``proxy_host`` and ``proxy_port`` must be set; ``proxy_username``,\n           ``proxy_pass`` and ``proxy_auth_mode`` are optional.  Proxies are\n           currently only supported with ``curl_httpclient``.\n        :arg int proxy_port: HTTP proxy port\n        :arg str proxy_username: HTTP proxy username\n        :arg str proxy_password: HTTP proxy password\n        :arg str proxy_auth_mode: HTTP proxy Authentication mode;\n           default is \"basic\". supports \"basic\" and \"digest\"\n        :arg bool allow_nonstandard_methods: Allow unknown values for ``method``\n           argument? Default is False.\n        :arg bool validate_cert: For HTTPS requests, validate the server's\n           certificate? Default is True.\n        :arg str ca_certs: filename of CA certificates in PEM format,\n           or None to use defaults.  See note below when used with\n           ``curl_httpclient``.\n        :arg str client_key: Filename for client SSL key, if any.  See\n           note below when used with ``curl_httpclient``.\n        :arg str client_cert: Filename for client SSL certificate, if any.\n           See note below when used with ``curl_httpclient``.\n        :arg ssl.SSLContext ssl_options: `ssl.SSLContext` object for use in\n           ``simple_httpclient`` (unsupported by ``curl_httpclient``).\n           Overrides ``validate_cert``, ``ca_certs``, ``client_key``,\n           and ``client_cert``.\n        :arg bool allow_ipv6: Use IPv6 when available?  Default is true.\n        :arg bool expect_100_continue: If true, send the\n           ``Expect: 100-continue`` header and wait for a continue response\n           before sending the request body.  Only supported with\n           simple_httpclient.\n\n        .. note::\n\n            When using ``curl_httpclient`` certain options may be\n            inherited by subsequent fetches because ``pycurl`` does\n            not allow them to be cleanly reset.  This applies to the\n            ``ca_certs``, ``client_key``, ``client_cert``, and\n            ``network_interface`` arguments.  If you use these\n            options, you should pass them on every request (you don't\n            have to always use the same values, but it's not possible\n            to mix requests that specify these options with ones that\n            use the defaults).\n\n        .. versionadded:: 3.1\n           The ``auth_mode`` argument.\n\n        .. versionadded:: 4.0\n           The ``body_producer`` and ``expect_100_continue`` arguments.\n\n        .. versionadded:: 4.2\n           The ``ssl_options`` argument.\n\n        .. versionadded:: 4.5\n           The ``proxy_auth_mode`` argument.\n        \"\"\"\n        # Note that some of these attributes go through property setters\n        # defined below.\n        self.headers = headers\n        if if_modified_since:\n            self.headers[\"If-Modified-Since\"] = httputil.format_timestamp(\n                if_modified_since\n            )\n        self.proxy_host = proxy_host\n        self.proxy_port = proxy_port\n        self.proxy_username = proxy_username\n        self.proxy_password = proxy_password\n        self.proxy_auth_mode = proxy_auth_mode\n        self.url = url\n        self.method = method\n        self.body = body\n        self.body_producer = body_producer\n        self.auth_username = auth_username\n        self.auth_password = auth_password\n        self.auth_mode = auth_mode\n        self.connect_timeout = connect_timeout\n        self.request_timeout = request_timeout\n        self.follow_redirects = follow_redirects\n        self.max_redirects = max_redirects\n        self.user_agent = user_agent\n        if decompress_response is not None:\n            self.decompress_response = decompress_response  # type: Optional[bool]\n        else:\n            self.decompress_response = use_gzip\n        self.network_interface = network_interface\n        self.streaming_callback = streaming_callback\n        self.header_callback = header_callback\n        self.prepare_curl_callback = prepare_curl_callback\n        self.allow_nonstandard_methods = allow_nonstandard_methods\n        self.validate_cert = validate_cert\n        self.ca_certs = ca_certs\n        self.allow_ipv6 = allow_ipv6\n        self.client_key = client_key\n        self.client_cert = client_cert\n        self.ssl_options = ssl_options\n        self.expect_100_continue = expect_100_continue\n        self.start_time = time.time()",
        "begin_line": 349,
        "end_line": 536,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005271481286241434,
            "pseudo_dstar_susp": 0.0005934718100890207,
            "pseudo_tarantula_susp": 0.00048828125,
            "pseudo_op2_susp": 0.0005934718100890207,
            "pseudo_barinel_susp": 0.00048828125
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.headers#539",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.headers(self)",
        "snippet": "    def headers(self) -> httputil.HTTPHeaders:\n        # TODO: headers may actually be a plain dict until fairly late in\n        # the process (AsyncHTTPClient.fetch), but practically speaking,\n        # whenever the property is used they're already HTTPHeaders.\n        return self._headers  # type: ignore",
        "begin_line": 539,
        "end_line": 543,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000547945205479452,
            "pseudo_dstar_susp": 0.0006180469715698393,
            "pseudo_tarantula_susp": 0.0005058168942842691,
            "pseudo_op2_susp": 0.0006180469715698393,
            "pseudo_barinel_susp": 0.0005058168942842691
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.headers#546",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.headers(self, value: Union[Dict[str, str], httputil.HTTPHeaders])",
        "snippet": "    def headers(self, value: Union[Dict[str, str], httputil.HTTPHeaders]) -> None:\n        if value is None:\n            self._headers = httputil.HTTPHeaders()\n        else:\n            self._headers = value  # type: ignore",
        "begin_line": 546,
        "end_line": 550,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006265664160401002,
            "pseudo_dstar_susp": 0.0007092198581560284,
            "pseudo_tarantula_susp": 0.0005941770647653001,
            "pseudo_op2_susp": 0.0007092198581560284,
            "pseudo_barinel_susp": 0.0005941770647653001
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.body#553",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.body(self)",
        "snippet": "    def body(self) -> bytes:\n        return self._body",
        "begin_line": 553,
        "end_line": 554,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005733944954128441,
            "pseudo_dstar_susp": 0.000646830530401035,
            "pseudo_tarantula_susp": 0.0005279831045406547,
            "pseudo_op2_susp": 0.000646830530401035,
            "pseudo_barinel_susp": 0.0005279831045406547
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.body#557",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.body(self, value: Union[bytes, str])",
        "snippet": "    def body(self, value: Union[bytes, str]) -> None:\n        self._body = utf8(value)",
        "begin_line": 557,
        "end_line": 558,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005271481286241434,
            "pseudo_dstar_susp": 0.0005934718100890207,
            "pseudo_tarantula_susp": 0.00048828125,
            "pseudo_op2_susp": 0.0005934718100890207,
            "pseudo_barinel_susp": 0.00048828125
        }
    },
    {
        "name": "tornado.httpclient.HTTPResponse.__init__#615",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPResponse",
        "signature": "tornado.httpclient.HTTPResponse.__init__(self, request: HTTPRequest, code: int, headers: httputil.HTTPHeaders=None, buffer: BytesIO=None, effective_url: str=None, error: BaseException=None, request_time: float=None, time_info: Dict[str, float]=None, reason: str=None, start_time: float=None)",
        "snippet": "    def __init__(\n        self,\n        request: HTTPRequest,\n        code: int,\n        headers: httputil.HTTPHeaders = None,\n        buffer: BytesIO = None,\n        effective_url: str = None,\n        error: BaseException = None,\n        request_time: float = None,\n        time_info: Dict[str, float] = None,\n        reason: str = None,\n        start_time: float = None,\n    ) -> None:\n        if isinstance(request, _RequestProxy):\n            self.request = request.request\n        else:\n            self.request = request\n        self.code = code\n        self.reason = reason or httputil.responses.get(code, \"Unknown\")\n        if headers is not None:\n            self.headers = headers\n        else:\n            self.headers = httputil.HTTPHeaders()\n        self.buffer = buffer\n        self._body = None  # type: Optional[bytes]\n        if effective_url is None:\n            self.effective_url = request.url\n        else:\n            self.effective_url = effective_url\n        self._error_is_response_code = False\n        if error is None:\n            if self.code < 200 or self.code >= 300:\n                self._error_is_response_code = True\n                self.error = HTTPError(self.code, message=self.reason, response=self)\n            else:\n                self.error = None\n        else:\n            self.error = error\n        self.start_time = start_time\n        self.request_time = request_time\n        self.time_info = time_info or {}",
        "begin_line": 615,
        "end_line": 655,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011086474501108647,
            "pseudo_dstar_susp": 0.0006839945280437756,
            "pseudo_tarantula_susp": 0.003401360544217687,
            "pseudo_op2_susp": 0.0006839945280437756,
            "pseudo_barinel_susp": 0.003401360544217687
        }
    },
    {
        "name": "tornado.httpclient.HTTPResponse.body#658",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPResponse",
        "signature": "tornado.httpclient.HTTPResponse.body(self)",
        "snippet": "    def body(self) -> bytes:\n        if self.buffer is None:\n            raise ValueError(\"body not set\")\n        elif self._body is None:\n            self._body = self.buffer.getvalue()\n\n        return self._body",
        "begin_line": 658,
        "end_line": 664,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00040816326530612246,
            "pseudo_dstar_susp": 0.0004280821917808219,
            "pseudo_tarantula_susp": 0.00040404040404040404,
            "pseudo_op2_susp": 0.0004280821917808219,
            "pseudo_barinel_susp": 0.00040404040404040404
        }
    },
    {
        "name": "tornado.httpclient.HTTPResponse.rethrow#666",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPResponse",
        "signature": "tornado.httpclient.HTTPResponse.rethrow(self)",
        "snippet": "    def rethrow(self) -> None:\n        \"\"\"If there was an error on the request, raise an `HTTPError`.\"\"\"\n        if self.error:\n            raise self.error",
        "begin_line": 666,
        "end_line": 669,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpclient.HTTPResponse.__repr__#671",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPResponse",
        "signature": "tornado.httpclient.HTTPResponse.__repr__(self)",
        "snippet": "    def __repr__(self) -> str:\n        args = \",\".join(\"%s=%r\" % i for i in sorted(self.__dict__.items()))\n        return \"%s(%s)\" % (self.__class__.__name__, args)",
        "begin_line": 671,
        "end_line": 673,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpclient.HTTPClientError.__init__#697",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPClientError",
        "signature": "tornado.httpclient.HTTPClientError.__init__(self, code: int, message: str=None, response: HTTPResponse=None)",
        "snippet": "    def __init__(\n        self, code: int, message: str = None, response: HTTPResponse = None\n    ) -> None:\n        self.code = code\n        self.message = message or httputil.responses.get(code, \"Unknown\")\n        self.response = response\n        super(HTTPClientError, self).__init__(code, message, response)",
        "begin_line": 697,
        "end_line": 703,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000968054211035818,
            "pseudo_dstar_susp": 0.0005675368898978433,
            "pseudo_tarantula_susp": 0.001589825119236884,
            "pseudo_op2_susp": 0.0005675368898978433,
            "pseudo_barinel_susp": 0.0015923566878980893
        }
    },
    {
        "name": "tornado.httpclient.HTTPClientError.__str__#705",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPClientError",
        "signature": "tornado.httpclient.HTTPClientError.__str__(self)",
        "snippet": "    def __str__(self) -> str:\n        return \"HTTP %d: %s\" % (self.code, self.message)",
        "begin_line": 705,
        "end_line": 706,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httpclient._RequestProxy.__init__#724",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient._RequestProxy",
        "signature": "tornado.httpclient._RequestProxy.__init__(self, request: HTTPRequest, defaults: Optional[Dict[str, Any]])",
        "snippet": "    def __init__(\n        self, request: HTTPRequest, defaults: Optional[Dict[str, Any]]\n    ) -> None:\n        self.request = request\n        self.defaults = defaults",
        "begin_line": 724,
        "end_line": 728,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000544069640914037,
            "pseudo_dstar_susp": 0.0006142506142506142,
            "pseudo_tarantula_susp": 0.0005030181086519115,
            "pseudo_op2_susp": 0.0006142506142506142,
            "pseudo_barinel_susp": 0.0005030181086519115
        }
    },
    {
        "name": "tornado.httpclient._RequestProxy.__getattr__#730",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient._RequestProxy",
        "signature": "tornado.httpclient._RequestProxy.__getattr__(self, name: str)",
        "snippet": "    def __getattr__(self, name: str) -> Any:\n        request_attr = getattr(self.request, name)\n        if request_attr is not None:\n            return request_attr\n        elif self.defaults is not None:\n            return self.defaults.get(name, None)\n        else:\n            return None",
        "begin_line": 730,
        "end_line": 737,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005491488193300384,
            "pseudo_dstar_susp": 0.0006195786864931846,
            "pseudo_tarantula_susp": 0.0005068423720223011,
            "pseudo_op2_susp": 0.0006195786864931846,
            "pseudo_barinel_susp": 0.0005068423720223011
        }
    },
    {
        "name": "tornado.httputil._NormalizedHeaderCache.__missing__#87",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil._NormalizedHeaderCache",
        "signature": "tornado.httputil._NormalizedHeaderCache.__missing__(self, key: str)",
        "snippet": "    def __missing__(self, key: str) -> str:\n        normalized = \"-\".join([w.capitalize() for w in key.split(\"-\")])\n        self[key] = normalized\n        self.queue.append(key)\n        if len(self.queue) > self.size:\n            # Limit the size of the cache.  LRU would be better, but this\n            # simpler approach should be fine.  In Python 2.7+ we could\n            # use OrderedDict (or in 3.2+, @functools.lru_cache).\n            old_key = self.queue.popleft()\n            del self[old_key]\n        return normalized",
        "begin_line": 87,
        "end_line": 97,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001543924656476764,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.__init__#148",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.__init__(self, *args: typing.Any, **kwargs: str)",
        "snippet": "    def __init__(self, *args: typing.Any, **kwargs: str) -> None:  # noqa: F811\n        self._dict = {}  # type: typing.Dict[str, str]\n        self._as_list = {}  # type: typing.Dict[str, typing.List[str]]\n        self._last_key = None\n        if len(args) == 1 and len(kwargs) == 0 and isinstance(args[0], HTTPHeaders):\n            # Copy constructor\n            for k, v in args[0].get_all():\n                self.add(k, v)\n        else:\n            # Dict-style initialization\n            self.update(*args, **kwargs)",
        "begin_line": 148,
        "end_line": 158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008857395925597874,
            "pseudo_dstar_susp": 0.001182033096926714,
            "pseudo_tarantula_susp": 0.0007215007215007215,
            "pseudo_op2_susp": 0.001182033096926714,
            "pseudo_barinel_susp": 0.0007215007215007215
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.add#162",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.add(self, name: str, value: str)",
        "snippet": "    def add(self, name: str, value: str) -> None:\n        \"\"\"Adds a new value for the given key.\"\"\"\n        norm_name = _normalized_headers[name]\n        self._last_key = norm_name\n        if norm_name in self:\n            self._dict[norm_name] = (\n                native_str(self[norm_name]) + \",\" + native_str(value)\n            )\n            self._as_list[norm_name].append(value)\n        else:\n            self[norm_name] = value",
        "begin_line": 162,
        "end_line": 172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006978367062107466,
            "pseudo_dstar_susp": 0.0008264462809917355,
            "pseudo_tarantula_susp": 0.0006357279084551812,
            "pseudo_op2_susp": 0.0008264462809917355,
            "pseudo_barinel_susp": 0.0006357279084551812
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.get_list#174",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.get_list(self, name: str)",
        "snippet": "    def get_list(self, name: str) -> List[str]:\n        \"\"\"Returns all values for the given header as a list.\"\"\"\n        norm_name = _normalized_headers[name]\n        return self._as_list.get(norm_name, [])",
        "begin_line": 174,
        "end_line": 177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017885888034340904,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.get_all#179",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.get_all(self)",
        "snippet": "    def get_all(self) -> Iterable[Tuple[str, str]]:\n        \"\"\"Returns an iterable of all (name, value) pairs.\n\n        If a header has multiple values, multiple pairs will be\n        returned with the same name.\n        \"\"\"\n        for name, values in self._as_list.items():\n            for value in values:\n                yield (name, value)",
        "begin_line": 179,
        "end_line": 187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006261740763932373,
            "pseudo_dstar_susp": 0.0007215007215007215,
            "pseudo_tarantula_susp": 0.0005319148936170213,
            "pseudo_op2_susp": 0.0007215007215007215,
            "pseudo_barinel_susp": 0.0005319148936170213
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.parse_line#189",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.parse_line(self, line: str)",
        "snippet": "    def parse_line(self, line: str) -> None:\n        \"\"\"Updates the dictionary with a single header line.\n\n        >>> h = HTTPHeaders()\n        >>> h.parse_line(\"Content-Type: text/html\")\n        >>> h.get('content-type')\n        'text/html'\n        \"\"\"\n        if line[0].isspace():\n            # continuation of a multi-line header\n            if self._last_key is None:\n                raise HTTPInputError(\"first header line cannot start with whitespace\")\n            new_part = \" \" + line.lstrip()\n            self._as_list[self._last_key][-1] += new_part\n            self._dict[self._last_key] += new_part\n        else:\n            try:\n                name, value = line.split(\":\", 1)\n            except ValueError:\n                raise HTTPInputError(\"no colon in header line\")\n            self.add(name, value.strip())",
        "begin_line": 189,
        "end_line": 209,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011441647597254005,
            "pseudo_dstar_susp": 0.0009233610341643582,
            "pseudo_tarantula_susp": 0.05,
            "pseudo_op2_susp": 0.0009233610341643582,
            "pseudo_barinel_susp": 0.05
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.parse#212",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.parse(cls, headers: str)",
        "snippet": "    def parse(cls, headers: str) -> \"HTTPHeaders\":\n        \"\"\"Returns a dictionary from HTTP header text.\n\n        >>> h = HTTPHeaders.parse(\"Content-Type: text/html\\\\r\\\\nContent-Length: 42\\\\r\\\\n\")\n        >>> sorted(h.items())\n        [('Content-Length', '42'), ('Content-Type', 'text/html')]\n\n        .. versionchanged:: 5.1\n\n           Raises `HTTPInputError` on malformed headers instead of a\n           mix of `KeyError`, and `ValueError`.\n\n        \"\"\"\n        h = cls()\n        for line in _CRLF_RE.split(headers):\n            if line:\n                h.parse_line(line)\n        return h",
        "begin_line": 212,
        "end_line": 229,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010395010395010396,
            "pseudo_dstar_susp": 0.0014265335235378032,
            "pseudo_tarantula_susp": 0.0008984725965858042,
            "pseudo_op2_susp": 0.0014265335235378032,
            "pseudo_barinel_susp": 0.0008984725965858042
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.__setitem__#233",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.__setitem__(self, name: str, value: str)",
        "snippet": "    def __setitem__(self, name: str, value: str) -> None:\n        norm_name = _normalized_headers[name]\n        self._dict[norm_name] = value\n        self._as_list[norm_name] = [value]",
        "begin_line": 233,
        "end_line": 236,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006939625260235947,
            "pseudo_dstar_susp": 0.0008210180623973727,
            "pseudo_tarantula_susp": 0.0006067961165048543,
            "pseudo_op2_susp": 0.0008210180623973727,
            "pseudo_barinel_susp": 0.0006067961165048543
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.__getitem__#238",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.__getitem__(self, name: str)",
        "snippet": "    def __getitem__(self, name: str) -> str:\n        return self._dict[_normalized_headers[name]]",
        "begin_line": 238,
        "end_line": 239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007267441860465116,
            "pseudo_dstar_susp": 0.0009191176470588235,
            "pseudo_tarantula_susp": 0.0006414368184733803,
            "pseudo_op2_susp": 0.0009191176470588235,
            "pseudo_barinel_susp": 0.0006414368184733803
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.__delitem__#241",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.__delitem__(self, name: str)",
        "snippet": "    def __delitem__(self, name: str) -> None:\n        norm_name = _normalized_headers[name]\n        del self._dict[norm_name]\n        del self._as_list[norm_name]",
        "begin_line": 241,
        "end_line": 244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00013984058173682003,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.__len__#246",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.__len__(self)",
        "snippet": "    def __len__(self) -> int:\n        return len(self._dict)",
        "begin_line": 246,
        "end_line": 247,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007251631617113851,
            "pseudo_dstar_susp": 0.0008613264427217916,
            "pseudo_tarantula_susp": 0.000663129973474801,
            "pseudo_op2_susp": 0.0008613264427217916,
            "pseudo_barinel_susp": 0.000663129973474801
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.__iter__#249",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.__iter__(self)",
        "snippet": "    def __iter__(self) -> Iterator[typing.Any]:\n        return iter(self._dict)",
        "begin_line": 249,
        "end_line": 250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015698587127158556,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.copy#252",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.copy(self)",
        "snippet": "    def copy(self) -> \"HTTPHeaders\":\n        # defined in dict but not in MutableMapping.\n        return HTTPHeaders(self)",
        "begin_line": 252,
        "end_line": 254,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.__str__#261",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.__str__(self)",
        "snippet": "    def __str__(self) -> str:\n        lines = []\n        for name, value in self.get_all():\n            lines.append(\"%s: %s\\n\" % (name, value))\n        return \"\".join(lines)",
        "begin_line": 261,
        "end_line": 265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil.HTTPServerRequest.__init__#369",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPServerRequest",
        "signature": "tornado.httputil.HTTPServerRequest.__init__(self, method: str=None, uri: str=None, version: str='HTTP/1.0', headers: HTTPHeaders=None, body: bytes=None, host: str=None, files: Dict[str, List['HTTPFile']]=None, connection: 'HTTPConnection'=None, start_line: 'RequestStartLine'=None, server_connection: object=None)",
        "snippet": "    def __init__(\n        self,\n        method: str = None,\n        uri: str = None,\n        version: str = \"HTTP/1.0\",\n        headers: HTTPHeaders = None,\n        body: bytes = None,\n        host: str = None,\n        files: Dict[str, List[\"HTTPFile\"]] = None,\n        connection: \"HTTPConnection\" = None,\n        start_line: \"RequestStartLine\" = None,\n        server_connection: object = None,\n    ) -> None:\n        if start_line is not None:\n            method, uri, version = start_line\n        self.method = method\n        self.uri = uri\n        self.version = version\n        self.headers = headers or HTTPHeaders()\n        self.body = body or b\"\"\n\n        # set remote IP and protocol\n        context = getattr(connection, \"context\", None)\n        self.remote_ip = getattr(context, \"remote_ip\", None)\n        self.protocol = getattr(context, \"protocol\", \"http\")\n\n        self.host = host or self.headers.get(\"Host\") or \"127.0.0.1\"\n        self.host_name = split_host_and_port(self.host.lower())[0]\n        self.files = files or {}\n        self.connection = connection\n        self.server_connection = server_connection\n        self._start_time = time.time()\n        self._finish_time = None\n\n        if uri is not None:\n            self.path, sep, self.query = uri.partition(\"?\")\n        self.arguments = parse_qs_bytes(self.query, keep_blank_values=True)\n        self.query_arguments = copy.deepcopy(self.arguments)\n        self.body_arguments = {}  # type: Dict[str, List[bytes]]",
        "begin_line": 369,
        "end_line": 407,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000725689404934688,
            "pseudo_dstar_susp": 0.0008620689655172414,
            "pseudo_tarantula_susp": 0.0006640106241699867,
            "pseudo_op2_susp": 0.0008620689655172414,
            "pseudo_barinel_susp": 0.0006640106241699867
        }
    },
    {
        "name": "tornado.httputil.HTTPServerRequest.cookies#410",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPServerRequest",
        "signature": "tornado.httputil.HTTPServerRequest.cookies(self)",
        "snippet": "    def cookies(self) -> Dict[str, http.cookies.Morsel]:\n        \"\"\"A dictionary of ``http.cookies.Morsel`` objects.\"\"\"\n        if not hasattr(self, \"_cookies\"):\n            self._cookies = http.cookies.SimpleCookie()\n            if \"Cookie\" in self.headers:\n                try:\n                    parsed = parse_cookie(self.headers[\"Cookie\"])\n                except Exception:\n                    pass\n                else:\n                    for k, v in parsed.items():\n                        try:\n                            self._cookies[k] = v\n                        except Exception:\n                            # SimpleCookie imposes some restrictions on keys;\n                            # parse_cookie does not. Discard any cookies\n                            # with disallowed keys.\n                            pass\n        return self._cookies",
        "begin_line": 410,
        "end_line": 428,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil.HTTPServerRequest.full_url#430",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPServerRequest",
        "signature": "tornado.httputil.HTTPServerRequest.full_url(self)",
        "snippet": "    def full_url(self) -> str:\n        \"\"\"Reconstructs the full URL for this request.\"\"\"\n        return self.protocol + \"://\" + self.host + self.uri",
        "begin_line": 430,
        "end_line": 432,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil.HTTPServerRequest.request_time#434",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPServerRequest",
        "signature": "tornado.httputil.HTTPServerRequest.request_time(self)",
        "snippet": "    def request_time(self) -> float:\n        \"\"\"Returns the amount of time it took for this request to execute.\"\"\"\n        if self._finish_time is None:\n            return time.time() - self._start_time\n        else:\n            return self._finish_time - self._start_time",
        "begin_line": 434,
        "end_line": 439,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004266211604095563,
            "pseudo_dstar_susp": 0.0004578754578754579,
            "pseudo_tarantula_susp": 0.0004084967320261438,
            "pseudo_op2_susp": 0.0004578754578754579,
            "pseudo_barinel_susp": 0.0004084967320261438
        }
    },
    {
        "name": "tornado.httputil.HTTPServerRequest._parse_body#472",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPServerRequest",
        "signature": "tornado.httputil.HTTPServerRequest._parse_body(self)",
        "snippet": "    def _parse_body(self) -> None:\n        parse_body_arguments(\n            self.headers.get(\"Content-Type\", \"\"),\n            self.body,\n            self.body_arguments,\n            self.files,\n            self.headers,\n        )\n\n        for k, v in self.body_arguments.items():\n            self.arguments.setdefault(k, []).extend(v)",
        "begin_line": 472,
        "end_line": 482,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00045955882352941176,
            "pseudo_dstar_susp": 0.0005025125628140704,
            "pseudo_tarantula_susp": 0.0004338394793926247,
            "pseudo_op2_susp": 0.0005025125628140704,
            "pseudo_barinel_susp": 0.0004338394793926247
        }
    },
    {
        "name": "tornado.httputil.HTTPServerRequest.__repr__#484",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPServerRequest",
        "signature": "tornado.httputil.HTTPServerRequest.__repr__(self)",
        "snippet": "    def __repr__(self) -> str:\n        attrs = (\"protocol\", \"host\", \"method\", \"uri\", \"version\", \"remote_ip\")\n        args = \", \".join([\"%s=%r\" % (n, getattr(self, n)) for n in attrs])\n        return \"%s(%s)\" % (self.__class__.__name__, args)",
        "begin_line": 484,
        "end_line": 487,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018135654697134566,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil.HTTPMessageDelegate.headers_received#545",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPMessageDelegate",
        "signature": "tornado.httputil.HTTPMessageDelegate.headers_received(self, start_line: Union['RequestStartLine', 'ResponseStartLine'], headers: HTTPHeaders)",
        "snippet": "    def headers_received(\n        self,\n        start_line: Union[\"RequestStartLine\", \"ResponseStartLine\"],\n        headers: HTTPHeaders,\n    ) -> Optional[Awaitable[None]]:\n        \"\"\"Called when the HTTP headers have been received and parsed.\n\n        :arg start_line: a `.RequestStartLine` or `.ResponseStartLine`\n            depending on whether this is a client or server message.\n        :arg headers: a `.HTTPHeaders` instance.\n\n        Some `.HTTPConnection` methods can only be called during\n        ``headers_received``.\n\n        May return a `.Future`; if it does the body will not be read\n        until it is done.\n        \"\"\"\n        pass",
        "begin_line": 545,
        "end_line": 562,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil.url_concat#631",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.url_concat(url: str, args: Union[None, Dict[str, str], List[Tuple[str, str]], Tuple[Tuple[str, str], ...]])",
        "snippet": "def url_concat(\n    url: str,\n    args: Union[\n        None, Dict[str, str], List[Tuple[str, str]], Tuple[Tuple[str, str], ...]\n    ],\n) -> str:\n    \"\"\"Concatenate url and arguments regardless of whether\n    url has existing query parameters.\n\n    ``args`` may be either a dictionary or a list of key-value pairs\n    (the latter allows for multiple values with the same key.\n\n    >>> url_concat(\"http://example.com/foo\", dict(c=\"d\"))\n    'http://example.com/foo?c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", [(\"c\", \"d\"), (\"c\", \"d2\")])\n    'http://example.com/foo?a=b&c=d&c=d2'\n    \"\"\"\n    if args is None:\n        return url\n    parsed_url = urlparse(url)\n    if isinstance(args, dict):\n        parsed_query = parse_qsl(parsed_url.query, keep_blank_values=True)\n        parsed_query.extend(args.items())\n    elif isinstance(args, list) or isinstance(args, tuple):\n        parsed_query = parse_qsl(parsed_url.query, keep_blank_values=True)\n        parsed_query.extend(args)\n    else:\n        err = \"'args' parameter should be dict, list or tuple. Not {0}\".format(\n            type(args)\n        )\n        raise TypeError(err)\n    final_query = urlencode(parsed_query)\n    url = urlunparse(\n        (\n            parsed_url[0],\n            parsed_url[1],\n            parsed_url[2],\n            parsed_url[3],\n            final_query,\n            parsed_url[5],\n        )\n    )\n    return url",
        "begin_line": 631,
        "end_line": 675,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil._parse_request_range#692",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil._parse_request_range(range_header: str)",
        "snippet": "def _parse_request_range(\n    range_header: str\n) -> Optional[Tuple[Optional[int], Optional[int]]]:\n    \"\"\"Parses a Range header.\n\n    Returns either ``None`` or tuple ``(start, end)``.\n    Note that while the HTTP headers use inclusive byte positions,\n    this method returns indexes suitable for use in slices.\n\n    >>> start, end = _parse_request_range(\"bytes=1-2\")\n    >>> start, end\n    (1, 3)\n    >>> [0, 1, 2, 3, 4][start:end]\n    [1, 2]\n    >>> _parse_request_range(\"bytes=6-\")\n    (6, None)\n    >>> _parse_request_range(\"bytes=-6\")\n    (-6, None)\n    >>> _parse_request_range(\"bytes=-0\")\n    (None, 0)\n    >>> _parse_request_range(\"bytes=\")\n    (None, None)\n    >>> _parse_request_range(\"foo=42\")\n    >>> _parse_request_range(\"bytes=1-2,6-10\")\n\n    Note: only supports one range (ex, ``bytes=1-2,6-10`` is not allowed).\n\n    See [0] for the details of the range header.\n\n    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    \"\"\"\n    unit, _, value = range_header.partition(\"=\")\n    unit, value = unit.strip(), value.strip()\n    if unit != \"bytes\":\n        return None\n    start_b, _, end_b = value.partition(\"-\")\n    try:\n        start = _int_or_none(start_b)\n        end = _int_or_none(end_b)\n    except ValueError:\n        return None\n    if end is not None:\n        if start is None:\n            if end != 0:\n                start = -end\n                end = None\n        else:\n            end += 1\n    return (start, end)",
        "begin_line": 692,
        "end_line": 740,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil._get_content_range#743",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil._get_content_range(start: Optional[int], end: Optional[int], total: int)",
        "snippet": "def _get_content_range(start: Optional[int], end: Optional[int], total: int) -> str:\n    \"\"\"Returns a suitable Content-Range header:\n\n    >>> print(_get_content_range(None, 1, 4))\n    bytes 0-0/4\n    >>> print(_get_content_range(1, 3, 4))\n    bytes 1-2/4\n    >>> print(_get_content_range(None, None, 4))\n    bytes 0-3/4\n    \"\"\"\n    start = start or 0\n    end = (end or total) - 1\n    return \"bytes %s-%s/%s\" % (start, end, total)",
        "begin_line": 743,
        "end_line": 755,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil._int_or_none#758",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil._int_or_none(val: str)",
        "snippet": "def _int_or_none(val: str) -> Optional[int]:\n    val = val.strip()\n    if val == \"\":\n        return None\n    return int(val)",
        "begin_line": 758,
        "end_line": 762,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019334880123743234,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil.parse_body_arguments#765",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.parse_body_arguments(content_type: str, body: bytes, arguments: Dict[str, List[bytes]], files: Dict[str, List[HTTPFile]], headers: HTTPHeaders=None)",
        "snippet": "def parse_body_arguments(\n    content_type: str,\n    body: bytes,\n    arguments: Dict[str, List[bytes]],\n    files: Dict[str, List[HTTPFile]],\n    headers: HTTPHeaders = None,\n) -> None:\n    \"\"\"Parses a form request body.\n\n    Supports ``application/x-www-form-urlencoded`` and\n    ``multipart/form-data``.  The ``content_type`` parameter should be\n    a string and ``body`` should be a byte string.  The ``arguments``\n    and ``files`` parameters are dictionaries that will be updated\n    with the parsed contents.\n    \"\"\"\n    if headers and \"Content-Encoding\" in headers:\n        gen_log.warning(\"Unsupported Content-Encoding: %s\", headers[\"Content-Encoding\"])\n        return\n    if content_type.startswith(\"application/x-www-form-urlencoded\"):\n        try:\n            uri_arguments = parse_qs_bytes(native_str(body), keep_blank_values=True)\n        except Exception as e:\n            gen_log.warning(\"Invalid x-www-form-urlencoded body: %s\", e)\n            uri_arguments = {}\n        for name, values in uri_arguments.items():\n            if values:\n                arguments.setdefault(name, []).extend(values)\n    elif content_type.startswith(\"multipart/form-data\"):\n        try:\n            fields = content_type.split(\";\")\n            for field in fields:\n                k, sep, v = field.strip().partition(\"=\")\n                if k == \"boundary\" and v:\n                    parse_multipart_form_data(utf8(v), body, arguments, files)\n                    break\n            else:\n                raise ValueError(\"multipart boundary not found\")\n        except Exception as e:\n            gen_log.warning(\"Invalid multipart/form-data: %s\", e)",
        "begin_line": 765,
        "end_line": 803,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004631773969430292,
            "pseudo_dstar_susp": 0.0005053057099545225,
            "pseudo_tarantula_susp": 0.00043706293706293706,
            "pseudo_op2_susp": 0.0005053057099545225,
            "pseudo_barinel_susp": 0.00043706293706293706
        }
    },
    {
        "name": "tornado.httputil.parse_multipart_form_data#806",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.parse_multipart_form_data(boundary: bytes, data: bytes, arguments: Dict[str, List[bytes]], files: Dict[str, List[HTTPFile]])",
        "snippet": "def parse_multipart_form_data(\n    boundary: bytes,\n    data: bytes,\n    arguments: Dict[str, List[bytes]],\n    files: Dict[str, List[HTTPFile]],\n) -> None:\n    \"\"\"Parses a ``multipart/form-data`` body.\n\n    The ``boundary`` and ``data`` parameters are both byte strings.\n    The dictionaries given in the arguments and files parameters\n    will be updated with the contents of the body.\n\n    .. versionchanged:: 5.1\n\n       Now recognizes non-ASCII filenames in RFC 2231/5987\n       (``filename*=``) format.\n    \"\"\"\n    # The standard allows for the boundary to be quoted in the header,\n    # although it's rare (it happens at least for google app engine\n    # xmpp).  I think we're also supposed to handle backslash-escapes\n    # here but I'll save that until we see a client that uses them\n    # in the wild.\n    if boundary.startswith(b'\"') and boundary.endswith(b'\"'):\n        boundary = boundary[1:-1]\n    final_boundary_index = data.rfind(b\"--\" + boundary + b\"--\")\n    if final_boundary_index == -1:\n        gen_log.warning(\"Invalid multipart/form-data: no final boundary\")\n        return\n    parts = data[:final_boundary_index].split(b\"--\" + boundary + b\"\\r\\n\")\n    for part in parts:\n        if not part:\n            continue\n        eoh = part.find(b\"\\r\\n\\r\\n\")\n        if eoh == -1:\n            gen_log.warning(\"multipart/form-data missing headers\")\n            continue\n        headers = HTTPHeaders.parse(part[:eoh].decode(\"utf-8\"))\n        disp_header = headers.get(\"Content-Disposition\", \"\")\n        disposition, disp_params = _parse_header(disp_header)\n        if disposition != \"form-data\" or not part.endswith(b\"\\r\\n\"):\n            gen_log.warning(\"Invalid multipart/form-data\")\n            continue\n        value = part[eoh + 4 : -2]\n        if not disp_params.get(\"name\"):\n            gen_log.warning(\"multipart/form-data value missing name\")\n            continue\n        name = disp_params[\"name\"]\n        if disp_params.get(\"filename\"):\n            ctype = headers.get(\"Content-Type\", \"application/unknown\")\n            files.setdefault(name, []).append(\n                HTTPFile(\n                    filename=disp_params[\"filename\"], body=value, content_type=ctype\n                )\n            )\n        else:\n            arguments.setdefault(name, []).append(value)",
        "begin_line": 806,
        "end_line": 861,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil.format_timestamp#864",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.format_timestamp(ts: Union[int, float, tuple, time.struct_time, datetime.datetime])",
        "snippet": "def format_timestamp(\n    ts: Union[int, float, tuple, time.struct_time, datetime.datetime]\n) -> str:\n    \"\"\"Formats a timestamp in the format used by HTTP.\n\n    The argument may be a numeric timestamp as returned by `time.time`,\n    a time tuple as returned by `time.gmtime`, or a `datetime.datetime`\n    object.\n\n    >>> format_timestamp(1359312200)\n    'Sun, 27 Jan 2013 18:43:20 GMT'\n    \"\"\"\n    if isinstance(ts, (int, float)):\n        time_num = ts\n    elif isinstance(ts, (tuple, time.struct_time)):\n        time_num = calendar.timegm(ts)\n    elif isinstance(ts, datetime.datetime):\n        time_num = calendar.timegm(ts.utctimetuple())\n    else:\n        raise TypeError(\"unknown timestamp type: %r\" % ts)\n    return email.utils.formatdate(time_num, usegmt=True)",
        "begin_line": 864,
        "end_line": 884,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004901960784313725,
            "pseudo_dstar_susp": 0.0005422993492407809,
            "pseudo_tarantula_susp": 0.00045475216007276033,
            "pseudo_op2_susp": 0.0005422993492407809,
            "pseudo_barinel_susp": 0.00045475216007276033
        }
    },
    {
        "name": "tornado.httputil.parse_request_start_line#892",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.parse_request_start_line(line: str)",
        "snippet": "def parse_request_start_line(line: str) -> RequestStartLine:\n    \"\"\"Returns a (method, path, version) tuple for an HTTP 1.x request line.\n\n    The response is a `collections.namedtuple`.\n\n    >>> parse_request_start_line(\"GET /foo HTTP/1.1\")\n    RequestStartLine(method='GET', path='/foo', version='HTTP/1.1')\n    \"\"\"\n    try:\n        method, path, version = line.split(\" \")\n    except ValueError:\n        # https://tools.ietf.org/html/rfc7230#section-3.1.1\n        # invalid request-line SHOULD respond with a 400 (Bad Request)\n        raise HTTPInputError(\"Malformed HTTP request line\")\n    if not re.match(r\"^HTTP/1\\.[0-9]$\", version):\n        raise HTTPInputError(\n            \"Malformed HTTP version in HTTP Request-Line: %r\" % version\n        )\n    return RequestStartLine(method, path, version)",
        "begin_line": 892,
        "end_line": 910,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004098360655737705,
            "pseudo_dstar_susp": 0.0011534025374855825,
            "pseudo_tarantula_susp": 0.05,
            "pseudo_op2_susp": 0.0011534025374855825,
            "pseudo_barinel_susp": 0.05
        }
    },
    {
        "name": "tornado.httputil.parse_response_start_line#918",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.parse_response_start_line(line: str)",
        "snippet": "def parse_response_start_line(line: str) -> ResponseStartLine:\n    \"\"\"Returns a (version, code, reason) tuple for an HTTP 1.x response line.\n\n    The response is a `collections.namedtuple`.\n\n    >>> parse_response_start_line(\"HTTP/1.1 200 OK\")\n    ResponseStartLine(version='HTTP/1.1', code=200, reason='OK')\n    \"\"\"\n    line = native_str(line)\n    match = re.match(\"(HTTP/1.[0-9]) ([0-9]+) ([^\\r]*)\", line)\n    if not match:\n        raise HTTPInputError(\"Error parsing response start line\")\n    return ResponseStartLine(match.group(1), int(match.group(2)), match.group(3))",
        "begin_line": 918,
        "end_line": 930,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006531678641410843,
            "pseudo_dstar_susp": 0.0007501875468867217,
            "pseudo_tarantula_susp": 0.0006006006006006006,
            "pseudo_op2_susp": 0.0007501875468867217,
            "pseudo_barinel_susp": 0.0005988023952095808
        }
    },
    {
        "name": "tornado.httputil._parseparam#941",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil._parseparam(s: str)",
        "snippet": "def _parseparam(s: str) -> Generator[str, None, None]:\n    while s[:1] == \";\":\n        s = s[1:]\n        end = s.find(\";\")\n        while end > 0 and (s.count('\"', 0, end) - s.count('\\\\\"', 0, end)) % 2:\n            end = s.find(\";\", end + 1)\n        if end < 0:\n            end = len(s)\n        f = s[:end]\n        yield f.strip()\n        s = s[end:]",
        "begin_line": 941,
        "end_line": 951,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil._parse_header#954",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil._parse_header(line: str)",
        "snippet": "def _parse_header(line: str) -> Tuple[str, Dict[str, str]]:\n    r\"\"\"Parse a Content-type like header.\n\n    Return the main content-type and a dictionary of options.\n\n    >>> d = \"form-data; foo=\\\"b\\\\\\\\a\\\\\\\"r\\\"; file*=utf-8''T%C3%A4st\"\n    >>> ct, d = _parse_header(d)\n    >>> ct\n    'form-data'\n    >>> d['file'] == r'T\\u00e4st'.encode('ascii').decode('unicode_escape')\n    True\n    >>> d['foo']\n    'b\\\\a\"r'\n    \"\"\"\n    parts = _parseparam(\";\" + line)\n    key = next(parts)\n    # decode_params treats first argument special, but we already stripped key\n    params = [(\"Dummy\", \"value\")]\n    for p in parts:\n        i = p.find(\"=\")\n        if i >= 0:\n            name = p[:i].strip().lower()\n            value = p[i + 1 :].strip()\n            params.append((name, native_str(value)))\n    decoded_params = email.utils.decode_params(params)\n    decoded_params.pop(0)  # get rid of the dummy again\n    pdict = {}\n    for name, decoded_value in decoded_params:\n        value = email.utils.collapse_rfc2231_value(decoded_value)\n        if len(value) >= 2 and value[0] == '\"' and value[-1] == '\"':\n            value = value[1:-1]\n        pdict[name] = value\n    return key, pdict",
        "begin_line": 954,
        "end_line": 986,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil._encode_header#989",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil._encode_header(key: str, pdict: Dict[str, str])",
        "snippet": "def _encode_header(key: str, pdict: Dict[str, str]) -> str:\n    \"\"\"Inverse of _parse_header.\n\n    >>> _encode_header('permessage-deflate',\n    ...     {'client_max_window_bits': 15, 'client_no_context_takeover': None})\n    'permessage-deflate; client_max_window_bits=15; client_no_context_takeover'\n    \"\"\"\n    if not pdict:\n        return key\n    out = [key]\n    # Sort the parameters just to make it easy to test.\n    for k, v in sorted(pdict.items()):\n        if v is None:\n            out.append(k)\n        else:\n            # TODO: quote if necessary.\n            out.append(\"%s=%s\" % (k, v))\n    return \"; \".join(out)",
        "begin_line": 989,
        "end_line": 1006,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil.encode_username_password#1009",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.encode_username_password(username: Union[str, bytes], password: Union[str, bytes])",
        "snippet": "def encode_username_password(\n    username: Union[str, bytes], password: Union[str, bytes]\n) -> bytes:\n    \"\"\"Encodes a username/password pair in the format used by HTTP auth.\n\n    The return value is a byte string in the form ``username:password``.\n\n    .. versionadded:: 5.1\n    \"\"\"\n    if isinstance(username, unicode_type):\n        username = unicodedata.normalize(\"NFC\", username)\n    if isinstance(password, unicode_type):\n        password = unicodedata.normalize(\"NFC\", password)\n    return utf8(username) + b\":\" + utf8(password)",
        "begin_line": 1009,
        "end_line": 1022,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018135654697134566,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil.split_host_and_port#1032",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.split_host_and_port(netloc: str)",
        "snippet": "def split_host_and_port(netloc: str) -> Tuple[str, Optional[int]]:\n    \"\"\"Returns ``(host, port)`` tuple from ``netloc``.\n\n    Returned ``port`` will be ``None`` if not present.\n\n    .. versionadded:: 4.1\n    \"\"\"\n    match = re.match(r\"^(.+):(\\d+)$\", netloc)\n    if match:\n        host = match.group(1)\n        port = int(match.group(2))  # type: Optional[int]\n    else:\n        host = netloc\n        port = None\n    return (host, port)",
        "begin_line": 1032,
        "end_line": 1046,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006958942240779402,
            "pseudo_dstar_susp": 0.0008237232289950577,
            "pseudo_tarantula_susp": 0.001589825119236884,
            "pseudo_op2_susp": 0.0008237232289950577,
            "pseudo_barinel_susp": 0.0015923566878980893
        }
    },
    {
        "name": "tornado.httputil.qs_to_qsl#1049",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.qs_to_qsl(qs: Dict[str, List[AnyStr]])",
        "snippet": "def qs_to_qsl(qs: Dict[str, List[AnyStr]]) -> Iterable[Tuple[str, AnyStr]]:\n    \"\"\"Generator converting a result of ``parse_qs`` back to name-value pairs.\n\n    .. versionadded:: 5.0\n    \"\"\"\n    for k, vs in qs.items():\n        for v in vs:\n            yield (k, v)",
        "begin_line": 1049,
        "end_line": 1056,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil._unquote_cookie#1064",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil._unquote_cookie(s: str)",
        "snippet": "def _unquote_cookie(s: str) -> str:\n    \"\"\"Handle double quotes and escaping in cookie values.\n\n    This method is copied verbatim from the Python 3.5 standard\n    library (http.cookies._unquote) so we don't have to depend on\n    non-public interfaces.\n    \"\"\"\n    # If there aren't any doublequotes,\n    # then there can't be any special characters.  See RFC 2109.\n    if s is None or len(s) < 2:\n        return s\n    if s[0] != '\"' or s[-1] != '\"':\n        return s\n\n    # We have to assume that we must decode this string.\n    # Down to work.\n\n    # Remove the \"s\n    s = s[1:-1]\n\n    # Check for special sequences.  Examples:\n    #    \\012 --> \\n\n    #    \\\"   --> \"\n    #\n    i = 0\n    n = len(s)\n    res = []\n    while 0 <= i < n:\n        o_match = _OctalPatt.search(s, i)\n        q_match = _QuotePatt.search(s, i)\n        if not o_match and not q_match:  # Neither matched\n            res.append(s[i:])\n            break\n        # else:\n        j = k = -1\n        if o_match:\n            j = o_match.start(0)\n        if q_match:\n            k = q_match.start(0)\n        if q_match and (not o_match or k < j):  # QuotePatt matched\n            res.append(s[i:k])\n            res.append(s[k + 1])\n            i = k + 2\n        else:  # OctalPatt matched\n            res.append(s[i:j])\n            res.append(chr(int(s[j + 1 : j + 4], 8)))\n            i = j + 4\n    return _nulljoin(res)",
        "begin_line": 1064,
        "end_line": 1111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.httputil.parse_cookie#1114",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.parse_cookie(cookie: str)",
        "snippet": "def parse_cookie(cookie: str) -> Dict[str, str]:\n    \"\"\"Parse a ``Cookie`` HTTP header into a dict of name/value pairs.\n\n    This function attempts to mimic browser cookie parsing behavior;\n    it specifically does not follow any of the cookie-related RFCs\n    (because browsers don't either).\n\n    The algorithm used is identical to that used by Django version 1.9.10.\n\n    .. versionadded:: 4.4.2\n    \"\"\"\n    cookiedict = {}\n    for chunk in cookie.split(str(\";\")):\n        if str(\"=\") in chunk:\n            key, val = chunk.split(str(\"=\"), 1)\n        else:\n            # Assume an empty name per\n            # https://bugzilla.mozilla.org/show_bug.cgi?id=169091\n            key, val = str(\"\"), chunk\n        key, val = key.strip(), val.strip()\n        if key or val:\n            # unquote using Python's algorithm.\n            cookiedict[key] = _unquote_cookie(val)\n    return cookiedict",
        "begin_line": 1114,
        "end_line": 1137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.gen._value_from_stopiteration#130",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen._value_from_stopiteration(e: Union[StopIteration, 'Return'])",
        "snippet": "def _value_from_stopiteration(e: Union[StopIteration, \"Return\"]) -> Any:\n    try:\n        # StopIteration has a value attribute beginning in py33.\n        # So does our Return class.\n        return e.value\n    except AttributeError:\n        pass\n    try:\n        # Cython backports coroutine functionality by putting the value in\n        # e.args[0].\n        return e.args[0]\n    except (AttributeError, IndexError):\n        return None",
        "begin_line": 130,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001160092807424594,
            "pseudo_dstar_susp": 0.001607717041800643,
            "pseudo_tarantula_susp": 0.0010362694300518134,
            "pseudo_op2_susp": 0.001607717041800643,
            "pseudo_barinel_susp": 0.0010362694300518134
        }
    },
    {
        "name": "tornado.gen._create_future#145",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen._create_future()",
        "snippet": "def _create_future() -> Future:\n    future = Future()  # type: Future\n    # Fixup asyncio debug info by removing extraneous stack entries\n    source_traceback = getattr(future, \"_source_traceback\", ())\n    while source_traceback:\n        # Each traceback entry is equivalent to a\n        # (filename, self.lineno, self.name, self.line) tuple\n        filename = source_traceback[-1][0]\n        if filename == __file__:\n            del source_traceback[-1]\n        else:\n            break\n    return future",
        "begin_line": 145,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0025,
            "pseudo_dstar_susp": 0.004807692307692308,
            "pseudo_tarantula_susp": 0.001177856301531213,
            "pseudo_op2_susp": 0.004807692307692308,
            "pseudo_barinel_susp": 0.001177856301531213
        }
    },
    {
        "name": "tornado.gen.coroutine#160",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.coroutine(func: Callable[..., 'Generator[Any, Any, _T]'])",
        "snippet": "def coroutine(\n    func: Callable[..., \"Generator[Any, Any, _T]\"]\n) -> Callable[..., \"Future[_T]\"]:\n    \"\"\"Decorator for asynchronous generators.\n\n    Any generator that yields objects from this module must be wrapped\n    in this decorator (or use ``async def`` and ``await`` for similar\n    functionality).\n\n    Coroutines may \"return\" by raising the special exception\n    `Return(value) <Return>`.  In Python 3.3+, it is also possible for\n    the function to simply use the ``return value`` statement (prior to\n    Python 3.3 generators were not allowed to also return values).\n    In all versions of Python a coroutine that simply wishes to exit\n    early may use the ``return`` statement without a value.\n\n    Functions with this decorator return a `.Future`.\n\n    .. warning::\n\n       When exceptions occur inside a coroutine, the exception\n       information will be stored in the `.Future` object. You must\n       examine the result of the `.Future` object, or the exception\n       may go unnoticed by your code. This means yielding the function\n       if called from another coroutine, using something like\n       `.IOLoop.run_sync` for top-level calls, or passing the `.Future`\n       to `.IOLoop.add_future`.\n\n    .. versionchanged:: 6.0\n\n       The ``callback`` argument was removed. Use the returned\n       awaitable object instead.\n\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # type: (*Any, **Any) -> Future[_T]\n        # This function is type-annotated with a comment to work around\n        # https://bitbucket.org/pypy/pypy/issues/2868/segfault-with-args-type-annotation-in\n        future = _create_future()\n        try:\n            result = func(*args, **kwargs)\n        except (Return, StopIteration) as e:\n            result = _value_from_stopiteration(e)\n        except Exception:\n            future_set_exc_info(future, sys.exc_info())\n            try:\n                return future\n            finally:\n                # Avoid circular references\n                future = None  # type: ignore\n        else:\n            if isinstance(result, Generator):\n                # Inline the first iteration of Runner.run.  This lets us\n                # avoid the cost of creating a Runner when the coroutine\n                # never actually yields, which in turn allows us to\n                # use \"optional\" coroutines in critical path code without\n                # performance penalty for the synchronous case.\n                try:\n                    yielded = next(result)\n                except (StopIteration, Return) as e:\n                    future_set_result_unless_cancelled(\n                        future, _value_from_stopiteration(e)\n                    )\n                except Exception:\n                    future_set_exc_info(future, sys.exc_info())\n                else:\n                    # Provide strong references to Runner objects as long\n                    # as their result future objects also have strong\n                    # references (typically from the parent coroutine's\n                    # Runner). This keeps the coroutine's Runner alive.\n                    # We do this by exploiting the public API\n                    # add_done_callback() instead of putting a private\n                    # attribute on the Future.\n                    # (Github issues #1769, #2229).\n                    runner = Runner(result, future, yielded)\n                    future.add_done_callback(lambda _: runner)\n                yielded = None\n                try:\n                    return future\n                finally:\n                    # Subtle memory optimization: if next() raised an exception,\n                    # the future's exc_info contains a traceback which\n                    # includes this stack frame.  This creates a cycle,\n                    # which will be collected at the next full GC but has\n                    # been shown to greatly increase memory usage of\n                    # benchmarks (relative to the refcount-based scheme\n                    # used in the absence of cycles).  We can avoid the\n                    # cycle by clearing the local variable after we return it.\n                    future = None  # type: ignore\n        future_set_result_unless_cancelled(future, result)\n        return future\n\n    wrapper.__wrapped__ = func  # type: ignore\n    wrapper.__tornado_coroutine__ = True  # type: ignore\n    return wrapper",
        "begin_line": 160,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013568521031207597,
            "pseudo_dstar_susp": 0.002008032128514056,
            "pseudo_tarantula_susp": 0.0011235955056179776,
            "pseudo_op2_susp": 0.002008032128514056,
            "pseudo_barinel_susp": 0.0011235955056179776
        }
    },
    {
        "name": "tornado.gen.wrapper#196",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.wrapper(*args, **kwargs)",
        "snippet": "    def wrapper(*args, **kwargs):\n        # type: (*Any, **Any) -> Future[_T]\n        # This function is type-annotated with a comment to work around\n        # https://bitbucket.org/pypy/pypy/issues/2868/segfault-with-args-type-annotation-in\n        future = _create_future()\n        try:\n            result = func(*args, **kwargs)\n        except (Return, StopIteration) as e:\n            result = _value_from_stopiteration(e)\n        except Exception:\n            future_set_exc_info(future, sys.exc_info())\n            try:\n                return future\n            finally:\n                # Avoid circular references\n                future = None  # type: ignore\n        else:\n            if isinstance(result, Generator):\n                # Inline the first iteration of Runner.run.  This lets us\n                # avoid the cost of creating a Runner when the coroutine\n                # never actually yields, which in turn allows us to\n                # use \"optional\" coroutines in critical path code without\n                # performance penalty for the synchronous case.\n                try:\n                    yielded = next(result)\n                except (StopIteration, Return) as e:\n                    future_set_result_unless_cancelled(\n                        future, _value_from_stopiteration(e)\n                    )\n                except Exception:\n                    future_set_exc_info(future, sys.exc_info())\n                else:\n                    # Provide strong references to Runner objects as long\n                    # as their result future objects also have strong\n                    # references (typically from the parent coroutine's\n                    # Runner). This keeps the coroutine's Runner alive.\n                    # We do this by exploiting the public API\n                    # add_done_callback() instead of putting a private\n                    # attribute on the Future.\n                    # (Github issues #1769, #2229).\n                    runner = Runner(result, future, yielded)\n                    future.add_done_callback(lambda _: runner)\n                yielded = None\n                try:\n                    return future\n                finally:\n                    # Subtle memory optimization: if next() raised an exception,\n                    # the future's exc_info contains a traceback which\n                    # includes this stack frame.  This creates a cycle,\n                    # which will be collected at the next full GC but has\n                    # been shown to greatly increase memory usage of\n                    # benchmarks (relative to the refcount-based scheme\n                    # used in the absence of cycles).  We can avoid the\n                    # cycle by clearing the local variable after we return it.\n                    future = None  # type: ignore\n        future_set_result_unless_cancelled(future, result)\n        return future",
        "begin_line": 196,
        "end_line": 252,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.011904761904761904,
            "pseudo_dstar_susp": 0.08333333333333333,
            "pseudo_tarantula_susp": 0.003367003367003367,
            "pseudo_op2_susp": 0.08333333333333333,
            "pseudo_barinel_susp": 0.003367003367003367
        }
    },
    {
        "name": "tornado.gen.is_coroutine_function#259",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.is_coroutine_function(func: Any)",
        "snippet": "def is_coroutine_function(func: Any) -> bool:\n    \"\"\"Return whether *func* is a coroutine function, i.e. a function\n    wrapped with `~.gen.coroutine`.\n\n    .. versionadded:: 4.5\n    \"\"\"\n    return getattr(func, \"__tornado_coroutine__\", False)",
        "begin_line": 259,
        "end_line": 265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.gen.Return.__init__#289",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Return",
        "signature": "tornado.gen.Return.__init__(self, value: Any=None)",
        "snippet": "    def __init__(self, value: Any = None) -> None:\n        super(Return, self).__init__()\n        self.value = value\n        # Cython recognizes subclasses of StopIteration with a .args tuple.\n        self.args = (value,)",
        "begin_line": 289,
        "end_line": 293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002617801047120419,
            "pseudo_dstar_susp": 0.001524390243902439,
            "pseudo_tarantula_susp": 0.0028735632183908046,
            "pseudo_op2_susp": 0.001524390243902439,
            "pseudo_barinel_susp": 0.0028735632183908046
        }
    },
    {
        "name": "tornado.gen.WaitIterator.__init__#352",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitIterator",
        "signature": "tornado.gen.WaitIterator.__init__(self, *args: Future, **kwargs: Future)",
        "snippet": "    def __init__(self, *args: Future, **kwargs: Future) -> None:\n        if args and kwargs:\n            raise ValueError(\"You must provide args or kwargs, not both\")\n\n        if kwargs:\n            self._unfinished = dict((f, k) for (k, f) in kwargs.items())\n            futures = list(kwargs.values())  # type: Sequence[Future]\n        else:\n            self._unfinished = dict((f, i) for (i, f) in enumerate(args))\n            futures = args\n\n        self._finished = collections.deque()  # type: Deque[Future]\n        self.current_index = None  # type: Optional[Union[str, int]]\n        self.current_future = None  # type: Optional[Future]\n        self._running_future = None  # type: Optional[Future]\n\n        for future in futures:\n            future_add_done_callback(future, self._done_callback)",
        "begin_line": 352,
        "end_line": 369,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.gen.WaitIterator.done#371",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitIterator",
        "signature": "tornado.gen.WaitIterator.done(self)",
        "snippet": "    def done(self) -> bool:\n        \"\"\"Returns True if this iterator has no more results.\"\"\"\n        if self._finished or self._unfinished:\n            return False\n        # Clear the 'current' values when iteration is done.\n        self.current_index = self.current_future = None\n        return True",
        "begin_line": 371,
        "end_line": 377,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.gen.WaitIterator.next#379",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitIterator",
        "signature": "tornado.gen.WaitIterator.next(self)",
        "snippet": "    def next(self) -> Future:\n        \"\"\"Returns a `.Future` that will yield the next available result.\n\n        Note that this `.Future` will not be the same object as any of\n        the inputs.\n        \"\"\"\n        self._running_future = Future()\n\n        if self._finished:\n            self._return_result(self._finished.popleft())\n\n        return self._running_future",
        "begin_line": 379,
        "end_line": 390,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.gen.WaitIterator._done_callback#392",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitIterator",
        "signature": "tornado.gen.WaitIterator._done_callback(self, done: Future)",
        "snippet": "    def _done_callback(self, done: Future) -> None:\n        if self._running_future and not self._running_future.done():\n            self._return_result(done)\n        else:\n            self._finished.append(done)",
        "begin_line": 392,
        "end_line": 396,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.gen.WaitIterator._return_result#398",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitIterator",
        "signature": "tornado.gen.WaitIterator._return_result(self, done: Future)",
        "snippet": "    def _return_result(self, done: Future) -> None:\n        \"\"\"Called set the returned future's state that of the future\n        we yielded, and set the current future for the iterator.\n        \"\"\"\n        if self._running_future is None:\n            raise Exception(\"no future is running\")\n        chain_future(done, self._running_future)\n\n        self.current_future = done\n        self.current_index = self._unfinished.pop(done)",
        "begin_line": 398,
        "end_line": 407,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019334880123743234,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.gen.WaitIterator.__aiter__#409",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitIterator",
        "signature": "tornado.gen.WaitIterator.__aiter__(self)",
        "snippet": "    def __aiter__(self) -> typing.AsyncIterator:\n        return self",
        "begin_line": 409,
        "end_line": 410,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.gen.WaitIterator.__anext__#412",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitIterator",
        "signature": "tornado.gen.WaitIterator.__anext__(self)",
        "snippet": "    def __anext__(self) -> Future:\n        if self.done():\n            # Lookup by name to silence pyflakes on older versions.\n            raise getattr(builtins, \"StopAsyncIteration\")()\n        return self.next()",
        "begin_line": 412,
        "end_line": 416,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.gen.multi#419",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.multi(children: Union[List[_Yieldable], Dict[Any, _Yieldable]], quiet_exceptions: Union[Type[Exception], Tuple[Type[Exception], ...]]=())",
        "snippet": "def multi(\n    children: Union[List[_Yieldable], Dict[Any, _Yieldable]],\n    quiet_exceptions: Union[Type[Exception], Tuple[Type[Exception], ...]] = (),\n) -> Union[\"Future[List]\", \"Future[Dict]\"]:\n    \"\"\"Runs multiple asynchronous operations in parallel.\n\n    ``children`` may either be a list or a dict whose values are\n    yieldable objects. ``multi()`` returns a new yieldable\n    object that resolves to a parallel structure containing their\n    results. If ``children`` is a list, the result is a list of\n    results in the same order; if it is a dict, the result is a dict\n    with the same keys.\n\n    That is, ``results = yield multi(list_of_futures)`` is equivalent\n    to::\n\n        results = []\n        for future in list_of_futures:\n            results.append(yield future)\n\n    If any children raise exceptions, ``multi()`` will raise the first\n    one. All others will be logged, unless they are of types\n    contained in the ``quiet_exceptions`` argument.\n\n    In a ``yield``-based coroutine, it is not normally necessary to\n    call this function directly, since the coroutine runner will\n    do it automatically when a list or dict is yielded. However,\n    it is necessary in ``await``-based coroutines, or to pass\n    the ``quiet_exceptions`` argument.\n\n    This function is available under the names ``multi()`` and ``Multi()``\n    for historical reasons.\n\n    Cancelling a `.Future` returned by ``multi()`` does not cancel its\n    children. `asyncio.gather` is similar to ``multi()``, but it does\n    cancel its children.\n\n    .. versionchanged:: 4.2\n       If multiple yieldables fail, any exceptions after the first\n       (which is raised) will be logged. Added the ``quiet_exceptions``\n       argument to suppress this logging for selected exception types.\n\n    .. versionchanged:: 4.3\n       Replaced the class ``Multi`` and the function ``multi_future``\n       with a unified function ``multi``. Added support for yieldables\n       other than ``YieldPoint`` and `.Future`.\n\n    \"\"\"\n    return multi_future(children, quiet_exceptions=quiet_exceptions)",
        "begin_line": 419,
        "end_line": 467,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007692307692307693,
            "pseudo_dstar_susp": 0.001564945226917058,
            "pseudo_tarantula_susp": 0.004201680672268907,
            "pseudo_op2_susp": 0.001564945226917058,
            "pseudo_barinel_susp": 0.004201680672268907
        }
    },
    {
        "name": "tornado.gen.multi_future#473",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.multi_future(children: Union[List[_Yieldable], Dict[Any, _Yieldable]], quiet_exceptions: Union[Type[Exception], Tuple[Type[Exception], ...]]=())",
        "snippet": "def multi_future(\n    children: Union[List[_Yieldable], Dict[Any, _Yieldable]],\n    quiet_exceptions: Union[Type[Exception], Tuple[Type[Exception], ...]] = (),\n) -> Union[\"Future[List]\", \"Future[Dict]\"]:\n    \"\"\"Wait for multiple asynchronous futures in parallel.\n\n    Since Tornado 6.0, this function is exactly the same as `multi`.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.2\n       If multiple ``Futures`` fail, any exceptions after the first (which is\n       raised) will be logged. Added the ``quiet_exceptions``\n       argument to suppress this logging for selected exception types.\n\n    .. deprecated:: 4.3\n       Use `multi` instead.\n    \"\"\"\n    if isinstance(children, dict):\n        keys = list(children.keys())  # type: Optional[List]\n        children_seq = children.values()  # type: Iterable\n    else:\n        keys = None\n        children_seq = children\n    children_futs = list(map(convert_yielded, children_seq))\n    assert all(is_future(i) or isinstance(i, _NullFuture) for i in children_futs)\n    unfinished_children = set(children_futs)\n\n    future = _create_future()\n    if not children_futs:\n        future_set_result_unless_cancelled(future, {} if keys is not None else [])\n\n    def callback(fut: Future) -> None:\n        unfinished_children.remove(fut)\n        if not unfinished_children:\n            result_list = []\n            for f in children_futs:\n                try:\n                    result_list.append(f.result())\n                except Exception as e:\n                    if future.done():\n                        if not isinstance(e, quiet_exceptions):\n                            app_log.error(\n                                \"Multiple exceptions in yield list\", exc_info=True\n                            )\n                    else:\n                        future_set_exc_info(future, sys.exc_info())\n            if not future.done():\n                if keys is not None:\n                    future_set_result_unless_cancelled(\n                        future, dict(zip(keys, result_list))\n                    )\n                else:\n                    future_set_result_unless_cancelled(future, result_list)\n\n    listening = set()  # type: Set[Future]\n    for f in children_futs:\n        if f not in listening:\n            listening.add(f)\n            future_add_done_callback(f, callback)\n    return future",
        "begin_line": 473,
        "end_line": 533,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.014492753623188406,
            "pseudo_dstar_susp": 0.002849002849002849,
            "pseudo_tarantula_susp": 0.004347826086956522,
            "pseudo_op2_susp": 0.002849002849002849,
            "pseudo_barinel_susp": 0.004347826086956522
        }
    },
    {
        "name": "tornado.gen.callback#505",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.callback(fut: Future)",
        "snippet": "    def callback(fut: Future) -> None:\n        unfinished_children.remove(fut)\n        if not unfinished_children:\n            result_list = []\n            for f in children_futs:\n                try:\n                    result_list.append(f.result())\n                except Exception as e:\n                    if future.done():\n                        if not isinstance(e, quiet_exceptions):\n                            app_log.error(\n                                \"Multiple exceptions in yield list\", exc_info=True\n                            )\n                    else:\n                        future_set_exc_info(future, sys.exc_info())\n            if not future.done():\n                if keys is not None:\n                    future_set_result_unless_cancelled(\n                        future, dict(zip(keys, result_list))\n                    )\n                else:\n                    future_set_result_unless_cancelled(future, result_list)",
        "begin_line": 505,
        "end_line": 526,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.014705882352941176,
            "pseudo_dstar_susp": 0.002857142857142857,
            "pseudo_tarantula_susp": 0.004424778761061947,
            "pseudo_op2_susp": 0.002857142857142857,
            "pseudo_barinel_susp": 0.004424778761061947
        }
    },
    {
        "name": "tornado.gen.with_timeout#557",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.with_timeout(timeout: Union[float, datetime.timedelta], future: _Yieldable, quiet_exceptions: Union[Type[Exception], Tuple[Type[Exception], ...]]=())",
        "snippet": "def with_timeout(\n    timeout: Union[float, datetime.timedelta],\n    future: _Yieldable,\n    quiet_exceptions: Union[Type[Exception], Tuple[Type[Exception], ...]] = (),\n) -> Future:\n    \"\"\"Wraps a `.Future` (or other yieldable object) in a timeout.\n\n    Raises `tornado.util.TimeoutError` if the input future does not\n    complete before ``timeout``, which may be specified in any form\n    allowed by `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or\n    an absolute time relative to `.IOLoop.time`)\n\n    If the wrapped `.Future` fails after it has timed out, the exception\n    will be logged unless it is of a type contained in ``quiet_exceptions``\n    (which may be an exception type or a sequence of types).\n\n    The wrapped `.Future` is not canceled when the timeout expires,\n    permitting it to be reused. `asyncio.wait_for` is similar to this\n    function but it does cancel the wrapped `.Future` on timeout.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.1\n       Added the ``quiet_exceptions`` argument and the logging of unhandled\n       exceptions.\n\n    .. versionchanged:: 4.4\n       Added support for yieldable objects other than `.Future`.\n\n    \"\"\"\n    # It's tempting to optimize this by cancelling the input future on timeout\n    # instead of creating a new one, but A) we can't know if we are the only\n    # one waiting on the input future, so cancelling it might disrupt other\n    # callers and B) concurrent futures can only be cancelled while they are\n    # in the queue, so cancellation cannot reliably bound our waiting time.\n    future_converted = convert_yielded(future)\n    result = _create_future()\n    chain_future(future_converted, result)\n    io_loop = IOLoop.current()\n\n    def error_callback(future: Future) -> None:\n        try:\n            future.result()\n        except Exception as e:\n            if not isinstance(e, quiet_exceptions):\n                app_log.error(\n                    \"Exception in Future %r after timeout\", future, exc_info=True\n                )\n\n    def timeout_callback() -> None:\n        if not result.done():\n            result.set_exception(TimeoutError(\"Timeout\"))\n        # In case the wrapped future goes on to fail, log it.\n        future_add_done_callback(future_converted, error_callback)\n\n    timeout_handle = io_loop.add_timeout(timeout, timeout_callback)\n    if isinstance(future_converted, Future):\n        # We know this future will resolve on the IOLoop, so we don't\n        # need the extra thread-safety of IOLoop.add_future (and we also\n        # don't care about StackContext here.\n        future_add_done_callback(\n            future_converted, lambda future: io_loop.remove_timeout(timeout_handle)\n        )\n    else:\n        # concurrent.futures.Futures may resolve on any thread, so we\n        # need to route them back to the IOLoop.\n        io_loop.add_future(\n            future_converted, lambda future: io_loop.remove_timeout(timeout_handle)\n        )\n    return result",
        "begin_line": 557,
        "end_line": 626,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012345679012345679,
            "pseudo_dstar_susp": 0.0022222222222222222,
            "pseudo_tarantula_susp": 0.0008431703204047217,
            "pseudo_op2_susp": 0.0022222222222222222,
            "pseudo_barinel_susp": 0.0008431703204047217
        }
    },
    {
        "name": "tornado.gen.error_callback#597",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.error_callback(future: Future)",
        "snippet": "    def error_callback(future: Future) -> None:\n        try:\n            future.result()\n        except Exception as e:\n            if not isinstance(e, quiet_exceptions):\n                app_log.error(\n                    \"Exception in Future %r after timeout\", future, exc_info=True\n                )",
        "begin_line": 597,
        "end_line": 604,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010822510822510823,
            "pseudo_dstar_susp": 0.0015105740181268882,
            "pseudo_tarantula_susp": 0.00684931506849315,
            "pseudo_op2_susp": 0.0015105740181268882,
            "pseudo_barinel_susp": 0.00684931506849315
        }
    },
    {
        "name": "tornado.gen.timeout_callback#606",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.timeout_callback()",
        "snippet": "    def timeout_callback() -> None:\n        if not result.done():\n            result.set_exception(TimeoutError(\"Timeout\"))\n        # In case the wrapped future goes on to fail, log it.\n        future_add_done_callback(future_converted, error_callback)",
        "begin_line": 606,
        "end_line": 610,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001081081081081081,
            "pseudo_dstar_susp": 0.0015082956259426848,
            "pseudo_tarantula_susp": 0.002403846153846154,
            "pseudo_op2_susp": 0.0015082956259426848,
            "pseudo_barinel_susp": 0.002403846153846154
        }
    },
    {
        "name": "tornado.gen.sleep#629",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.sleep(duration: float)",
        "snippet": "def sleep(duration: float) -> \"Future[None]\":\n    \"\"\"Return a `.Future` that resolves after the given number of seconds.\n\n    When used with ``yield`` in a coroutine, this is a non-blocking\n    analogue to `time.sleep` (which should not be used in coroutines\n    because it is blocking)::\n\n        yield gen.sleep(0.5)\n\n    Note that calling this function on its own does nothing; you must\n    wait on the `.Future` it returns (usually by yielding it).\n\n    .. versionadded:: 4.1\n    \"\"\"\n    f = _create_future()\n    IOLoop.current().call_later(\n        duration, lambda: future_set_result_unless_cancelled(f, None)\n    )\n    return f",
        "begin_line": 629,
        "end_line": 647,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014118311449950587,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.gen._NullFuture.result#663",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen._NullFuture",
        "signature": "tornado.gen._NullFuture.result(self)",
        "snippet": "    def result(self) -> None:\n        return None",
        "begin_line": 663,
        "end_line": 664,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001410039481105471,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.gen._NullFuture.done#666",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen._NullFuture",
        "signature": "tornado.gen._NullFuture.done(self)",
        "snippet": "    def done(self) -> bool:\n        return True",
        "begin_line": 666,
        "end_line": 667,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001410039481105471,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.gen.Runner.__init__#701",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.__init__(self, gen: 'Generator[_Yieldable, Any, _T]', result_future: 'Future[_T]', first_yielded: _Yieldable)",
        "snippet": "    def __init__(\n        self,\n        gen: \"Generator[_Yieldable, Any, _T]\",\n        result_future: \"Future[_T]\",\n        first_yielded: _Yieldable,\n    ) -> None:\n        self.gen = gen\n        self.result_future = result_future\n        self.future = _null_future  # type: Union[None, Future]\n        self.running = False\n        self.finished = False\n        self.io_loop = IOLoop.current()\n        if self.handle_yield(first_yielded):\n            gen = result_future = first_yielded = None  # type: ignore\n            self.run()",
        "begin_line": 701,
        "end_line": 715,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018552875695732839,
            "pseudo_dstar_susp": 0.002079002079002079,
            "pseudo_tarantula_susp": 0.0016863406408094434,
            "pseudo_op2_susp": 0.002079002079002079,
            "pseudo_barinel_susp": 0.0016863406408094434
        }
    },
    {
        "name": "tornado.gen.Runner.run#717",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.run(self)",
        "snippet": "    def run(self) -> None:\n        \"\"\"Starts or resumes the generator, running until it reaches a\n        yield point that is not ready.\n        \"\"\"\n        if self.running or self.finished:\n            return\n        try:\n            self.running = True\n            while True:\n                future = self.future\n                if future is None:\n                    raise Exception(\"No pending future\")\n                if not future.done():\n                    return\n                self.future = None\n                try:\n                    exc_info = None\n\n                    try:\n                        value = future.result()\n                    except Exception:\n                        exc_info = sys.exc_info()\n                    future = None\n\n                    if exc_info is not None:\n                        try:\n                            yielded = self.gen.throw(*exc_info)  # type: ignore\n                        finally:\n                            # Break up a reference to itself\n                            # for faster GC on CPython.\n                            exc_info = None\n                    else:\n                        yielded = self.gen.send(value)\n\n                except (StopIteration, Return) as e:\n                    self.finished = True\n                    self.future = _null_future\n                    future_set_result_unless_cancelled(\n                        self.result_future, _value_from_stopiteration(e)\n                    )\n                    self.result_future = None  # type: ignore\n                    return\n                except Exception:\n                    self.finished = True\n                    self.future = _null_future\n                    future_set_exc_info(self.result_future, sys.exc_info())\n                    self.result_future = None  # type: ignore\n                    return\n                if not self.handle_yield(yielded):\n                    return\n                yielded = None\n        finally:\n            self.running = False",
        "begin_line": 717,
        "end_line": 769,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.09090909090909091,
            "pseudo_dstar_susp": 0.0021929824561403508,
            "pseudo_tarantula_susp": 0.014925373134328358,
            "pseudo_op2_susp": 0.0021929824561403508,
            "pseudo_barinel_susp": 0.014925373134328358
        }
    },
    {
        "name": "tornado.gen.Runner.handle_yield#771",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.handle_yield(self, yielded: _Yieldable)",
        "snippet": "    def handle_yield(self, yielded: _Yieldable) -> bool:\n        try:\n            self.future = convert_yielded(yielded)\n        except BadYieldError:\n            self.future = Future()\n            future_set_exc_info(self.future, sys.exc_info())\n\n        if self.future is moment:\n            self.io_loop.add_callback(self.run)\n            return False\n        elif self.future is None:\n            raise Exception(\"no pending future\")\n        elif not self.future.done():\n\n            def inner(f: Any) -> None:\n                # Break a reference cycle to speed GC.\n                f = None  # noqa: F841\n                self.run()\n\n            self.io_loop.add_future(self.future, inner)\n            return False\n        return True",
        "begin_line": 771,
        "end_line": 792,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0025575447570332483,
            "pseudo_dstar_susp": 0.002188183807439825,
            "pseudo_tarantula_susp": 0.002178649237472767,
            "pseudo_op2_susp": 0.002188183807439825,
            "pseudo_barinel_susp": 0.002178649237472767
        }
    },
    {
        "name": "tornado.gen.Runner.inner#785",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.inner(f: Any)",
        "snippet": "            def inner(f: Any) -> None:\n                # Break a reference cycle to speed GC.\n                f = None  # noqa: F841\n                self.run()",
        "begin_line": 785,
        "end_line": 788,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.011764705882352941,
            "pseudo_dstar_susp": 0.07692307692307693,
            "pseudo_tarantula_susp": 0.0022271714922048997,
            "pseudo_op2_susp": 0.07692307692307693,
            "pseudo_barinel_susp": 0.0022271714922048997
        }
    },
    {
        "name": "tornado.gen.convert_yielded#815",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.convert_yielded(yielded: _Yieldable)",
        "snippet": "def convert_yielded(yielded: _Yieldable) -> Future:\n    \"\"\"Convert a yielded object into a `.Future`.\n\n    The default implementation accepts lists, dictionaries, and Futures.\n\n    If the `~functools.singledispatch` library is available, this function\n    may be extended to support additional types. For example::\n\n        @convert_yielded.register(asyncio.Future)\n        def _(asyncio_future):\n            return tornado.platform.asyncio.to_tornado_future(asyncio_future)\n\n    .. versionadded:: 4.1\n    \"\"\"\n    if yielded is None or yielded is moment:\n        return moment\n    elif yielded is _null_future:\n        return _null_future\n    elif isinstance(yielded, (list, dict)):\n        return multi(yielded)  # type: ignore\n    elif is_future(yielded):\n        return typing.cast(Future, yielded)\n    elif isawaitable(yielded):\n        return _wrap_awaitable(yielded)  # type: ignore\n    else:\n        raise BadYieldError(\"yielded unknown object %r\" % (yielded,))",
        "begin_line": 815,
        "end_line": 840,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008264462809917356,
            "pseudo_dstar_susp": 0.004901960784313725,
            "pseudo_tarantula_susp": 0.004405286343612335,
            "pseudo_op2_susp": 0.004901960784313725,
            "pseudo_barinel_susp": 0.004405286343612335
        }
    },
    {
        "name": "tornado.simple_httpclient.HTTPTimeoutError.__init__#53",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.HTTPTimeoutError",
        "signature": "tornado.simple_httpclient.HTTPTimeoutError.__init__(self, message: str)",
        "snippet": "    def __init__(self, message: str) -> None:\n        super(HTTPTimeoutError, self).__init__(599, message=message)",
        "begin_line": 53,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001892863903085368,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.simple_httpclient.HTTPTimeoutError.__str__#56",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.HTTPTimeoutError",
        "signature": "tornado.simple_httpclient.HTTPTimeoutError.__str__(self)",
        "snippet": "    def __str__(self) -> str:\n        return self.message or \"Timeout\"",
        "begin_line": 56,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.simple_httpclient.HTTPStreamClosedError.__init__#72",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.HTTPStreamClosedError",
        "signature": "tornado.simple_httpclient.HTTPStreamClosedError.__init__(self, message: str)",
        "snippet": "    def __init__(self, message: str) -> None:\n        super(HTTPStreamClosedError, self).__init__(599, message=message)",
        "begin_line": 72,
        "end_line": 73,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012755102040816326,
            "pseudo_dstar_susp": 0.0004948045522018803,
            "pseudo_tarantula_susp": 0.006666666666666667,
            "pseudo_op2_susp": 0.0004948045522018803,
            "pseudo_barinel_susp": 0.006666666666666667
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient.initialize#89",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient.initialize(self, max_clients: int=10, hostname_mapping: Dict[str, str]=None, max_buffer_size: int=104857600, resolver: Resolver=None, defaults: Dict[str, Any]=None, max_header_size: int=None, max_body_size: int=None)",
        "snippet": "    def initialize(  # type: ignore\n        self,\n        max_clients: int = 10,\n        hostname_mapping: Dict[str, str] = None,\n        max_buffer_size: int = 104857600,\n        resolver: Resolver = None,\n        defaults: Dict[str, Any] = None,\n        max_header_size: int = None,\n        max_body_size: int = None,\n    ) -> None:\n        \"\"\"Creates a AsyncHTTPClient.\n\n        Only a single AsyncHTTPClient instance exists per IOLoop\n        in order to provide limitations on the number of pending connections.\n        ``force_instance=True`` may be used to suppress this behavior.\n\n        Note that because of this implicit reuse, unless ``force_instance``\n        is used, only the first call to the constructor actually uses\n        its arguments. It is recommended to use the ``configure`` method\n        instead of the constructor to ensure that arguments take effect.\n\n        ``max_clients`` is the number of concurrent requests that can be\n        in progress; when this limit is reached additional requests will be\n        queued. Note that time spent waiting in this queue still counts\n        against the ``request_timeout``.\n\n        ``hostname_mapping`` is a dictionary mapping hostnames to IP addresses.\n        It can be used to make local DNS changes when modifying system-wide\n        settings like ``/etc/hosts`` is not possible or desirable (e.g. in\n        unittests).\n\n        ``max_buffer_size`` (default 100MB) is the number of bytes\n        that can be read into memory at once. ``max_body_size``\n        (defaults to ``max_buffer_size``) is the largest response body\n        that the client will accept.  Without a\n        ``streaming_callback``, the smaller of these two limits\n        applies; with a ``streaming_callback`` only ``max_body_size``\n        does.\n\n        .. versionchanged:: 4.2\n           Added the ``max_body_size`` argument.\n        \"\"\"\n        super(SimpleAsyncHTTPClient, self).initialize(defaults=defaults)\n        self.max_clients = max_clients\n        self.queue = (\n            collections.deque()\n        )  # type: Deque[Tuple[object, HTTPRequest, Callable[[HTTPResponse], None]]]\n        self.active = (\n            {}\n        )  # type: Dict[object, Tuple[HTTPRequest, Callable[[HTTPResponse], None]]]\n        self.waiting = (\n            {}\n        )  # type: Dict[object, Tuple[HTTPRequest, Callable[[HTTPResponse], None], object]]\n        self.max_buffer_size = max_buffer_size\n        self.max_header_size = max_header_size\n        self.max_body_size = max_body_size\n        # TCPClient could create a Resolver for us, but we have to do it\n        # ourselves to support hostname_mapping.\n        if resolver:\n            self.resolver = resolver\n            self.own_resolver = False\n        else:\n            self.resolver = Resolver()\n            self.own_resolver = True\n        if hostname_mapping is not None:\n            self.resolver = OverrideResolver(\n                resolver=self.resolver, mapping=hostname_mapping\n            )\n        self.tcp_client = TCPClient(resolver=self.resolver)",
        "begin_line": 89,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00078125,
            "pseudo_dstar_susp": 0.000999000999000999,
            "pseudo_tarantula_susp": 0.0007092198581560284,
            "pseudo_op2_susp": 0.000999000999000999,
            "pseudo_barinel_susp": 0.0007092198581560284
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient.close#159",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient.close(self)",
        "snippet": "    def close(self) -> None:\n        super(SimpleAsyncHTTPClient, self).close()\n        if self.own_resolver:\n            self.resolver.close()\n        self.tcp_client.close()",
        "begin_line": 159,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007993605115907274,
            "pseudo_dstar_susp": 0.0010193679918450561,
            "pseudo_tarantula_susp": 0.0007230657989877079,
            "pseudo_op2_susp": 0.0010193679918450561,
            "pseudo_barinel_susp": 0.0007230657989877079
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient.fetch_impl#165",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient.fetch_impl(self, request: HTTPRequest, callback: Callable[[HTTPResponse], None])",
        "snippet": "    def fetch_impl(\n        self, request: HTTPRequest, callback: Callable[[HTTPResponse], None]\n    ) -> None:\n        key = object()\n        self.queue.append((key, request, callback))\n        if not len(self.active) < self.max_clients:\n            assert request.connect_timeout is not None\n            assert request.request_timeout is not None\n            timeout_handle = self.io_loop.add_timeout(\n                self.io_loop.time()\n                + min(request.connect_timeout, request.request_timeout),\n                functools.partial(self._on_timeout, key, \"in request queue\"),\n            )\n        else:\n            timeout_handle = None\n        self.waiting[key] = (request, callback, timeout_handle)\n        self._process_queue()\n        if self.queue:\n            gen_log.debug(\n                \"max_clients limit reached, request queued. \"\n                \"%d active, %d queued requests.\" % (len(self.active), len(self.queue))\n            )",
        "begin_line": 165,
        "end_line": 186,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006165228113440197,
            "pseudo_dstar_susp": 0.000697350069735007,
            "pseudo_tarantula_susp": 0.0005841121495327102,
            "pseudo_op2_susp": 0.000697350069735007,
            "pseudo_barinel_susp": 0.0005841121495327102
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient._process_queue#188",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient._process_queue(self)",
        "snippet": "    def _process_queue(self) -> None:\n        while self.queue and len(self.active) < self.max_clients:\n            key, request, callback = self.queue.popleft()\n            if key not in self.waiting:\n                continue\n            self._remove_timeout(key)\n            self.active[key] = (request, callback)\n            release_callback = functools.partial(self._release_fetch, key)\n            self._handle_request(request, release_callback, callback)",
        "begin_line": 188,
        "end_line": 196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006165228113440197,
            "pseudo_dstar_susp": 0.000697350069735007,
            "pseudo_tarantula_susp": 0.0005841121495327102,
            "pseudo_op2_susp": 0.000697350069735007,
            "pseudo_barinel_susp": 0.0005841121495327102
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient._connection_class#198",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient._connection_class(self)",
        "snippet": "    def _connection_class(self) -> type:\n        return _HTTPConnection",
        "begin_line": 198,
        "end_line": 199,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006165228113440197,
            "pseudo_dstar_susp": 0.000697350069735007,
            "pseudo_tarantula_susp": 0.0005841121495327102,
            "pseudo_op2_susp": 0.000697350069735007,
            "pseudo_barinel_susp": 0.0005841121495327102
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient._handle_request#201",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient._handle_request(self, request: HTTPRequest, release_callback: Callable[[], None], final_callback: Callable[[HTTPResponse], None])",
        "snippet": "    def _handle_request(\n        self,\n        request: HTTPRequest,\n        release_callback: Callable[[], None],\n        final_callback: Callable[[HTTPResponse], None],\n    ) -> None:\n        self._connection_class()(\n            self,\n            request,\n            release_callback,\n            final_callback,\n            self.max_buffer_size,\n            self.tcp_client,\n            self.max_header_size,\n            self.max_body_size,\n        )",
        "begin_line": 201,
        "end_line": 216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006165228113440197,
            "pseudo_dstar_susp": 0.000697350069735007,
            "pseudo_tarantula_susp": 0.0005841121495327102,
            "pseudo_op2_susp": 0.000697350069735007,
            "pseudo_barinel_susp": 0.0005841121495327102
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient._release_fetch#218",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient._release_fetch(self, key: object)",
        "snippet": "    def _release_fetch(self, key: object) -> None:\n        del self.active[key]\n        self._process_queue()",
        "begin_line": 218,
        "end_line": 220,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006165228113440197,
            "pseudo_dstar_susp": 0.000697350069735007,
            "pseudo_tarantula_susp": 0.0005841121495327102,
            "pseudo_op2_susp": 0.000697350069735007,
            "pseudo_barinel_susp": 0.0005841121495327102
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient._remove_timeout#222",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient._remove_timeout(self, key: object)",
        "snippet": "    def _remove_timeout(self, key: object) -> None:\n        if key in self.waiting:\n            request, callback, timeout_handle = self.waiting[key]\n            if timeout_handle is not None:\n                self.io_loop.remove_timeout(timeout_handle)\n            del self.waiting[key]",
        "begin_line": 222,
        "end_line": 227,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006165228113440197,
            "pseudo_dstar_susp": 0.000697350069735007,
            "pseudo_tarantula_susp": 0.0005841121495327102,
            "pseudo_op2_susp": 0.000697350069735007,
            "pseudo_barinel_susp": 0.0005841121495327102
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient._on_timeout#229",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient._on_timeout(self, key: object, info: str=None)",
        "snippet": "    def _on_timeout(self, key: object, info: str = None) -> None:\n        \"\"\"Timeout callback of request.\n\n        Construct a timeout HTTPResponse when a timeout occurs.\n\n        :arg object key: A simple object to mark the request.\n        :info string key: More detailed timeout information.\n        \"\"\"\n        request, callback, timeout_handle = self.waiting[key]\n        self.queue.remove((key, request, callback))\n\n        error_message = \"Timeout {0}\".format(info) if info else \"Timeout\"\n        timeout_response = HTTPResponse(\n            request,\n            599,\n            error=HTTPTimeoutError(error_message),\n            request_time=self.io_loop.time() - request.start_time,\n        )\n        self.io_loop.add_callback(callback, timeout_response)\n        del self.waiting[key]",
        "begin_line": 229,
        "end_line": 248,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection.__init__#256",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection.__init__(self, client: Optional[SimpleAsyncHTTPClient], request: HTTPRequest, release_callback: Callable[[], None], final_callback: Callable[[HTTPResponse], None], max_buffer_size: int, tcp_client: TCPClient, max_header_size: int, max_body_size: int)",
        "snippet": "    def __init__(\n        self,\n        client: Optional[SimpleAsyncHTTPClient],\n        request: HTTPRequest,\n        release_callback: Callable[[], None],\n        final_callback: Callable[[HTTPResponse], None],\n        max_buffer_size: int,\n        tcp_client: TCPClient,\n        max_header_size: int,\n        max_body_size: int,\n    ) -> None:\n        self.io_loop = IOLoop.current()\n        self.start_time = self.io_loop.time()\n        self.start_wall_time = time.time()\n        self.client = client\n        self.request = request\n        self.release_callback = release_callback\n        self.final_callback = final_callback\n        self.max_buffer_size = max_buffer_size\n        self.tcp_client = tcp_client\n        self.max_header_size = max_header_size\n        self.max_body_size = max_body_size\n        self.code = None  # type: Optional[int]\n        self.headers = None  # type: Optional[httputil.HTTPHeaders]\n        self.chunks = []  # type: List[bytes]\n        self._decompressor = None\n        # Timeout handle returned by IOLoop.add_timeout\n        self._timeout = None  # type: object\n        self._sockaddr = None\n        IOLoop.current().add_future(\n            gen.convert_yielded(self.run()), lambda f: f.result()\n        )",
        "begin_line": 256,
        "end_line": 287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007423904974016332,
            "pseudo_dstar_susp": 0.001597444089456869,
            "pseudo_tarantula_susp": 0.00051440329218107,
            "pseudo_op2_susp": 0.001597444089456869,
            "pseudo_barinel_susp": 0.00051440329218107
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection.run#289",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection.run(self)",
        "snippet": "    async def run(self) -> None:\n        try:\n            self.parsed = urllib.parse.urlsplit(_unicode(self.request.url))\n            if self.parsed.scheme not in (\"http\", \"https\"):\n                raise ValueError(\"Unsupported url scheme: %s\" % self.request.url)\n            # urlsplit results have hostname and port results, but they\n            # didn't support ipv6 literals until python 2.7.\n            netloc = self.parsed.netloc\n            if \"@\" in netloc:\n                userpass, _, netloc = netloc.rpartition(\"@\")\n            host, port = httputil.split_host_and_port(netloc)\n            if port is None:\n                port = 443 if self.parsed.scheme == \"https\" else 80\n            if re.match(r\"^\\[.*\\]$\", host):\n                # raw ipv6 addresses in urls are enclosed in brackets\n                host = host[1:-1]\n            self.parsed_hostname = host  # save final host for _on_connect\n\n            if self.request.allow_ipv6 is False:\n                af = socket.AF_INET\n            else:\n                af = socket.AF_UNSPEC\n\n            ssl_options = self._get_ssl_options(self.parsed.scheme)\n\n            source_ip = None\n            if self.request.network_interface:\n                if is_valid_ip(self.request.network_interface):\n                    source_ip = self.request.network_interface\n                else:\n                    raise ValueError(\n                        \"Unrecognized IPv4 or IPv6 address for network_interface, got %r\"\n                        % (self.request.network_interface,)\n                    )\n\n            timeout = min(self.request.connect_timeout, self.request.request_timeout)\n            if timeout:\n                self._timeout = self.io_loop.add_timeout(\n                    self.start_time + timeout,\n                    functools.partial(self._on_timeout, \"while connecting\"),\n                )\n                stream = await self.tcp_client.connect(\n                    host,\n                    port,\n                    af=af,\n                    ssl_options=ssl_options,\n                    max_buffer_size=self.max_buffer_size,\n                    source_ip=source_ip,\n                )\n\n                if self.final_callback is None:\n                    # final_callback is cleared if we've hit our timeout.\n                    stream.close()\n                    return\n                self.stream = stream\n                self.stream.set_close_callback(self.on_connection_close)\n                self._remove_timeout()\n                if self.final_callback is None:\n                    return\n                if self.request.request_timeout:\n                    self._timeout = self.io_loop.add_timeout(\n                        self.start_time + self.request.request_timeout,\n                        functools.partial(self._on_timeout, \"during request\"),\n                    )\n                if (\n                    self.request.method not in self._SUPPORTED_METHODS\n                    and not self.request.allow_nonstandard_methods\n                ):\n                    raise KeyError(\"unknown method %s\" % self.request.method)\n                for key in (\n                    \"proxy_host\",\n                    \"proxy_port\",\n                    \"proxy_username\",\n                    \"proxy_password\",\n                    \"proxy_auth_mode\",\n                ):\n                    if getattr(self.request, key, None):\n                        raise NotImplementedError(\"%s not supported\" % key)\n                if \"Connection\" not in self.request.headers:\n                    self.request.headers[\"Connection\"] = \"close\"\n                if \"Host\" not in self.request.headers:\n                    if \"@\" in self.parsed.netloc:\n                        self.request.headers[\"Host\"] = self.parsed.netloc.rpartition(\n                            \"@\"\n                        )[-1]\n                    else:\n                        self.request.headers[\"Host\"] = self.parsed.netloc\n                username, password = None, None\n                if self.parsed.username is not None:\n                    username, password = self.parsed.username, self.parsed.password\n                elif self.request.auth_username is not None:\n                    username = self.request.auth_username\n                    password = self.request.auth_password or \"\"\n                if username is not None:\n                    assert password is not None\n                    if self.request.auth_mode not in (None, \"basic\"):\n                        raise ValueError(\n                            \"unsupported auth_mode %s\", self.request.auth_mode\n                        )\n                    self.request.headers[\"Authorization\"] = \"Basic \" + _unicode(\n                        base64.b64encode(\n                            httputil.encode_username_password(username, password)\n                        )\n                    )\n                if self.request.user_agent:\n                    self.request.headers[\"User-Agent\"] = self.request.user_agent\n                if not self.request.allow_nonstandard_methods:\n                    # Some HTTP methods nearly always have bodies while others\n                    # almost never do. Fail in this case unless the user has\n                    # opted out of sanity checks with allow_nonstandard_methods.\n                    body_expected = self.request.method in (\"POST\", \"PATCH\", \"PUT\")\n                    body_present = (\n                        self.request.body is not None\n                        or self.request.body_producer is not None\n                    )\n                    if (body_expected and not body_present) or (\n                        body_present and not body_expected\n                    ):\n                        raise ValueError(\n                            \"Body must %sbe None for method %s (unless \"\n                            \"allow_nonstandard_methods is true)\"\n                            % (\"not \" if body_expected else \"\", self.request.method)\n                        )\n                if self.request.expect_100_continue:\n                    self.request.headers[\"Expect\"] = \"100-continue\"\n                if self.request.body is not None:\n                    # When body_producer is used the caller is responsible for\n                    # setting Content-Length (or else chunked encoding will be used).\n                    self.request.headers[\"Content-Length\"] = str(len(self.request.body))\n                if (\n                    self.request.method == \"POST\"\n                    and \"Content-Type\" not in self.request.headers\n                ):\n                    self.request.headers[\n                        \"Content-Type\"\n                    ] = \"application/x-www-form-urlencoded\"\n                if self.request.decompress_response:\n                    self.request.headers[\"Accept-Encoding\"] = \"gzip\"\n                req_path = (self.parsed.path or \"/\") + (\n                    (\"?\" + self.parsed.query) if self.parsed.query else \"\"\n                )\n                self.connection = self._create_connection(stream)\n                start_line = httputil.RequestStartLine(\n                    self.request.method, req_path, \"\"\n                )\n                self.connection.write_headers(start_line, self.request.headers)\n                if self.request.expect_100_continue:\n                    await self.connection.read_response(self)\n                else:\n                    await self._write_body(True)\n        except Exception:\n            if not self._handle_exception(*sys.exc_info()):\n                raise",
        "begin_line": 289,
        "end_line": 441,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006369426751592356,
            "pseudo_dstar_susp": 0.0007097232079489,
            "pseudo_tarantula_susp": 0.0006657789613848203,
            "pseudo_op2_susp": 0.0007097232079489,
            "pseudo_barinel_susp": 0.0006657789613848203
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._get_ssl_options#443",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._get_ssl_options(self, scheme: str)",
        "snippet": "    def _get_ssl_options(\n        self, scheme: str\n    ) -> Union[None, Dict[str, Any], ssl.SSLContext]:\n        if scheme == \"https\":\n            if self.request.ssl_options is not None:\n                return self.request.ssl_options\n            # If we are using the defaults, don't construct a\n            # new SSLContext.\n            if (\n                self.request.validate_cert\n                and self.request.ca_certs is None\n                and self.request.client_cert is None\n                and self.request.client_key is None\n            ):\n                return _client_ssl_defaults\n            ssl_ctx = ssl.create_default_context(\n                ssl.Purpose.SERVER_AUTH, cafile=self.request.ca_certs\n            )\n            if not self.request.validate_cert:\n                ssl_ctx.check_hostname = False\n                ssl_ctx.verify_mode = ssl.CERT_NONE\n            if self.request.client_cert is not None:\n                ssl_ctx.load_cert_chain(\n                    self.request.client_cert, self.request.client_key\n                )\n            if hasattr(ssl, \"OP_NO_COMPRESSION\"):\n                # See netutil.ssl_options_to_context\n                ssl_ctx.options |= ssl.OP_NO_COMPRESSION\n            return ssl_ctx\n        return None",
        "begin_line": 443,
        "end_line": 472,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005574136008918618,
            "pseudo_dstar_susp": 0.000630119722747322,
            "pseudo_tarantula_susp": 0.0005970149253731343,
            "pseudo_op2_susp": 0.000630119722747322,
            "pseudo_barinel_susp": 0.0005988023952095808
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._on_timeout#474",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._on_timeout(self, info: str=None)",
        "snippet": "    def _on_timeout(self, info: str = None) -> None:\n        \"\"\"Timeout callback of _HTTPConnection instance.\n\n        Raise a `HTTPTimeoutError` when a timeout occurs.\n\n        :info string key: More detailed timeout information.\n        \"\"\"\n        self._timeout = None\n        error_message = \"Timeout {0}\".format(info) if info else \"Timeout\"\n        if self.final_callback is not None:\n            self._handle_exception(\n                HTTPTimeoutError, HTTPTimeoutError(error_message), None\n            )",
        "begin_line": 474,
        "end_line": 486,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._remove_timeout#488",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._remove_timeout(self)",
        "snippet": "    def _remove_timeout(self) -> None:\n        if self._timeout is not None:\n            self.io_loop.remove_timeout(self._timeout)\n            self._timeout = None",
        "begin_line": 488,
        "end_line": 491,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005675368898978433,
            "pseudo_dstar_susp": 0.0006418485237483953,
            "pseudo_tarantula_susp": 0.0005238344683080147,
            "pseudo_op2_susp": 0.0006418485237483953,
            "pseudo_barinel_susp": 0.0005238344683080147
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._create_connection#493",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._create_connection(self, stream: IOStream)",
        "snippet": "    def _create_connection(self, stream: IOStream) -> HTTP1Connection:\n        stream.set_nodelay(True)\n        connection = HTTP1Connection(\n            stream,\n            True,\n            HTTP1ConnectionParameters(\n                no_keep_alive=True,\n                max_header_size=self.max_header_size,\n                max_body_size=self.max_body_size,\n                decompress=bool(self.request.decompress_response),\n            ),\n            self._sockaddr,\n        )\n        return connection",
        "begin_line": 493,
        "end_line": 506,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005824111822947001,
            "pseudo_dstar_susp": 0.0006583278472679394,
            "pseudo_tarantula_susp": 0.0005370569280343716,
            "pseudo_op2_susp": 0.0006583278472679394,
            "pseudo_barinel_susp": 0.0005370569280343716
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._write_body#508",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._write_body(self, start_read: bool)",
        "snippet": "    async def _write_body(self, start_read: bool) -> None:\n        if self.request.body is not None:\n            self.connection.write(self.request.body)\n        elif self.request.body_producer is not None:\n            fut = self.request.body_producer(self.connection.write)\n            if fut is not None:\n                await fut\n        self.connection.finish()\n        if start_read:\n            try:\n                await self.connection.read_response(self)\n            except StreamClosedError:\n                if not self._handle_exception(*sys.exc_info()):\n                    raise",
        "begin_line": 508,
        "end_line": 521,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006501950585175553,
            "pseudo_dstar_susp": 0.0006734006734006734,
            "pseudo_tarantula_susp": 0.003401360544217687,
            "pseudo_op2_susp": 0.0006734006734006734,
            "pseudo_barinel_susp": 0.003401360544217687
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._release#523",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._release(self)",
        "snippet": "    def _release(self) -> None:\n        if self.release_callback is not None:\n            release_callback = self.release_callback\n            self.release_callback = None  # type: ignore\n            release_callback()",
        "begin_line": 523,
        "end_line": 527,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006053268765133172,
            "pseudo_dstar_susp": 0.0006839945280437756,
            "pseudo_tarantula_susp": 0.0005724098454493417,
            "pseudo_op2_susp": 0.0006839945280437756,
            "pseudo_barinel_susp": 0.0005724098454493417
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._run_callback#529",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._run_callback(self, response: HTTPResponse)",
        "snippet": "    def _run_callback(self, response: HTTPResponse) -> None:\n        self._release()\n        if self.final_callback is not None:\n            final_callback = self.final_callback\n            self.final_callback = None  # type: ignore\n            self.io_loop.add_callback(final_callback, response)",
        "begin_line": 529,
        "end_line": 534,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006053268765133172,
            "pseudo_dstar_susp": 0.0006839945280437756,
            "pseudo_tarantula_susp": 0.0005724098454493417,
            "pseudo_op2_susp": 0.0006839945280437756,
            "pseudo_barinel_susp": 0.0005724098454493417
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._handle_exception#536",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._handle_exception(self, typ: Optional[Type[BaseException]], value: Optional[BaseException], tb: Optional[TracebackType])",
        "snippet": "    def _handle_exception(\n        self,\n        typ: Optional[Type[BaseException]],\n        value: Optional[BaseException],\n        tb: Optional[TracebackType],\n    ) -> bool:\n        if self.final_callback:\n            self._remove_timeout()\n            if isinstance(value, StreamClosedError):\n                if value.real_error is None:\n                    value = HTTPStreamClosedError(\"Stream closed\")\n                else:\n                    value = value.real_error\n            self._run_callback(\n                HTTPResponse(\n                    self.request,\n                    599,\n                    error=value,\n                    request_time=self.io_loop.time() - self.start_time,\n                    start_time=self.start_wall_time,\n                )\n            )\n\n            if hasattr(self, \"stream\"):\n                # TODO: this may cause a StreamClosedError to be raised\n                # by the connection's Future.  Should we cancel the\n                # connection more gracefully?\n                self.stream.close()\n            return True\n        else:\n            # If our callback has already been called, we are probably\n            # catching an exception that is not caused by us but rather\n            # some child of our callback. Rather than drop it on the floor,\n            # pass it along, unless it's just the stream being closed.\n            return isinstance(value, StreamClosedError)",
        "begin_line": 536,
        "end_line": 570,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001277139208173691,
            "pseudo_dstar_susp": 0.0005277044854881266,
            "pseudo_tarantula_susp": 0.005952380952380952,
            "pseudo_op2_susp": 0.0005277044854881266,
            "pseudo_barinel_susp": 0.005952380952380952
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection.on_connection_close#572",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection.on_connection_close(self)",
        "snippet": "    def on_connection_close(self) -> None:\n        if self.final_callback is not None:\n            message = \"Connection closed\"\n            if self.stream.error:\n                raise self.stream.error\n            try:\n                raise HTTPStreamClosedError(message)\n            except HTTPStreamClosedError:\n                self._handle_exception(*sys.exc_info())",
        "begin_line": 572,
        "end_line": 580,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010752688172043012,
            "pseudo_dstar_susp": 0.00049800796812749,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.00049800796812749,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection.headers_received#582",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection.headers_received(self, first_line: Union[httputil.ResponseStartLine, httputil.RequestStartLine], headers: httputil.HTTPHeaders)",
        "snippet": "    async def headers_received(\n        self,\n        first_line: Union[httputil.ResponseStartLine, httputil.RequestStartLine],\n        headers: httputil.HTTPHeaders,\n    ) -> None:\n        assert isinstance(first_line, httputil.ResponseStartLine)\n        if self.request.expect_100_continue and first_line.code == 100:\n            await self._write_body(False)\n            return\n        self.code = first_line.code\n        self.reason = first_line.reason\n        self.headers = headers\n\n        if self._should_follow_redirect():\n            return\n\n        if self.request.header_callback is not None:\n            # Reassemble the start line.\n            self.request.header_callback(\"%s %s %s\\r\\n\" % first_line)\n            for k, v in self.headers.get_all():\n                self.request.header_callback(\"%s: %s\\r\\n\" % (k, v))\n            self.request.header_callback(\"\\r\\n\")",
        "begin_line": 582,
        "end_line": 603,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005157297576070139,
            "pseudo_dstar_susp": 0.0005621135469364812,
            "pseudo_tarantula_susp": 0.0005633802816901409,
            "pseudo_op2_susp": 0.0005621135469364812,
            "pseudo_barinel_susp": 0.0005633802816901409
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._should_follow_redirect#605",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._should_follow_redirect(self)",
        "snippet": "    def _should_follow_redirect(self) -> bool:\n        if self.request.follow_redirects:\n            assert self.request.max_redirects is not None\n            return (\n                self.code in (301, 302, 303, 307, 308)\n                and self.request.max_redirects > 0\n            )\n        return False",
        "begin_line": 605,
        "end_line": 612,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005470459518599562,
            "pseudo_dstar_susp": 0.000564652738565782,
            "pseudo_tarantula_susp": 0.0005747126436781609,
            "pseudo_op2_susp": 0.000564652738565782,
            "pseudo_barinel_susp": 0.0005747126436781609
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection.finish#614",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection.finish(self)",
        "snippet": "    def finish(self) -> None:\n        assert self.code is not None\n        data = b\"\".join(self.chunks)\n        self._remove_timeout()\n        original_request = getattr(self.request, \"original_request\", self.request)\n        if self._should_follow_redirect():\n            assert isinstance(self.request, _RequestProxy)\n            new_request = copy.copy(self.request.request)\n            new_request.url = urllib.parse.urljoin(\n                self.request.url, self.headers[\"Location\"]\n            )\n            new_request.max_redirects = self.request.max_redirects - 1\n            del new_request.headers[\"Host\"]\n            # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n            # Client SHOULD make a GET request after a 303.\n            # According to the spec, 302 should be followed by the same\n            # method as the original request, but in practice browsers\n            # treat 302 the same as 303, and many servers use 302 for\n            # compatibility with pre-HTTP/1.1 user agents which don't\n            # understand the 303 status.\n            if self.code in (302, 303):\n                new_request.method = \"GET\"\n                new_request.body = None\n                for h in [\n                    \"Content-Length\",\n                    \"Content-Type\",\n                    \"Content-Encoding\",\n                    \"Transfer-Encoding\",\n                ]:\n                    try:\n                        del self.request.headers[h]\n                    except KeyError:\n                        pass\n            new_request.original_request = original_request\n            final_callback = self.final_callback\n            self.final_callback = None\n            self._release()\n            fut = self.client.fetch(new_request, raise_error=False)\n            fut.add_done_callback(lambda f: final_callback(f.result()))\n            self._on_end_request()\n            return\n        if self.request.streaming_callback:\n            buffer = BytesIO()\n        else:\n            buffer = BytesIO(data)  # TODO: don't require one big string?\n        response = HTTPResponse(\n            original_request,\n            self.code,\n            reason=getattr(self, \"reason\", None),\n            headers=self.headers,\n            request_time=self.io_loop.time() - self.start_time,\n            start_time=self.start_wall_time,\n            buffer=buffer,\n            effective_url=self.request.url,\n        )\n        self._run_callback(response)\n        self._on_end_request()",
        "begin_line": 614,
        "end_line": 670,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004697040864255519,
            "pseudo_dstar_susp": 0.0005128205128205128,
            "pseudo_tarantula_susp": 0.00044822949350067237,
            "pseudo_op2_susp": 0.0005128205128205128,
            "pseudo_barinel_susp": 0.00044822949350067237
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._on_end_request#672",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._on_end_request(self)",
        "snippet": "    def _on_end_request(self) -> None:\n        self.stream.close()",
        "begin_line": 672,
        "end_line": 673,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004666355576294914,
            "pseudo_dstar_susp": 0.0005091649694501018,
            "pseudo_tarantula_susp": 0.0004426737494466578,
            "pseudo_op2_susp": 0.0005091649694501018,
            "pseudo_barinel_susp": 0.0004426737494466578
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection.data_received#675",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection.data_received(self, chunk: bytes)",
        "snippet": "    def data_received(self, chunk: bytes) -> None:\n        if self._should_follow_redirect():\n            # We're going to follow a redirect so just discard the body.\n            return\n        if self.request.streaming_callback is not None:\n            self.request.streaming_callback(chunk)\n        else:\n            self.chunks.append(chunk)",
        "begin_line": 675,
        "end_line": 682,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00047505938242280285,
            "pseudo_dstar_susp": 0.0005159958720330237,
            "pseudo_tarantula_susp": 0.00045310376076121433,
            "pseudo_op2_susp": 0.0005159958720330237,
            "pseudo_barinel_susp": 0.00045310376076121433
        }
    },
    {
        "name": "tornado.util.ObjectDict.__getattr__#80",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.ObjectDict",
        "signature": "tornado.util.ObjectDict.__getattr__(self, name: str)",
        "snippet": "    def __getattr__(self, name: str) -> Any:\n        try:\n            return self[name]\n        except KeyError:\n            raise AttributeError(name)",
        "begin_line": 80,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016700066800267202,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.GzipDecompressor.__init__#97",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.GzipDecompressor",
        "signature": "tornado.util.GzipDecompressor.__init__(self)",
        "snippet": "    def __init__(self) -> None:\n        # Magic parameter makes zlib module understand gzip header\n        # http://stackoverflow.com/questions/1838699/how-can-i-decompress-a-gzip-stream-with-zlib\n        # This works on cpython and pypy, but not jython.\n        self.decompressobj = zlib.decompressobj(16 + zlib.MAX_WBITS)",
        "begin_line": 97,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017214666896195557,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.GzipDecompressor.decompress#103",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.GzipDecompressor",
        "signature": "tornado.util.GzipDecompressor.decompress(self, value: bytes, max_length: int=0)",
        "snippet": "    def decompress(self, value: bytes, max_length: int = 0) -> bytes:\n        \"\"\"Decompress a chunk, returning newly-available data.\n\n        Some data may be buffered for later processing; `flush` must\n        be called when there is no more input data to ensure that\n        all data was processed.\n\n        If ``max_length`` is given, some input data may be left over\n        in ``unconsumed_tail``; you must retrieve this value and pass\n        it back to a future call to `decompress` if it is not empty.\n        \"\"\"\n        return self.decompressobj.decompress(value, max_length)",
        "begin_line": 103,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017214666896195557,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.GzipDecompressor.unconsumed_tail#117",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.GzipDecompressor",
        "signature": "tornado.util.GzipDecompressor.unconsumed_tail(self)",
        "snippet": "    def unconsumed_tail(self) -> bytes:\n        \"\"\"Returns the unconsumed portion left over\n        \"\"\"\n        return self.decompressobj.unconsumed_tail",
        "begin_line": 117,
        "end_line": 120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017214666896195557,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.GzipDecompressor.flush#122",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.GzipDecompressor",
        "signature": "tornado.util.GzipDecompressor.flush(self)",
        "snippet": "    def flush(self) -> bytes:\n        \"\"\"Return any remaining buffered data not yet returned by decompress.\n\n        Also checks for errors such as truncated input.\n        No other methods may be called on this object after `flush`.\n        \"\"\"\n        return self.decompressobj.flush()",
        "begin_line": 122,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017214666896195557,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.import_object#131",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util",
        "signature": "tornado.util.import_object(name: str)",
        "snippet": "def import_object(name: str) -> Any:\n    \"\"\"Imports an object by name.\n\n    import_object('x') is equivalent to 'import x'.\n    import_object('x.y.z') is equivalent to 'from x.y import z'.\n\n    >>> import tornado.escape\n    >>> import_object('tornado.escape') is tornado.escape\n    True\n    >>> import_object('tornado.escape.utf8') is tornado.escape.utf8\n    True\n    >>> import_object('tornado') is tornado\n    True\n    >>> import_object('tornado.missing_module')\n    Traceback (most recent call last):\n        ...\n    ImportError: No module named missing_module\n    \"\"\"\n    if name.count(\".\") == 0:\n        return __import__(name)\n\n    parts = name.split(\".\")\n    obj = __import__(\".\".join(parts[:-1]), fromlist=[parts[-1]])\n    try:\n        return getattr(obj, parts[-1])\n    except AttributeError:\n        raise ImportError(\"No module named %s\" % parts[-1])",
        "begin_line": 131,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001892863903085368,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.exec_in#160",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util",
        "signature": "tornado.util.exec_in(code: Any, glob: Dict[str, Any], loc: Mapping[str, Any]=None)",
        "snippet": "def exec_in(code: Any, glob: Dict[str, Any], loc: Mapping[str, Any] = None) -> None:\n    if isinstance(code, str):\n        # exec(string) inherits the caller's future imports; compile\n        # the string first to prevent that.\n        code = compile(code, \"<string>\", \"exec\", dont_inherit=True)\n    exec(code, glob, loc)",
        "begin_line": 160,
        "end_line": 165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.raise_exc_info#168",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util",
        "signature": "tornado.util.raise_exc_info(exc_info)",
        "snippet": "def raise_exc_info(\n    exc_info,  # type: Tuple[Optional[type], Optional[BaseException], Optional[TracebackType]]\n):\n    # type: (...) -> typing.NoReturn\n    #\n    # This function's type annotation must use comments instead of\n    # real annotations because typing.NoReturn does not exist in\n    # python 3.5's typing module. The formatting is funky because this\n    # is apparently what flake8 wants.\n    try:\n        if exc_info[1] is not None:\n            raise exc_info[1].with_traceback(exc_info[2])\n        else:\n            raise TypeError(\"raise_exc_info called with no exception\")\n    finally:\n        # Clear the traceback reference from our stack frame to\n        # minimize circular references that slow down GC.\n        exc_info = (None, None, None)",
        "begin_line": 168,
        "end_line": 185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.errno_from_exception#188",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util",
        "signature": "tornado.util.errno_from_exception(e: BaseException)",
        "snippet": "def errno_from_exception(e: BaseException) -> Optional[int]:\n    \"\"\"Provides the errno from an Exception object.\n\n    There are cases that the errno attribute was not set so we pull\n    the errno out of the args but if someone instantiates an Exception\n    without any args you will get a tuple error. So this function\n    abstracts all that behavior to give you a safe way to get the\n    errno.\n    \"\"\"\n\n    if hasattr(e, \"errno\"):\n        return e.errno  # type: ignore\n    elif e.args:\n        return e.args[0]\n    else:\n        return None",
        "begin_line": 188,
        "end_line": 203,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002061855670103093,
            "pseudo_dstar_susp": 0.002512562814070352,
            "pseudo_tarantula_susp": 0.0013123359580052493,
            "pseudo_op2_susp": 0.002512562814070352,
            "pseudo_barinel_susp": 0.0013123359580052493
        }
    },
    {
        "name": "tornado.util._re_unescape_replacement#209",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util",
        "signature": "tornado.util._re_unescape_replacement(match: Match[str])",
        "snippet": "def _re_unescape_replacement(match: Match[str]) -> str:\n    group = match.group(1)\n    if group[0] in _alphanum:\n        raise ValueError(\"cannot unescape '\\\\\\\\%s'\" % group[0])\n    return group",
        "begin_line": 209,
        "end_line": 213,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.re_unescape#219",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util",
        "signature": "tornado.util.re_unescape(s: str)",
        "snippet": "def re_unescape(s: str) -> str:\n    r\"\"\"Unescape a string escaped by `re.escape`.\n\n    May raise ``ValueError`` for regular expressions which could not\n    have been produced by `re.escape` (for example, strings containing\n    ``\\d`` cannot be unescaped).\n\n    .. versionadded:: 4.4\n    \"\"\"\n    return _re_unescape_pattern.sub(_re_unescape_replacement, s)",
        "begin_line": 219,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008525149190110827,
            "pseudo_dstar_susp": 0.0011061946902654867,
            "pseudo_tarantula_susp": 0.0007739938080495357,
            "pseudo_op2_susp": 0.0011061946902654867,
            "pseudo_barinel_susp": 0.0007739938080495357
        }
    },
    {
        "name": "tornado.util.Configurable.__new__#269",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.Configurable",
        "signature": "tornado.util.Configurable.__new__(cls, *args: Any, **kwargs: Any)",
        "snippet": "    def __new__(cls, *args: Any, **kwargs: Any) -> Any:\n        base = cls.configurable_base()\n        init_kwargs = {}  # type: Dict[str, Any]\n        if cls is base:\n            impl = cls.configured_class()\n            if base.__impl_kwargs:\n                init_kwargs.update(base.__impl_kwargs)\n        else:\n            impl = cls\n        init_kwargs.update(kwargs)\n        if impl.configurable_base() is not base:\n            # The impl class is itself configurable, so recurse.\n            return impl(*args, **init_kwargs)\n        instance = super(Configurable, cls).__new__(impl)\n        # initialize vs __init__ chosen for compatibility with AsyncHTTPClient\n        # singleton magic.  If we get rid of that we can switch to __init__\n        # here too.\n        instance.initialize(*args, **init_kwargs)\n        return instance",
        "begin_line": 269,
        "end_line": 287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015015015015015015,
            "pseudo_dstar_susp": 0.0031847133757961785,
            "pseudo_tarantula_susp": 0.001336898395721925,
            "pseudo_op2_susp": 0.0031847133757961785,
            "pseudo_barinel_susp": 0.001336898395721925
        }
    },
    {
        "name": "tornado.util.Configurable._initialize#305",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.Configurable",
        "signature": "tornado.util.Configurable._initialize(self)",
        "snippet": "    def _initialize(self) -> None:\n        pass",
        "begin_line": 305,
        "end_line": 306,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007627765064836003,
            "pseudo_dstar_susp": 0.0009727626459143969,
            "pseudo_tarantula_susp": 0.0006954102920723226,
            "pseudo_op2_susp": 0.0009727626459143969,
            "pseudo_barinel_susp": 0.0006954102920723226
        }
    },
    {
        "name": "tornado.util.Configurable.configure#318",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.Configurable",
        "signature": "tornado.util.Configurable.configure(cls, impl, **kwargs)",
        "snippet": "    def configure(cls, impl, **kwargs):\n        # type: (Union[None, str, Type[Configurable]], Any) -> None\n        \"\"\"Sets the class to use when the base class is instantiated.\n\n        Keyword arguments will be saved and added to the arguments passed\n        to the constructor.  This can be used to set global defaults for\n        some parameters.\n        \"\"\"\n        base = cls.configurable_base()\n        if isinstance(impl, str):\n            impl = typing.cast(Type[Configurable], import_object(impl))\n        if impl is not None and not issubclass(impl, cls):\n            raise ValueError(\"Invalid subclass of %s\" % cls)\n        base.__impl_class = impl\n        base.__impl_kwargs = kwargs",
        "begin_line": 318,
        "end_line": 332,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.Configurable.configured_class#335",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.Configurable",
        "signature": "tornado.util.Configurable.configured_class(cls)",
        "snippet": "    def configured_class(cls):\n        # type: () -> Type[Configurable]\n        \"\"\"Returns the currently configured class.\"\"\"\n        base = cls.configurable_base()\n        # Manually mangle the private name to see whether this base\n        # has been configured (and not another base higher in the\n        # hierarchy).\n        if base.__dict__.get(\"_Configurable__impl_class\") is None:\n            base.__impl_class = cls.configurable_default()\n        if base.__impl_class is not None:\n            return base.__impl_class\n        else:\n            # Should be impossible, but mypy wants an explicit check.\n            raise ValueError(\"configured class not found\")",
        "begin_line": 335,
        "end_line": 348,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015015015015015015,
            "pseudo_dstar_susp": 0.0031847133757961785,
            "pseudo_tarantula_susp": 0.000999000999000999,
            "pseudo_op2_susp": 0.0031847133757961785,
            "pseudo_barinel_susp": 0.000999000999000999
        }
    },
    {
        "name": "tornado.util.Configurable._save_configuration#351",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.Configurable",
        "signature": "tornado.util.Configurable._save_configuration(cls)",
        "snippet": "    def _save_configuration(cls):\n        # type: () -> Tuple[Optional[Type[Configurable]], Dict[str, Any]]\n        base = cls.configurable_base()\n        return (base.__impl_class, base.__impl_kwargs)",
        "begin_line": 351,
        "end_line": 354,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.Configurable._restore_configuration#357",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.Configurable",
        "signature": "tornado.util.Configurable._restore_configuration(cls, saved)",
        "snippet": "    def _restore_configuration(cls, saved):\n        # type: (Tuple[Optional[Type[Configurable]], Dict[str, Any]]) -> None\n        base = cls.configurable_base()\n        base.__impl_class = saved[0]\n        base.__impl_kwargs = saved[1]",
        "begin_line": 357,
        "end_line": 361,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.ArgReplacer.__init__#372",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.ArgReplacer",
        "signature": "tornado.util.ArgReplacer.__init__(self, func: Callable, name: str)",
        "snippet": "    def __init__(self, func: Callable, name: str) -> None:\n        self.name = name\n        try:\n            self.arg_pos = self._getargnames(func).index(name)  # type: Optional[int]\n        except ValueError:\n            # Not a positional parameter\n            self.arg_pos = None",
        "begin_line": 372,
        "end_line": 378,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.ArgReplacer._getargnames#380",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.ArgReplacer",
        "signature": "tornado.util.ArgReplacer._getargnames(self, func: Callable)",
        "snippet": "    def _getargnames(self, func: Callable) -> List[str]:\n        try:\n            return getfullargspec(func).args\n        except TypeError:\n            if hasattr(func, \"func_code\"):\n                # Cython-generated code has all the attributes needed\n                # by inspect.getfullargspec, but the inspect module only\n                # works with ordinary functions. Inline the portion of\n                # getfullargspec that we need here. Note that for static\n                # functions the @cython.binding(True) decorator must\n                # be used (for methods it works out of the box).\n                code = func.func_code  # type: ignore\n                return code.co_varnames[: code.co_argcount]\n            raise",
        "begin_line": 380,
        "end_line": 393,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.ArgReplacer.get_old_value#395",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.ArgReplacer",
        "signature": "tornado.util.ArgReplacer.get_old_value(self, args: Sequence[Any], kwargs: Dict[str, Any], default: Any=None)",
        "snippet": "    def get_old_value(\n        self, args: Sequence[Any], kwargs: Dict[str, Any], default: Any = None\n    ) -> Any:\n        \"\"\"Returns the old value of the named argument without replacing it.\n\n        Returns ``default`` if the argument is not present.\n        \"\"\"\n        if self.arg_pos is not None and len(args) > self.arg_pos:\n            return args[self.arg_pos]\n        else:\n            return kwargs.get(self.name, default)",
        "begin_line": 395,
        "end_line": 405,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.ArgReplacer.replace#407",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.ArgReplacer",
        "signature": "tornado.util.ArgReplacer.replace(self, new_value: Any, args: Sequence[Any], kwargs: Dict[str, Any])",
        "snippet": "    def replace(\n        self, new_value: Any, args: Sequence[Any], kwargs: Dict[str, Any]\n    ) -> Tuple[Any, Sequence[Any], Dict[str, Any]]:\n        \"\"\"Replace the named argument in ``args, kwargs`` with ``new_value``.\n\n        Returns ``(old_value, args, kwargs)``.  The returned ``args`` and\n        ``kwargs`` objects may not be the same as the input objects, or\n        the input objects may be mutated.\n\n        If the named argument was not found, ``new_value`` will be added\n        to ``kwargs`` and None will be returned as ``old_value``.\n        \"\"\"\n        if self.arg_pos is not None and len(args) > self.arg_pos:\n            # The arg to replace is passed positionally\n            old_value = args[self.arg_pos]\n            args = list(args)  # *args is normally a tuple\n            args[self.arg_pos] = new_value\n        else:\n            # The arg to replace is either omitted or passed by keyword.\n            old_value = kwargs.get(self.name)\n            kwargs[self.name] = new_value\n        return old_value, args, kwargs",
        "begin_line": 407,
        "end_line": 428,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util.timedelta_to_seconds#431",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util",
        "signature": "tornado.util.timedelta_to_seconds(td)",
        "snippet": "def timedelta_to_seconds(td):\n    # type: (datetime.timedelta) -> float\n    \"\"\"Equivalent to td.total_seconds() (introduced in python 2.7).\"\"\"\n    return td.total_seconds()",
        "begin_line": 431,
        "end_line": 434,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.util._websocket_mask_python#437",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util",
        "signature": "tornado.util._websocket_mask_python(mask: bytes, data: bytes)",
        "snippet": "def _websocket_mask_python(mask: bytes, data: bytes) -> bytes:\n    \"\"\"Websocket masking function.\n\n    `mask` is a `bytes` object of length 4; `data` is a `bytes` object of any length.\n    Returns a `bytes` object of the same length as `data` with the mask applied\n    as specified in section 5.3 of RFC 6455.\n\n    This pure-python implementation may be replaced by an optimized version when available.\n    \"\"\"\n    mask_arr = array.array(\"B\", mask)\n    unmasked_arr = array.array(\"B\", data)\n    for i in range(len(data)):\n        unmasked_arr[i] = unmasked_arr[i] ^ mask_arr[i % 4]\n    return unmasked_arr.tobytes()",
        "begin_line": 437,
        "end_line": 450,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014637002341920375,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.escape.xhtml_escape#43",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.xhtml_escape(value: Union[str, bytes])",
        "snippet": "def xhtml_escape(value: Union[str, bytes]) -> str:\n    \"\"\"Escapes a string so it is valid within HTML or XML.\n\n    Escapes the characters ``<``, ``>``, ``\"``, ``'``, and ``&``.\n    When used in attribute values the escaped strings must be enclosed\n    in quotes.\n\n    .. versionchanged:: 3.2\n\n       Added the single quote to the list of escaped characters.\n    \"\"\"\n    return _XHTML_ESCAPE_RE.sub(\n        lambda match: _XHTML_ESCAPE_DICT[match.group(0)], to_basestring(value)\n    )",
        "begin_line": 43,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001618384851917786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.escape.xhtml_unescape#59",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.xhtml_unescape(value: Union[str, bytes])",
        "snippet": "def xhtml_unescape(value: Union[str, bytes]) -> str:\n    \"\"\"Un-escapes an XML-escaped string.\"\"\"\n    return re.sub(r\"&(#?)(\\w+?);\", _convert_entity, _unicode(value))",
        "begin_line": 59,
        "end_line": 61,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.escape.json_encode#67",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.json_encode(value: Any)",
        "snippet": "def json_encode(value: Any) -> str:\n    \"\"\"JSON-encodes the given Python object.\"\"\"\n    # JSON permits but does not require forward slashes to be escaped.\n    # This is useful when json data is emitted in a <script> tag\n    # in HTML, as it prevents </script> tags from prematurely terminating\n    # the javascript.  Some json libraries do this escaping by default,\n    # although python's standard library does not, so we do it here.\n    # http://stackoverflow.com/questions/1580647/json-why-are-forward-slashes-escaped\n    return json.dumps(value).replace(\"</\", \"<\\\\/\")",
        "begin_line": 67,
        "end_line": 75,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001417233560090703,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.escape.json_decode#78",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.json_decode(value: Union[str, bytes])",
        "snippet": "def json_decode(value: Union[str, bytes]) -> Any:\n    \"\"\"Returns Python objects for the given JSON string.\"\"\"\n    return json.loads(to_basestring(value))",
        "begin_line": 78,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001422879908935686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.escape.squeeze#83",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.squeeze(value: str)",
        "snippet": "def squeeze(value: str) -> str:\n    \"\"\"Replace all sequences of whitespace chars with a single space.\"\"\"\n    return re.sub(r\"[\\x00-\\x20]+\", \" \", value).strip()",
        "begin_line": 83,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.escape.url_escape#88",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.url_escape(value: Union[str, bytes], plus: bool=True)",
        "snippet": "def url_escape(value: Union[str, bytes], plus: bool = True) -> str:\n    \"\"\"Returns a URL-encoded version of the given value.\n\n    If ``plus`` is true (the default), spaces will be represented\n    as \"+\" instead of \"%20\".  This is appropriate for query strings\n    but not for the path component of a URL.  Note that this default\n    is the reverse of Python's urllib module.\n\n    .. versionadded:: 3.1\n        The ``plus`` argument\n    \"\"\"\n    quote = urllib.parse.quote_plus if plus else urllib.parse.quote\n    return quote(utf8(value))",
        "begin_line": 88,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017590149516270889,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.escape.url_unescape#115",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.url_unescape(value: Union[str, bytes], encoding: Optional[str]='utf-8', plus: bool=True)",
        "snippet": "def url_unescape(  # noqa: F811\n    value: Union[str, bytes], encoding: Optional[str] = \"utf-8\", plus: bool = True\n) -> Union[str, bytes]:\n    \"\"\"Decodes the given value from a URL.\n\n    The argument may be either a byte or unicode string.\n\n    If encoding is None, the result will be a byte string.  Otherwise,\n    the result is a unicode string in the specified encoding.\n\n    If ``plus`` is true (the default), plus signs will be interpreted\n    as spaces (literal plus signs must be represented as \"%2B\").  This\n    is appropriate for query strings and form-encoded values but not\n    for the path component of a URL.  Note that this default is the\n    reverse of Python's urllib module.\n\n    .. versionadded:: 3.1\n       The ``plus`` argument\n    \"\"\"\n    if encoding is None:\n        if plus:\n            # unquote_to_bytes doesn't have a _plus variant\n            value = to_basestring(value).replace(\"+\", \" \")\n        return urllib.parse.unquote_to_bytes(value)\n    else:\n        unquote = urllib.parse.unquote_plus if plus else urllib.parse.unquote\n        return unquote(to_basestring(value), encoding=encoding)",
        "begin_line": 115,
        "end_line": 141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.escape.parse_qs_bytes#144",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.parse_qs_bytes(qs: str, keep_blank_values: bool=False, strict_parsing: bool=False)",
        "snippet": "def parse_qs_bytes(\n    qs: str, keep_blank_values: bool = False, strict_parsing: bool = False\n) -> Dict[str, List[bytes]]:\n    \"\"\"Parses a query string like urlparse.parse_qs, but returns the\n    values as byte strings.\n\n    Keys still become type str (interpreted as latin1 in python3!)\n    because it's too painful to keep them as byte strings in\n    python3 and in practice they're nearly always ascii anyway.\n    \"\"\"\n    # This is gross, but python3 doesn't give us another way.\n    # Latin1 is the universal donor of character encodings.\n    result = urllib.parse.parse_qs(\n        qs, keep_blank_values, strict_parsing, encoding=\"latin1\", errors=\"strict\"\n    )\n    encoded = {}\n    for k, v in result.items():\n        encoded[k] = [i.encode(\"latin1\") for i in v]\n    return encoded",
        "begin_line": 144,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000741839762611276,
            "pseudo_dstar_susp": 0.0008503401360544217,
            "pseudo_tarantula_susp": 0.000992063492063492,
            "pseudo_op2_susp": 0.0008503401360544217,
            "pseudo_barinel_susp": 0.000992063492063492
        }
    },
    {
        "name": "tornado.escape.utf8#183",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.utf8(value: Union[None, str, bytes])",
        "snippet": "def utf8(value: Union[None, str, bytes]) -> Optional[bytes]:  # noqa: F811\n    \"\"\"Converts a string argument to a byte string.\n\n    If the argument is already a byte string or None, it is returned unchanged.\n    Otherwise it must be a unicode string and is encoded as utf8.\n    \"\"\"\n    if isinstance(value, _UTF8_TYPES):\n        return value\n    if not isinstance(value, unicode_type):\n        raise TypeError(\"Expected bytes, unicode, or None; got %r\" % type(value))\n    return value.encode(\"utf-8\")",
        "begin_line": 183,
        "end_line": 193,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005330490405117271,
            "pseudo_dstar_susp": 0.0007194244604316547,
            "pseudo_tarantula_susp": 0.00047778308647873863,
            "pseudo_op2_susp": 0.0007194244604316547,
            "pseudo_barinel_susp": 0.00047778308647873863
        }
    },
    {
        "name": "tornado.escape.to_unicode#214",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.to_unicode(value: Union[None, str, bytes])",
        "snippet": "def to_unicode(value: Union[None, str, bytes]) -> Optional[str]:  # noqa: F811\n    \"\"\"Converts a string argument to a unicode string.\n\n    If the argument is already a unicode string or None, it is returned\n    unchanged.  Otherwise it must be a byte string and is decoded as utf8.\n    \"\"\"\n    if isinstance(value, _TO_UNICODE_TYPES):\n        return value\n    if not isinstance(value, bytes):\n        raise TypeError(\"Expected bytes, unicode, or None; got %r\" % type(value))\n    return value.decode(\"utf-8\")",
        "begin_line": 214,
        "end_line": 224,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007564296520423601,
            "pseudo_dstar_susp": 0.0011750881316098707,
            "pseudo_tarantula_susp": 0.000676132521974307,
            "pseudo_op2_susp": 0.0011750881316098707,
            "pseudo_barinel_susp": 0.000676132521974307
        }
    },
    {
        "name": "tornado.escape.to_basestring#253",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.to_basestring(value: Union[None, str, bytes])",
        "snippet": "def to_basestring(value: Union[None, str, bytes]) -> Optional[str]:  # noqa: F811\n    \"\"\"Converts a string argument to a subclass of basestring.\n\n    In python2, byte and unicode strings are mostly interchangeable,\n    so functions that deal with a user-supplied argument in combination\n    with ascii string constants can use either and should return the type\n    the user supplied.  In python3, the two types are not interchangeable,\n    so this method is needed to convert byte strings to unicode.\n    \"\"\"\n    if isinstance(value, _BASESTRING_TYPES):\n        return value\n    if not isinstance(value, bytes):\n        raise TypeError(\"Expected bytes, unicode, or None; got %r\" % type(value))\n    return value.decode(\"utf-8\")",
        "begin_line": 253,
        "end_line": 266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016220600162206002,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.escape.recursive_unicode#269",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.recursive_unicode(obj: Any)",
        "snippet": "def recursive_unicode(obj: Any) -> Any:\n    \"\"\"Walks a simple data structure, converting byte strings to unicode.\n\n    Supports lists, tuples, and dictionaries.\n    \"\"\"\n    if isinstance(obj, dict):\n        return dict(\n            (recursive_unicode(k), recursive_unicode(v)) for (k, v) in obj.items()\n        )\n    elif isinstance(obj, list):\n        return list(recursive_unicode(i) for i in obj)\n    elif isinstance(obj, tuple):\n        return tuple(recursive_unicode(i) for i in obj)\n    elif isinstance(obj, bytes):\n        return to_unicode(obj)\n    else:\n        return obj",
        "begin_line": 269,
        "end_line": 285,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.escape.linkify#302",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.linkify(text: Union[str, bytes], shorten: bool=False, extra_params: Union[str, Callable[[str], str]]='', require_protocol: bool=False, permitted_protocols: List[str]=['http', 'https'])",
        "snippet": "def linkify(\n    text: Union[str, bytes],\n    shorten: bool = False,\n    extra_params: Union[str, Callable[[str], str]] = \"\",\n    require_protocol: bool = False,\n    permitted_protocols: List[str] = [\"http\", \"https\"],\n) -> str:\n    \"\"\"Converts plain text into HTML with links.\n\n    For example: ``linkify(\"Hello http://tornadoweb.org!\")`` would return\n    ``Hello <a href=\"http://tornadoweb.org\">http://tornadoweb.org</a>!``\n\n    Parameters:\n\n    * ``shorten``: Long urls will be shortened for display.\n\n    * ``extra_params``: Extra text to include in the link tag, or a callable\n      taking the link as an argument and returning the extra text\n      e.g. ``linkify(text, extra_params='rel=\"nofollow\" class=\"external\"')``,\n      or::\n\n          def extra_params_cb(url):\n              if url.startswith(\"http://example.com\"):\n                  return 'class=\"internal\"'\n              else:\n                  return 'class=\"external\" rel=\"nofollow\"'\n          linkify(text, extra_params=extra_params_cb)\n\n    * ``require_protocol``: Only linkify urls which include a protocol. If\n      this is False, urls such as www.facebook.com will also be linkified.\n\n    * ``permitted_protocols``: List (or set) of protocols which should be\n      linkified, e.g. ``linkify(text, permitted_protocols=[\"http\", \"ftp\",\n      \"mailto\"])``. It is very unsafe to include protocols such as\n      ``javascript``.\n    \"\"\"\n    if extra_params and not callable(extra_params):\n        extra_params = \" \" + extra_params.strip()\n\n    def make_link(m: typing.Match) -> str:\n        url = m.group(1)\n        proto = m.group(2)\n        if require_protocol and not proto:\n            return url  # not protocol, no linkify\n\n        if proto and proto not in permitted_protocols:\n            return url  # bad protocol, no linkify\n\n        href = m.group(1)\n        if not proto:\n            href = \"http://\" + href  # no proto specified, use http\n\n        if callable(extra_params):\n            params = \" \" + extra_params(href).strip()\n        else:\n            params = extra_params\n\n        # clip long urls. max_len is just an approximation\n        max_len = 30\n        if shorten and len(url) > max_len:\n            before_clip = url\n            if proto:\n                proto_len = len(proto) + 1 + len(m.group(3) or \"\")  # +1 for :\n            else:\n                proto_len = 0\n\n            parts = url[proto_len:].split(\"/\")\n            if len(parts) > 1:\n                # Grab the whole host part plus the first bit of the path\n                # The path is usually not that interesting once shortened\n                # (no more slug, etc), so it really just provides a little\n                # extra indication of shortening.\n                url = (\n                    url[:proto_len]\n                    + parts[0]\n                    + \"/\"\n                    + parts[1][:8].split(\"?\")[0].split(\".\")[0]\n                )\n\n            if len(url) > max_len * 1.5:  # still too long\n                url = url[:max_len]\n\n            if url != before_clip:\n                amp = url.rfind(\"&\")\n                # avoid splitting html char entities\n                if amp > max_len - 5:\n                    url = url[:amp]\n                url += \"...\"\n\n                if len(url) >= len(before_clip):\n                    url = before_clip\n                else:\n                    # full url is visible on mouse-over (for those who don't\n                    # have a status bar, such as Safari by default)\n                    params += ' title=\"%s\"' % href\n\n        return u'<a href=\"%s\"%s>%s</a>' % (href, params, url)\n\n    # First HTML-escape so that our strings are all safe.\n    # The regex is modified to avoid character entites other than &amp; so\n    # that we won't pick up &quot;, etc.\n    text = _unicode(xhtml_escape(text))\n    return _URL_RE.sub(make_link, text)",
        "begin_line": 302,
        "end_line": 404,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.escape.make_link#341",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.make_link(m: typing.Match)",
        "snippet": "    def make_link(m: typing.Match) -> str:\n        url = m.group(1)\n        proto = m.group(2)\n        if require_protocol and not proto:\n            return url  # not protocol, no linkify\n\n        if proto and proto not in permitted_protocols:\n            return url  # bad protocol, no linkify\n\n        href = m.group(1)\n        if not proto:\n            href = \"http://\" + href  # no proto specified, use http\n\n        if callable(extra_params):\n            params = \" \" + extra_params(href).strip()\n        else:\n            params = extra_params\n\n        # clip long urls. max_len is just an approximation\n        max_len = 30\n        if shorten and len(url) > max_len:\n            before_clip = url\n            if proto:\n                proto_len = len(proto) + 1 + len(m.group(3) or \"\")  # +1 for :\n            else:\n                proto_len = 0\n\n            parts = url[proto_len:].split(\"/\")\n            if len(parts) > 1:\n                # Grab the whole host part plus the first bit of the path\n                # The path is usually not that interesting once shortened\n                # (no more slug, etc), so it really just provides a little\n                # extra indication of shortening.\n                url = (\n                    url[:proto_len]\n                    + parts[0]\n                    + \"/\"\n                    + parts[1][:8].split(\"?\")[0].split(\".\")[0]\n                )\n\n            if len(url) > max_len * 1.5:  # still too long\n                url = url[:max_len]\n\n            if url != before_clip:\n                amp = url.rfind(\"&\")\n                # avoid splitting html char entities\n                if amp > max_len - 5:\n                    url = url[:amp]\n                url += \"...\"\n\n                if len(url) >= len(before_clip):\n                    url = before_clip\n                else:\n                    # full url is visible on mouse-over (for those who don't\n                    # have a status bar, such as Safari by default)\n                    params += ' title=\"%s\"' % href\n\n        return u'<a href=\"%s\"%s>%s</a>' % (href, params, url)",
        "begin_line": 341,
        "end_line": 398,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.escape._convert_entity#407",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape._convert_entity(m: typing.Match)",
        "snippet": "def _convert_entity(m: typing.Match) -> str:\n    if m.group(1) == \"#\":\n        try:\n            if m.group(2)[:1].lower() == \"x\":\n                return chr(int(m.group(2)[1:], 16))\n            else:\n                return chr(int(m.group(2)))\n        except ValueError:\n            return \"&#%s;\" % m.group(2)\n    try:\n        return _HTML_UNICODE_MAP[m.group(2)]\n    except KeyError:\n        return \"&%s;\" % m.group(2)",
        "begin_line": 407,
        "end_line": 419,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues._set_timeout#59",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues",
        "signature": "tornado.queues._set_timeout(future: Future, timeout: Union[None, float, datetime.timedelta])",
        "snippet": "def _set_timeout(\n    future: Future, timeout: Union[None, float, datetime.timedelta]\n) -> None:\n    if timeout:\n\n        def on_timeout() -> None:\n            if not future.done():\n                future.set_exception(gen.TimeoutError())\n\n        io_loop = ioloop.IOLoop.current()\n        timeout_handle = io_loop.add_timeout(timeout, on_timeout)\n        future.add_done_callback(lambda _: io_loop.remove_timeout(timeout_handle))",
        "begin_line": 59,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018135654697134566,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.on_timeout#64",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues",
        "signature": "tornado.queues.on_timeout()",
        "snippet": "        def on_timeout() -> None:\n            if not future.done():\n                future.set_exception(gen.TimeoutError())",
        "begin_line": 64,
        "end_line": 66,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019334880123743234,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues._QueueIterator.__init__#74",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues._QueueIterator",
        "signature": "tornado.queues._QueueIterator.__init__(self, q: 'Queue[_T]')",
        "snippet": "    def __init__(self, q: \"Queue[_T]\") -> None:\n        self.q = q",
        "begin_line": 74,
        "end_line": 75,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues._QueueIterator.__anext__#77",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues._QueueIterator",
        "signature": "tornado.queues._QueueIterator.__anext__(self)",
        "snippet": "    def __anext__(self) -> Awaitable[_T]:\n        return self.q.get()",
        "begin_line": 77,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue.__init__#153",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.__init__(self, maxsize: int=0)",
        "snippet": "    def __init__(self, maxsize: int = 0) -> None:\n        if maxsize is None:\n            raise TypeError(\"maxsize can't be None\")\n\n        if maxsize < 0:\n            raise ValueError(\"maxsize can't be negative\")\n\n        self._maxsize = maxsize\n        self._init()\n        self._getters = collections.deque([])  # type: Deque[Future[_T]]\n        self._putters = collections.deque([])  # type: Deque[Tuple[_T, Future[None]]]\n        self._unfinished_tasks = 0\n        self._finished = Event()\n        self._finished.set()",
        "begin_line": 153,
        "end_line": 166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue.maxsize#169",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.maxsize(self)",
        "snippet": "    def maxsize(self) -> int:\n        \"\"\"Number of items allowed in the queue.\"\"\"\n        return self._maxsize",
        "begin_line": 169,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001414227124876255,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue.qsize#173",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.qsize(self)",
        "snippet": "    def qsize(self) -> int:\n        \"\"\"Number of items in the queue.\"\"\"\n        return len(self._queue)",
        "begin_line": 173,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.000140331181588549,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue.empty#177",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.empty(self)",
        "snippet": "    def empty(self) -> bool:\n        return not self._queue",
        "begin_line": 177,
        "end_line": 178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014858841010401187,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue.full#180",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.full(self)",
        "snippet": "    def full(self) -> bool:\n        if self.maxsize == 0:\n            return False\n        else:\n            return self.qsize() >= self.maxsize",
        "begin_line": 180,
        "end_line": 184,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001636929120969062,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue.put#186",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.put(self, item: _T, timeout: Union[float, datetime.timedelta]=None)",
        "snippet": "    def put(\n        self, item: _T, timeout: Union[float, datetime.timedelta] = None\n    ) -> \"Future[None]\":\n        \"\"\"Put an item into the queue, perhaps waiting until there is room.\n\n        Returns a Future, which raises `tornado.util.TimeoutError` after a\n        timeout.\n\n        ``timeout`` may be a number denoting a time (on the same\n        scale as `tornado.ioloop.IOLoop.time`, normally `time.time`), or a\n        `datetime.timedelta` object for a deadline relative to the\n        current time.\n        \"\"\"\n        future = Future()  # type: Future[None]\n        try:\n            self.put_nowait(item)\n        except QueueFull:\n            self._putters.append((item, future))\n            _set_timeout(future, timeout)\n        else:\n            future.set_result(None)\n        return future",
        "begin_line": 186,
        "end_line": 207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017373175816539263,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue.put_nowait#209",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.put_nowait(self, item: _T)",
        "snippet": "    def put_nowait(self, item: _T) -> None:\n        \"\"\"Put an item into the queue without blocking.\n\n        If no free slot is immediately available, raise `QueueFull`.\n        \"\"\"\n        self._consume_expired()\n        if self._getters:\n            assert self.empty(), \"queue non-empty, why are getters waiting?\"\n            getter = self._getters.popleft()\n            self.__put_internal(item)\n            future_set_result_unless_cancelled(getter, self._get())\n        elif self.full():\n            raise QueueFull\n        else:\n            self.__put_internal(item)",
        "begin_line": 209,
        "end_line": 223,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017214666896195557,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue.get#225",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.get(self, timeout: Union[float, datetime.timedelta]=None)",
        "snippet": "    def get(self, timeout: Union[float, datetime.timedelta] = None) -> \"Future[_T]\":\n        \"\"\"Remove and return an item from the queue.\n\n        Returns a Future which resolves once an item is available, or raises\n        `tornado.util.TimeoutError` after a timeout.\n\n        ``timeout`` may be a number denoting a time (on the same\n        scale as `tornado.ioloop.IOLoop.time`, normally `time.time`), or a\n        `datetime.timedelta` object for a deadline relative to the\n        current time.\n        \"\"\"\n        future = Future()  # type: Future[_T]\n        try:\n            future.set_result(self.get_nowait())\n        except QueueEmpty:\n            self._getters.append(future)\n            _set_timeout(future, timeout)\n        return future",
        "begin_line": 225,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015160703456640388,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue.get_nowait#244",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.get_nowait(self)",
        "snippet": "    def get_nowait(self) -> _T:\n        \"\"\"Remove and return an item from the queue without blocking.\n\n        Return an item if one is immediately available, else raise\n        `QueueEmpty`.\n        \"\"\"\n        self._consume_expired()\n        if self._putters:\n            assert self.full(), \"queue not full, why are putters waiting?\"\n            item, putter = self._putters.popleft()\n            self.__put_internal(item)\n            future_set_result_unless_cancelled(putter, None)\n            return self._get()\n        elif self.qsize():\n            return self._get()\n        else:\n            raise QueueEmpty",
        "begin_line": 244,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017885888034340904,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue.task_done#262",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.task_done(self)",
        "snippet": "    def task_done(self) -> None:\n        \"\"\"Indicate that a formerly enqueued task is complete.\n\n        Used by queue consumers. For each `.get` used to fetch a task, a\n        subsequent call to `.task_done` tells the queue that the processing\n        on the task is complete.\n\n        If a `.join` is blocking, it resumes when all items have been\n        processed; that is, when every `.put` is matched by a `.task_done`.\n\n        Raises `ValueError` if called more times than `.put`.\n        \"\"\"\n        if self._unfinished_tasks <= 0:\n            raise ValueError(\"task_done() called too many times\")\n        self._unfinished_tasks -= 1\n        if self._unfinished_tasks == 0:\n            self._finished.set()",
        "begin_line": 262,
        "end_line": 278,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue.join#280",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.join(self, timeout: Union[float, datetime.timedelta]=None)",
        "snippet": "    def join(self, timeout: Union[float, datetime.timedelta] = None) -> \"Future[None]\":\n        \"\"\"Block until all items in the queue are processed.\n\n        Returns a Future, which raises `tornado.util.TimeoutError` after a\n        timeout.\n        \"\"\"\n        return self._finished.wait(timeout)",
        "begin_line": 280,
        "end_line": 286,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017214666896195557,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue.__aiter__#288",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.__aiter__(self)",
        "snippet": "    def __aiter__(self) -> _QueueIterator[_T]:\n        return _QueueIterator(self)",
        "begin_line": 288,
        "end_line": 289,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue._init#292",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue._init(self)",
        "snippet": "    def _init(self) -> None:\n        self._queue = collections.deque()",
        "begin_line": 292,
        "end_line": 293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00013970382788488405,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue._get#295",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue._get(self)",
        "snippet": "    def _get(self) -> _T:\n        return self._queue.popleft()",
        "begin_line": 295,
        "end_line": 296,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001414227124876255,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue._put#298",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue._put(self, item: _T)",
        "snippet": "    def _put(self, item: _T) -> None:\n        self._queue.append(item)",
        "begin_line": 298,
        "end_line": 299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014072614691809738,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue.__put_internal#303",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.__put_internal(self, item: _T)",
        "snippet": "    def __put_internal(self, item: _T) -> None:\n        self._unfinished_tasks += 1\n        self._finished.clear()\n        self._put(item)",
        "begin_line": 303,
        "end_line": 306,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014019346698443852,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue._consume_expired#308",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue._consume_expired(self)",
        "snippet": "    def _consume_expired(self) -> None:\n        # Remove timed-out waiters.\n        while self._putters and self._putters[0][1].done():\n            self._putters.popleft()\n\n        while self._getters and self._getters[0].done():\n            self._getters.popleft()",
        "begin_line": 308,
        "end_line": 314,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue.__repr__#316",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.__repr__(self)",
        "snippet": "    def __repr__(self) -> str:\n        return \"<%s at %s %s>\" % (type(self).__name__, hex(id(self)), self._format())",
        "begin_line": 316,
        "end_line": 317,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue.__str__#319",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.__str__(self)",
        "snippet": "    def __str__(self) -> str:\n        return \"<%s %s>\" % (type(self).__name__, self._format())",
        "begin_line": 319,
        "end_line": 320,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.Queue._format#322",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue._format(self)",
        "snippet": "    def _format(self) -> str:\n        result = \"maxsize=%r\" % (self.maxsize,)\n        if getattr(self, \"_queue\", None):\n            result += \" queue=%r\" % self._queue\n        if self._getters:\n            result += \" getters[%s]\" % len(self._getters)\n        if self._putters:\n            result += \" putters[%s]\" % len(self._putters)\n        if self._unfinished_tasks:\n            result += \" tasks=%s\" % self._unfinished_tasks\n        return result",
        "begin_line": 322,
        "end_line": 332,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.PriorityQueue._init#360",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.PriorityQueue",
        "signature": "tornado.queues.PriorityQueue._init(self)",
        "snippet": "    def _init(self) -> None:\n        self._queue = []",
        "begin_line": 360,
        "end_line": 361,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019334880123743234,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.PriorityQueue._put#363",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.PriorityQueue",
        "signature": "tornado.queues.PriorityQueue._put(self, item: _T)",
        "snippet": "    def _put(self, item: _T) -> None:\n        heapq.heappush(self._queue, item)",
        "begin_line": 363,
        "end_line": 364,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.PriorityQueue._get#366",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.PriorityQueue",
        "signature": "tornado.queues.PriorityQueue._get(self)",
        "snippet": "    def _get(self) -> _T:\n        return heapq.heappop(self._queue)",
        "begin_line": 366,
        "end_line": 367,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.LifoQueue._init#393",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.LifoQueue",
        "signature": "tornado.queues.LifoQueue._init(self)",
        "snippet": "    def _init(self) -> None:\n        self._queue = []",
        "begin_line": 393,
        "end_line": 394,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019334880123743234,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.LifoQueue._put#396",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.LifoQueue",
        "signature": "tornado.queues.LifoQueue._put(self, item: _T)",
        "snippet": "    def _put(self, item: _T) -> None:\n        self._queue.append(item)",
        "begin_line": 396,
        "end_line": 397,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.queues.LifoQueue._get#399",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.LifoQueue",
        "signature": "tornado.queues.LifoQueue._get(self)",
        "snippet": "    def _get(self) -> _T:\n        return self._queue.pop()",
        "begin_line": 399,
        "end_line": 400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.iostream.StreamClosedError.__init__#117",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.StreamClosedError",
        "signature": "tornado.iostream.StreamClosedError.__init__(self, real_error: BaseException=None)",
        "snippet": "    def __init__(self, real_error: BaseException = None) -> None:\n        super(StreamClosedError, self).__init__(\"Stream is closed\")\n        self.real_error = real_error",
        "begin_line": 117,
        "end_line": 119,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001984126984126984,
            "pseudo_dstar_susp": 0.0022026431718061676,
            "pseudo_tarantula_susp": 0.0014903129657228018,
            "pseudo_op2_susp": 0.0022026431718061676,
            "pseudo_barinel_susp": 0.0014903129657228018
        }
    },
    {
        "name": "tornado.iostream._StreamBuffer.__init__#143",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream._StreamBuffer",
        "signature": "tornado.iostream._StreamBuffer.__init__(self)",
        "snippet": "    def __init__(self) -> None:\n        # A sequence of (False, bytearray) and (True, memoryview) objects\n        self._buffers = (\n            collections.deque()\n        )  # type: Deque[Tuple[bool, Union[bytearray, memoryview]]]\n        # Position in the first buffer\n        self._first_pos = 0\n        self._size = 0",
        "begin_line": 143,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0032258064516129032,
            "pseudo_dstar_susp": 0.0051813471502590676,
            "pseudo_tarantula_susp": 0.0015015015015015015,
            "pseudo_op2_susp": 0.0051813471502590676,
            "pseudo_barinel_susp": 0.0015015015015015015
        }
    },
    {
        "name": "tornado.iostream._StreamBuffer.__len__#152",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream._StreamBuffer",
        "signature": "tornado.iostream._StreamBuffer.__len__(self)",
        "snippet": "    def __len__(self) -> int:\n        return self._size",
        "begin_line": 152,
        "end_line": 153,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003952569169960474,
            "pseudo_dstar_susp": 0.007352941176470588,
            "pseudo_tarantula_susp": 0.0017271157167530224,
            "pseudo_op2_susp": 0.007352941176470588,
            "pseudo_barinel_susp": 0.0017271157167530224
        }
    },
    {
        "name": "tornado.iostream._StreamBuffer.append#159",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream._StreamBuffer",
        "signature": "tornado.iostream._StreamBuffer.append(self, data: Union[bytes, bytearray, memoryview])",
        "snippet": "    def append(self, data: Union[bytes, bytearray, memoryview]) -> None:\n        \"\"\"\n        Append the given piece of data (should be a buffer-compatible object).\n        \"\"\"\n        size = len(data)\n        if size > self._large_buf_threshold:\n            if not isinstance(data, memoryview):\n                data = memoryview(data)\n            self._buffers.append((True, data))\n        elif size > 0:\n            if self._buffers:\n                is_memview, b = self._buffers[-1]\n                new_buf = is_memview or len(b) >= self._large_buf_threshold\n            else:\n                new_buf = True\n            if new_buf:\n                self._buffers.append((False, bytearray(data)))\n            else:\n                b += data  # type: ignore\n\n        self._size += size",
        "begin_line": 159,
        "end_line": 179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007194244604316547,
            "pseudo_dstar_susp": 0.02702702702702703,
            "pseudo_tarantula_susp": 0.0037593984962406013,
            "pseudo_op2_susp": 0.02702702702702703,
            "pseudo_barinel_susp": 0.0037593984962406013
        }
    },
    {
        "name": "tornado.iostream._StreamBuffer.peek#181",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream._StreamBuffer",
        "signature": "tornado.iostream._StreamBuffer.peek(self, size: int)",
        "snippet": "    def peek(self, size: int) -> memoryview:\n        \"\"\"\n        Get a view over at most ``size`` bytes (possibly fewer) at the\n        current buffer position.\n        \"\"\"\n        assert size > 0\n        try:\n            is_memview, b = self._buffers[0]\n        except IndexError:\n            return memoryview(b\"\")\n\n        pos = self._first_pos\n        if is_memview:\n            return typing.cast(memoryview, b[pos : pos + size])\n        else:\n            return memoryview(b)[pos : pos + size]",
        "begin_line": 181,
        "end_line": 196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007194244604316547,
            "pseudo_dstar_susp": 0.02702702702702703,
            "pseudo_tarantula_susp": 0.0037593984962406013,
            "pseudo_op2_susp": 0.02702702702702703,
            "pseudo_barinel_susp": 0.0037593984962406013
        }
    },
    {
        "name": "tornado.iostream._StreamBuffer.advance#198",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream._StreamBuffer",
        "signature": "tornado.iostream._StreamBuffer.advance(self, size: int)",
        "snippet": "    def advance(self, size: int) -> None:\n        \"\"\"\n        Advance the current buffer position by ``size`` bytes.\n        \"\"\"\n        assert 0 < size <= self._size\n        self._size -= size\n        pos = self._first_pos\n\n        buffers = self._buffers\n        while buffers and size > 0:\n            is_large, b = buffers[0]\n            b_remain = len(b) - size - pos\n            if b_remain <= 0:\n                buffers.popleft()\n                size -= len(b) - pos\n                pos = 0\n            elif is_large:\n                pos += size\n                size = 0\n            else:\n                # Amortized O(1) shrink for Python 2\n                pos += size\n                if len(b) <= 2 * pos:\n                    del typing.cast(bytearray, b)[:pos]\n                    pos = 0\n                size = 0\n\n        assert size == 0\n        self._first_pos = pos",
        "begin_line": 198,
        "end_line": 226,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005494505494505495,
            "pseudo_dstar_susp": 0.014492753623188406,
            "pseudo_tarantula_susp": 0.0020408163265306124,
            "pseudo_op2_susp": 0.014492753623188406,
            "pseudo_barinel_susp": 0.0020408163265306124
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.__init__#247",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.__init__(self, max_buffer_size: int=None, read_chunk_size: int=None, max_write_buffer_size: int=None)",
        "snippet": "    def __init__(\n        self,\n        max_buffer_size: int = None,\n        read_chunk_size: int = None,\n        max_write_buffer_size: int = None,\n    ) -> None:\n        \"\"\"`BaseIOStream` constructor.\n\n        :arg max_buffer_size: Maximum amount of incoming data to buffer;\n            defaults to 100MB.\n        :arg read_chunk_size: Amount of data to read at one time from the\n            underlying transport; defaults to 64KB.\n        :arg max_write_buffer_size: Amount of outgoing data to buffer;\n            defaults to unlimited.\n\n        .. versionchanged:: 4.0\n           Add the ``max_write_buffer_size`` parameter.  Changed default\n           ``read_chunk_size`` to 64KB.\n        .. versionchanged:: 5.0\n           The ``io_loop`` argument (deprecated since version 4.1) has been\n           removed.\n        \"\"\"\n        self.io_loop = ioloop.IOLoop.current()\n        self.max_buffer_size = max_buffer_size or 104857600\n        # A chunk size that is too close to max_buffer_size can cause\n        # spurious failures.\n        self.read_chunk_size = min(read_chunk_size or 65536, self.max_buffer_size // 2)\n        self.max_write_buffer_size = max_write_buffer_size\n        self.error = None  # type: Optional[BaseException]\n        self._read_buffer = bytearray()\n        self._read_buffer_pos = 0\n        self._read_buffer_size = 0\n        self._user_read_buffer = False\n        self._after_user_read_buffer = None  # type: Optional[bytearray]\n        self._write_buffer = _StreamBuffer()\n        self._total_write_index = 0\n        self._total_write_done_index = 0\n        self._read_delimiter = None  # type: Optional[bytes]\n        self._read_regex = None  # type: Optional[Pattern]\n        self._read_max_bytes = None  # type: Optional[int]\n        self._read_bytes = None  # type: Optional[int]\n        self._read_partial = False\n        self._read_until_close = False\n        self._read_future = None  # type: Optional[Future]\n        self._write_futures = (\n            collections.deque()\n        )  # type: Deque[Tuple[int, Future[None]]]\n        self._close_callback = None  # type: Optional[Callable[[], None]]\n        self._connect_future = None  # type: Optional[Future[IOStream]]\n        # _ssl_connect_future should be defined in SSLIOStream\n        # but it's here so we can clean it up in _signal_closed\n        # TODO: refactor that so subclasses can add additional futures\n        # to be cancelled.\n        self._ssl_connect_future = None  # type: Optional[Future[SSLIOStream]]\n        self._connecting = False\n        self._state = None  # type: Optional[int]\n        self._closed = False",
        "begin_line": 247,
        "end_line": 303,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003424657534246575,
            "pseudo_dstar_susp": 0.005714285714285714,
            "pseudo_tarantula_susp": 0.0015432098765432098,
            "pseudo_op2_susp": 0.005714285714285714,
            "pseudo_barinel_susp": 0.0015432098765432098
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.read_until_regex#349",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.read_until_regex(self, regex: bytes, max_bytes: int=None)",
        "snippet": "    def read_until_regex(self, regex: bytes, max_bytes: int = None) -> Awaitable[bytes]:\n        \"\"\"Asynchronously read until we have matched the given regex.\n\n        The result includes the data that matches the regex and anything\n        that came before it.\n\n        If ``max_bytes`` is not None, the connection will be closed\n        if more than ``max_bytes`` bytes have been read and the regex is\n        not satisfied.\n\n        .. versionchanged:: 4.0\n            Added the ``max_bytes`` argument.  The ``callback`` argument is\n            now optional and a `.Future` will be returned if it is omitted.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned\n           `.Future` instead.\n\n        \"\"\"\n        future = self._start_read()\n        self._read_regex = re.compile(regex)\n        self._read_max_bytes = max_bytes\n        try:\n            self._try_inline_read()\n        except UnsatisfiableReadError as e:\n            # Handle this the same way as in _handle_events.\n            gen_log.info(\"Unsatisfiable read, closing connection: %s\" % e)\n            self.close(exc_info=e)\n            return future\n        except:\n            # Ensure that the future doesn't log an error because its\n            # failure was never examined.\n            future.add_done_callback(lambda f: f.exception())\n            raise\n        return future",
        "begin_line": 349,
        "end_line": 384,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02,
            "pseudo_dstar_susp": 0.001984126984126984,
            "pseudo_tarantula_susp": 0.05,
            "pseudo_op2_susp": 0.001984126984126984,
            "pseudo_barinel_susp": 0.05
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.read_until#386",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.read_until(self, delimiter: bytes, max_bytes: int=None)",
        "snippet": "    def read_until(self, delimiter: bytes, max_bytes: int = None) -> Awaitable[bytes]:\n        \"\"\"Asynchronously read until we have found the given delimiter.\n\n        The result includes all the data read including the delimiter.\n\n        If ``max_bytes`` is not None, the connection will be closed\n        if more than ``max_bytes`` bytes have been read and the delimiter\n        is not found.\n\n        .. versionchanged:: 4.0\n            Added the ``max_bytes`` argument.  The ``callback`` argument is\n            now optional and a `.Future` will be returned if it is omitted.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned\n           `.Future` instead.\n        \"\"\"\n        future = self._start_read()\n        self._read_delimiter = delimiter\n        self._read_max_bytes = max_bytes\n        try:\n            self._try_inline_read()\n        except UnsatisfiableReadError as e:\n            # Handle this the same way as in _handle_events.\n            gen_log.info(\"Unsatisfiable read, closing connection: %s\" % e)\n            self.close(exc_info=e)\n            return future\n        except:\n            future.add_done_callback(lambda f: f.exception())\n            raise\n        return future",
        "begin_line": 386,
        "end_line": 417,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02,
            "pseudo_dstar_susp": 0.0009478672985781991,
            "pseudo_tarantula_susp": 0.05,
            "pseudo_op2_susp": 0.0009478672985781991,
            "pseudo_barinel_susp": 0.05
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.read_bytes#419",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.read_bytes(self, num_bytes: int, partial: bool=False)",
        "snippet": "    def read_bytes(self, num_bytes: int, partial: bool = False) -> Awaitable[bytes]:\n        \"\"\"Asynchronously read a number of bytes.\n\n        If ``partial`` is true, data is returned as soon as we have\n        any bytes to return (but never more than ``num_bytes``)\n\n        .. versionchanged:: 4.0\n            Added the ``partial`` argument.  The callback argument is now\n            optional and a `.Future` will be returned if it is omitted.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` and ``streaming_callback`` arguments have\n           been removed. Use the returned `.Future` (and\n           ``partial=True`` for ``streaming_callback``) instead.\n\n        \"\"\"\n        future = self._start_read()\n        assert isinstance(num_bytes, numbers.Integral)\n        self._read_bytes = num_bytes\n        self._read_partial = partial\n        try:\n            self._try_inline_read()\n        except:\n            future.add_done_callback(lambda f: f.exception())\n            raise\n        return future",
        "begin_line": 419,
        "end_line": 445,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00043122035360068997,
            "pseudo_dstar_susp": 0.0004631773969430292,
            "pseudo_tarantula_susp": 0.0004127115146512588,
            "pseudo_op2_susp": 0.0004631773969430292,
            "pseudo_barinel_susp": 0.0004127115146512588
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.read_into#447",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.read_into(self, buf: bytearray, partial: bool=False)",
        "snippet": "    def read_into(self, buf: bytearray, partial: bool = False) -> Awaitable[int]:\n        \"\"\"Asynchronously read a number of bytes.\n\n        ``buf`` must be a writable buffer into which data will be read.\n\n        If ``partial`` is true, the callback is run as soon as any bytes\n        have been read.  Otherwise, it is run when the ``buf`` has been\n        entirely filled with read data.\n\n        .. versionadded:: 5.0\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned\n           `.Future` instead.\n\n        \"\"\"\n        future = self._start_read()\n\n        # First copy data already in read buffer\n        available_bytes = self._read_buffer_size\n        n = len(buf)\n        if available_bytes >= n:\n            end = self._read_buffer_pos + n\n            buf[:] = memoryview(self._read_buffer)[self._read_buffer_pos : end]\n            del self._read_buffer[:end]\n            self._after_user_read_buffer = self._read_buffer\n        elif available_bytes > 0:\n            buf[:available_bytes] = memoryview(self._read_buffer)[\n                self._read_buffer_pos :\n            ]\n\n        # Set up the supplied buffer as our temporary read buffer.\n        # The original (if it had any data remaining) has been\n        # saved for later.\n        self._user_read_buffer = True\n        self._read_buffer = buf\n        self._read_buffer_pos = 0\n        self._read_buffer_size = available_bytes\n        self._read_bytes = n\n        self._read_partial = partial\n\n        try:\n            self._try_inline_read()\n        except:\n            future.add_done_callback(lambda f: f.exception())\n            raise\n        return future",
        "begin_line": 447,
        "end_line": 494,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019334880123743234,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.read_until_close#496",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.read_until_close(self)",
        "snippet": "    def read_until_close(self) -> Awaitable[bytes]:\n        \"\"\"Asynchronously reads all data from the socket until it is closed.\n\n        This will buffer all available data until ``max_buffer_size``\n        is reached. If flow control or cancellation are desired, use a\n        loop with `read_bytes(partial=True) <.read_bytes>` instead.\n\n        .. versionchanged:: 4.0\n            The callback argument is now optional and a `.Future` will\n            be returned if it is omitted.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` and ``streaming_callback`` arguments have\n           been removed. Use the returned `.Future` (and `read_bytes`\n           with ``partial=True`` for ``streaming_callback``) instead.\n\n        \"\"\"\n        future = self._start_read()\n        if self.closed():\n            self._finish_read(self._read_buffer_size, False)\n            return future\n        self._read_until_close = True\n        try:\n            self._try_inline_read()\n        except:\n            future.add_done_callback(lambda f: f.exception())\n            raise\n        return future",
        "begin_line": 496,
        "end_line": 524,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028169014084507044,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.006134969325153374,
            "pseudo_op2_susp": 0.0005711022272986865,
            "pseudo_barinel_susp": 0.006134969325153374
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.write#526",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.write(self, data: Union[bytes, memoryview])",
        "snippet": "    def write(self, data: Union[bytes, memoryview]) -> \"Future[None]\":\n        \"\"\"Asynchronously write the given data to this stream.\n\n        This method returns a `.Future` that resolves (with a result\n        of ``None``) when the write has been completed.\n\n        The ``data`` argument may be of type `bytes` or `memoryview`.\n\n        .. versionchanged:: 4.0\n            Now returns a `.Future` if no callback is given.\n\n        .. versionchanged:: 4.5\n            Added support for `memoryview` arguments.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned\n           `.Future` instead.\n\n        \"\"\"\n        self._check_closed()\n        if data:\n            if (\n                self.max_write_buffer_size is not None\n                and len(self._write_buffer) + len(data) > self.max_write_buffer_size\n            ):\n                raise StreamBufferFullError(\"Reached maximum write buffer size\")\n            self._write_buffer.append(data)\n            self._total_write_index += len(data)\n        future = Future()  # type: Future[None]\n        future.add_done_callback(lambda f: f.exception())\n        self._write_futures.append((self._total_write_index, future))\n        if not self._connecting:\n            self._handle_write()\n            if self._write_buffer:\n                self._add_io_state(self.io_loop.WRITE)\n            self._maybe_add_error_listener()\n        return future",
        "begin_line": 526,
        "end_line": 563,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.014285714285714285,
            "pseudo_dstar_susp": 0.2,
            "pseudo_tarantula_susp": 0.0021231422505307855,
            "pseudo_op2_susp": 0.2,
            "pseudo_barinel_susp": 0.0021231422505307855
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.set_close_callback#565",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.set_close_callback(self, callback: Optional[Callable[[], None]])",
        "snippet": "    def set_close_callback(self, callback: Optional[Callable[[], None]]) -> None:\n        \"\"\"Call the given callback when the stream is closed.\n\n        This mostly is not necessary for applications that use the\n        `.Future` interface; all outstanding ``Futures`` will resolve\n        with a `StreamClosedError` when the stream is closed. However,\n        it is still useful as a way to signal that the stream has been\n        closed while no other read or write is in progress.\n\n        Unlike other callback-based interfaces, ``set_close_callback``\n        was not removed in Tornado 6.0.\n        \"\"\"\n        self._close_callback = callback\n        self._maybe_add_error_listener()",
        "begin_line": 565,
        "end_line": 578,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008620689655172414,
            "pseudo_dstar_susp": 0.030303030303030304,
            "pseudo_tarantula_susp": 0.002352941176470588,
            "pseudo_op2_susp": 0.030303030303030304,
            "pseudo_barinel_susp": 0.002352941176470588
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.close#580",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.close(self, exc_info: Union[None, bool, BaseException, Tuple[Optional[Type[BaseException]], Optional[BaseException], Optional[TracebackType]]]=False)",
        "snippet": "    def close(\n        self,\n        exc_info: Union[\n            None,\n            bool,\n            BaseException,\n            Tuple[\n                Optional[Type[BaseException]],\n                Optional[BaseException],\n                Optional[TracebackType],\n            ],\n        ] = False,\n    ) -> None:\n        \"\"\"Close this stream.\n\n        If ``exc_info`` is true, set the ``error`` attribute to the current\n        exception from `sys.exc_info` (or if ``exc_info`` is a tuple,\n        use that instead of `sys.exc_info`).\n        \"\"\"\n        if not self.closed():\n            if exc_info:\n                if isinstance(exc_info, tuple):\n                    self.error = exc_info[1]\n                elif isinstance(exc_info, BaseException):\n                    self.error = exc_info\n                else:\n                    exc_info = sys.exc_info()\n                    if any(exc_info):\n                        self.error = exc_info[1]\n            if self._read_until_close:\n                self._read_until_close = False\n                self._finish_read(self._read_buffer_size, False)\n            if self._state is not None:\n                self.io_loop.remove_handler(self.fileno())\n                self._state = None\n            self.close_fd()\n            self._closed = True\n        self._signal_closed()",
        "begin_line": 580,
        "end_line": 617,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02631578947368421,
            "pseudo_dstar_susp": 0.007575757575757576,
            "pseudo_tarantula_susp": 0.012658227848101266,
            "pseudo_op2_susp": 0.007575757575757576,
            "pseudo_barinel_susp": 0.012658227848101266
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._signal_closed#619",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._signal_closed(self)",
        "snippet": "    def _signal_closed(self) -> None:\n        futures = []  # type: List[Future]\n        if self._read_future is not None:\n            futures.append(self._read_future)\n            self._read_future = None\n        futures += [future for _, future in self._write_futures]\n        self._write_futures.clear()\n        if self._connect_future is not None:\n            futures.append(self._connect_future)\n            self._connect_future = None\n        for future in futures:\n            future.set_exception(StreamClosedError(real_error=self.error))\n            future.exception()\n        if self._ssl_connect_future is not None:\n            # _ssl_connect_future expects to see the real exception (typically\n            # an ssl.SSLError), not just StreamClosedError.\n            if self.error is not None:\n                self._ssl_connect_future.set_exception(self.error)\n            else:\n                self._ssl_connect_future.set_exception(StreamClosedError())\n            self._ssl_connect_future.exception()\n            self._ssl_connect_future = None\n        if self._close_callback is not None:\n            cb = self._close_callback\n            self._close_callback = None\n            self.io_loop.add_callback(cb)\n        # Clear the buffers so they can be cleared immediately even\n        # if the IOStream object is kept alive by a reference cycle.\n        # TODO: Clear the read buffer too; it currently breaks some tests.\n        self._write_buffer = None  # type: ignore",
        "begin_line": 619,
        "end_line": 648,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.018518518518518517,
            "pseudo_dstar_susp": 0.16666666666666666,
            "pseudo_tarantula_susp": 0.006756756756756757,
            "pseudo_op2_susp": 0.16666666666666666,
            "pseudo_barinel_susp": 0.006756756756756757
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.reading#650",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.reading(self)",
        "snippet": "    def reading(self) -> bool:\n        \"\"\"Returns true if we are currently reading from the stream.\"\"\"\n        return self._read_future is not None",
        "begin_line": 650,
        "end_line": 652,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002976190476190476,
            "pseudo_dstar_susp": 0.0029154518950437317,
            "pseudo_tarantula_susp": 0.0014124293785310734,
            "pseudo_op2_susp": 0.0029154518950437317,
            "pseudo_barinel_susp": 0.0014124293785310734
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.writing#654",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.writing(self)",
        "snippet": "    def writing(self) -> bool:\n        \"\"\"Returns true if we are currently writing to the stream.\"\"\"\n        return bool(self._write_buffer)",
        "begin_line": 654,
        "end_line": 656,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003048780487804878,
            "pseudo_dstar_susp": 0.0029850746268656717,
            "pseudo_tarantula_susp": 0.001447178002894356,
            "pseudo_op2_susp": 0.0029850746268656717,
            "pseudo_barinel_susp": 0.001447178002894356
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.closed#658",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.closed(self)",
        "snippet": "    def closed(self) -> bool:\n        \"\"\"Returns true if the stream has been closed.\"\"\"\n        return self._closed",
        "begin_line": 658,
        "end_line": 660,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003424657534246575,
            "pseudo_dstar_susp": 0.005714285714285714,
            "pseudo_tarantula_susp": 0.0015432098765432098,
            "pseudo_op2_susp": 0.005714285714285714,
            "pseudo_barinel_susp": 0.0015432098765432098
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._handle_events#680",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._handle_events(self, fd: Union[int, ioloop._Selectable], events: int)",
        "snippet": "    def _handle_events(self, fd: Union[int, ioloop._Selectable], events: int) -> None:\n        if self.closed():\n            gen_log.warning(\"Got events for closed stream %s\", fd)\n            return\n        try:\n            if self._connecting:\n                # Most IOLoops will report a write failed connect\n                # with the WRITE event, but SelectIOLoop reports a\n                # READ as well so we must check for connecting before\n                # either.\n                self._handle_connect()\n            if self.closed():\n                return\n            if events & self.io_loop.READ:\n                self._handle_read()\n            if self.closed():\n                return\n            if events & self.io_loop.WRITE:\n                self._handle_write()\n            if self.closed():\n                return\n            if events & self.io_loop.ERROR:\n                self.error = self.get_fd_error()\n                # We may have queued up a user callback in _handle_read or\n                # _handle_write, so don't close the IOStream until those\n                # callbacks have had a chance to run.\n                self.io_loop.add_callback(self.close)\n                return\n            state = self.io_loop.ERROR\n            if self.reading():\n                state |= self.io_loop.READ\n            if self.writing():\n                state |= self.io_loop.WRITE\n            if state == self.io_loop.ERROR and self._read_buffer_size == 0:\n                # If the connection is idle, listen for reads too so\n                # we can tell if the connection is closed.  If there is\n                # data in the read buffer we won't run the close callback\n                # yet anyway, so we don't need to listen in this case.\n                state |= self.io_loop.READ\n            if state != self._state:\n                assert (\n                    self._state is not None\n                ), \"shouldn't happen: _handle_events without self._state\"\n                self._state = state\n                self.io_loop.update_handler(self.fileno(), self._state)\n        except UnsatisfiableReadError as e:\n            gen_log.info(\"Unsatisfiable read, closing connection: %s\" % e)\n            self.close(exc_info=e)\n        except Exception as e:\n            gen_log.error(\"Uncaught exception, closing connection.\", exc_info=True)\n            self.close(exc_info=e)\n            raise",
        "begin_line": 680,
        "end_line": 731,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.023809523809523808,
            "pseudo_dstar_susp": 0.00303951367781155,
            "pseudo_tarantula_susp": 0.022222222222222223,
            "pseudo_op2_susp": 0.00303951367781155,
            "pseudo_barinel_susp": 0.022222222222222223
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._read_to_buffer_loop#733",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._read_to_buffer_loop(self)",
        "snippet": "    def _read_to_buffer_loop(self) -> Optional[int]:\n        # This method is called from _handle_read and _try_inline_read.\n        if self._read_bytes is not None:\n            target_bytes = self._read_bytes  # type: Optional[int]\n        elif self._read_max_bytes is not None:\n            target_bytes = self._read_max_bytes\n        elif self.reading():\n            # For read_until without max_bytes, or\n            # read_until_close, read as much as we can before\n            # scanning for the delimiter.\n            target_bytes = None\n        else:\n            target_bytes = 0\n        next_find_pos = 0\n        while not self.closed():\n            # Read from the socket until we get EWOULDBLOCK or equivalent.\n            # SSL sockets do some internal buffering, and if the data is\n            # sitting in the SSL object's buffer select() and friends\n            # can't see it; the only way to find out if it's there is to\n            # try to read it.\n            if self._read_to_buffer() == 0:\n                break\n\n            # If we've read all the bytes we can use, break out of\n            # this loop.\n\n            # If we've reached target_bytes, we know we're done.\n            if target_bytes is not None and self._read_buffer_size >= target_bytes:\n                break\n\n            # Otherwise, we need to call the more expensive find_read_pos.\n            # It's inefficient to do this on every read, so instead\n            # do it on the first read and whenever the read buffer\n            # size has doubled.\n            if self._read_buffer_size >= next_find_pos:\n                pos = self._find_read_pos()\n                if pos is not None:\n                    return pos\n                next_find_pos = self._read_buffer_size * 2\n        return self._find_read_pos()",
        "begin_line": 733,
        "end_line": 772,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.013888888888888888,
            "pseudo_dstar_susp": 0.03225806451612903,
            "pseudo_tarantula_susp": 0.005555555555555556,
            "pseudo_op2_susp": 0.03225806451612903,
            "pseudo_barinel_susp": 0.005555555555555556
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._handle_read#774",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._handle_read(self)",
        "snippet": "    def _handle_read(self) -> None:\n        try:\n            pos = self._read_to_buffer_loop()\n        except UnsatisfiableReadError:\n            raise\n        except Exception as e:\n            gen_log.warning(\"error on read: %s\" % e)\n            self.close(exc_info=e)\n            return\n        if pos is not None:\n            self._read_from_buffer(pos)",
        "begin_line": 774,
        "end_line": 784,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.023809523809523808,
            "pseudo_dstar_susp": 0.0028328611898017,
            "pseudo_tarantula_susp": 0.022222222222222223,
            "pseudo_op2_susp": 0.0028328611898017,
            "pseudo_barinel_susp": 0.022222222222222223
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._start_read#786",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._start_read(self)",
        "snippet": "    def _start_read(self) -> Future:\n        assert self._read_future is None, \"Already reading\"\n        self._read_future = Future()\n        return self._read_future",
        "begin_line": 786,
        "end_line": 789,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0044444444444444444,
            "pseudo_dstar_susp": 0.008928571428571428,
            "pseudo_tarantula_susp": 0.0018552875695732839,
            "pseudo_op2_susp": 0.008928571428571428,
            "pseudo_barinel_susp": 0.0018552875695732839
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._finish_read#791",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._finish_read(self, size: int, streaming: bool)",
        "snippet": "    def _finish_read(self, size: int, streaming: bool) -> None:\n        if self._user_read_buffer:\n            self._read_buffer = self._after_user_read_buffer or bytearray()\n            self._after_user_read_buffer = None\n            self._read_buffer_pos = 0\n            self._read_buffer_size = len(self._read_buffer)\n            self._user_read_buffer = False\n            result = size  # type: Union[int, bytes]\n        else:\n            result = self._consume(size)\n        if self._read_future is not None:\n            future = self._read_future\n            self._read_future = None\n            future.set_result(result)\n        self._maybe_add_error_listener()",
        "begin_line": 791,
        "end_line": 805,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012077294685990338,
            "pseudo_dstar_susp": 0.0017730496453900709,
            "pseudo_tarantula_susp": 0.0009940357852882703,
            "pseudo_op2_susp": 0.0017730496453900709,
            "pseudo_barinel_susp": 0.0009940357852882703
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._try_inline_read#807",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._try_inline_read(self)",
        "snippet": "    def _try_inline_read(self) -> None:\n        \"\"\"Attempt to complete the current read operation from buffered data.\n\n        If the read can be completed without blocking, schedules the\n        read callback on the next IOLoop iteration; otherwise starts\n        listening for reads on the socket.\n        \"\"\"\n        # See if we've already got the data from a previous read\n        pos = self._find_read_pos()\n        if pos is not None:\n            self._read_from_buffer(pos)\n            return\n        self._check_closed()\n        pos = self._read_to_buffer_loop()\n        if pos is not None:\n            self._read_from_buffer(pos)\n            return\n        # We couldn't satisfy the read inline, so make sure we're\n        # listening for new data unless the stream is closed.\n        if not self.closed():\n            self._add_io_state(ioloop.IOLoop.READ)",
        "begin_line": 807,
        "end_line": 827,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004739336492890996,
            "pseudo_dstar_susp": 0.01020408163265306,
            "pseudo_tarantula_susp": 0.0019193857965451055,
            "pseudo_op2_susp": 0.01020408163265306,
            "pseudo_barinel_susp": 0.0019193857965451055
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._read_to_buffer#829",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._read_to_buffer(self)",
        "snippet": "    def _read_to_buffer(self) -> Optional[int]:\n        \"\"\"Reads from the socket and appends the result to the read buffer.\n\n        Returns the number of bytes read.  Returns 0 if there is nothing\n        to read (i.e. the read returns EWOULDBLOCK or equivalent).  On\n        error closes the socket and raises an exception.\n        \"\"\"\n        try:\n            while True:\n                try:\n                    if self._user_read_buffer:\n                        buf = memoryview(self._read_buffer)[\n                            self._read_buffer_size :\n                        ]  # type: Union[memoryview, bytearray]\n                    else:\n                        buf = bytearray(self.read_chunk_size)\n                    bytes_read = self.read_from_fd(buf)\n                except (socket.error, IOError, OSError) as e:\n                    if errno_from_exception(e) == errno.EINTR:\n                        continue\n                    # ssl.SSLError is a subclass of socket.error\n                    if self._is_connreset(e):\n                        # Treat ECONNRESET as a connection close rather than\n                        # an error to minimize log spam  (the exception will\n                        # be available on self.error for apps that care).\n                        self.close(exc_info=e)\n                        return None\n                    self.close(exc_info=e)\n                    raise\n                break\n            if bytes_read is None:\n                return 0\n            elif bytes_read == 0:\n                self.close()\n                return 0\n            if not self._user_read_buffer:\n                self._read_buffer += memoryview(buf)[:bytes_read]\n            self._read_buffer_size += bytes_read\n        finally:\n            # Break the reference to buf so we don't waste a chunk's worth of\n            # memory in case an exception hangs on to our stack frame.\n            del buf\n        if self._read_buffer_size > self.max_buffer_size:\n            gen_log.error(\"Reached maximum read buffer size\")\n            self.close()\n            raise StreamBufferFullError(\"Reached maximum read buffer size\")\n        return bytes_read",
        "begin_line": 829,
        "end_line": 875,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.024390243902439025,
            "pseudo_tarantula_susp": 0.004347826086956522,
            "pseudo_op2_susp": 0.024390243902439025,
            "pseudo_barinel_susp": 0.004347826086956522
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._read_from_buffer#877",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._read_from_buffer(self, pos: int)",
        "snippet": "    def _read_from_buffer(self, pos: int) -> None:\n        \"\"\"Attempts to complete the currently-pending read from the buffer.\n\n        The argument is either a position in the read buffer or None,\n        as returned by _find_read_pos.\n        \"\"\"\n        self._read_bytes = self._read_delimiter = self._read_regex = None\n        self._read_partial = False\n        self._finish_read(pos, False)",
        "begin_line": 877,
        "end_line": 885,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012033694344163659,
            "pseudo_dstar_susp": 0.001763668430335097,
            "pseudo_tarantula_susp": 0.000980392156862745,
            "pseudo_op2_susp": 0.001763668430335097,
            "pseudo_barinel_susp": 0.000980392156862745
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._find_read_pos#887",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._find_read_pos(self)",
        "snippet": "    def _find_read_pos(self) -> Optional[int]:\n        \"\"\"Attempts to find a position in the read buffer that satisfies\n        the currently-pending read.\n\n        Returns a position in the buffer if the current read can be satisfied,\n        or None if it cannot.\n        \"\"\"\n        if self._read_bytes is not None and (\n            self._read_buffer_size >= self._read_bytes\n            or (self._read_partial and self._read_buffer_size > 0)\n        ):\n            num_bytes = min(self._read_bytes, self._read_buffer_size)\n            return num_bytes\n        elif self._read_delimiter is not None:\n            # Multi-byte delimiters (e.g. '\\r\\n') may straddle two\n            # chunks in the read buffer, so we can't easily find them\n            # without collapsing the buffer.  However, since protocols\n            # using delimited reads (as opposed to reads of a known\n            # length) tend to be \"line\" oriented, the delimiter is likely\n            # to be in the first few chunks.  Merge the buffer gradually\n            # since large merges are relatively expensive and get undone in\n            # _consume().\n            if self._read_buffer:\n                loc = self._read_buffer.find(\n                    self._read_delimiter, self._read_buffer_pos\n                )\n                if loc != -1:\n                    loc -= self._read_buffer_pos\n                    delimiter_len = len(self._read_delimiter)\n                    self._check_max_bytes(self._read_delimiter, loc + delimiter_len)\n                    return loc + delimiter_len\n                self._check_max_bytes(self._read_delimiter, self._read_buffer_size)\n        elif self._read_regex is not None:\n            if self._read_buffer:\n                m = self._read_regex.search(self._read_buffer, self._read_buffer_pos)\n                if m is not None:\n                    loc = m.end() - self._read_buffer_pos\n                    self._check_max_bytes(self._read_regex, loc)\n                    return loc\n                self._check_max_bytes(self._read_regex, self._read_buffer_size)\n        return None",
        "begin_line": 887,
        "end_line": 927,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009523809523809525,
            "pseudo_dstar_susp": 0.008130081300813009,
            "pseudo_tarantula_susp": 0.011235955056179775,
            "pseudo_op2_susp": 0.008130081300813009,
            "pseudo_barinel_susp": 0.011235955056179775
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._check_max_bytes#929",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._check_max_bytes(self, delimiter: Union[bytes, Pattern], size: int)",
        "snippet": "    def _check_max_bytes(self, delimiter: Union[bytes, Pattern], size: int) -> None:\n        if self._read_max_bytes is not None and size > self._read_max_bytes:\n            raise UnsatisfiableReadError(\n                \"delimiter %r not found within %d bytes\"\n                % (delimiter, self._read_max_bytes)\n            )",
        "begin_line": 929,
        "end_line": 934,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.25,
            "pseudo_dstar_susp": 0.034482758620689655,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.034482758620689655,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._handle_write#936",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._handle_write(self)",
        "snippet": "    def _handle_write(self) -> None:\n        while True:\n            size = len(self._write_buffer)\n            if not size:\n                break\n            assert size > 0\n            try:\n                if _WINDOWS:\n                    # On windows, socket.send blows up if given a\n                    # write buffer that's too large, instead of just\n                    # returning the number of bytes it was able to\n                    # process.  Therefore we must not call socket.send\n                    # with more than 128KB at a time.\n                    size = 128 * 1024\n\n                num_bytes = self.write_to_fd(self._write_buffer.peek(size))\n                if num_bytes == 0:\n                    break\n                self._write_buffer.advance(num_bytes)\n                self._total_write_done_index += num_bytes\n            except (socket.error, IOError, OSError) as e:\n                if e.args[0] in _ERRNO_WOULDBLOCK:\n                    break\n                else:\n                    if not self._is_connreset(e):\n                        # Broken pipe errors are usually caused by connection\n                        # reset, and its better to not log EPIPE errors to\n                        # minimize log spam\n                        gen_log.warning(\"Write error on %s: %s\", self.fileno(), e)\n                    self.close(exc_info=e)\n                    return\n\n        while self._write_futures:\n            index, future = self._write_futures[0]\n            if index > self._total_write_done_index:\n                break\n            self._write_futures.popleft()\n            future.set_result(None)",
        "begin_line": 936,
        "end_line": 973,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006060606060606061,
            "pseudo_dstar_susp": 0.019230769230769232,
            "pseudo_tarantula_susp": 0.0021231422505307855,
            "pseudo_op2_susp": 0.019230769230769232,
            "pseudo_barinel_susp": 0.0021231422505307855
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._consume#975",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._consume(self, loc: int)",
        "snippet": "    def _consume(self, loc: int) -> bytes:\n        # Consume loc bytes from the read buffer and return them\n        if loc == 0:\n            return b\"\"\n        assert loc <= self._read_buffer_size\n        # Slice the bytearray buffer into bytes, without intermediate copying\n        b = (\n            memoryview(self._read_buffer)[\n                self._read_buffer_pos : self._read_buffer_pos + loc\n            ]\n        ).tobytes()\n        self._read_buffer_pos += loc\n        self._read_buffer_size -= loc\n        # Amortized O(1) shrink\n        # (this heuristic is implemented natively in Python 3.4+\n        #  but is replicated here for Python 2)\n        if self._read_buffer_pos > self._read_buffer_size:\n            del self._read_buffer[: self._read_buffer_pos]\n            self._read_buffer_pos = 0\n        return b",
        "begin_line": 975,
        "end_line": 994,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001218026796589525,
            "pseudo_dstar_susp": 0.0017953321364452424,
            "pseudo_tarantula_susp": 0.0030864197530864196,
            "pseudo_op2_susp": 0.0017953321364452424,
            "pseudo_barinel_susp": 0.0030864197530864196
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._check_closed#996",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._check_closed(self)",
        "snippet": "    def _check_closed(self) -> None:\n        if self.closed():\n            raise StreamClosedError(real_error=self.error)",
        "begin_line": 996,
        "end_line": 998,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004608294930875576,
            "pseudo_dstar_susp": 0.009615384615384616,
            "pseudo_tarantula_susp": 0.0018832391713747645,
            "pseudo_op2_susp": 0.009615384615384616,
            "pseudo_barinel_susp": 0.0018832391713747645
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._maybe_add_error_listener#1000",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._maybe_add_error_listener(self)",
        "snippet": "    def _maybe_add_error_listener(self) -> None:\n        # This method is part of an optimization: to detect a connection that\n        # is closed when we're not actively reading or writing, we must listen\n        # for read events.  However, it is inefficient to do this when the\n        # connection is first established because we are going to read or write\n        # immediately anyway.  Instead, we insert checks at various times to\n        # see if the connection is idle and add the read listener then.\n        if self._state is None or self._state == ioloop.IOLoop.ERROR:\n            if (\n                not self.closed()\n                and self._read_buffer_size == 0\n                and self._close_callback is not None\n            ):\n                self._add_io_state(ioloop.IOLoop.READ)",
        "begin_line": 1000,
        "end_line": 1013,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00398406374501992,
            "pseudo_dstar_susp": 0.007462686567164179,
            "pseudo_tarantula_susp": 0.0024154589371980675,
            "pseudo_op2_susp": 0.007462686567164179,
            "pseudo_barinel_susp": 0.0024154589371980675
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._add_io_state#1015",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._add_io_state(self, state: int)",
        "snippet": "    def _add_io_state(self, state: int) -> None:\n        \"\"\"Adds `state` (IOLoop.{READ,WRITE} flags) to our event handler.\n\n        Implementation notes: Reads and writes have a fast path and a\n        slow path.  The fast path reads synchronously from socket\n        buffers, while the slow path uses `_add_io_state` to schedule\n        an IOLoop callback.\n\n        To detect closed connections, we must have called\n        `_add_io_state` at some point, but we want to delay this as\n        much as possible so we don't have to set an `IOLoop.ERROR`\n        listener that will be overwritten by the next slow-path\n        operation. If a sequence of fast-path ops do not end in a\n        slow-path op, (e.g. for an @asynchronous long-poll request),\n        we must add the error handler.\n\n        TODO: reevaluate this now that callbacks are gone.\n\n        \"\"\"\n        if self.closed():\n            # connection has been closed, so there can be no future events\n            return\n        if self._state is None:\n            self._state = ioloop.IOLoop.ERROR | state\n            self.io_loop.add_handler(self.fileno(), self._handle_events, self._state)\n        elif not self._state & state:\n            self._state = self._state | state\n            self.io_loop.update_handler(self.fileno(), self._state)",
        "begin_line": 1015,
        "end_line": 1042,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0038910505836575876,
            "pseudo_dstar_susp": 0.007142857142857143,
            "pseudo_tarantula_susp": 0.0017123287671232876,
            "pseudo_op2_susp": 0.007142857142857143,
            "pseudo_barinel_susp": 0.0017123287671232876
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._is_connreset#1044",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._is_connreset(self, exc: BaseException)",
        "snippet": "    def _is_connreset(self, exc: BaseException) -> bool:\n        \"\"\"Return true if exc is ECONNRESET or equivalent.\n\n        May be overridden in subclasses.\n        \"\"\"\n        return (\n            isinstance(exc, (socket.error, IOError))\n            and errno_from_exception(exc) in _ERRNO_CONNRESET\n        )",
        "begin_line": 1044,
        "end_line": 1052,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.iostream.IOStream.__init__#1103",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.__init__(self, socket: socket.socket, *args: Any, **kwargs: Any)",
        "snippet": "    def __init__(self, socket: socket.socket, *args: Any, **kwargs: Any) -> None:\n        self.socket = socket\n        self.socket.setblocking(False)\n        super(IOStream, self).__init__(*args, **kwargs)",
        "begin_line": 1103,
        "end_line": 1106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002061855670103093,
            "pseudo_dstar_susp": 0.002512562814070352,
            "pseudo_tarantula_susp": 0.0013123359580052493,
            "pseudo_op2_susp": 0.002512562814070352,
            "pseudo_barinel_susp": 0.0013123359580052493
        }
    },
    {
        "name": "tornado.iostream.IOStream.fileno#1108",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.fileno(self)",
        "snippet": "    def fileno(self) -> Union[int, ioloop._Selectable]:\n        return self.socket",
        "begin_line": 1108,
        "end_line": 1109,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020920502092050207,
            "pseudo_dstar_susp": 0.002544529262086514,
            "pseudo_tarantula_susp": 0.001321003963011889,
            "pseudo_op2_susp": 0.002544529262086514,
            "pseudo_barinel_susp": 0.001321003963011889
        }
    },
    {
        "name": "tornado.iostream.IOStream.close_fd#1111",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.close_fd(self)",
        "snippet": "    def close_fd(self) -> None:\n        self.socket.close()\n        self.socket = None  # type: ignore",
        "begin_line": 1111,
        "end_line": 1113,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00211864406779661,
            "pseudo_dstar_susp": 0.002570694087403599,
            "pseudo_tarantula_susp": 0.0013297872340425532,
            "pseudo_op2_susp": 0.002570694087403599,
            "pseudo_barinel_susp": 0.0013297872340425532
        }
    },
    {
        "name": "tornado.iostream.IOStream.read_from_fd#1119",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.read_from_fd(self, buf: Union[bytearray, memoryview])",
        "snippet": "    def read_from_fd(self, buf: Union[bytearray, memoryview]) -> Optional[int]:\n        try:\n            return self.socket.recv_into(buf, len(buf))\n        except socket.error as e:\n            if e.args[0] in _ERRNO_WOULDBLOCK:\n                return None\n            else:\n                raise\n        finally:\n            del buf",
        "begin_line": 1119,
        "end_line": 1128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011792452830188679,
            "pseudo_dstar_susp": 0.0016666666666666668,
            "pseudo_tarantula_susp": 0.0010893246187363835,
            "pseudo_op2_susp": 0.0016666666666666668,
            "pseudo_barinel_susp": 0.0010893246187363835
        }
    },
    {
        "name": "tornado.iostream.IOStream.write_to_fd#1130",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.write_to_fd(self, data: memoryview)",
        "snippet": "    def write_to_fd(self, data: memoryview) -> int:\n        try:\n            return self.socket.send(data)  # type: ignore\n        finally:\n            # Avoid keeping to data, which can be a memoryview.\n            # See https://github.com/tornadoweb/tornado/pull/2008\n            del data",
        "begin_line": 1130,
        "end_line": 1136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001184834123222749,
            "pseudo_dstar_susp": 0.0016778523489932886,
            "pseudo_tarantula_susp": 0.0010964912280701754,
            "pseudo_op2_susp": 0.0016778523489932886,
            "pseudo_barinel_susp": 0.0010964912280701754
        }
    },
    {
        "name": "tornado.iostream.IOStream.connect#1138",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.connect(self: _IOStreamType, address: tuple, server_hostname: str=None)",
        "snippet": "    def connect(\n        self: _IOStreamType, address: tuple, server_hostname: str = None\n    ) -> \"Future[_IOStreamType]\":\n        \"\"\"Connects the socket to a remote address without blocking.\n\n        May only be called if the socket passed to the constructor was\n        not previously connected.  The address parameter is in the\n        same format as for `socket.connect <socket.socket.connect>` for\n        the type of socket passed to the IOStream constructor,\n        e.g. an ``(ip, port)`` tuple.  Hostnames are accepted here,\n        but will be resolved synchronously and block the IOLoop.\n        If you have a hostname instead of an IP address, the `.TCPClient`\n        class is recommended instead of calling this method directly.\n        `.TCPClient` will do asynchronous DNS resolution and handle\n        both IPv4 and IPv6.\n\n        If ``callback`` is specified, it will be called with no\n        arguments when the connection is completed; if not this method\n        returns a `.Future` (whose result after a successful\n        connection will be the stream itself).\n\n        In SSL mode, the ``server_hostname`` parameter will be used\n        for certificate validation (unless disabled in the\n        ``ssl_options``) and SNI (if supported; requires Python\n        2.7.9+).\n\n        Note that it is safe to call `IOStream.write\n        <BaseIOStream.write>` while the connection is pending, in\n        which case the data will be written as soon as the connection\n        is ready.  Calling `IOStream` read methods before the socket is\n        connected works on some platforms but is non-portable.\n\n        .. versionchanged:: 4.0\n            If no callback is given, returns a `.Future`.\n\n        .. versionchanged:: 4.2\n           SSL certificates are validated by default; pass\n           ``ssl_options=dict(cert_reqs=ssl.CERT_NONE)`` or a\n           suitably-configured `ssl.SSLContext` to the\n           `SSLIOStream` constructor to disable.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned\n           `.Future` instead.\n\n        \"\"\"\n        self._connecting = True\n        future = Future()  # type: Future[_IOStreamType]\n        self._connect_future = typing.cast(\"Future[IOStream]\", future)\n        try:\n            self.socket.connect(address)\n        except socket.error as e:\n            # In non-blocking mode we expect connect() to raise an\n            # exception with EINPROGRESS or EWOULDBLOCK.\n            #\n            # On freebsd, other errors such as ECONNREFUSED may be\n            # returned immediately when attempting to connect to\n            # localhost, so handle them the same way as an error\n            # reported later in _handle_connect.\n            if (\n                errno_from_exception(e) not in _ERRNO_INPROGRESS\n                and errno_from_exception(e) not in _ERRNO_WOULDBLOCK\n            ):\n                if future is None:\n                    gen_log.warning(\n                        \"Connect error on fd %s: %s\", self.socket.fileno(), e\n                    )\n                self.close(exc_info=e)\n                return future\n        self._add_io_state(self.io_loop.WRITE)\n        return future",
        "begin_line": 1138,
        "end_line": 1209,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002188183807439825,
            "pseudo_dstar_susp": 0.0026595744680851063,
            "pseudo_tarantula_susp": 0.0013605442176870747,
            "pseudo_op2_susp": 0.0026595744680851063,
            "pseudo_barinel_susp": 0.0013605442176870747
        }
    },
    {
        "name": "tornado.iostream.IOStream.start_tls#1211",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.start_tls(self, server_side: bool, ssl_options: Union[Dict[str, Any], ssl.SSLContext]=None, server_hostname: str=None)",
        "snippet": "    def start_tls(\n        self,\n        server_side: bool,\n        ssl_options: Union[Dict[str, Any], ssl.SSLContext] = None,\n        server_hostname: str = None,\n    ) -> Awaitable[\"SSLIOStream\"]:\n        \"\"\"Convert this `IOStream` to an `SSLIOStream`.\n\n        This enables protocols that begin in clear-text mode and\n        switch to SSL after some initial negotiation (such as the\n        ``STARTTLS`` extension to SMTP and IMAP).\n\n        This method cannot be used if there are outstanding reads\n        or writes on the stream, or if there is any data in the\n        IOStream's buffer (data in the operating system's socket\n        buffer is allowed).  This means it must generally be used\n        immediately after reading or writing the last clear-text\n        data.  It can also be used immediately after connecting,\n        before any reads or writes.\n\n        The ``ssl_options`` argument may be either an `ssl.SSLContext`\n        object or a dictionary of keyword arguments for the\n        `ssl.wrap_socket` function.  The ``server_hostname`` argument\n        will be used for certificate validation unless disabled\n        in the ``ssl_options``.\n\n        This method returns a `.Future` whose result is the new\n        `SSLIOStream`.  After this method has been called,\n        any other operation on the original stream is undefined.\n\n        If a close callback is defined on this stream, it will be\n        transferred to the new stream.\n\n        .. versionadded:: 4.0\n\n        .. versionchanged:: 4.2\n           SSL certificates are validated by default; pass\n           ``ssl_options=dict(cert_reqs=ssl.CERT_NONE)`` or a\n           suitably-configured `ssl.SSLContext` to disable.\n        \"\"\"\n        if (\n            self._read_future\n            or self._write_futures\n            or self._connect_future\n            or self._closed\n            or self._read_buffer\n            or self._write_buffer\n        ):\n            raise ValueError(\"IOStream is not idle; cannot convert to SSL\")\n        if ssl_options is None:\n            if server_side:\n                ssl_options = _server_ssl_defaults\n            else:\n                ssl_options = _client_ssl_defaults\n\n        socket = self.socket\n        self.io_loop.remove_handler(socket)\n        self.socket = None  # type: ignore\n        socket = ssl_wrap_socket(\n            socket,\n            ssl_options,\n            server_hostname=server_hostname,\n            server_side=server_side,\n            do_handshake_on_connect=False,\n        )\n        orig_close_callback = self._close_callback\n        self._close_callback = None\n\n        future = Future()  # type: Future[SSLIOStream]\n        ssl_stream = SSLIOStream(socket, ssl_options=ssl_options)\n        ssl_stream.set_close_callback(orig_close_callback)\n        ssl_stream._ssl_connect_future = future\n        ssl_stream.max_buffer_size = self.max_buffer_size\n        ssl_stream.read_chunk_size = self.read_chunk_size\n        return future",
        "begin_line": 1211,
        "end_line": 1285,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004116920543433512,
            "pseudo_dstar_susp": 0.0004095004095004095,
            "pseudo_tarantula_susp": 0.00046992481203007516,
            "pseudo_op2_susp": 0.0004095004095004095,
            "pseudo_barinel_susp": 0.00046992481203007516
        }
    },
    {
        "name": "tornado.iostream.IOStream._handle_connect#1287",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream._handle_connect(self)",
        "snippet": "    def _handle_connect(self) -> None:\n        try:\n            err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n        except socket.error as e:\n            # Hurd doesn't allow SO_ERROR for loopback sockets because all\n            # errors for such sockets are reported synchronously.\n            if errno_from_exception(e) == errno.ENOPROTOOPT:\n                err = 0\n        if err != 0:\n            self.error = socket.error(err, os.strerror(err))\n            # IOLoop implementations may vary: some of them return\n            # an error state before the socket becomes writable, so\n            # in that case a connection failure would be handled by the\n            # error path in _handle_events instead of here.\n            if self._connect_future is None:\n                gen_log.warning(\n                    \"Connect error on fd %s: %s\",\n                    self.socket.fileno(),\n                    errno.errorcode[err],\n                )\n            self.close()\n            return\n        if self._connect_future is not None:\n            future = self._connect_future\n            self._connect_future = None\n            future.set_result(self)\n        self._connecting = False",
        "begin_line": 1287,
        "end_line": 1313,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002531645569620253,
            "pseudo_dstar_susp": 0.002777777777777778,
            "pseudo_tarantula_susp": 0.0013908205841446453,
            "pseudo_op2_susp": 0.002777777777777778,
            "pseudo_barinel_susp": 0.0013908205841446453
        }
    },
    {
        "name": "tornado.iostream.IOStream.set_nodelay#1315",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.set_nodelay(self, value: bool)",
        "snippet": "    def set_nodelay(self, value: bool) -> None:\n        if self.socket is not None and self.socket.family in (\n            socket.AF_INET,\n            socket.AF_INET6,\n        ):\n            try:\n                self.socket.setsockopt(\n                    socket.IPPROTO_TCP, socket.TCP_NODELAY, 1 if value else 0\n                )\n            except socket.error as e:\n                # Sometimes setsockopt will fail if the socket is closed\n                # at the wrong time.  This can happen with HTTPServer\n                # resetting the value to false between requests.\n                if e.errno != errno.EINVAL and not self._is_connreset(e):\n                    raise",
        "begin_line": 1315,
        "end_line": 1329,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006459948320413437,
            "pseudo_dstar_susp": 0.0007446016381236039,
            "pseudo_tarantula_susp": 0.0005611672278338945,
            "pseudo_op2_susp": 0.0007446016381236039,
            "pseudo_barinel_susp": 0.0005611672278338945
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream.__init__#1346",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream.__init__(self, *args: Any, **kwargs: Any)",
        "snippet": "    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"The ``ssl_options`` keyword argument may either be an\n        `ssl.SSLContext` object or a dictionary of keywords arguments\n        for `ssl.wrap_socket`\n        \"\"\"\n        self._ssl_options = kwargs.pop(\"ssl_options\", _client_ssl_defaults)\n        super(SSLIOStream, self).__init__(*args, **kwargs)\n        self._ssl_accepting = True\n        self._handshake_reading = False\n        self._handshake_writing = False\n        self._server_hostname = None  # type: Optional[str]\n\n        # If the socket is already connected, attempt to start the handshake.\n        try:\n            self.socket.getpeername()\n        except socket.error:\n            pass\n        else:\n            # Indirectly start the handshake, which will run on the next\n            # IOLoop iteration and then the real IO state will be set in\n            # _handle_events.\n            self._add_io_state(self.io_loop.WRITE)",
        "begin_line": 1346,
        "end_line": 1367,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002717391304347826,
            "pseudo_dstar_susp": 0.0008787346221441124,
            "pseudo_tarantula_susp": 0.004694835680751174,
            "pseudo_op2_susp": 0.0008787346221441124,
            "pseudo_barinel_susp": 0.004694835680751174
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream.reading#1369",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream.reading(self)",
        "snippet": "    def reading(self) -> bool:\n        return self._handshake_reading or super(SSLIOStream, self).reading()",
        "begin_line": 1369,
        "end_line": 1370,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013089005235602095,
            "pseudo_dstar_susp": 0.0008787346221441124,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0008787346221441124,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream.writing#1372",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream.writing(self)",
        "snippet": "    def writing(self) -> bool:\n        return self._handshake_writing or super(SSLIOStream, self).writing()",
        "begin_line": 1372,
        "end_line": 1373,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013089005235602095,
            "pseudo_dstar_susp": 0.0008787346221441124,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0008787346221441124,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream._do_ssl_handshake#1375",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream._do_ssl_handshake(self)",
        "snippet": "    def _do_ssl_handshake(self) -> None:\n        # Based on code from test_ssl.py in the python stdlib\n        try:\n            self._handshake_reading = False\n            self._handshake_writing = False\n            self.socket.do_handshake()\n        except ssl.SSLError as err:\n            if err.args[0] == ssl.SSL_ERROR_WANT_READ:\n                self._handshake_reading = True\n                return\n            elif err.args[0] == ssl.SSL_ERROR_WANT_WRITE:\n                self._handshake_writing = True\n                return\n            elif err.args[0] in (ssl.SSL_ERROR_EOF, ssl.SSL_ERROR_ZERO_RETURN):\n                return self.close(exc_info=err)\n            elif err.args[0] == ssl.SSL_ERROR_SSL:\n                try:\n                    peer = self.socket.getpeername()\n                except Exception:\n                    peer = \"(not connected)\"\n                gen_log.warning(\n                    \"SSL Error on %s %s: %s\", self.socket.fileno(), peer, err\n                )\n                return self.close(exc_info=err)\n            raise\n        except socket.error as err:\n            # Some port scans (e.g. nmap in -sT mode) have been known\n            # to cause do_handshake to raise EBADF and ENOTCONN, so make\n            # those errors quiet as well.\n            # https://groups.google.com/forum/?fromgroups#!topic/python-tornado/ApucKJat1_0\n            # Errno 0 is also possible in some cases (nc -z).\n            # https://github.com/tornadoweb/tornado/issues/2504\n            if self._is_connreset(err) or err.args[0] in (\n                0,\n                errno.EBADF,\n                errno.ENOTCONN,\n            ):\n                return self.close(exc_info=err)\n            raise\n        except AttributeError as err:\n            # On Linux, if the connection was reset before the call to\n            # wrap_socket, do_handshake will fail with an\n            # AttributeError.\n            return self.close(exc_info=err)\n        else:\n            self._ssl_accepting = False\n            if not self._verify_cert(self.socket.getpeercert()):\n                self.close()\n                return\n            self._finish_ssl_connect()",
        "begin_line": 1375,
        "end_line": 1424,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013774104683195593,
            "pseudo_dstar_susp": 0.0009033423667570009,
            "pseudo_tarantula_susp": 0.0029585798816568047,
            "pseudo_op2_susp": 0.0009033423667570009,
            "pseudo_barinel_susp": 0.0029585798816568047
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream._finish_ssl_connect#1426",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream._finish_ssl_connect(self)",
        "snippet": "    def _finish_ssl_connect(self) -> None:\n        if self._ssl_connect_future is not None:\n            future = self._ssl_connect_future\n            self._ssl_connect_future = None\n            future.set_result(self)",
        "begin_line": 1426,
        "end_line": 1430,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013774104683195593,
            "pseudo_dstar_susp": 0.0009033423667570009,
            "pseudo_tarantula_susp": 0.0029585798816568047,
            "pseudo_op2_susp": 0.0009033423667570009,
            "pseudo_barinel_susp": 0.0029585798816568047
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream._verify_cert#1432",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream._verify_cert(self, peercert: Any)",
        "snippet": "    def _verify_cert(self, peercert: Any) -> bool:\n        \"\"\"Returns True if peercert is valid according to the configured\n        validation mode and hostname.\n\n        The ssl handshake already tested the certificate for a valid\n        CA signature; the only thing that remains is to check\n        the hostname.\n        \"\"\"\n        if isinstance(self._ssl_options, dict):\n            verify_mode = self._ssl_options.get(\"cert_reqs\", ssl.CERT_NONE)\n        elif isinstance(self._ssl_options, ssl.SSLContext):\n            verify_mode = self._ssl_options.verify_mode\n        assert verify_mode in (ssl.CERT_NONE, ssl.CERT_REQUIRED, ssl.CERT_OPTIONAL)\n        if verify_mode == ssl.CERT_NONE or self._server_hostname is None:\n            return True\n        cert = self.socket.getpeercert()\n        if cert is None and verify_mode == ssl.CERT_REQUIRED:\n            gen_log.warning(\"No SSL certificate given\")\n            return False\n        try:\n            ssl.match_hostname(peercert, self._server_hostname)\n        except ssl.CertificateError as e:\n            gen_log.warning(\"Invalid SSL certificate: %s\" % e)\n            return False\n        else:\n            return True",
        "begin_line": 1432,
        "end_line": 1457,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013986013986013986,
            "pseudo_dstar_susp": 0.0009107468123861566,
            "pseudo_tarantula_susp": 0.0034965034965034965,
            "pseudo_op2_susp": 0.0009107468123861566,
            "pseudo_barinel_susp": 0.0034965034965034965
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream._handle_read#1459",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream._handle_read(self)",
        "snippet": "    def _handle_read(self) -> None:\n        if self._ssl_accepting:\n            self._do_ssl_handshake()\n            return\n        super(SSLIOStream, self)._handle_read()",
        "begin_line": 1459,
        "end_line": 1463,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013774104683195593,
            "pseudo_dstar_susp": 0.0009033423667570009,
            "pseudo_tarantula_susp": 0.0029585798816568047,
            "pseudo_op2_susp": 0.0009033423667570009,
            "pseudo_barinel_susp": 0.0029585798816568047
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream._handle_write#1465",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream._handle_write(self)",
        "snippet": "    def _handle_write(self) -> None:\n        if self._ssl_accepting:\n            self._do_ssl_handshake()\n            return\n        super(SSLIOStream, self)._handle_write()",
        "begin_line": 1465,
        "end_line": 1469,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014326647564469914,
            "pseudo_dstar_susp": 0.0009140767824497258,
            "pseudo_tarantula_susp": 0.003289473684210526,
            "pseudo_op2_susp": 0.0009140767824497258,
            "pseudo_barinel_susp": 0.003289473684210526
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream.connect#1471",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream.connect(self, address: Tuple, server_hostname: str=None)",
        "snippet": "    def connect(\n        self, address: Tuple, server_hostname: str = None\n    ) -> \"Future[SSLIOStream]\":\n        self._server_hostname = server_hostname\n        # Ignore the result of connect(). If it fails,\n        # wait_for_handshake will raise an error too. This is\n        # necessary for the old semantics of the connect callback\n        # (which takes no arguments). In 6.0 this can be refactored to\n        # be a regular coroutine.\n        # TODO: This is trickier than it looks, since if write()\n        # is called with a connect() pending, we want the connect\n        # to resolve before the write. Or do we care about this?\n        # (There's a test for it, but I think in practice users\n        # either wait for the connect before performing a write or\n        # they don't care about the connect Future at all)\n        fut = super(SSLIOStream, self).connect(address)\n        fut.add_done_callback(lambda f: f.exception())\n        return self.wait_for_handshake()",
        "begin_line": 1471,
        "end_line": 1488,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.013157894736842105,
            "pseudo_dstar_susp": 0.001718213058419244,
            "pseudo_tarantula_susp": 0.004694835680751174,
            "pseudo_op2_susp": 0.001718213058419244,
            "pseudo_barinel_susp": 0.004694835680751174
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream._handle_connect#1490",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream._handle_connect(self)",
        "snippet": "    def _handle_connect(self) -> None:\n        # Call the superclass method to check for errors.\n        super(SSLIOStream, self)._handle_connect()\n        if self.closed():\n            return\n        # When the connection is complete, wrap the socket for SSL\n        # traffic.  Note that we do this by overriding _handle_connect\n        # instead of by passing a callback to super().connect because\n        # user callbacks are enqueued asynchronously on the IOLoop,\n        # but since _handle_events calls _handle_connect immediately\n        # followed by _handle_write we need this to be synchronous.\n        #\n        # The IOLoop will get confused if we swap out self.socket while the\n        # fd is registered, so remove it now and re-register after\n        # wrap_socket().\n        self.io_loop.remove_handler(self.socket)\n        old_state = self._state\n        assert old_state is not None\n        self._state = None\n        self.socket = ssl_wrap_socket(\n            self.socket,\n            self._ssl_options,\n            server_hostname=self._server_hostname,\n            do_handshake_on_connect=False,\n        )\n        self._add_io_state(old_state)",
        "begin_line": 1490,
        "end_line": 1515,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002717391304347826,
            "pseudo_dstar_susp": 0.0008103727714748784,
            "pseudo_tarantula_susp": 0.004694835680751174,
            "pseudo_op2_susp": 0.0008103727714748784,
            "pseudo_barinel_susp": 0.004694835680751174
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream.wait_for_handshake#1517",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream.wait_for_handshake(self)",
        "snippet": "    def wait_for_handshake(self) -> \"Future[SSLIOStream]\":\n        \"\"\"Wait for the initial SSL handshake to complete.\n\n        If a ``callback`` is given, it will be called with no\n        arguments once the handshake is complete; otherwise this\n        method returns a `.Future` which will resolve to the\n        stream itself after the handshake is complete.\n\n        Once the handshake is complete, information such as\n        the peer's certificate and NPN/ALPN selections may be\n        accessed on ``self.socket``.\n\n        This method is intended for use on server-side streams\n        or after using `IOStream.start_tls`; it should not be used\n        with `IOStream.connect` (which already waits for the\n        handshake to complete). It may only be called once per stream.\n\n        .. versionadded:: 4.2\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned\n           `.Future` instead.\n\n        \"\"\"\n        if self._ssl_connect_future is not None:\n            raise RuntimeError(\"Already waiting\")\n        future = self._ssl_connect_future = Future()\n        if not self._ssl_accepting:\n            self._finish_ssl_connect()\n        return future",
        "begin_line": 1517,
        "end_line": 1547,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002717391304347826,
            "pseudo_dstar_susp": 0.0008103727714748784,
            "pseudo_tarantula_susp": 0.004694835680751174,
            "pseudo_op2_susp": 0.0008103727714748784,
            "pseudo_barinel_susp": 0.004694835680751174
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream.write_to_fd#1549",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream.write_to_fd(self, data: memoryview)",
        "snippet": "    def write_to_fd(self, data: memoryview) -> int:\n        try:\n            return self.socket.send(data)  # type: ignore\n        except ssl.SSLError as e:\n            if e.args[0] == ssl.SSL_ERROR_WANT_WRITE:\n                # In Python 3.5+, SSLSocket.send raises a WANT_WRITE error if\n                # the socket is not writeable; we need to transform this into\n                # an EWOULDBLOCK socket.error or a zero return value,\n                # either of which will be recognized by the caller of this\n                # method. Prior to Python 3.5, an unwriteable socket would\n                # simply return 0 bytes written.\n                return 0\n            raise\n        finally:\n            # Avoid keeping to data, which can be a memoryview.\n            # See https://github.com/tornadoweb/tornado/pull/2008\n            del data",
        "begin_line": 1549,
        "end_line": 1565,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014577259475218659,
            "pseudo_dstar_susp": 0.0009165902841429881,
            "pseudo_tarantula_susp": 0.0033333333333333335,
            "pseudo_op2_susp": 0.0009165902841429881,
            "pseudo_barinel_susp": 0.0033333333333333335
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream.read_from_fd#1567",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream.read_from_fd(self, buf: Union[bytearray, memoryview])",
        "snippet": "    def read_from_fd(self, buf: Union[bytearray, memoryview]) -> Optional[int]:\n        try:\n            if self._ssl_accepting:\n                # If the handshake hasn't finished yet, there can't be anything\n                # to read (attempting to read may or may not raise an exception\n                # depending on the SSL version)\n                return None\n            try:\n                return self.socket.recv_into(buf, len(buf))\n            except ssl.SSLError as e:\n                # SSLError is a subclass of socket.error, so this except\n                # block must come first.\n                if e.args[0] == ssl.SSL_ERROR_WANT_READ:\n                    return None\n                else:\n                    raise\n            except socket.error as e:\n                if e.args[0] in _ERRNO_WOULDBLOCK:\n                    return None\n                else:\n                    raise\n        finally:\n            del buf",
        "begin_line": 1567,
        "end_line": 1589,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014144271570014145,
            "pseudo_dstar_susp": 0.0009124087591240876,
            "pseudo_tarantula_susp": 0.0030581039755351682,
            "pseudo_op2_susp": 0.0009124087591240876,
            "pseudo_barinel_susp": 0.0030581039755351682
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream._is_connreset#1591",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream._is_connreset(self, e: BaseException)",
        "snippet": "    def _is_connreset(self, e: BaseException) -> bool:\n        if isinstance(e, ssl.SSLError) and e.args[0] == ssl.SSL_ERROR_EOF:\n            return True\n        return super(SSLIOStream, self)._is_connreset(e)",
        "begin_line": 1591,
        "end_line": 1594,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.iostream.PipeIOStream.__init__#1606",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.PipeIOStream",
        "signature": "tornado.iostream.PipeIOStream.__init__(self, fd: int, *args: Any, **kwargs: Any)",
        "snippet": "    def __init__(self, fd: int, *args: Any, **kwargs: Any) -> None:\n        self.fd = fd\n        self._fio = io.FileIO(self.fd, \"r+\")\n        _set_nonblocking(fd)\n        super(PipeIOStream, self).__init__(*args, **kwargs)",
        "begin_line": 1606,
        "end_line": 1610,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012406947890818859,
            "pseudo_dstar_susp": 0.0005254860746190226,
            "pseudo_tarantula_susp": 0.0053475935828877,
            "pseudo_op2_susp": 0.0005254860746190226,
            "pseudo_barinel_susp": 0.0053475935828877
        }
    },
    {
        "name": "tornado.iostream.PipeIOStream.fileno#1612",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.PipeIOStream",
        "signature": "tornado.iostream.PipeIOStream.fileno(self)",
        "snippet": "    def fileno(self) -> int:\n        return self.fd",
        "begin_line": 1612,
        "end_line": 1613,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001394700139470014,
            "pseudo_dstar_susp": 0.0005293806246691371,
            "pseudo_tarantula_susp": 0.0064516129032258064,
            "pseudo_op2_susp": 0.0005293806246691371,
            "pseudo_barinel_susp": 0.006493506493506494
        }
    },
    {
        "name": "tornado.iostream.PipeIOStream.close_fd#1615",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.PipeIOStream",
        "signature": "tornado.iostream.PipeIOStream.close_fd(self)",
        "snippet": "    def close_fd(self) -> None:\n        self._fio.close()",
        "begin_line": 1615,
        "end_line": 1616,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012406947890818859,
            "pseudo_dstar_susp": 0.0005254860746190226,
            "pseudo_tarantula_susp": 0.0053475935828877,
            "pseudo_op2_susp": 0.0005254860746190226,
            "pseudo_barinel_susp": 0.0053475935828877
        }
    },
    {
        "name": "tornado.iostream.PipeIOStream.write_to_fd#1618",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.PipeIOStream",
        "signature": "tornado.iostream.PipeIOStream.write_to_fd(self, data: memoryview)",
        "snippet": "    def write_to_fd(self, data: memoryview) -> int:\n        try:\n            return os.write(self.fd, data)  # type: ignore\n        finally:\n            # Avoid keeping to data, which can be a memoryview.\n            # See https://github.com/tornadoweb/tornado/pull/2008\n            del data",
        "begin_line": 1618,
        "end_line": 1624,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013531799729364006,
            "pseudo_dstar_susp": 0.0005285412262156448,
            "pseudo_tarantula_susp": 0.006060606060606061,
            "pseudo_op2_susp": 0.0005285412262156448,
            "pseudo_barinel_susp": 0.006060606060606061
        }
    },
    {
        "name": "tornado.iostream.PipeIOStream.read_from_fd#1626",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.PipeIOStream",
        "signature": "tornado.iostream.PipeIOStream.read_from_fd(self, buf: Union[bytearray, memoryview])",
        "snippet": "    def read_from_fd(self, buf: Union[bytearray, memoryview]) -> Optional[int]:\n        try:\n            return self._fio.readinto(buf)  # type: ignore\n        except (IOError, OSError) as e:\n            if errno_from_exception(e) == errno.EBADF:\n                # If the writing half of a pipe is closed, select will\n                # report it as readable but reads will fail with EBADF.\n                self.close(exc_info=e)\n                return None\n            else:\n                raise\n        finally:\n            del buf",
        "begin_line": 1626,
        "end_line": 1638,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012626262626262627,
            "pseudo_dstar_susp": 0.0005271481286241434,
            "pseudo_tarantula_susp": 0.005681818181818182,
            "pseudo_op2_susp": 0.0005271481286241434,
            "pseudo_barinel_susp": 0.005681818181818182
        }
    },
    {
        "name": "tornado.routing.Router.start_request#207",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.Router",
        "signature": "tornado.routing.Router.start_request(self, server_conn: object, request_conn: httputil.HTTPConnection)",
        "snippet": "    def start_request(\n        self, server_conn: object, request_conn: httputil.HTTPConnection\n    ) -> httputil.HTTPMessageDelegate:\n        return _RoutingDelegate(self, server_conn, request_conn)",
        "begin_line": 207,
        "end_line": 210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000877963125548727,
            "pseudo_dstar_susp": 0.0011441647597254005,
            "pseudo_tarantula_susp": 0.0008071025020177562,
            "pseudo_op2_susp": 0.0011441647597254005,
            "pseudo_barinel_susp": 0.0008071025020177562
        }
    },
    {
        "name": "tornado.routing._RoutingDelegate.__init__#230",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing._RoutingDelegate",
        "signature": "tornado.routing._RoutingDelegate.__init__(self, router: Router, server_conn: object, request_conn: httputil.HTTPConnection)",
        "snippet": "    def __init__(\n        self, router: Router, server_conn: object, request_conn: httputil.HTTPConnection\n    ) -> None:\n        self.server_conn = server_conn\n        self.request_conn = request_conn\n        self.delegate = None  # type: Optional[httputil.HTTPMessageDelegate]\n        self.router = router  # type: Router",
        "begin_line": 230,
        "end_line": 236,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000877963125548727,
            "pseudo_dstar_susp": 0.0011441647597254005,
            "pseudo_tarantula_susp": 0.0008071025020177562,
            "pseudo_op2_susp": 0.0011441647597254005,
            "pseudo_barinel_susp": 0.0008071025020177562
        }
    },
    {
        "name": "tornado.routing._RoutingDelegate.headers_received#238",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing._RoutingDelegate",
        "signature": "tornado.routing._RoutingDelegate.headers_received(self, start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine], headers: httputil.HTTPHeaders)",
        "snippet": "    def headers_received(\n        self,\n        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],\n        headers: httputil.HTTPHeaders,\n    ) -> Optional[Awaitable[None]]:\n        assert isinstance(start_line, httputil.RequestStartLine)\n        request = httputil.HTTPServerRequest(\n            connection=self.request_conn,\n            server_connection=self.server_conn,\n            start_line=start_line,\n            headers=headers,\n        )\n\n        self.delegate = self.router.find_handler(request)\n        if self.delegate is None:\n            app_log.debug(\n                \"Delegate for %s %s request not found\",\n                start_line.method,\n                start_line.path,\n            )\n            self.delegate = _DefaultMessageDelegate(self.request_conn)\n\n        return self.delegate.headers_received(start_line, headers)",
        "begin_line": 238,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006684491978609625,
            "pseudo_dstar_susp": 0.0007692307692307692,
            "pseudo_tarantula_susp": 0.0006153846153846154,
            "pseudo_op2_susp": 0.0007692307692307692,
            "pseudo_barinel_susp": 0.0006153846153846154
        }
    },
    {
        "name": "tornado.routing._RoutingDelegate.data_received#262",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing._RoutingDelegate",
        "signature": "tornado.routing._RoutingDelegate.data_received(self, chunk: bytes)",
        "snippet": "    def data_received(self, chunk: bytes) -> Optional[Awaitable[None]]:\n        assert self.delegate is not None\n        return self.delegate.data_received(chunk)",
        "begin_line": 262,
        "end_line": 264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004014452027298274,
            "pseudo_dstar_susp": 0.0004014452027298274,
            "pseudo_tarantula_susp": 0.0004297378599054577,
            "pseudo_op2_susp": 0.0004014452027298274,
            "pseudo_barinel_susp": 0.0004297378599054577
        }
    },
    {
        "name": "tornado.routing._RoutingDelegate.finish#266",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing._RoutingDelegate",
        "signature": "tornado.routing._RoutingDelegate.finish(self)",
        "snippet": "    def finish(self) -> None:\n        assert self.delegate is not None\n        self.delegate.finish()",
        "begin_line": 266,
        "end_line": 268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00045641259698767686,
            "pseudo_dstar_susp": 0.0004997501249375312,
            "pseudo_tarantula_susp": 0.0004317789291882556,
            "pseudo_op2_susp": 0.0004997501249375312,
            "pseudo_barinel_susp": 0.0004317789291882556
        }
    },
    {
        "name": "tornado.routing._RoutingDelegate.on_connection_close#270",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing._RoutingDelegate",
        "signature": "tornado.routing._RoutingDelegate.on_connection_close(self)",
        "snippet": "    def on_connection_close(self) -> None:\n        assert self.delegate is not None\n        self.delegate.on_connection_close()",
        "begin_line": 270,
        "end_line": 272,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009900990099009901,
            "pseudo_dstar_susp": 0.0005341880341880342,
            "pseudo_tarantula_susp": 0.014925373134328358,
            "pseudo_op2_susp": 0.0005341880341880342,
            "pseudo_barinel_susp": 0.014925373134328358
        }
    },
    {
        "name": "tornado.routing._DefaultMessageDelegate.__init__#276",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing._DefaultMessageDelegate",
        "signature": "tornado.routing._DefaultMessageDelegate.__init__(self, connection: httputil.HTTPConnection)",
        "snippet": "    def __init__(self, connection: httputil.HTTPConnection) -> None:\n        self.connection = connection",
        "begin_line": 276,
        "end_line": 277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.routing._DefaultMessageDelegate.finish#279",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing._DefaultMessageDelegate",
        "signature": "tornado.routing._DefaultMessageDelegate.finish(self)",
        "snippet": "    def finish(self) -> None:\n        self.connection.write_headers(\n            httputil.ResponseStartLine(\"HTTP/1.1\", 404, \"Not Found\"),\n            httputil.HTTPHeaders(),\n        )\n        self.connection.finish()",
        "begin_line": 279,
        "end_line": 284,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.routing.RuleRouter.__init__#303",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.RuleRouter",
        "signature": "tornado.routing.RuleRouter.__init__(self, rules: _RuleList=None)",
        "snippet": "    def __init__(self, rules: _RuleList = None) -> None:\n        \"\"\"Constructs a router from an ordered list of rules::\n\n            RuleRouter([\n                Rule(PathMatches(\"/handler\"), Target),\n                # ... more rules\n            ])\n\n        You can also omit explicit `Rule` constructor and use tuples of arguments::\n\n            RuleRouter([\n                (PathMatches(\"/handler\"), Target),\n            ])\n\n        `PathMatches` is a default matcher, so the example above can be simplified::\n\n            RuleRouter([\n                (\"/handler\", Target),\n            ])\n\n        In the examples above, ``Target`` can be a nested `Router` instance, an instance of\n        `~.httputil.HTTPServerConnectionDelegate` or an old-style callable,\n        accepting a request argument.\n\n        :arg rules: a list of `Rule` instances or tuples of `Rule`\n            constructor arguments.\n        \"\"\"\n        self.rules = []  # type: List[Rule]\n        if rules:\n            self.add_rules(rules)",
        "begin_line": 303,
        "end_line": 332,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008326394671107411,
            "pseudo_dstar_susp": 0.001072961373390558,
            "pseudo_tarantula_susp": 0.0007518796992481203,
            "pseudo_op2_susp": 0.001072961373390558,
            "pseudo_barinel_susp": 0.0007518796992481203
        }
    },
    {
        "name": "tornado.routing.RuleRouter.add_rules#334",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.RuleRouter",
        "signature": "tornado.routing.RuleRouter.add_rules(self, rules: _RuleList)",
        "snippet": "    def add_rules(self, rules: _RuleList) -> None:\n        \"\"\"Appends new rules to the router.\n\n        :arg rules: a list of Rule instances (or tuples of arguments, which are\n            passed to Rule constructor).\n        \"\"\"\n        for rule in rules:\n            if isinstance(rule, (tuple, list)):\n                assert len(rule) in (2, 3, 4)\n                if isinstance(rule[0], basestring_type):\n                    rule = Rule(PathMatches(rule[0]), *rule[1:])\n                else:\n                    rule = Rule(*rule)\n\n            self.rules.append(self.process_rule(rule))",
        "begin_line": 334,
        "end_line": 348,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010695187165775401,
            "pseudo_dstar_susp": 0.001072961373390558,
            "pseudo_tarantula_susp": 0.0009652509652509653,
            "pseudo_op2_susp": 0.001072961373390558,
            "pseudo_barinel_susp": 0.0009652509652509653
        }
    },
    {
        "name": "tornado.routing.RuleRouter.process_rule#350",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.RuleRouter",
        "signature": "tornado.routing.RuleRouter.process_rule(self, rule: 'Rule')",
        "snippet": "    def process_rule(self, rule: \"Rule\") -> \"Rule\":\n        \"\"\"Override this method for additional preprocessing of each rule.\n\n        :arg Rule rule: a rule to be processed.\n        :returns: the same or modified Rule instance.\n        \"\"\"\n        return rule",
        "begin_line": 350,
        "end_line": 356,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008326394671107411,
            "pseudo_dstar_susp": 0.001072961373390558,
            "pseudo_tarantula_susp": 0.0007518796992481203,
            "pseudo_op2_susp": 0.001072961373390558,
            "pseudo_barinel_susp": 0.0007518796992481203
        }
    },
    {
        "name": "tornado.routing.RuleRouter.find_handler#358",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.RuleRouter",
        "signature": "tornado.routing.RuleRouter.find_handler(self, request: httputil.HTTPServerRequest, **kwargs: Any)",
        "snippet": "    def find_handler(\n        self, request: httputil.HTTPServerRequest, **kwargs: Any\n    ) -> Optional[httputil.HTTPMessageDelegate]:\n        for rule in self.rules:\n            target_params = rule.matcher.match(request)\n            if target_params is not None:\n                if rule.target_kwargs:\n                    target_params[\"target_kwargs\"] = rule.target_kwargs\n\n                delegate = self.get_target_delegate(\n                    rule.target, request, **target_params\n                )\n\n                if delegate is not None:\n                    return delegate\n\n        return None",
        "begin_line": 358,
        "end_line": 374,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006915629322268327,
            "pseudo_dstar_susp": 0.0008,
            "pseudo_tarantula_susp": 0.0006381620931716656,
            "pseudo_op2_susp": 0.0008,
            "pseudo_barinel_susp": 0.0006381620931716656
        }
    },
    {
        "name": "tornado.routing.RuleRouter.get_target_delegate#376",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.RuleRouter",
        "signature": "tornado.routing.RuleRouter.get_target_delegate(self, target: Any, request: httputil.HTTPServerRequest, **target_params: Any)",
        "snippet": "    def get_target_delegate(\n        self, target: Any, request: httputil.HTTPServerRequest, **target_params: Any\n    ) -> Optional[httputil.HTTPMessageDelegate]:\n        \"\"\"Returns an instance of `~.httputil.HTTPMessageDelegate` for a\n        Rule's target. This method is called by `~.find_handler` and can be\n        extended to provide additional target types.\n\n        :arg target: a Rule's target.\n        :arg httputil.HTTPServerRequest request: current request.\n        :arg target_params: additional parameters that can be useful\n            for `~.httputil.HTTPMessageDelegate` creation.\n        \"\"\"\n        if isinstance(target, Router):\n            return target.find_handler(request, **target_params)\n\n        elif isinstance(target, httputil.HTTPServerConnectionDelegate):\n            assert request.connection is not None\n            return target.start_request(request.server_connection, request.connection)\n\n        elif callable(target):\n            assert request.connection is not None\n            return _CallableAdapter(\n                partial(target, **target_params), request.connection\n            )\n\n        return None",
        "begin_line": 376,
        "end_line": 401,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006844626967830253,
            "pseudo_dstar_susp": 0.0007905138339920949,
            "pseudo_tarantula_susp": 0.0006297229219143577,
            "pseudo_op2_susp": 0.0007905138339920949,
            "pseudo_barinel_susp": 0.0006297229219143577
        }
    },
    {
        "name": "tornado.routing.ReversibleRuleRouter.__init__#412",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.ReversibleRuleRouter",
        "signature": "tornado.routing.ReversibleRuleRouter.__init__(self, rules: _RuleList=None)",
        "snippet": "    def __init__(self, rules: _RuleList = None) -> None:\n        self.named_rules = {}  # type: Dict[str, Any]\n        super(ReversibleRuleRouter, self).__init__(rules)",
        "begin_line": 412,
        "end_line": 414,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008326394671107411,
            "pseudo_dstar_susp": 0.001072961373390558,
            "pseudo_tarantula_susp": 0.0007518796992481203,
            "pseudo_op2_susp": 0.001072961373390558,
            "pseudo_barinel_susp": 0.0007518796992481203
        }
    },
    {
        "name": "tornado.routing.ReversibleRuleRouter.process_rule#416",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.ReversibleRuleRouter",
        "signature": "tornado.routing.ReversibleRuleRouter.process_rule(self, rule: 'Rule')",
        "snippet": "    def process_rule(self, rule: \"Rule\") -> \"Rule\":\n        rule = super(ReversibleRuleRouter, self).process_rule(rule)\n\n        if rule.name:\n            if rule.name in self.named_rules:\n                app_log.warning(\n                    \"Multiple handlers named %s; replacing previous value\", rule.name\n                )\n            self.named_rules[rule.name] = rule\n\n        return rule",
        "begin_line": 416,
        "end_line": 426,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008326394671107411,
            "pseudo_dstar_susp": 0.001072961373390558,
            "pseudo_tarantula_susp": 0.0007518796992481203,
            "pseudo_op2_susp": 0.001072961373390558,
            "pseudo_barinel_susp": 0.0007518796992481203
        }
    },
    {
        "name": "tornado.routing.ReversibleRuleRouter.reverse_url#428",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.ReversibleRuleRouter",
        "signature": "tornado.routing.ReversibleRuleRouter.reverse_url(self, name: str, *args: Any)",
        "snippet": "    def reverse_url(self, name: str, *args: Any) -> Optional[str]:\n        if name in self.named_rules:\n            return self.named_rules[name].matcher.reverse(*args)\n\n        for rule in self.rules:\n            if isinstance(rule.target, ReversibleRouter):\n                reversed_url = rule.target.reverse_url(name, *args)\n                if reversed_url is not None:\n                    return reversed_url\n\n        return None",
        "begin_line": 428,
        "end_line": 438,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.routing.Rule.__init__#444",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.Rule",
        "signature": "tornado.routing.Rule.__init__(self, matcher: 'Matcher', target: Any, target_kwargs: Dict[str, Any]=None, name: str=None)",
        "snippet": "    def __init__(\n        self,\n        matcher: \"Matcher\",\n        target: Any,\n        target_kwargs: Dict[str, Any] = None,\n        name: str = None,\n    ) -> None:\n        \"\"\"Constructs a Rule instance.\n\n        :arg Matcher matcher: a `Matcher` instance used for determining\n            whether the rule should be considered a match for a specific\n            request.\n        :arg target: a Rule's target (typically a ``RequestHandler`` or\n            `~.httputil.HTTPServerConnectionDelegate` subclass or even a nested `Router`,\n            depending on routing implementation).\n        :arg dict target_kwargs: a dict of parameters that can be useful\n            at the moment of target instantiation (for example, ``status_code``\n            for a ``RequestHandler`` subclass). They end up in\n            ``target_params['target_kwargs']`` of `RuleRouter.get_target_delegate`\n            method.\n        :arg str name: the name of the rule that can be used to find it\n            in `ReversibleRouter.reverse_url` implementation.\n        \"\"\"\n        if isinstance(target, str):\n            # import the Module and instantiate the class\n            # Must be a fully qualified name (module.ClassName)\n            target = import_object(target)\n\n        self.matcher = matcher  # type: Matcher\n        self.target = target\n        self.target_kwargs = target_kwargs if target_kwargs else {}\n        self.name = name",
        "begin_line": 444,
        "end_line": 475,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008077544426494346,
            "pseudo_dstar_susp": 0.0010319917440660474,
            "pseudo_tarantula_susp": 0.000731528895391368,
            "pseudo_op2_susp": 0.0010319917440660474,
            "pseudo_barinel_susp": 0.000731528895391368
        }
    },
    {
        "name": "tornado.routing.Rule.reverse#477",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.Rule",
        "signature": "tornado.routing.Rule.reverse(self, *args: Any)",
        "snippet": "    def reverse(self, *args: Any) -> Optional[str]:\n        return self.matcher.reverse(*args)",
        "begin_line": 477,
        "end_line": 478,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.routing.AnyMatches.match#513",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.AnyMatches",
        "signature": "tornado.routing.AnyMatches.match(self, request: httputil.HTTPServerRequest)",
        "snippet": "    def match(self, request: httputil.HTTPServerRequest) -> Optional[Dict[str, Any]]:\n        return {}",
        "begin_line": 513,
        "end_line": 514,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006844626967830253,
            "pseudo_dstar_susp": 0.0007905138339920949,
            "pseudo_tarantula_susp": 0.0006297229219143577,
            "pseudo_op2_susp": 0.0007905138339920949,
            "pseudo_barinel_susp": 0.0006297229219143577
        }
    },
    {
        "name": "tornado.routing.HostMatches.__init__#520",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.HostMatches",
        "signature": "tornado.routing.HostMatches.__init__(self, host_pattern: Union[str, Pattern])",
        "snippet": "    def __init__(self, host_pattern: Union[str, Pattern]) -> None:\n        if isinstance(host_pattern, basestring_type):\n            if not host_pattern.endswith(\"$\"):\n                host_pattern += \"$\"\n            self.host_pattern = re.compile(host_pattern)\n        else:\n            self.host_pattern = host_pattern",
        "begin_line": 520,
        "end_line": 526,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.routing.HostMatches.match#528",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.HostMatches",
        "signature": "tornado.routing.HostMatches.match(self, request: httputil.HTTPServerRequest)",
        "snippet": "    def match(self, request: httputil.HTTPServerRequest) -> Optional[Dict[str, Any]]:\n        if self.host_pattern.match(request.host_name):\n            return {}\n\n        return None",
        "begin_line": 528,
        "end_line": 532,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.routing.DefaultHostMatches.__init__#540",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.DefaultHostMatches",
        "signature": "tornado.routing.DefaultHostMatches.__init__(self, application: Any, host_pattern: Pattern)",
        "snippet": "    def __init__(self, application: Any, host_pattern: Pattern) -> None:\n        self.application = application\n        self.host_pattern = host_pattern",
        "begin_line": 540,
        "end_line": 542,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.routing.DefaultHostMatches.match#544",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.DefaultHostMatches",
        "signature": "tornado.routing.DefaultHostMatches.match(self, request: httputil.HTTPServerRequest)",
        "snippet": "    def match(self, request: httputil.HTTPServerRequest) -> Optional[Dict[str, Any]]:\n        # Look for default host if not behind load balancer (for debugging)\n        if \"X-Real-Ip\" not in request.headers:\n            if self.host_pattern.match(self.application.default_host):\n                return {}\n        return None",
        "begin_line": 544,
        "end_line": 549,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.routing.PathMatches.__init__#555",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.PathMatches",
        "signature": "tornado.routing.PathMatches.__init__(self, path_pattern: Union[str, Pattern])",
        "snippet": "    def __init__(self, path_pattern: Union[str, Pattern]) -> None:\n        if isinstance(path_pattern, basestring_type):\n            if not path_pattern.endswith(\"$\"):\n                path_pattern += \"$\"\n            self.regex = re.compile(path_pattern)\n        else:\n            self.regex = path_pattern\n\n        assert len(self.regex.groupindex) in (0, self.regex.groups), (\n            \"groups in url regexes must either be all named or all \"\n            \"positional: %r\" % self.regex.pattern\n        )\n\n        self._path, self._group_count = self._find_groups()",
        "begin_line": 555,
        "end_line": 568,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008688097306689834,
            "pseudo_dstar_susp": 0.0011312217194570137,
            "pseudo_tarantula_susp": 0.0007974481658692185,
            "pseudo_op2_susp": 0.0011312217194570137,
            "pseudo_barinel_susp": 0.0007974481658692185
        }
    },
    {
        "name": "tornado.routing.PathMatches.match#570",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.PathMatches",
        "signature": "tornado.routing.PathMatches.match(self, request: httputil.HTTPServerRequest)",
        "snippet": "    def match(self, request: httputil.HTTPServerRequest) -> Optional[Dict[str, Any]]:\n        match = self.regex.match(request.path)\n        if match is None:\n            return None\n        if not self.regex.groups:\n            return {}\n\n        path_args = []  # type: List[bytes]\n        path_kwargs = {}  # type: Dict[str, bytes]\n\n        # Pass matched groups to the handler.  Since\n        # match.groups() includes both named and\n        # unnamed groups, we want to use either groups\n        # or groupdict but not both.\n        if self.regex.groupindex:\n            path_kwargs = dict(\n                (str(k), _unquote_or_none(v)) for (k, v) in match.groupdict().items()\n            )\n        else:\n            path_args = [_unquote_or_none(s) for s in match.groups()]\n\n        return dict(path_args=path_args, path_kwargs=path_kwargs)",
        "begin_line": 570,
        "end_line": 591,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007272727272727272,
            "pseudo_dstar_susp": 0.0008019246190858059,
            "pseudo_tarantula_susp": 0.0008012820512820513,
            "pseudo_op2_susp": 0.0008019246190858059,
            "pseudo_barinel_susp": 0.0008012820512820513
        }
    },
    {
        "name": "tornado.routing.PathMatches.reverse#593",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.PathMatches",
        "signature": "tornado.routing.PathMatches.reverse(self, *args: Any)",
        "snippet": "    def reverse(self, *args: Any) -> Optional[str]:\n        if self._path is None:\n            raise ValueError(\"Cannot reverse url regex \" + self.regex.pattern)\n        assert len(args) == self._group_count, (\n            \"required number of arguments \" \"not found\"\n        )\n        if not len(args):\n            return self._path\n        converted_args = []\n        for a in args:\n            if not isinstance(a, (unicode_type, bytes)):\n                a = str(a)\n            converted_args.append(url_escape(utf8(a), plus=False))\n        return self._path % tuple(converted_args)",
        "begin_line": 593,
        "end_line": 606,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.routing.PathMatches._find_groups#608",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.PathMatches",
        "signature": "tornado.routing.PathMatches._find_groups(self)",
        "snippet": "    def _find_groups(self) -> Tuple[Optional[str], Optional[int]]:\n        \"\"\"Returns a tuple (reverse string, group count) for a url.\n\n        For example: Given the url pattern /([0-9]{4})/([a-z-]+)/, this method\n        would return ('/%s/%s/', 2).\n        \"\"\"\n        pattern = self.regex.pattern\n        if pattern.startswith(\"^\"):\n            pattern = pattern[1:]\n        if pattern.endswith(\"$\"):\n            pattern = pattern[:-1]\n\n        if self.regex.groups != pattern.count(\"(\"):\n            # The pattern is too complicated for our simplistic matching,\n            # so we can't support reversing it.\n            return None, None\n\n        pieces = []\n        for fragment in pattern.split(\"(\"):\n            if \")\" in fragment:\n                paren_loc = fragment.index(\")\")\n                if paren_loc >= 0:\n                    pieces.append(\"%s\" + fragment[paren_loc + 1 :])\n            else:\n                try:\n                    unescaped_fragment = re_unescape(fragment)\n                except ValueError:\n                    # If we can't unescape part of it, we can't\n                    # reverse this url.\n                    return (None, None)\n                pieces.append(unescaped_fragment)\n\n        return \"\".join(pieces), self.regex.groups",
        "begin_line": 608,
        "end_line": 640,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008680555555555555,
            "pseudo_dstar_susp": 0.0011299435028248588,
            "pseudo_tarantula_susp": 0.0007961783439490446,
            "pseudo_op2_susp": 0.0011299435028248588,
            "pseudo_barinel_susp": 0.0007961783439490446
        }
    },
    {
        "name": "tornado.routing.URLSpec.__init__#651",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.URLSpec",
        "signature": "tornado.routing.URLSpec.__init__(self, pattern: Union[str, Pattern], handler: Any, kwargs: Dict[str, Any]=None, name: str=None)",
        "snippet": "    def __init__(\n        self,\n        pattern: Union[str, Pattern],\n        handler: Any,\n        kwargs: Dict[str, Any] = None,\n        name: str = None,\n    ) -> None:\n        \"\"\"Parameters:\n\n        * ``pattern``: Regular expression to be matched. Any capturing\n          groups in the regex will be passed in to the handler's\n          get/post/etc methods as arguments (by keyword if named, by\n          position if unnamed. Named and unnamed capturing groups\n          may not be mixed in the same rule).\n\n        * ``handler``: `~.web.RequestHandler` subclass to be invoked.\n\n        * ``kwargs`` (optional): A dictionary of additional arguments\n          to be passed to the handler's constructor.\n\n        * ``name`` (optional): A name for this handler.  Used by\n          `~.web.Application.reverse_url`.\n\n        \"\"\"\n        matcher = PathMatches(pattern)\n        super(URLSpec, self).__init__(matcher, handler, kwargs, name)\n\n        self.regex = matcher.regex\n        self.handler_class = self.target\n        self.kwargs = kwargs",
        "begin_line": 651,
        "end_line": 680,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041718815185648727,
            "pseudo_dstar_susp": 0.000429553264604811,
            "pseudo_tarantula_susp": 0.00042625745950554135,
            "pseudo_op2_susp": 0.000429553264604811,
            "pseudo_barinel_susp": 0.00042625745950554135
        }
    },
    {
        "name": "tornado.routing._unquote_or_none#702",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing",
        "signature": "tornado.routing._unquote_or_none(s: Optional[str])",
        "snippet": "def _unquote_or_none(s: Optional[str]) -> Optional[bytes]:  # noqa: F811\n    \"\"\"None-safe wrapper around url_unescape to handle unmatched optional\n    groups correctly.\n\n    Note that args are passed as bytes so the handler can decide what\n    encoding to use.\n    \"\"\"\n    if s is None:\n        return s\n    return url_unescape(s, encoding=None, plus=False)",
        "begin_line": 702,
        "end_line": 711,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.netutil.bind_sockets#68",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.bind_sockets(port: int, address: str=None, family: socket.AddressFamily=socket.AF_UNSPEC, backlog: int=_DEFAULT_BACKLOG, flags: int=None, reuse_port: bool=False)",
        "snippet": "def bind_sockets(\n    port: int,\n    address: str = None,\n    family: socket.AddressFamily = socket.AF_UNSPEC,\n    backlog: int = _DEFAULT_BACKLOG,\n    flags: int = None,\n    reuse_port: bool = False,\n) -> List[socket.socket]:\n    \"\"\"Creates listening sockets bound to the given port and address.\n\n    Returns a list of socket objects (multiple sockets are returned if\n    the given address maps to multiple IP addresses, which is most common\n    for mixed IPv4 and IPv6 use).\n\n    Address may be either an IP address or hostname.  If it's a hostname,\n    the server will listen on all IP addresses associated with the\n    name.  Address may be an empty string or None to listen on all\n    available interfaces.  Family may be set to either `socket.AF_INET`\n    or `socket.AF_INET6` to restrict to IPv4 or IPv6 addresses, otherwise\n    both will be used if available.\n\n    The ``backlog`` argument has the same meaning as for\n    `socket.listen() <socket.socket.listen>`.\n\n    ``flags`` is a bitmask of AI_* flags to `~socket.getaddrinfo`, like\n    ``socket.AI_PASSIVE | socket.AI_NUMERICHOST``.\n\n    ``reuse_port`` option sets ``SO_REUSEPORT`` option for every socket\n    in the list. If your platform doesn't support this option ValueError will\n    be raised.\n    \"\"\"\n    if reuse_port and not hasattr(socket, \"SO_REUSEPORT\"):\n        raise ValueError(\"the platform doesn't support SO_REUSEPORT\")\n\n    sockets = []\n    if address == \"\":\n        address = None\n    if not socket.has_ipv6 and family == socket.AF_UNSPEC:\n        # Python can be compiled with --disable-ipv6, which causes\n        # operations on AF_INET6 sockets to fail, but does not\n        # automatically exclude those results from getaddrinfo\n        # results.\n        # http://bugs.python.org/issue16208\n        family = socket.AF_INET\n    if flags is None:\n        flags = socket.AI_PASSIVE\n    bound_port = None\n    unique_addresses = set()  # type: set\n    for res in sorted(\n        socket.getaddrinfo(address, port, family, socket.SOCK_STREAM, 0, flags),\n        key=lambda x: x[0],\n    ):\n        if res in unique_addresses:\n            continue\n\n        unique_addresses.add(res)\n\n        af, socktype, proto, canonname, sockaddr = res\n        if (\n            sys.platform == \"darwin\"\n            and address == \"localhost\"\n            and af == socket.AF_INET6\n            and sockaddr[3] != 0\n        ):\n            # Mac OS X includes a link-local address fe80::1%lo0 in the\n            # getaddrinfo results for 'localhost'.  However, the firewall\n            # doesn't understand that this is a local address and will\n            # prompt for access (often repeatedly, due to an apparent\n            # bug in its ability to remember granting access to an\n            # application). Skip these addresses.\n            continue\n        try:\n            sock = socket.socket(af, socktype, proto)\n        except socket.error as e:\n            if errno_from_exception(e) == errno.EAFNOSUPPORT:\n                continue\n            raise\n        set_close_exec(sock.fileno())\n        if os.name != \"nt\":\n            try:\n                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            except socket.error as e:\n                if errno_from_exception(e) != errno.ENOPROTOOPT:\n                    # Hurd doesn't support SO_REUSEADDR.\n                    raise\n        if reuse_port:\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n        if af == socket.AF_INET6:\n            # On linux, ipv6 sockets accept ipv4 too by default,\n            # but this makes it impossible to bind to both\n            # 0.0.0.0 in ipv4 and :: in ipv6.  On other systems,\n            # separate sockets *must* be used to listen for both ipv4\n            # and ipv6.  For consistency, always disable ipv4 on our\n            # ipv6 sockets and use a separate ipv4 socket when needed.\n            #\n            # Python 2.x on windows doesn't have IPPROTO_IPV6.\n            if hasattr(socket, \"IPPROTO_IPV6\"):\n                sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 1)\n\n        # automatic port allocation with port=None\n        # should bind on the same port on IPv4 and IPv6\n        host, requested_port = sockaddr[:2]\n        if requested_port == 0 and bound_port is not None:\n            sockaddr = tuple([host, bound_port] + list(sockaddr[2:]))\n\n        sock.setblocking(False)\n        sock.bind(sockaddr)\n        bound_port = sock.getsockname()[1]\n        sock.listen(backlog)\n        sockets.append(sock)\n    return sockets",
        "begin_line": 68,
        "end_line": 178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01020408163265306,
            "pseudo_dstar_susp": 0.09090909090909091,
            "pseudo_tarantula_susp": 0.0012345679012345679,
            "pseudo_op2_susp": 0.09090909090909091,
            "pseudo_barinel_susp": 0.0012345679012345679
        }
    },
    {
        "name": "tornado.netutil.bind_unix_socket#183",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.bind_unix_socket(file: str, mode: int=384, backlog: int=_DEFAULT_BACKLOG)",
        "snippet": "    def bind_unix_socket(\n        file: str, mode: int = 0o600, backlog: int = _DEFAULT_BACKLOG\n    ) -> socket.socket:\n        \"\"\"Creates a listening unix socket.\n\n        If a socket with the given name already exists, it will be deleted.\n        If any other file with that name exists, an exception will be\n        raised.\n\n        Returns a socket object (not a list of socket objects like\n        `bind_sockets`)\n        \"\"\"\n        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        set_close_exec(sock.fileno())\n        try:\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        except socket.error as e:\n            if errno_from_exception(e) != errno.ENOPROTOOPT:\n                # Hurd doesn't support SO_REUSEADDR\n                raise\n        sock.setblocking(False)\n        try:\n            st = os.stat(file)\n        except OSError as err:\n            if errno_from_exception(err) != errno.ENOENT:\n                raise\n        else:\n            if stat.S_ISSOCK(st.st_mode):\n                os.remove(file)\n            else:\n                raise ValueError(\"File %s exists and is not a socket\", file)\n        sock.bind(file)\n        os.chmod(file, mode)\n        sock.listen(backlog)\n        return sock",
        "begin_line": 183,
        "end_line": 217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007468259895444362,
            "pseudo_dstar_susp": 0.00042265426880811494,
            "pseudo_tarantula_susp": 0.011235955056179775,
            "pseudo_op2_susp": 0.00042265426880811494,
            "pseudo_barinel_susp": 0.011235955056179775
        }
    },
    {
        "name": "tornado.netutil.add_accept_handler#220",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.add_accept_handler(sock: socket.socket, callback: Callable[[socket.socket, Any], None])",
        "snippet": "def add_accept_handler(\n    sock: socket.socket, callback: Callable[[socket.socket, Any], None]\n) -> Callable[[], None]:\n    \"\"\"Adds an `.IOLoop` event handler to accept new connections on ``sock``.\n\n    When a connection is accepted, ``callback(connection, address)`` will\n    be run (``connection`` is a socket object, and ``address`` is the\n    address of the other end of the connection).  Note that this signature\n    is different from the ``callback(fd, events)`` signature used for\n    `.IOLoop` handlers.\n\n    A callable is returned which, when called, will remove the `.IOLoop`\n    event handler and stop processing further incoming connections.\n\n    .. versionchanged:: 5.0\n       The ``io_loop`` argument (deprecated since version 4.1) has been removed.\n\n    .. versionchanged:: 5.0\n       A callable is returned (``None`` was returned before).\n    \"\"\"\n    io_loop = IOLoop.current()\n    removed = [False]\n\n    def accept_handler(fd: socket.socket, events: int) -> None:\n        # More connections may come in while we're handling callbacks;\n        # to prevent starvation of other tasks we must limit the number\n        # of connections we accept at a time.  Ideally we would accept\n        # up to the number of connections that were waiting when we\n        # entered this method, but this information is not available\n        # (and rearranging this method to call accept() as many times\n        # as possible before running any callbacks would have adverse\n        # effects on load balancing in multiprocess configurations).\n        # Instead, we use the (default) listen backlog as a rough\n        # heuristic for the number of connections we can reasonably\n        # accept at once.\n        for i in range(_DEFAULT_BACKLOG):\n            if removed[0]:\n                # The socket was probably closed\n                return\n            try:\n                connection, address = sock.accept()\n            except socket.error as e:\n                # _ERRNO_WOULDBLOCK indicate we have accepted every\n                # connection that is available.\n                if errno_from_exception(e) in _ERRNO_WOULDBLOCK:\n                    return\n                # ECONNABORTED indicates that there was a connection\n                # but it was closed while still in the accept queue.\n                # (observed on FreeBSD).\n                if errno_from_exception(e) == errno.ECONNABORTED:\n                    continue\n                raise\n            set_close_exec(connection.fileno())\n            callback(connection, address)\n\n    def remove_handler() -> None:\n        io_loop.remove_handler(sock)\n        removed[0] = True\n\n    io_loop.add_handler(sock, accept_handler, IOLoop.READ)\n    return remove_handler",
        "begin_line": 220,
        "end_line": 280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002028397565922921,
            "pseudo_dstar_susp": 0.0024752475247524753,
            "pseudo_tarantula_susp": 0.0012903225806451613,
            "pseudo_op2_susp": 0.0024752475247524753,
            "pseudo_barinel_susp": 0.0012903225806451613
        }
    },
    {
        "name": "tornado.netutil.accept_handler#243",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.accept_handler(fd: socket.socket, events: int)",
        "snippet": "    def accept_handler(fd: socket.socket, events: int) -> None:\n        # More connections may come in while we're handling callbacks;\n        # to prevent starvation of other tasks we must limit the number\n        # of connections we accept at a time.  Ideally we would accept\n        # up to the number of connections that were waiting when we\n        # entered this method, but this information is not available\n        # (and rearranging this method to call accept() as many times\n        # as possible before running any callbacks would have adverse\n        # effects on load balancing in multiprocess configurations).\n        # Instead, we use the (default) listen backlog as a rough\n        # heuristic for the number of connections we can reasonably\n        # accept at once.\n        for i in range(_DEFAULT_BACKLOG):\n            if removed[0]:\n                # The socket was probably closed\n                return\n            try:\n                connection, address = sock.accept()\n            except socket.error as e:\n                # _ERRNO_WOULDBLOCK indicate we have accepted every\n                # connection that is available.\n                if errno_from_exception(e) in _ERRNO_WOULDBLOCK:\n                    return\n                # ECONNABORTED indicates that there was a connection\n                # but it was closed while still in the accept queue.\n                # (observed on FreeBSD).\n                if errno_from_exception(e) == errno.ECONNABORTED:\n                    continue\n                raise\n            set_close_exec(connection.fileno())\n            callback(connection, address)",
        "begin_line": 243,
        "end_line": 273,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0125,
            "pseudo_dstar_susp": 0.1,
            "pseudo_tarantula_susp": 0.0013774104683195593,
            "pseudo_op2_susp": 0.1,
            "pseudo_barinel_susp": 0.0013774104683195593
        }
    },
    {
        "name": "tornado.netutil.remove_handler#275",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.remove_handler()",
        "snippet": "    def remove_handler() -> None:\n        io_loop.remove_handler(sock)\n        removed[0] = True",
        "begin_line": 275,
        "end_line": 277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003115264797507788,
            "pseudo_dstar_susp": 0.07142857142857142,
            "pseudo_tarantula_susp": 0.001091703056768559,
            "pseudo_op2_susp": 0.07142857142857142,
            "pseudo_barinel_susp": 0.001091703056768559
        }
    },
    {
        "name": "tornado.netutil.is_valid_ip#283",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.is_valid_ip(ip: str)",
        "snippet": "def is_valid_ip(ip: str) -> bool:\n    \"\"\"Returns true if the given string is a well-formed IP address.\n\n    Supports IPv4 and IPv6.\n    \"\"\"\n    if not ip or \"\\x00\" in ip:\n        # getaddrinfo resolves empty strings to localhost, and truncates\n        # on zero bytes.\n        return False\n    try:\n        res = socket.getaddrinfo(\n            ip, 0, socket.AF_UNSPEC, socket.SOCK_STREAM, 0, socket.AI_NUMERICHOST\n        )\n        return bool(res)\n    except socket.gaierror as e:\n        if e.args[0] == socket.EAI_NONAME:\n            return False\n        raise\n    return True",
        "begin_line": 283,
        "end_line": 301,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.netutil.Resolver.configurable_base#329",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.Resolver",
        "signature": "tornado.netutil.Resolver.configurable_base(cls)",
        "snippet": "    def configurable_base(cls) -> Type[\"Resolver\"]:\n        return Resolver",
        "begin_line": 329,
        "end_line": 330,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007558578987150416,
            "pseudo_dstar_susp": 0.0009689922480620155,
            "pseudo_tarantula_susp": 0.0006901311249137336,
            "pseudo_op2_susp": 0.0009689922480620155,
            "pseudo_barinel_susp": 0.0006901311249137336
        }
    },
    {
        "name": "tornado.netutil.Resolver.configurable_default#333",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.Resolver",
        "signature": "tornado.netutil.Resolver.configurable_default(cls)",
        "snippet": "    def configurable_default(cls) -> Type[\"Resolver\"]:\n        return DefaultExecutorResolver",
        "begin_line": 333,
        "end_line": 334,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.netutil.Resolver.close#362",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.Resolver",
        "signature": "tornado.netutil.Resolver.close(self)",
        "snippet": "    def close(self) -> None:\n        \"\"\"Closes the `Resolver`, freeing any resources used.\n\n        .. versionadded:: 3.1\n\n        \"\"\"\n        pass",
        "begin_line": 362,
        "end_line": 368,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007651109410864575,
            "pseudo_dstar_susp": 0.0009765625,
            "pseudo_tarantula_susp": 0.000697350069735007,
            "pseudo_op2_susp": 0.0009765625,
            "pseudo_barinel_susp": 0.000697350069735007
        }
    },
    {
        "name": "tornado.netutil._resolve_addr#371",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil._resolve_addr(host: str, port: int, family: socket.AddressFamily=socket.AF_UNSPEC)",
        "snippet": "def _resolve_addr(\n    host: str, port: int, family: socket.AddressFamily = socket.AF_UNSPEC\n) -> List[Tuple[int, Any]]:\n    # On Solaris, getaddrinfo fails if the given port is not found\n    # in /etc/services and no socket type is given, so we must pass\n    # one here.  The socket type used here doesn't seem to actually\n    # matter (we discard the one we get back in the results),\n    # so the addresses we return should still be usable with SOCK_DGRAM.\n    addrinfo = socket.getaddrinfo(host, port, family, socket.SOCK_STREAM)\n    results = []\n    for fam, socktype, proto, canonname, address in addrinfo:\n        results.append((fam, address))\n    return results",
        "begin_line": 371,
        "end_line": 383,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005370569280343716,
            "pseudo_dstar_susp": 0.0006053268765133172,
            "pseudo_tarantula_susp": 0.0004970178926441351,
            "pseudo_op2_susp": 0.0006053268765133172,
            "pseudo_barinel_susp": 0.0004970178926441351
        }
    },
    {
        "name": "tornado.netutil.DefaultExecutorResolver.resolve#392",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.DefaultExecutorResolver",
        "signature": "tornado.netutil.DefaultExecutorResolver.resolve(self, host: str, port: int, family: socket.AddressFamily=socket.AF_UNSPEC)",
        "snippet": "    async def resolve(\n        self, host: str, port: int, family: socket.AddressFamily = socket.AF_UNSPEC\n    ) -> List[Tuple[int, Any]]:\n        result = await IOLoop.current().run_in_executor(\n            None, _resolve_addr, host, port, family\n        )\n        return result",
        "begin_line": 392,
        "end_line": 398,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005458515283842794,
            "pseudo_dstar_susp": 0.0006165228113440197,
            "pseudo_tarantula_susp": 0.0005045408678102926,
            "pseudo_op2_susp": 0.0006165228113440197,
            "pseudo_barinel_susp": 0.0005045408678102926
        }
    },
    {
        "name": "tornado.netutil.ExecutorResolver.initialize#419",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.ExecutorResolver",
        "signature": "tornado.netutil.ExecutorResolver.initialize(self, executor: concurrent.futures.Executor=None, close_executor: bool=True)",
        "snippet": "    def initialize(\n        self, executor: concurrent.futures.Executor = None, close_executor: bool = True\n    ) -> None:\n        self.io_loop = IOLoop.current()\n        if executor is not None:\n            self.executor = executor\n            self.close_executor = close_executor\n        else:\n            self.executor = dummy_executor\n            self.close_executor = False",
        "begin_line": 419,
        "end_line": 428,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.netutil.ExecutorResolver.close#430",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.ExecutorResolver",
        "signature": "tornado.netutil.ExecutorResolver.close(self)",
        "snippet": "    def close(self) -> None:\n        if self.close_executor:\n            self.executor.shutdown()\n        self.executor = None  # type: ignore",
        "begin_line": 430,
        "end_line": 433,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.netutil.ExecutorResolver.resolve#436",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.ExecutorResolver",
        "signature": "tornado.netutil.ExecutorResolver.resolve(self, host: str, port: int, family: socket.AddressFamily=socket.AF_UNSPEC)",
        "snippet": "    def resolve(\n        self, host: str, port: int, family: socket.AddressFamily = socket.AF_UNSPEC\n    ) -> List[Tuple[int, Any]]:\n        return _resolve_addr(host, port, family)",
        "begin_line": 436,
        "end_line": 439,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019334880123743234,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.netutil.BlockingResolver.initialize#453",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.BlockingResolver",
        "signature": "tornado.netutil.BlockingResolver.initialize(self)",
        "snippet": "    def initialize(self) -> None:  # type: ignore\n        super(BlockingResolver, self).initialize()",
        "begin_line": 453,
        "end_line": 454,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.netutil.ThreadedResolver.initialize#481",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.ThreadedResolver",
        "signature": "tornado.netutil.ThreadedResolver.initialize(self, num_threads: int=10)",
        "snippet": "    def initialize(self, num_threads: int = 10) -> None:  # type: ignore\n        threadpool = ThreadedResolver._create_threadpool(num_threads)\n        super(ThreadedResolver, self).initialize(\n            executor=threadpool, close_executor=False\n        )",
        "begin_line": 481,
        "end_line": 485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.netutil.ThreadedResolver._create_threadpool#488",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.ThreadedResolver",
        "signature": "tornado.netutil.ThreadedResolver._create_threadpool(cls, num_threads: int)",
        "snippet": "    def _create_threadpool(\n        cls, num_threads: int\n    ) -> concurrent.futures.ThreadPoolExecutor:\n        pid = os.getpid()\n        if cls._threadpool_pid != pid:\n            # Threads cannot survive after a fork, so if our pid isn't what it\n            # was when we created the pool then delete it.\n            cls._threadpool = None\n        if cls._threadpool is None:\n            cls._threadpool = concurrent.futures.ThreadPoolExecutor(num_threads)\n            cls._threadpool_pid = pid\n        return cls._threadpool",
        "begin_line": 488,
        "end_line": 499,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.netutil.OverrideResolver.initialize#525",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.OverrideResolver",
        "signature": "tornado.netutil.OverrideResolver.initialize(self, resolver: Resolver, mapping: dict)",
        "snippet": "    def initialize(self, resolver: Resolver, mapping: dict) -> None:\n        self.resolver = resolver\n        self.mapping = mapping",
        "begin_line": 525,
        "end_line": 527,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.netutil.OverrideResolver.close#529",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.OverrideResolver",
        "signature": "tornado.netutil.OverrideResolver.close(self)",
        "snippet": "    def close(self) -> None:\n        self.resolver.close()",
        "begin_line": 529,
        "end_line": 530,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.netutil.OverrideResolver.resolve#532",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.OverrideResolver",
        "signature": "tornado.netutil.OverrideResolver.resolve(self, host: str, port: int, family: socket.AddressFamily=socket.AF_UNSPEC)",
        "snippet": "    def resolve(\n        self, host: str, port: int, family: socket.AddressFamily = socket.AF_UNSPEC\n    ) -> Awaitable[List[Tuple[int, Any]]]:\n        if (host, port, family) in self.mapping:\n            host, port = self.mapping[(host, port, family)]\n        elif (host, port) in self.mapping:\n            host, port = self.mapping[(host, port)]\n        elif host in self.mapping:\n            host = self.mapping[host]\n        return self.resolver.resolve(host, port, family)",
        "begin_line": 532,
        "end_line": 541,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.netutil.ssl_options_to_context#552",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.ssl_options_to_context(ssl_options: Union[Dict[str, Any], ssl.SSLContext])",
        "snippet": "def ssl_options_to_context(\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext]\n) -> ssl.SSLContext:\n    \"\"\"Try to convert an ``ssl_options`` dictionary to an\n    `~ssl.SSLContext` object.\n\n    The ``ssl_options`` dictionary contains keywords to be passed to\n    `ssl.wrap_socket`.  In Python 2.7.9+, `ssl.SSLContext` objects can\n    be used instead.  This function converts the dict form to its\n    `~ssl.SSLContext` equivalent, and may be used when a component which\n    accepts both forms needs to upgrade to the `~ssl.SSLContext` version\n    to use features like SNI or NPN.\n    \"\"\"\n    if isinstance(ssl_options, ssl.SSLContext):\n        return ssl_options\n    assert isinstance(ssl_options, dict)\n    assert all(k in _SSL_CONTEXT_KEYWORDS for k in ssl_options), ssl_options\n    # Can't use create_default_context since this interface doesn't\n    # tell us client vs server.\n    context = ssl.SSLContext(ssl_options.get(\"ssl_version\", ssl.PROTOCOL_SSLv23))\n    if \"certfile\" in ssl_options:\n        context.load_cert_chain(\n            ssl_options[\"certfile\"], ssl_options.get(\"keyfile\", None)\n        )\n    if \"cert_reqs\" in ssl_options:\n        context.verify_mode = ssl_options[\"cert_reqs\"]\n    if \"ca_certs\" in ssl_options:\n        context.load_verify_locations(ssl_options[\"ca_certs\"])\n    if \"ciphers\" in ssl_options:\n        context.set_ciphers(ssl_options[\"ciphers\"])\n    if hasattr(ssl, \"OP_NO_COMPRESSION\"):\n        # Disable TLS compression to avoid CRIME and related attacks.\n        # This constant depends on openssl version 1.0.\n        # TODO: Do we need to do this ourselves or can we trust\n        # the defaults?\n        context.options |= ssl.OP_NO_COMPRESSION\n    return context",
        "begin_line": 552,
        "end_line": 588,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013089005235602095,
            "pseudo_dstar_susp": 0.0009442870632672333,
            "pseudo_tarantula_susp": 0.0034965034965034965,
            "pseudo_op2_susp": 0.0009442870632672333,
            "pseudo_barinel_susp": 0.0034965034965034965
        }
    },
    {
        "name": "tornado.netutil.ssl_wrap_socket#591",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.ssl_wrap_socket(socket: socket.socket, ssl_options: Union[Dict[str, Any], ssl.SSLContext], server_hostname: str=None, **kwargs: Any)",
        "snippet": "def ssl_wrap_socket(\n    socket: socket.socket,\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext],\n    server_hostname: str = None,\n    **kwargs: Any\n) -> ssl.SSLSocket:\n    \"\"\"Returns an ``ssl.SSLSocket`` wrapping the given socket.\n\n    ``ssl_options`` may be either an `ssl.SSLContext` object or a\n    dictionary (as accepted by `ssl_options_to_context`).  Additional\n    keyword arguments are passed to ``wrap_socket`` (either the\n    `~ssl.SSLContext` method or the `ssl` module function as\n    appropriate).\n    \"\"\"\n    context = ssl_options_to_context(ssl_options)\n    if ssl.HAS_SNI:\n        # In python 3.4, wrap_socket only accepts the server_hostname\n        # argument if HAS_SNI is true.\n        # TODO: add a unittest (python added server-side SNI support in 3.4)\n        # In the meantime it can be manually tested with\n        # python3 -m tornado.httpclient https://sni.velox.ch\n        return context.wrap_socket(socket, server_hostname=server_hostname, **kwargs)\n    else:\n        return context.wrap_socket(socket, **kwargs)",
        "begin_line": 591,
        "end_line": 614,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013089005235602095,
            "pseudo_dstar_susp": 0.0008787346221441124,
            "pseudo_tarantula_susp": 0.0026109660574412533,
            "pseudo_op2_susp": 0.0008787346221441124,
            "pseudo_barinel_susp": 0.0026109660574412533
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.__init__#232",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.__init__(self, application: tornado.web.Application, request: httputil.HTTPServerRequest, **kwargs: Any)",
        "snippet": "    def __init__(\n        self,\n        application: tornado.web.Application,\n        request: httputil.HTTPServerRequest,\n        **kwargs: Any\n    ) -> None:\n        super(WebSocketHandler, self).__init__(application, request, **kwargs)\n        self.ws_connection = None  # type: Optional[WebSocketProtocol]\n        self.close_code = None  # type: Optional[int]\n        self.close_reason = None  # type: Optional[str]\n        self.stream = None  # type: Optional[IOStream]\n        self._on_close_called = False",
        "begin_line": 232,
        "end_line": 243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014755791648221928,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.get#245",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.get(self, *args: Any, **kwargs: Any)",
        "snippet": "    def get(self, *args: Any, **kwargs: Any) -> None:\n        self.open_args = args\n        self.open_kwargs = kwargs\n\n        # Upgrade header should be present and should be equal to WebSocket\n        if self.request.headers.get(\"Upgrade\", \"\").lower() != \"websocket\":\n            self.set_status(400)\n            log_msg = 'Can \"Upgrade\" only to \"WebSocket\".'\n            self.finish(log_msg)\n            gen_log.debug(log_msg)\n            return\n\n        # Connection header should be upgrade.\n        # Some proxy servers/load balancers\n        # might mess with it.\n        headers = self.request.headers\n        connection = map(\n            lambda s: s.strip().lower(), headers.get(\"Connection\", \"\").split(\",\")\n        )\n        if \"upgrade\" not in connection:\n            self.set_status(400)\n            log_msg = '\"Connection\" must be \"Upgrade\".'\n            self.finish(log_msg)\n            gen_log.debug(log_msg)\n            return\n\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n\n        # If there was an origin header, check to make sure it matches\n        # according to check_origin. When the origin is None, we assume it\n        # did not come from a browser and that it can be passed on.\n        if origin is not None and not self.check_origin(origin):\n            self.set_status(403)\n            log_msg = \"Cross origin websockets not allowed\"\n            self.finish(log_msg)\n            gen_log.debug(log_msg)\n            return\n\n        self.ws_connection = self.get_websocket_protocol()\n        if self.ws_connection:\n            self.ws_connection.accept_connection(self)\n        else:\n            self.set_status(426, \"Upgrade Required\")\n            self.set_header(\"Sec-WebSocket-Version\", \"7, 8, 13\")\n            self.finish()",
        "begin_line": 245,
        "end_line": 296,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.ping_interval#301",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.ping_interval(self)",
        "snippet": "    def ping_interval(self) -> Optional[float]:\n        \"\"\"The interval for websocket keep-alive pings.\n\n        Set websocket_ping_interval = 0 to disable pings.\n        \"\"\"\n        return self.settings.get(\"websocket_ping_interval\", None)",
        "begin_line": 301,
        "end_line": 306,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015160703456640388,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.ping_timeout#309",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.ping_timeout(self)",
        "snippet": "    def ping_timeout(self) -> Optional[float]:\n        \"\"\"If no ping is received in this many seconds,\n        close the websocket connection (VPNs, etc. can fail to cleanly close ws connections).\n        Default is max of 3 pings or 30 seconds.\n        \"\"\"\n        return self.settings.get(\"websocket_ping_timeout\", None)",
        "begin_line": 309,
        "end_line": 314,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.max_message_size#317",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.max_message_size(self)",
        "snippet": "    def max_message_size(self) -> int:\n        \"\"\"Maximum allowed message size.\n\n        If the remote peer sends a message larger than this, the connection\n        will be closed.\n\n        Default is 10MiB.\n        \"\"\"\n        return self.settings.get(\n            \"websocket_max_message_size\", _default_max_message_size\n        )",
        "begin_line": 317,
        "end_line": 327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015698587127158556,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.write_message#329",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.write_message(self, message: Union[bytes, str, Dict[str, Any]], binary: bool=False)",
        "snippet": "    def write_message(\n        self, message: Union[bytes, str, Dict[str, Any]], binary: bool = False\n    ) -> \"Future[None]\":\n        \"\"\"Sends the given message to the client of this Web Socket.\n\n        The message may be either a string or a dict (which will be\n        encoded as json).  If the ``binary`` argument is false, the\n        message will be sent as utf8; in binary mode any byte string\n        is allowed.\n\n        If the connection is already closed, raises `WebSocketClosedError`.\n        Returns a `.Future` which can be used for flow control.\n\n        .. versionchanged:: 3.2\n           `WebSocketClosedError` was added (previously a closed connection\n           would raise an `AttributeError`)\n\n        .. versionchanged:: 4.3\n           Returns a `.Future` which can be used for flow control.\n\n        .. versionchanged:: 5.0\n           Consistently raises `WebSocketClosedError`. Previously could\n           sometimes raise `.StreamClosedError`.\n        \"\"\"\n        if self.ws_connection is None or self.ws_connection.is_closing():\n            raise WebSocketClosedError()\n        if isinstance(message, dict):\n            message = tornado.escape.json_encode(message)\n        return self.ws_connection.write_message(message, binary=binary)",
        "begin_line": 329,
        "end_line": 357,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015698587127158556,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.select_subprotocol#359",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.select_subprotocol(self, subprotocols: List[str])",
        "snippet": "    def select_subprotocol(self, subprotocols: List[str]) -> Optional[str]:\n        \"\"\"Override to implement subprotocol negotiation.\n\n        ``subprotocols`` is a list of strings identifying the\n        subprotocols proposed by the client.  This method may be\n        overridden to return one of those strings to select it, or\n        ``None`` to not select a subprotocol.\n\n        Failure to select a subprotocol does not automatically abort\n        the connection, although clients may close the connection if\n        none of their proposed subprotocols was selected.\n\n        The list may be empty, in which case this method must return\n        None. This method is always called exactly once even if no\n        subprotocols were proposed so that the handler can be advised\n        of this fact.\n\n        .. versionchanged:: 5.1\n\n           Previously, this method was called with a list containing\n           an empty string instead of an empty list if no subprotocols\n           were proposed by the client.\n        \"\"\"\n        return None",
        "begin_line": 359,
        "end_line": 382,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001543924656476764,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.selected_subprotocol#385",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.selected_subprotocol(self)",
        "snippet": "    def selected_subprotocol(self) -> Optional[str]:\n        \"\"\"The subprotocol returned by `select_subprotocol`.\n\n        .. versionadded:: 5.1\n        \"\"\"\n        assert self.ws_connection is not None\n        return self.ws_connection.selected_subprotocol",
        "begin_line": 385,
        "end_line": 391,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.open#417",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.open(self, *args: str, **kwargs: str)",
        "snippet": "    def open(self, *args: str, **kwargs: str) -> Optional[Awaitable[None]]:\n        \"\"\"Invoked when a new WebSocket is opened.\n\n        The arguments to `open` are extracted from the `tornado.web.URLSpec`\n        regular expression, just like the arguments to\n        `tornado.web.RequestHandler.get`.\n\n        `open` may be a coroutine. `on_message` will not be called until\n        `open` has returned.\n\n        .. versionchanged:: 5.1\n\n           ``open`` may be a coroutine.\n        \"\"\"\n        pass",
        "begin_line": 417,
        "end_line": 431,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016074586079408456,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.close#486",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.close(self, code: int=None, reason: str=None)",
        "snippet": "    def close(self, code: int = None, reason: str = None) -> None:\n        \"\"\"Closes this Web Socket.\n\n        Once the close handshake is successful the socket will be closed.\n\n        ``code`` may be a numeric status code, taken from the values\n        defined in `RFC 6455 section 7.4.1\n        <https://tools.ietf.org/html/rfc6455#section-7.4.1>`_.\n        ``reason`` may be a textual message about why the connection is\n        closing.  These values are made available to the client, but are\n        not otherwise interpreted by the websocket protocol.\n\n        .. versionchanged:: 4.0\n\n           Added the ``code`` and ``reason`` arguments.\n        \"\"\"\n        if self.ws_connection:\n            self.ws_connection.close(code, reason)\n            self.ws_connection = None",
        "begin_line": 486,
        "end_line": 504,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.check_origin#506",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.check_origin(self, origin: str)",
        "snippet": "    def check_origin(self, origin: str) -> bool:\n        \"\"\"Override to enable support for allowing alternate origins.\n\n        The ``origin`` argument is the value of the ``Origin`` HTTP\n        header, the url responsible for initiating this request.  This\n        method is not called for clients that do not send this header;\n        such requests are always allowed (because all browsers that\n        implement WebSockets support this header, and non-browser\n        clients do not have the same cross-site security concerns).\n\n        Should return True to accept the request or False to reject it.\n        By default, rejects all requests with an origin on a host other\n        than this one.\n\n        This is a security protection against cross site scripting attacks on\n        browsers, since WebSockets are allowed to bypass the usual same-origin\n        policies and don't use CORS headers.\n\n        .. warning::\n\n           This is an important security measure; don't disable it\n           without understanding the security implications. In\n           particular, if your authentication is cookie-based, you\n           must either restrict the origins allowed by\n           ``check_origin()`` or implement your own XSRF-like\n           protection for websocket connections. See `these\n           <https://www.christian-schneider.net/CrossSiteWebSocketHijacking.html>`_\n           `articles\n           <https://devcenter.heroku.com/articles/websocket-security>`_\n           for more.\n\n        To accept all cross-origin traffic (which was the default prior to\n        Tornado 4.0), simply override this method to always return true::\n\n            def check_origin(self, origin):\n                return True\n\n        To allow connections from any subdomain of your site, you might\n        do something like::\n\n            def check_origin(self, origin):\n                parsed_origin = urllib.parse.urlparse(origin)\n                return parsed_origin.netloc.endswith(\".mydomain.com\")\n\n        .. versionadded:: 4.0\n\n        \"\"\"\n        parsed_origin = urlparse(origin)\n        origin = parsed_origin.netloc\n        origin = origin.lower()\n\n        host = self.request.headers.get(\"Host\")\n\n        # Check to see that origin matches host directly, including ports\n        return origin == host",
        "begin_line": 506,
        "end_line": 560,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.on_connection_close#579",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.on_connection_close(self)",
        "snippet": "    def on_connection_close(self) -> None:\n        if self.ws_connection:\n            self.ws_connection.on_connection_close()\n            self.ws_connection = None\n        if not self._on_close_called:\n            self._on_close_called = True\n            self.on_close()\n            self._break_cycles()",
        "begin_line": 579,
        "end_line": 586,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001588057805304113,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler._break_cycles#588",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler._break_cycles(self)",
        "snippet": "    def _break_cycles(self) -> None:\n        # WebSocketHandlers call finish() early, but we don't want to\n        # break up reference cycles (which makes it impossible to call\n        # self.render_string) until after we've really closed the\n        # connection (if it was established in the first place,\n        # indicated by status code 101).\n        if self.get_status() != 101 or self._on_close_called:\n            super(WebSocketHandler, self)._break_cycles()",
        "begin_line": 588,
        "end_line": 595,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.000148720999405116,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.get_websocket_protocol#607",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.get_websocket_protocol(self)",
        "snippet": "    def get_websocket_protocol(self) -> Optional[\"WebSocketProtocol\"]:\n        websocket_version = self.request.headers.get(\"Sec-WebSocket-Version\")\n        if websocket_version in (\"7\", \"8\", \"13\"):\n            return WebSocketProtocol13(\n                self, compression_options=self.get_compression_options()\n            )\n        return None",
        "begin_line": 607,
        "end_line": 613,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler._attach_stream#615",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler._attach_stream(self)",
        "snippet": "    def _attach_stream(self) -> None:\n        self.stream = self.detach()\n        self.stream.set_close_callback(self.on_connection_close)\n        # disable non-WS methods\n        for method in [\n            \"write\",\n            \"redirect\",\n            \"set_header\",\n            \"set_cookie\",\n            \"set_status\",\n            \"flush\",\n            \"finish\",\n        ]:\n            setattr(self, method, _raise_not_supported_for_websockets)",
        "begin_line": 615,
        "end_line": 628,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015160703456640388,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket._raise_not_supported_for_websockets#631",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket",
        "signature": "tornado.websocket._raise_not_supported_for_websockets(*args: Any, **kwargs: Any)",
        "snippet": "def _raise_not_supported_for_websockets(*args: Any, **kwargs: Any) -> None:\n    raise RuntimeError(\"Method not supported for Web Sockets\")",
        "begin_line": 631,
        "end_line": 632,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol.__init__#639",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol",
        "signature": "tornado.websocket.WebSocketProtocol.__init__(self, handler: '_WebSocketConnection')",
        "snippet": "    def __init__(self, handler: \"_WebSocketConnection\") -> None:\n        self.handler = handler\n        self.stream = handler.stream\n        self.client_terminated = False\n        self.server_terminated = False",
        "begin_line": 639,
        "end_line": 643,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014925373134328358,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol._run_callback#645",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol",
        "signature": "tornado.websocket.WebSocketProtocol._run_callback(self, callback: Callable, *args: Any, **kwargs: Any)",
        "snippet": "    def _run_callback(\n        self, callback: Callable, *args: Any, **kwargs: Any\n    ) -> Optional[\"Future[Any]\"]:\n        \"\"\"Runs the given callback with exception handling.\n\n        If the callback is a coroutine, returns its Future. On error, aborts the\n        websocket connection and returns None.\n        \"\"\"\n        try:\n            result = callback(*args, **kwargs)\n        except Exception:\n            self.handler.log_exception(*sys.exc_info())\n            self._abort()\n            return None\n        else:\n            if result is not None:\n                result = gen.convert_yielded(result)\n                assert self.stream is not None\n                self.stream.io_loop.add_future(result, lambda f: f.result())\n            return result",
        "begin_line": 645,
        "end_line": 664,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol.on_connection_close#666",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol",
        "signature": "tornado.websocket.WebSocketProtocol.on_connection_close(self)",
        "snippet": "    def on_connection_close(self) -> None:\n        self._abort()",
        "begin_line": 666,
        "end_line": 667,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001588057805304113,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol._abort#669",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol",
        "signature": "tornado.websocket.WebSocketProtocol._abort(self)",
        "snippet": "    def _abort(self) -> None:\n        \"\"\"Instantly aborts the WebSocket connection by closing the socket\"\"\"\n        self.client_terminated = True\n        self.server_terminated = True\n        if self.stream is not None:\n            self.stream.close()  # forcibly tear down the connection\n        self.close()  # let the subclass cleanup",
        "begin_line": 669,
        "end_line": 675,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001588057805304113,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket._PerMessageDeflateCompressor.__init__#724",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket._PerMessageDeflateCompressor",
        "signature": "tornado.websocket._PerMessageDeflateCompressor.__init__(self, persistent: bool, max_wbits: Optional[int], compression_options: Dict[str, Any]=None)",
        "snippet": "    def __init__(\n        self,\n        persistent: bool,\n        max_wbits: Optional[int],\n        compression_options: Dict[str, Any] = None,\n    ) -> None:\n        if max_wbits is None:\n            max_wbits = zlib.MAX_WBITS\n        # There is no symbolic constant for the minimum wbits value.\n        if not (8 <= max_wbits <= zlib.MAX_WBITS):\n            raise ValueError(\n                \"Invalid max_wbits value %r; allowed range 8-%d\",\n                max_wbits,\n                zlib.MAX_WBITS,\n            )\n        self._max_wbits = max_wbits\n\n        if (\n            compression_options is None\n            or \"compression_level\" not in compression_options\n        ):\n            self._compression_level = tornado.web.GZipContentEncoding.GZIP_LEVEL\n        else:\n            self._compression_level = compression_options[\"compression_level\"]\n\n        if compression_options is None or \"mem_level\" not in compression_options:\n            self._mem_level = 8\n        else:\n            self._mem_level = compression_options[\"mem_level\"]\n\n        if persistent:\n            self._compressor = self._create_compressor()  # type: Optional[_Compressor]\n        else:\n            self._compressor = None",
        "begin_line": 724,
        "end_line": 757,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket._PerMessageDeflateCompressor._create_compressor#759",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket._PerMessageDeflateCompressor",
        "signature": "tornado.websocket._PerMessageDeflateCompressor._create_compressor(self)",
        "snippet": "    def _create_compressor(self) -> \"_Compressor\":\n        return zlib.compressobj(\n            self._compression_level, zlib.DEFLATED, -self._max_wbits, self._mem_level\n        )",
        "begin_line": 759,
        "end_line": 762,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket._PerMessageDeflateCompressor.compress#764",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket._PerMessageDeflateCompressor",
        "signature": "tornado.websocket._PerMessageDeflateCompressor.compress(self, data: bytes)",
        "snippet": "    def compress(self, data: bytes) -> bytes:\n        compressor = self._compressor or self._create_compressor()\n        data = compressor.compress(data) + compressor.flush(zlib.Z_SYNC_FLUSH)\n        assert data.endswith(b\"\\x00\\x00\\xff\\xff\")\n        return data[:-4]",
        "begin_line": 764,
        "end_line": 768,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket._PerMessageDeflateDecompressor.__init__#772",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket._PerMessageDeflateDecompressor",
        "signature": "tornado.websocket._PerMessageDeflateDecompressor.__init__(self, persistent: bool, max_wbits: Optional[int], max_message_size: int, compression_options: Dict[str, Any]=None)",
        "snippet": "    def __init__(\n        self,\n        persistent: bool,\n        max_wbits: Optional[int],\n        max_message_size: int,\n        compression_options: Dict[str, Any] = None,\n    ) -> None:\n        self._max_message_size = max_message_size\n        if max_wbits is None:\n            max_wbits = zlib.MAX_WBITS\n        if not (8 <= max_wbits <= zlib.MAX_WBITS):\n            raise ValueError(\n                \"Invalid max_wbits value %r; allowed range 8-%d\",\n                max_wbits,\n                zlib.MAX_WBITS,\n            )\n        self._max_wbits = max_wbits\n        if persistent:\n            self._decompressor = (\n                self._create_decompressor()\n            )  # type: Optional[_Decompressor]\n        else:\n            self._decompressor = None",
        "begin_line": 772,
        "end_line": 794,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket._PerMessageDeflateDecompressor._create_decompressor#796",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket._PerMessageDeflateDecompressor",
        "signature": "tornado.websocket._PerMessageDeflateDecompressor._create_decompressor(self)",
        "snippet": "    def _create_decompressor(self) -> \"_Decompressor\":\n        return zlib.decompressobj(-self._max_wbits)",
        "begin_line": 796,
        "end_line": 797,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket._PerMessageDeflateDecompressor.decompress#799",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket._PerMessageDeflateDecompressor",
        "signature": "tornado.websocket._PerMessageDeflateDecompressor.decompress(self, data: bytes)",
        "snippet": "    def decompress(self, data: bytes) -> bytes:\n        decompressor = self._decompressor or self._create_decompressor()\n        result = decompressor.decompress(\n            data + b\"\\x00\\x00\\xff\\xff\", self._max_message_size\n        )\n        if decompressor.unconsumed_tail:\n            raise _DecompressTooLargeError()\n        return result",
        "begin_line": 799,
        "end_line": 806,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.__init__#826",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.__init__(self, handler: '_WebSocketConnection', mask_outgoing: bool=False, compression_options: Dict[str, Any]=None)",
        "snippet": "    def __init__(\n        self,\n        handler: \"_WebSocketConnection\",\n        mask_outgoing: bool = False,\n        compression_options: Dict[str, Any] = None,\n    ) -> None:\n        WebSocketProtocol.__init__(self, handler)\n        self.mask_outgoing = mask_outgoing\n        self._final_frame = False\n        self._frame_opcode = None\n        self._masked_frame = None\n        self._frame_mask = None  # type: Optional[bytes]\n        self._frame_length = None\n        self._fragmented_message_buffer = None\n        self._fragmented_message_opcode = None\n        self._waiting = None  # type: object\n        self._compression_options = compression_options\n        self._decompressor = None  # type: Optional[_PerMessageDeflateDecompressor]\n        self._compressor = None  # type: Optional[_PerMessageDeflateCompressor]\n        self._frame_compressed = None  # type: Optional[bool]\n        # The total uncompressed size of all messages received or sent.\n        # Unicode messages are encoded to utf8.\n        # Only for testing; subject to change.\n        self._message_bytes_in = 0\n        self._message_bytes_out = 0\n        # The total size of all packets received or sent.  Includes\n        # the effect of compression, frame overhead, and control frames.\n        self._wire_bytes_in = 0\n        self._wire_bytes_out = 0\n        self.ping_callback = None  # type: Optional[PeriodicCallback]\n        self.last_ping = 0.0\n        self.last_pong = 0.0",
        "begin_line": 826,
        "end_line": 857,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014925373134328358,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.selected_subprotocol#861",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.selected_subprotocol(self)",
        "snippet": "    def selected_subprotocol(self) -> Optional[str]:\n        return self._selected_subprotocol",
        "begin_line": 861,
        "end_line": 862,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015160703456640388,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.selected_subprotocol#865",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.selected_subprotocol(self, value: Optional[str])",
        "snippet": "    def selected_subprotocol(self, value: Optional[str]) -> None:\n        self._selected_subprotocol = value",
        "begin_line": 865,
        "end_line": 866,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015160703456640388,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.accept_connection#868",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.accept_connection(self, handler: WebSocketHandler)",
        "snippet": "    def accept_connection(self, handler: WebSocketHandler) -> None:\n        try:\n            self._handle_websocket_headers(handler)\n        except ValueError:\n            handler.set_status(400)\n            log_msg = \"Missing/Invalid WebSocket headers\"\n            handler.finish(log_msg)\n            gen_log.debug(log_msg)\n            return\n\n        try:\n            self._accept_connection(handler)\n        except ValueError:\n            gen_log.debug(\"Malformed WebSocket request received\", exc_info=True)\n            self._abort()\n            return",
        "begin_line": 868,
        "end_line": 883,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._handle_websocket_headers#885",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._handle_websocket_headers(self, handler: WebSocketHandler)",
        "snippet": "    def _handle_websocket_headers(self, handler: WebSocketHandler) -> None:\n        \"\"\"Verifies all invariant- and required headers\n\n        If a header is missing or have an incorrect value ValueError will be\n        raised\n        \"\"\"\n        fields = (\"Host\", \"Sec-Websocket-Key\", \"Sec-Websocket-Version\")\n        if not all(map(lambda f: handler.request.headers.get(f), fields)):\n            raise ValueError(\"Missing/Invalid WebSocket headers\")",
        "begin_line": 885,
        "end_line": 893,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.compute_accept_value#896",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.compute_accept_value(key: Union[str, bytes])",
        "snippet": "    def compute_accept_value(key: Union[str, bytes]) -> str:\n        \"\"\"Computes the value for the Sec-WebSocket-Accept header,\n        given the value for Sec-WebSocket-Key.\n        \"\"\"\n        sha1 = hashlib.sha1()\n        sha1.update(utf8(key))\n        sha1.update(b\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\")  # Magic value\n        return native_str(base64.b64encode(sha1.digest()))",
        "begin_line": 896,
        "end_line": 903,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015160703456640388,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._challenge_response#905",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._challenge_response(self, handler: WebSocketHandler)",
        "snippet": "    def _challenge_response(self, handler: WebSocketHandler) -> str:\n        return WebSocketProtocol13.compute_accept_value(\n            cast(str, handler.request.headers.get(\"Sec-Websocket-Key\"))\n        )",
        "begin_line": 905,
        "end_line": 908,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015160703456640388,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._accept_connection#911",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._accept_connection(self, handler: WebSocketHandler)",
        "snippet": "    def _accept_connection(\n        self, handler: WebSocketHandler\n    ) -> Generator[Any, Any, None]:\n        subprotocol_header = handler.request.headers.get(\"Sec-WebSocket-Protocol\")\n        if subprotocol_header:\n            subprotocols = [s.strip() for s in subprotocol_header.split(\",\")]\n        else:\n            subprotocols = []\n        self.selected_subprotocol = handler.select_subprotocol(subprotocols)\n        if self.selected_subprotocol:\n            assert self.selected_subprotocol in subprotocols\n            handler.set_header(\"Sec-WebSocket-Protocol\", self.selected_subprotocol)\n\n        extensions = self._parse_extensions_header(handler.request.headers)\n        for ext in extensions:\n            if ext[0] == \"permessage-deflate\" and self._compression_options is not None:\n                # TODO: negotiate parameters if compression_options\n                # specifies limits.\n                self._create_compressors(\"server\", ext[1], self._compression_options)\n                if (\n                    \"client_max_window_bits\" in ext[1]\n                    and ext[1][\"client_max_window_bits\"] is None\n                ):\n                    # Don't echo an offered client_max_window_bits\n                    # parameter with no value.\n                    del ext[1][\"client_max_window_bits\"]\n                handler.set_header(\n                    \"Sec-WebSocket-Extensions\",\n                    httputil._encode_header(\"permessage-deflate\", ext[1]),\n                )\n                break\n\n        handler.clear_header(\"Content-Type\")\n        handler.set_status(101)\n        handler.set_header(\"Upgrade\", \"websocket\")\n        handler.set_header(\"Connection\", \"Upgrade\")\n        handler.set_header(\"Sec-WebSocket-Accept\", self._challenge_response(handler))\n        handler.finish()\n\n        handler._attach_stream()\n        assert handler.stream is not None\n        self.stream = handler.stream\n\n        self.start_pinging()\n        open_result = self._run_callback(\n            handler.open, *handler.open_args, **handler.open_kwargs\n        )\n        if open_result is not None:\n            yield open_result\n        yield self._receive_frame_loop()",
        "begin_line": 911,
        "end_line": 960,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._parse_extensions_header#962",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._parse_extensions_header(self, headers: httputil.HTTPHeaders)",
        "snippet": "    def _parse_extensions_header(\n        self, headers: httputil.HTTPHeaders\n    ) -> List[Tuple[str, Dict[str, str]]]:\n        extensions = headers.get(\"Sec-WebSocket-Extensions\", \"\")\n        if extensions:\n            return [httputil._parse_header(e.strip()) for e in extensions.split(\",\")]\n        return []",
        "begin_line": 962,
        "end_line": 968,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._process_server_headers#970",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._process_server_headers(self, key: Union[str, bytes], headers: httputil.HTTPHeaders)",
        "snippet": "    def _process_server_headers(\n        self, key: Union[str, bytes], headers: httputil.HTTPHeaders\n    ) -> None:\n        \"\"\"Process the headers sent by the server to this client connection.\n\n        'key' is the websocket handshake challenge/response key.\n        \"\"\"\n        assert headers[\"Upgrade\"].lower() == \"websocket\"\n        assert headers[\"Connection\"].lower() == \"upgrade\"\n        accept = self.compute_accept_value(key)\n        assert headers[\"Sec-Websocket-Accept\"] == accept\n\n        extensions = self._parse_extensions_header(headers)\n        for ext in extensions:\n            if ext[0] == \"permessage-deflate\" and self._compression_options is not None:\n                self._create_compressors(\"client\", ext[1])\n            else:\n                raise ValueError(\"unsupported extension %r\", ext)\n\n        self.selected_subprotocol = headers.get(\"Sec-WebSocket-Protocol\", None)",
        "begin_line": 970,
        "end_line": 989,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._get_compressor_options#991",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._get_compressor_options(self, side: str, agreed_parameters: Dict[str, Any], compression_options: Dict[str, Any]=None)",
        "snippet": "    def _get_compressor_options(\n        self,\n        side: str,\n        agreed_parameters: Dict[str, Any],\n        compression_options: Dict[str, Any] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"Converts a websocket agreed_parameters set to keyword arguments\n        for our compressor objects.\n        \"\"\"\n        options = dict(\n            persistent=(side + \"_no_context_takeover\") not in agreed_parameters\n        )  # type: Dict[str, Any]\n        wbits_header = agreed_parameters.get(side + \"_max_window_bits\", None)\n        if wbits_header is None:\n            options[\"max_wbits\"] = zlib.MAX_WBITS\n        else:\n            options[\"max_wbits\"] = int(wbits_header)\n        options[\"compression_options\"] = compression_options\n        return options",
        "begin_line": 991,
        "end_line": 1009,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._create_compressors#1011",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._create_compressors(self, side: str, agreed_parameters: Dict[str, Any], compression_options: Dict[str, Any]=None)",
        "snippet": "    def _create_compressors(\n        self,\n        side: str,\n        agreed_parameters: Dict[str, Any],\n        compression_options: Dict[str, Any] = None,\n    ) -> None:\n        # TODO: handle invalid parameters gracefully\n        allowed_keys = set(\n            [\n                \"server_no_context_takeover\",\n                \"client_no_context_takeover\",\n                \"server_max_window_bits\",\n                \"client_max_window_bits\",\n            ]\n        )\n        for key in agreed_parameters:\n            if key not in allowed_keys:\n                raise ValueError(\"unsupported compression parameter %r\" % key)\n        other_side = \"client\" if (side == \"server\") else \"server\"\n        self._compressor = _PerMessageDeflateCompressor(\n            **self._get_compressor_options(side, agreed_parameters, compression_options)\n        )\n        self._decompressor = _PerMessageDeflateDecompressor(\n            max_message_size=self.handler.max_message_size,\n            **self._get_compressor_options(\n                other_side, agreed_parameters, compression_options\n            )\n        )",
        "begin_line": 1011,
        "end_line": 1038,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._write_frame#1040",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._write_frame(self, fin: bool, opcode: int, data: bytes, flags: int=0)",
        "snippet": "    def _write_frame(\n        self, fin: bool, opcode: int, data: bytes, flags: int = 0\n    ) -> \"Future[None]\":\n        data_len = len(data)\n        if opcode & 0x8:\n            # All control frames MUST have a payload length of 125\n            # bytes or less and MUST NOT be fragmented.\n            if not fin:\n                raise ValueError(\"control frames may not be fragmented\")\n            if data_len > 125:\n                raise ValueError(\"control frame payloads may not exceed 125 bytes\")\n        if fin:\n            finbit = self.FIN\n        else:\n            finbit = 0\n        frame = struct.pack(\"B\", finbit | opcode | flags)\n        if self.mask_outgoing:\n            mask_bit = 0x80\n        else:\n            mask_bit = 0\n        if data_len < 126:\n            frame += struct.pack(\"B\", data_len | mask_bit)\n        elif data_len <= 0xFFFF:\n            frame += struct.pack(\"!BH\", 126 | mask_bit, data_len)\n        else:\n            frame += struct.pack(\"!BQ\", 127 | mask_bit, data_len)\n        if self.mask_outgoing:\n            mask = os.urandom(4)\n            data = mask + _websocket_mask(mask, data)\n        frame += data\n        self._wire_bytes_out += len(frame)\n        return self.stream.write(frame)",
        "begin_line": 1040,
        "end_line": 1071,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.write_message#1073",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.write_message(self, message: Union[str, bytes], binary: bool=False)",
        "snippet": "    def write_message(\n        self, message: Union[str, bytes], binary: bool = False\n    ) -> \"Future[None]\":\n        \"\"\"Sends the given message to the client of this Web Socket.\"\"\"\n        if binary:\n            opcode = 0x2\n        else:\n            opcode = 0x1\n        message = tornado.escape.utf8(message)\n        assert isinstance(message, bytes)\n        self._message_bytes_out += len(message)\n        flags = 0\n        if self._compressor:\n            message = self._compressor.compress(message)\n            flags |= self.RSV1\n        # For historical reasons, write methods in Tornado operate in a semi-synchronous\n        # mode in which awaiting the Future they return is optional (But errors can\n        # still be raised). This requires us to go through an awkward dance here\n        # to transform the errors that may be returned while presenting the same\n        # semi-synchronous interface.\n        try:\n            fut = self._write_frame(True, opcode, message, flags=flags)\n        except StreamClosedError:\n            raise WebSocketClosedError()\n\n        @gen.coroutine\n        def wrapper() -> Generator[Any, Any, None]:\n            try:\n                yield fut\n            except StreamClosedError:\n                raise WebSocketClosedError()\n\n        return wrapper()",
        "begin_line": 1073,
        "end_line": 1105,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.wrapper#1099",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.wrapper()",
        "snippet": "        def wrapper() -> Generator[Any, Any, None]:\n            try:\n                yield fut\n            except StreamClosedError:\n                raise WebSocketClosedError()",
        "begin_line": 1099,
        "end_line": 1103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015603058199407084,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.write_ping#1107",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.write_ping(self, data: bytes)",
        "snippet": "    def write_ping(self, data: bytes) -> None:\n        \"\"\"Send ping frame.\"\"\"\n        assert isinstance(data, bytes)\n        self._write_frame(True, 0x9, data)",
        "begin_line": 1107,
        "end_line": 1110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._receive_frame_loop#1113",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._receive_frame_loop(self)",
        "snippet": "    def _receive_frame_loop(self) -> Generator[Any, Any, None]:\n        try:\n            while not self.client_terminated:\n                yield self._receive_frame()\n        except StreamClosedError:\n            self._abort()",
        "begin_line": 1113,
        "end_line": 1118,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._read_bytes#1120",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._read_bytes(self, n: int)",
        "snippet": "    def _read_bytes(self, n: int) -> Awaitable[bytes]:\n        self._wire_bytes_in += n\n        return self.stream.read_bytes(n)",
        "begin_line": 1120,
        "end_line": 1122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015160703456640388,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._receive_frame#1125",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._receive_frame(self)",
        "snippet": "    def _receive_frame(self) -> Generator[Any, Any, None]:\n        # Read the frame header.\n        data = yield self._read_bytes(2)\n        header, mask_payloadlen = struct.unpack(\"BB\", data)\n        is_final_frame = header & self.FIN\n        reserved_bits = header & self.RSV_MASK\n        opcode = header & self.OPCODE_MASK\n        opcode_is_control = opcode & 0x8\n        if self._decompressor is not None and opcode != 0:\n            # Compression flag is present in the first frame's header,\n            # but we can't decompress until we have all the frames of\n            # the message.\n            self._frame_compressed = bool(reserved_bits & self.RSV1)\n            reserved_bits &= ~self.RSV1\n        if reserved_bits:\n            # client is using as-yet-undefined extensions; abort\n            self._abort()\n            return\n        is_masked = bool(mask_payloadlen & 0x80)\n        payloadlen = mask_payloadlen & 0x7F\n\n        # Parse and validate the length.\n        if opcode_is_control and payloadlen >= 126:\n            # control frames must have payload < 126\n            self._abort()\n            return\n        if payloadlen < 126:\n            self._frame_length = payloadlen\n        elif payloadlen == 126:\n            data = yield self._read_bytes(2)\n            payloadlen = struct.unpack(\"!H\", data)[0]\n        elif payloadlen == 127:\n            data = yield self._read_bytes(8)\n            payloadlen = struct.unpack(\"!Q\", data)[0]\n        new_len = payloadlen\n        if self._fragmented_message_buffer is not None:\n            new_len += len(self._fragmented_message_buffer)\n        if new_len > self.handler.max_message_size:\n            self.close(1009, \"message too big\")\n            self._abort()\n            return\n\n        # Read the payload, unmasking if necessary.\n        if is_masked:\n            self._frame_mask = yield self._read_bytes(4)\n        data = yield self._read_bytes(payloadlen)\n        if is_masked:\n            assert self._frame_mask is not None\n            data = _websocket_mask(self._frame_mask, data)\n\n        # Decide what to do with this frame.\n        if opcode_is_control:\n            # control frames may be interleaved with a series of fragmented\n            # data frames, so control frames must not interact with\n            # self._fragmented_*\n            if not is_final_frame:\n                # control frames must not be fragmented\n                self._abort()\n                return\n        elif opcode == 0:  # continuation frame\n            if self._fragmented_message_buffer is None:\n                # nothing to continue\n                self._abort()\n                return\n            self._fragmented_message_buffer += data\n            if is_final_frame:\n                opcode = self._fragmented_message_opcode\n                data = self._fragmented_message_buffer\n                self._fragmented_message_buffer = None\n        else:  # start of new data message\n            if self._fragmented_message_buffer is not None:\n                # can't start new message until the old one is finished\n                self._abort()\n                return\n            if not is_final_frame:\n                self._fragmented_message_opcode = opcode\n                self._fragmented_message_buffer = data\n\n        if is_final_frame:\n            handled_future = self._handle_message(opcode, data)\n            if handled_future is not None:\n                yield handled_future",
        "begin_line": 1125,
        "end_line": 1206,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._handle_message#1208",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._handle_message(self, opcode: int, data: bytes)",
        "snippet": "    def _handle_message(self, opcode: int, data: bytes) -> Optional[\"Future[None]\"]:\n        \"\"\"Execute on_message, returning its Future if it is a coroutine.\"\"\"\n        if self.client_terminated:\n            return None\n\n        if self._frame_compressed:\n            assert self._decompressor is not None\n            try:\n                data = self._decompressor.decompress(data)\n            except _DecompressTooLargeError:\n                self.close(1009, \"message too big after decompression\")\n                self._abort()\n                return None\n\n        if opcode == 0x1:\n            # UTF-8 data\n            self._message_bytes_in += len(data)\n            try:\n                decoded = data.decode(\"utf-8\")\n            except UnicodeDecodeError:\n                self._abort()\n                return None\n            return self._run_callback(self.handler.on_message, decoded)\n        elif opcode == 0x2:\n            # Binary data\n            self._message_bytes_in += len(data)\n            return self._run_callback(self.handler.on_message, data)\n        elif opcode == 0x8:\n            # Close\n            self.client_terminated = True\n            if len(data) >= 2:\n                self.handler.close_code = struct.unpack(\">H\", data[:2])[0]\n            if len(data) > 2:\n                self.handler.close_reason = to_unicode(data[2:])\n            # Echo the received close code, if any (RFC 6455 section 5.5.1).\n            self.close(self.handler.close_code)\n        elif opcode == 0x9:\n            # Ping\n            try:\n                self._write_frame(True, 0xA, data)\n            except StreamClosedError:\n                self._abort()\n            self._run_callback(self.handler.on_ping, data)\n        elif opcode == 0xA:\n            # Pong\n            self.last_pong = IOLoop.current().time()\n            return self._run_callback(self.handler.on_pong, data)\n        else:\n            self._abort()\n        return None",
        "begin_line": 1208,
        "end_line": 1257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.close#1259",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.close(self, code: int=None, reason: str=None)",
        "snippet": "    def close(self, code: int = None, reason: str = None) -> None:\n        \"\"\"Closes the WebSocket connection.\"\"\"\n        if not self.server_terminated:\n            if not self.stream.closed():\n                if code is None and reason is not None:\n                    code = 1000  # \"normal closure\" status code\n                if code is None:\n                    close_data = b\"\"\n                else:\n                    close_data = struct.pack(\">H\", code)\n                if reason is not None:\n                    close_data += utf8(reason)\n                try:\n                    self._write_frame(True, 0x8, close_data)\n                except StreamClosedError:\n                    self._abort()\n            self.server_terminated = True\n        if self.client_terminated:\n            if self._waiting is not None:\n                self.stream.io_loop.remove_timeout(self._waiting)\n                self._waiting = None\n            self.stream.close()\n        elif self._waiting is None:\n            # Give the client a few seconds to complete a clean shutdown,\n            # otherwise just close the connection.\n            self._waiting = self.stream.io_loop.add_timeout(\n                self.stream.io_loop.time() + 5, self._abort\n            )",
        "begin_line": 1259,
        "end_line": 1286,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.is_closing#1288",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.is_closing(self)",
        "snippet": "    def is_closing(self) -> bool:\n        \"\"\"Return true if this connection is closing.\n\n        The connection is considered closing if either side has\n        initiated its closing handshake or if the stream has been\n        shut down uncleanly.\n        \"\"\"\n        return self.stream.closed() or self.client_terminated or self.server_terminated",
        "begin_line": 1288,
        "end_line": 1295,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015698587127158556,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.ping_interval#1298",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.ping_interval(self)",
        "snippet": "    def ping_interval(self) -> Optional[float]:\n        interval = self.handler.ping_interval\n        if interval is not None:\n            return interval\n        return 0",
        "begin_line": 1298,
        "end_line": 1302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.ping_timeout#1305",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.ping_timeout(self)",
        "snippet": "    def ping_timeout(self) -> Optional[float]:\n        timeout = self.handler.ping_timeout\n        if timeout is not None:\n            return timeout\n        assert self.ping_interval is not None\n        return max(3 * self.ping_interval, 30)",
        "begin_line": 1305,
        "end_line": 1310,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.start_pinging#1312",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.start_pinging(self)",
        "snippet": "    def start_pinging(self) -> None:\n        \"\"\"Start sending periodic pings to keep the connection alive\"\"\"\n        assert self.ping_interval is not None\n        if self.ping_interval > 0:\n            self.last_ping = self.last_pong = IOLoop.current().time()\n            self.ping_callback = PeriodicCallback(\n                self.periodic_ping, self.ping_interval * 1000\n            )\n            self.ping_callback.start()",
        "begin_line": 1312,
        "end_line": 1320,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.periodic_ping#1322",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.periodic_ping(self)",
        "snippet": "    def periodic_ping(self) -> None:\n        \"\"\"Send a ping to keep the websocket alive\n\n        Called periodically if the websocket_ping_interval is set and non-zero.\n        \"\"\"\n        if self.is_closing() and self.ping_callback is not None:\n            self.ping_callback.stop()\n            return\n\n        # Check for timeout on pong. Make sure that we really have\n        # sent a recent ping in case the machine with both server and\n        # client has been suspended since the last ping.\n        now = IOLoop.current().time()\n        since_last_pong = now - self.last_pong\n        since_last_ping = now - self.last_ping\n        assert self.ping_interval is not None\n        assert self.ping_timeout is not None\n        if (\n            since_last_ping < 2 * self.ping_interval\n            and since_last_pong > self.ping_timeout\n        ):\n            self.close()\n            return\n\n        self.write_ping(b\"\")\n        self.last_ping = now",
        "begin_line": 1322,
        "end_line": 1347,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.__init__#1359",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.__init__(self, request: httpclient.HTTPRequest, on_message_callback: Callable[[Union[None, str, bytes]], None]=None, compression_options: Dict[str, Any]=None, ping_interval: float=None, ping_timeout: float=None, max_message_size: int=_default_max_message_size, subprotocols: Optional[List[str]]=[])",
        "snippet": "    def __init__(\n        self,\n        request: httpclient.HTTPRequest,\n        on_message_callback: Callable[[Union[None, str, bytes]], None] = None,\n        compression_options: Dict[str, Any] = None,\n        ping_interval: float = None,\n        ping_timeout: float = None,\n        max_message_size: int = _default_max_message_size,\n        subprotocols: Optional[List[str]] = [],\n    ) -> None:\n        self.compression_options = compression_options\n        self.connect_future = Future()  # type: Future[WebSocketClientConnection]\n        self.read_queue = Queue(1)  # type: Queue[Union[None, str, bytes]]\n        self.key = base64.b64encode(os.urandom(16))\n        self._on_message_callback = on_message_callback\n        self.close_code = None  # type: Optional[int]\n        self.close_reason = None  # type: Optional[str]\n        self.ping_interval = ping_interval\n        self.ping_timeout = ping_timeout\n        self.max_message_size = max_message_size\n\n        scheme, sep, rest = request.url.partition(\":\")\n        scheme = {\"ws\": \"http\", \"wss\": \"https\"}[scheme]\n        request.url = scheme + sep + rest\n        request.headers.update(\n            {\n                \"Upgrade\": \"websocket\",\n                \"Connection\": \"Upgrade\",\n                \"Sec-WebSocket-Key\": self.key,\n                \"Sec-WebSocket-Version\": \"13\",\n            }\n        )\n        if subprotocols is not None:\n            request.headers[\"Sec-WebSocket-Protocol\"] = \",\".join(subprotocols)\n        if self.compression_options is not None:\n            # Always offer to let the server set our max_wbits (and even though\n            # we don't offer it, we will accept a client_no_context_takeover\n            # from the server).\n            # TODO: set server parameters for deflate extension\n            # if requested in self.compression_options.\n            request.headers[\n                \"Sec-WebSocket-Extensions\"\n            ] = \"permessage-deflate; client_max_window_bits\"\n\n        self.tcp_client = TCPClient()\n        super(WebSocketClientConnection, self).__init__(\n            None,\n            request,\n            lambda: None,\n            self._on_http_response,\n            104857600,\n            self.tcp_client,\n            65536,\n            104857600,\n        )",
        "begin_line": 1359,
        "end_line": 1413,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.close#1415",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.close(self, code: int=None, reason: str=None)",
        "snippet": "    def close(self, code: int = None, reason: str = None) -> None:\n        \"\"\"Closes the websocket connection.\n\n        ``code`` and ``reason`` are documented under\n        `WebSocketHandler.close`.\n\n        .. versionadded:: 3.2\n\n        .. versionchanged:: 4.0\n\n           Added the ``code`` and ``reason`` arguments.\n        \"\"\"\n        if self.protocol is not None:\n            self.protocol.close(code, reason)\n            self.protocol = None  # type: ignore",
        "begin_line": 1415,
        "end_line": 1429,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016144656118824668,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.on_connection_close#1431",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.on_connection_close(self)",
        "snippet": "    def on_connection_close(self) -> None:\n        if not self.connect_future.done():\n            self.connect_future.set_exception(StreamClosedError())\n        self._on_message(None)\n        self.tcp_client.close()\n        super(WebSocketClientConnection, self).on_connection_close()",
        "begin_line": 1431,
        "end_line": 1436,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015603058199407084,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection._on_http_response#1438",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection._on_http_response(self, response: httpclient.HTTPResponse)",
        "snippet": "    def _on_http_response(self, response: httpclient.HTTPResponse) -> None:\n        if not self.connect_future.done():\n            if response.error:\n                self.connect_future.set_exception(response.error)\n            else:\n                self.connect_future.set_exception(\n                    WebSocketError(\"Non-websocket response\")\n                )",
        "begin_line": 1438,
        "end_line": 1445,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.headers_received#1447",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.headers_received(self, start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine], headers: httputil.HTTPHeaders)",
        "snippet": "    async def headers_received(\n        self,\n        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],\n        headers: httputil.HTTPHeaders,\n    ) -> None:\n        assert isinstance(start_line, httputil.ResponseStartLine)\n        if start_line.code != 101:\n            await super(WebSocketClientConnection, self).headers_received(\n                start_line, headers\n            )\n            return\n\n        self.headers = headers\n        self.protocol = self.get_websocket_protocol()\n        self.protocol._process_server_headers(self.key, self.headers)\n        self.protocol.start_pinging()\n        IOLoop.current().add_callback(self.protocol._receive_frame_loop)\n\n        if self._timeout is not None:\n            self.io_loop.remove_timeout(self._timeout)\n            self._timeout = None\n\n        self.stream = self.connection.detach()\n        self.stream.set_close_callback(self.on_connection_close)\n        # Once we've taken over the connection, clear the final callback\n        # we set on the http request.  This deactivates the error handling\n        # in simple_httpclient that would otherwise interfere with our\n        # ability to see exceptions.\n        self.final_callback = None  # type: ignore\n\n        future_set_result_unless_cancelled(self.connect_future, self)",
        "begin_line": 1447,
        "end_line": 1477,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.write_message#1479",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.write_message(self, message: Union[str, bytes], binary: bool=False)",
        "snippet": "    def write_message(\n        self, message: Union[str, bytes], binary: bool = False\n    ) -> \"Future[None]\":\n        \"\"\"Sends a message to the WebSocket server.\n\n        If the stream is closed, raises `WebSocketClosedError`.\n        Returns a `.Future` which can be used for flow control.\n\n        .. versionchanged:: 5.0\n           Exception raised on a closed stream changed from `.StreamClosedError`\n           to `WebSocketClosedError`.\n        \"\"\"\n        return self.protocol.write_message(message, binary=binary)",
        "begin_line": 1479,
        "end_line": 1491,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016220600162206002,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.read_message#1493",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.read_message(self, callback: Callable[['Future[Union[None, str, bytes]]'], None]=None)",
        "snippet": "    def read_message(\n        self, callback: Callable[[\"Future[Union[None, str, bytes]]\"], None] = None\n    ) -> \"Future[Union[None, str, bytes]]\":\n        \"\"\"Reads a message from the WebSocket server.\n\n        If on_message_callback was specified at WebSocket\n        initialization, this function will never return messages\n\n        Returns a future whose result is the message, or None\n        if the connection is closed.  If a callback argument\n        is given it will be called with the future when it is\n        ready.\n        \"\"\"\n\n        future = self.read_queue.get()\n        if callback is not None:\n            self.io_loop.add_future(future, callback)\n        return future",
        "begin_line": 1493,
        "end_line": 1510,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.on_message#1512",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.on_message(self, message: Union[str, bytes])",
        "snippet": "    def on_message(self, message: Union[str, bytes]) -> Optional[\"Future[None]\"]:\n        return self._on_message(message)",
        "begin_line": 1512,
        "end_line": 1513,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001588057805304113,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection._on_message#1515",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection._on_message(self, message: Union[None, str, bytes])",
        "snippet": "    def _on_message(self, message: Union[None, str, bytes]) -> Optional[\"Future[None]\"]:\n        if self._on_message_callback:\n            self._on_message_callback(message)\n            return None\n        else:\n            return self.read_queue.put(message)",
        "begin_line": 1515,
        "end_line": 1520,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015160703456640388,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.ping#1522",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.ping(self, data: bytes=b'')",
        "snippet": "    def ping(self, data: bytes = b\"\") -> None:\n        \"\"\"Send ping frame to the remote end.\n\n        The data argument allows a small amount of data (up to 125\n        bytes) to be sent as a part of the ping message. Note that not\n        all websocket implementations expose this data to\n        applications.\n\n        Consider using the ``ping_interval`` argument to\n        `websocket_connect` instead of sending pings manually.\n\n        .. versionadded:: 5.1\n\n        \"\"\"\n        data = utf8(data)\n        if self.protocol is None:\n            raise WebSocketClosedError()\n        self.protocol.write_ping(data)",
        "begin_line": 1522,
        "end_line": 1539,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.on_pong#1541",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.on_pong(self, data: bytes)",
        "snippet": "    def on_pong(self, data: bytes) -> None:\n        pass",
        "begin_line": 1541,
        "end_line": 1542,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.on_ping#1544",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.on_ping(self, data: bytes)",
        "snippet": "    def on_ping(self, data: bytes) -> None:\n        pass",
        "begin_line": 1544,
        "end_line": 1545,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.get_websocket_protocol#1547",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.get_websocket_protocol(self)",
        "snippet": "    def get_websocket_protocol(self) -> WebSocketProtocol:\n        return WebSocketProtocol13(\n            self, mask_outgoing=True, compression_options=self.compression_options\n        )",
        "begin_line": 1547,
        "end_line": 1550,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00015160703456640388,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.selected_subprotocol#1553",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.selected_subprotocol(self)",
        "snippet": "    def selected_subprotocol(self) -> Optional[str]:\n        \"\"\"The subprotocol selected by the server.\n\n        .. versionadded:: 5.1\n        \"\"\"\n        return self.protocol.selected_subprotocol",
        "begin_line": 1553,
        "end_line": 1558,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.websocket.websocket_connect#1571",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket",
        "signature": "tornado.websocket.websocket_connect(url: Union[str, httpclient.HTTPRequest], callback: Callable[['Future[WebSocketClientConnection]'], None]=None, connect_timeout: float=None, on_message_callback: Callable[[Union[None, str, bytes]], None]=None, compression_options: Dict[str, Any]=None, ping_interval: float=None, ping_timeout: float=None, max_message_size: int=_default_max_message_size, subprotocols: List[str]=None)",
        "snippet": "def websocket_connect(\n    url: Union[str, httpclient.HTTPRequest],\n    callback: Callable[[\"Future[WebSocketClientConnection]\"], None] = None,\n    connect_timeout: float = None,\n    on_message_callback: Callable[[Union[None, str, bytes]], None] = None,\n    compression_options: Dict[str, Any] = None,\n    ping_interval: float = None,\n    ping_timeout: float = None,\n    max_message_size: int = _default_max_message_size,\n    subprotocols: List[str] = None,\n) -> \"Future[WebSocketClientConnection]\":\n    \"\"\"Client-side websocket support.\n\n    Takes a url and returns a Future whose result is a\n    `WebSocketClientConnection`.\n\n    ``compression_options`` is interpreted in the same way as the\n    return value of `.WebSocketHandler.get_compression_options`.\n\n    The connection supports two styles of operation. In the coroutine\n    style, the application typically calls\n    `~.WebSocketClientConnection.read_message` in a loop::\n\n        conn = yield websocket_connect(url)\n        while True:\n            msg = yield conn.read_message()\n            if msg is None: break\n            # Do something with msg\n\n    In the callback style, pass an ``on_message_callback`` to\n    ``websocket_connect``. In both styles, a message of ``None``\n    indicates that the connection has been closed.\n\n    ``subprotocols`` may be a list of strings specifying proposed\n    subprotocols. The selected protocol may be found on the\n    ``selected_subprotocol`` attribute of the connection object\n    when the connection is complete.\n\n    .. versionchanged:: 3.2\n       Also accepts ``HTTPRequest`` objects in place of urls.\n\n    .. versionchanged:: 4.1\n       Added ``compression_options`` and ``on_message_callback``.\n\n    .. versionchanged:: 4.5\n       Added the ``ping_interval``, ``ping_timeout``, and ``max_message_size``\n       arguments, which have the same meaning as in `WebSocketHandler`.\n\n    .. versionchanged:: 5.0\n       The ``io_loop`` argument (deprecated since version 4.1) has been removed.\n\n    .. versionchanged:: 5.1\n       Added the ``subprotocols`` argument.\n    \"\"\"\n    if isinstance(url, httpclient.HTTPRequest):\n        assert connect_timeout is None\n        request = url\n        # Copy and convert the headers dict/object (see comments in\n        # AsyncHTTPClient.fetch)\n        request.headers = httputil.HTTPHeaders(request.headers)\n    else:\n        request = httpclient.HTTPRequest(url, connect_timeout=connect_timeout)\n    request = cast(\n        httpclient.HTTPRequest,\n        httpclient._RequestProxy(request, httpclient.HTTPRequest._DEFAULTS),\n    )\n    conn = WebSocketClientConnection(\n        request,\n        on_message_callback=on_message_callback,\n        compression_options=compression_options,\n        ping_interval=ping_interval,\n        ping_timeout=ping_timeout,\n        max_message_size=max_message_size,\n        subprotocols=subprotocols,\n    )\n    if callback is not None:\n        IOLoop.current().add_future(conn.connect_future, callback)\n    return conn.connect_future",
        "begin_line": 1571,
        "end_line": 1648,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks._TimeoutGarbageCollector.__init__#42",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks._TimeoutGarbageCollector",
        "signature": "tornado.locks._TimeoutGarbageCollector.__init__(self)",
        "snippet": "    def __init__(self) -> None:\n        self._waiters = collections.deque()  # type: Deque[Future]\n        self._timeouts = 0",
        "begin_line": 42,
        "end_line": 44,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00014755791648221928,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks._TimeoutGarbageCollector._garbage_collect#46",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks._TimeoutGarbageCollector",
        "signature": "tornado.locks._TimeoutGarbageCollector._garbage_collect(self)",
        "snippet": "    def _garbage_collect(self) -> None:\n        # Occasionally clear timed-out waiters.\n        self._timeouts += 1\n        if self._timeouts > 100:\n            self._timeouts = 0\n            self._waiters = collections.deque(w for w in self._waiters if not w.done())",
        "begin_line": 46,
        "end_line": 51,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Condition.__init__#114",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Condition",
        "signature": "tornado.locks.Condition.__init__(self)",
        "snippet": "    def __init__(self) -> None:\n        super(Condition, self).__init__()\n        self.io_loop = ioloop.IOLoop.current()",
        "begin_line": 114,
        "end_line": 116,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016903313049357674,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Condition.__repr__#118",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Condition",
        "signature": "tornado.locks.Condition.__repr__(self)",
        "snippet": "    def __repr__(self) -> str:\n        result = \"<%s\" % (self.__class__.__name__,)\n        if self._waiters:\n            result += \" waiters[%s]\" % len(self._waiters)\n        return result + \">\"",
        "begin_line": 118,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Condition.wait#124",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Condition",
        "signature": "tornado.locks.Condition.wait(self, timeout: Union[float, datetime.timedelta]=None)",
        "snippet": "    def wait(self, timeout: Union[float, datetime.timedelta] = None) -> \"Future[bool]\":\n        \"\"\"Wait for `.notify`.\n\n        Returns a `.Future` that resolves ``True`` if the condition is notified,\n        or ``False`` after a timeout.\n        \"\"\"\n        waiter = Future()  # type: Future[bool]\n        self._waiters.append(waiter)\n        if timeout:\n\n            def on_timeout() -> None:\n                if not waiter.done():\n                    future_set_result_unless_cancelled(waiter, False)\n                self._garbage_collect()\n\n            io_loop = ioloop.IOLoop.current()\n            timeout_handle = io_loop.add_timeout(timeout, on_timeout)\n            waiter.add_done_callback(lambda _: io_loop.remove_timeout(timeout_handle))\n        return waiter",
        "begin_line": 124,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Condition.on_timeout#134",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Condition",
        "signature": "tornado.locks.Condition.on_timeout()",
        "snippet": "            def on_timeout() -> None:\n                if not waiter.done():\n                    future_set_result_unless_cancelled(waiter, False)\n                self._garbage_collect()",
        "begin_line": 134,
        "end_line": 137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Condition.notify#144",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Condition",
        "signature": "tornado.locks.Condition.notify(self, n: int=1)",
        "snippet": "    def notify(self, n: int = 1) -> None:\n        \"\"\"Wake ``n`` waiters.\"\"\"\n        waiters = []  # Waiters we plan to run right now.\n        while n and self._waiters:\n            waiter = self._waiters.popleft()\n            if not waiter.done():  # Might have timed out.\n                n -= 1\n                waiters.append(waiter)\n\n        for waiter in waiters:\n            future_set_result_unless_cancelled(waiter, True)",
        "begin_line": 144,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017214666896195557,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Condition.notify_all#156",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Condition",
        "signature": "tornado.locks.Condition.notify_all(self)",
        "snippet": "    def notify_all(self) -> None:\n        \"\"\"Wake all waiters.\"\"\"\n        self.notify(len(self._waiters))",
        "begin_line": 156,
        "end_line": 158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Event.__init__#201",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Event",
        "signature": "tornado.locks.Event.__init__(self)",
        "snippet": "    def __init__(self) -> None:\n        self._value = False\n        self._waiters = set()  # type: Set[Future[None]]",
        "begin_line": 201,
        "end_line": 203,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009259259259259259,
            "pseudo_dstar_susp": 0.001694915254237288,
            "pseudo_tarantula_susp": 0.003703703703703704,
            "pseudo_op2_susp": 0.001694915254237288,
            "pseudo_barinel_susp": 0.003703703703703704
        }
    },
    {
        "name": "tornado.locks.Event.__repr__#205",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Event",
        "signature": "tornado.locks.Event.__repr__(self)",
        "snippet": "    def __repr__(self) -> str:\n        return \"<%s %s>\" % (\n            self.__class__.__name__,\n            \"set\" if self.is_set() else \"clear\",\n        )",
        "begin_line": 205,
        "end_line": 209,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Event.is_set#211",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Event",
        "signature": "tornado.locks.Event.is_set(self)",
        "snippet": "    def is_set(self) -> bool:\n        \"\"\"Return ``True`` if the internal flag is true.\"\"\"\n        return self._value",
        "begin_line": 211,
        "end_line": 213,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Event.set#215",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Event",
        "signature": "tornado.locks.Event.set(self)",
        "snippet": "    def set(self) -> None:\n        \"\"\"Set the internal flag to ``True``. All waiters are awakened.\n\n        Calling `.wait` once the flag is set will not block.\n        \"\"\"\n        if not self._value:\n            self._value = True\n\n            for fut in self._waiters:\n                if not fut.done():\n                    fut.set_result(None)",
        "begin_line": 215,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.017857142857142856,
            "pseudo_dstar_susp": 0.0017064846416382253,
            "pseudo_tarantula_susp": 0.007874015748031496,
            "pseudo_op2_susp": 0.0017064846416382253,
            "pseudo_barinel_susp": 0.007874015748031496
        }
    },
    {
        "name": "tornado.locks.Event.clear#227",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Event",
        "signature": "tornado.locks.Event.clear(self)",
        "snippet": "    def clear(self) -> None:\n        \"\"\"Reset the internal flag to ``False``.\n\n        Calls to `.wait` will block until `.set` is called.\n        \"\"\"\n        self._value = False",
        "begin_line": 227,
        "end_line": 232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0001399972000559989,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Event.wait#234",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Event",
        "signature": "tornado.locks.Event.wait(self, timeout: Union[float, datetime.timedelta]=None)",
        "snippet": "    def wait(self, timeout: Union[float, datetime.timedelta] = None) -> \"Future[None]\":\n        \"\"\"Block until the internal flag is true.\n\n        Returns a Future, which raises `tornado.util.TimeoutError` after a\n        timeout.\n        \"\"\"\n        fut = Future()  # type: Future[None]\n        if self._value:\n            fut.set_result(None)\n            return fut\n        self._waiters.add(fut)\n        fut.add_done_callback(lambda fut: self._waiters.remove(fut))\n        if timeout is None:\n            return fut\n        else:\n            timeout_fut = gen.with_timeout(\n                timeout, fut, quiet_exceptions=(CancelledError,)\n            )\n            # This is a slightly clumsy workaround for the fact that\n            # gen.with_timeout doesn't cancel its futures. Cancelling\n            # fut will remove it from the waiters list.\n            timeout_fut.add_done_callback(\n                lambda tf: fut.cancel() if not fut.done() else None\n            )\n            return timeout_fut",
        "begin_line": 234,
        "end_line": 258,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03571428571428571,
            "pseudo_dstar_susp": 0.0030581039755351682,
            "pseudo_tarantula_susp": 0.008849557522123894,
            "pseudo_op2_susp": 0.0030581039755351682,
            "pseudo_barinel_susp": 0.008849557522123894
        }
    },
    {
        "name": "tornado.locks._ReleasingContextManager.__init__#270",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks._ReleasingContextManager",
        "signature": "tornado.locks._ReleasingContextManager.__init__(self, obj: Any)",
        "snippet": "    def __init__(self, obj: Any) -> None:\n        self._obj = obj",
        "begin_line": 270,
        "end_line": 271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016466326362588507,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks._ReleasingContextManager.__enter__#273",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks._ReleasingContextManager",
        "signature": "tornado.locks._ReleasingContextManager.__enter__(self)",
        "snippet": "    def __enter__(self) -> None:\n        pass",
        "begin_line": 273,
        "end_line": 274,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks._ReleasingContextManager.__exit__#276",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks._ReleasingContextManager",
        "signature": "tornado.locks._ReleasingContextManager.__exit__(self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException], exc_tb: Optional[types.TracebackType])",
        "snippet": "    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[types.TracebackType],\n    ) -> None:\n        self._obj.release()",
        "begin_line": 276,
        "end_line": 282,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Semaphore.__init__#381",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.__init__(self, value: int=1)",
        "snippet": "    def __init__(self, value: int = 1) -> None:\n        super(Semaphore, self).__init__()\n        if value < 0:\n            raise ValueError(\"semaphore initial value must be >= 0\")\n\n        self._value = value",
        "begin_line": 381,
        "end_line": 386,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Semaphore.__repr__#388",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.__repr__(self)",
        "snippet": "    def __repr__(self) -> str:\n        res = super(Semaphore, self).__repr__()\n        extra = (\n            \"locked\" if self._value == 0 else \"unlocked,value:{0}\".format(self._value)\n        )\n        if self._waiters:\n            extra = \"{0},waiters:{1}\".format(extra, len(self._waiters))\n        return \"<{0} [{1}]>\".format(res[1:-1], extra)",
        "begin_line": 388,
        "end_line": 395,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Semaphore.release#397",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.release(self)",
        "snippet": "    def release(self) -> None:\n        \"\"\"Increment the counter and wake one waiter.\"\"\"\n        self._value += 1\n        while self._waiters:\n            waiter = self._waiters.popleft()\n            if not waiter.done():\n                self._value -= 1\n\n                # If the waiter is a coroutine paused at\n                #\n                #     with (yield semaphore.acquire()):\n                #\n                # then the context manager's __exit__ calls release() at the end\n                # of the \"with\" block.\n                waiter.set_result(_ReleasingContextManager(self))\n                break",
        "begin_line": 397,
        "end_line": 412,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Semaphore.acquire#414",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.acquire(self, timeout: Union[float, datetime.timedelta]=None)",
        "snippet": "    def acquire(\n        self, timeout: Union[float, datetime.timedelta] = None\n    ) -> \"Future[_ReleasingContextManager]\":\n        \"\"\"Decrement the counter. Returns a Future.\n\n        Block if the counter is zero and wait for a `.release`. The Future\n        raises `.TimeoutError` after the deadline.\n        \"\"\"\n        waiter = Future()  # type: Future[_ReleasingContextManager]\n        if self._value > 0:\n            self._value -= 1\n            waiter.set_result(_ReleasingContextManager(self))\n        else:\n            self._waiters.append(waiter)\n            if timeout:\n\n                def on_timeout() -> None:\n                    if not waiter.done():\n                        waiter.set_exception(gen.TimeoutError())\n                    self._garbage_collect()\n\n                io_loop = ioloop.IOLoop.current()\n                timeout_handle = io_loop.add_timeout(timeout, on_timeout)\n                waiter.add_done_callback(\n                    lambda _: io_loop.remove_timeout(timeout_handle)\n                )\n        return waiter",
        "begin_line": 414,
        "end_line": 440,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019944156362185878,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Semaphore.on_timeout#430",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.on_timeout()",
        "snippet": "                def on_timeout() -> None:\n                    if not waiter.done():\n                        waiter.set_exception(gen.TimeoutError())\n                    self._garbage_collect()",
        "begin_line": 430,
        "end_line": 433,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Semaphore.__enter__#442",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.__enter__(self)",
        "snippet": "    def __enter__(self) -> None:\n        raise RuntimeError(\n            \"Use Semaphore like 'with (yield semaphore.acquire())', not like\"\n            \" 'with semaphore'\"\n        )",
        "begin_line": 442,
        "end_line": 446,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Semaphore.__aenter__#456",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.__aenter__(self)",
        "snippet": "    async def __aenter__(self) -> None:\n        await self.acquire()",
        "begin_line": 456,
        "end_line": 457,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Semaphore.__aexit__#459",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.__aexit__(self, typ: Optional[Type[BaseException]], value: Optional[BaseException], tb: Optional[types.TracebackType])",
        "snippet": "    async def __aexit__(\n        self,\n        typ: Optional[Type[BaseException]],\n        value: Optional[BaseException],\n        tb: Optional[types.TracebackType],\n    ) -> None:\n        self.release()",
        "begin_line": 459,
        "end_line": 465,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.BoundedSemaphore.__init__#477",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.BoundedSemaphore",
        "signature": "tornado.locks.BoundedSemaphore.__init__(self, value: int=1)",
        "snippet": "    def __init__(self, value: int = 1) -> None:\n        super(BoundedSemaphore, self).__init__(value=value)\n        self._initial_value = value",
        "begin_line": 477,
        "end_line": 479,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018135654697134566,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.BoundedSemaphore.release#481",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.BoundedSemaphore",
        "signature": "tornado.locks.BoundedSemaphore.release(self)",
        "snippet": "    def release(self) -> None:\n        \"\"\"Increment the counter and wake one waiter.\"\"\"\n        if self._value >= self._initial_value:\n            raise ValueError(\"Semaphore released too many times\")\n        super(BoundedSemaphore, self).release()",
        "begin_line": 481,
        "end_line": 485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Lock.__init__#525",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Lock",
        "signature": "tornado.locks.Lock.__init__(self)",
        "snippet": "    def __init__(self) -> None:\n        self._block = BoundedSemaphore(value=1)",
        "begin_line": 525,
        "end_line": 526,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00018511662347278786,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Lock.__repr__#528",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Lock",
        "signature": "tornado.locks.Lock.__repr__(self)",
        "snippet": "    def __repr__(self) -> str:\n        return \"<%s _block=%s>\" % (self.__class__.__name__, self._block)",
        "begin_line": 528,
        "end_line": 529,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002543881963876876,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Lock.acquire#531",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Lock",
        "signature": "tornado.locks.Lock.acquire(self, timeout: Union[float, datetime.timedelta]=None)",
        "snippet": "    def acquire(\n        self, timeout: Union[float, datetime.timedelta] = None\n    ) -> \"Future[_ReleasingContextManager]\":\n        \"\"\"Attempt to lock. Returns a Future.\n\n        Returns a Future, which raises `tornado.util.TimeoutError` after a\n        timeout.\n        \"\"\"\n        return self._block.acquire(timeout)",
        "begin_line": 531,
        "end_line": 539,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00019334880123743234,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Lock.release#541",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Lock",
        "signature": "tornado.locks.Lock.release(self)",
        "snippet": "    def release(self) -> None:\n        \"\"\"Unlock.\n\n        The first coroutine in line waiting for `acquire` gets the lock.\n\n        If not locked, raise a `RuntimeError`.\n        \"\"\"\n        try:\n            self._block.release()\n        except ValueError:\n            raise RuntimeError(\"release unlocked lock\")",
        "begin_line": 541,
        "end_line": 551,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Lock.__enter__#553",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Lock",
        "signature": "tornado.locks.Lock.__enter__(self)",
        "snippet": "    def __enter__(self) -> None:\n        raise RuntimeError(\"Use Lock like 'with (yield lock)', not like 'with lock'\")",
        "begin_line": 553,
        "end_line": 554,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Lock.__aenter__#564",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Lock",
        "signature": "tornado.locks.Lock.__aenter__(self)",
        "snippet": "    async def __aenter__(self) -> None:\n        await self.acquire()",
        "begin_line": 564,
        "end_line": 565,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locks.Lock.__aexit__#567",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Lock",
        "signature": "tornado.locks.Lock.__aexit__(self, typ: Optional[Type[BaseException]], value: Optional[BaseException], tb: Optional[types.TracebackType])",
        "snippet": "    async def __aexit__(\n        self,\n        typ: Optional[Type[BaseException]],\n        value: Optional[BaseException],\n        tb: Optional[types.TracebackType],\n    ) -> None:\n        self.release()",
        "begin_line": 567,
        "end_line": 573,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locale.get#63",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale",
        "signature": "tornado.locale.get(*locale_codes: str)",
        "snippet": "def get(*locale_codes: str) -> \"Locale\":\n    \"\"\"Returns the closest match for the given locale codes.\n\n    We iterate over all given locale codes in order. If we have a tight\n    or a loose match for the code (e.g., \"en\" for \"en_US\"), we return\n    the locale. Otherwise we move to the next code in the list.\n\n    By default we return ``en_US`` if no translations are found for any of\n    the specified locales. You can change the default locale with\n    `set_default_locale()`.\n    \"\"\"\n    return Locale.get_closest(*locale_codes)",
        "begin_line": 63,
        "end_line": 74,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016700066800267202,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locale.load_translations#91",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale",
        "signature": "tornado.locale.load_translations(directory: str, encoding: str=None)",
        "snippet": "def load_translations(directory: str, encoding: str = None) -> None:\n    \"\"\"Loads translations from CSV files in a directory.\n\n    Translations are strings with optional Python-style named placeholders\n    (e.g., ``My name is %(name)s``) and their associated translations.\n\n    The directory should have translation files of the form ``LOCALE.csv``,\n    e.g. ``es_GT.csv``. The CSV files should have two or three columns: string,\n    translation, and an optional plural indicator. Plural indicators should\n    be one of \"plural\" or \"singular\". A given string can have both singular\n    and plural forms. For example ``%(name)s liked this`` may have a\n    different verb conjugation depending on whether %(name)s is one\n    name or a list of names. There should be two rows in the CSV file for\n    that string, one with plural indicator \"singular\", and one \"plural\".\n    For strings with no verbs that would change on translation, simply\n    use \"unknown\" or the empty string (or don't include the column at all).\n\n    The file is read using the `csv` module in the default \"excel\" dialect.\n    In this format there should not be spaces after the commas.\n\n    If no ``encoding`` parameter is given, the encoding will be\n    detected automatically (among UTF-8 and UTF-16) if the file\n    contains a byte-order marker (BOM), defaulting to UTF-8 if no BOM\n    is present.\n\n    Example translation ``es_LA.csv``::\n\n        \"I love you\",\"Te amo\"\n        \"%(name)s liked this\",\"A %(name)s les gust\u00f3 esto\",\"plural\"\n        \"%(name)s liked this\",\"A %(name)s le gust\u00f3 esto\",\"singular\"\n\n    .. versionchanged:: 4.3\n       Added ``encoding`` parameter. Added support for BOM-based encoding\n       detection, UTF-16, and UTF-8-with-BOM.\n    \"\"\"\n    global _translations\n    global _supported_locales\n    _translations = {}\n    for path in os.listdir(directory):\n        if not path.endswith(\".csv\"):\n            continue\n        locale, extension = path.split(\".\")\n        if not re.match(\"[a-z]+(_[A-Z]+)?$\", locale):\n            gen_log.error(\n                \"Unrecognized locale %r (path: %s)\",\n                locale,\n                os.path.join(directory, path),\n            )\n            continue\n        full_path = os.path.join(directory, path)\n        if encoding is None:\n            # Try to autodetect encoding based on the BOM.\n            with open(full_path, \"rb\") as bf:\n                data = bf.read(len(codecs.BOM_UTF16_LE))\n            if data in (codecs.BOM_UTF16_LE, codecs.BOM_UTF16_BE):\n                encoding = \"utf-16\"\n            else:\n                # utf-8-sig is \"utf-8 with optional BOM\". It's discouraged\n                # in most cases but is common with CSV files because Excel\n                # cannot read utf-8 files without a BOM.\n                encoding = \"utf-8-sig\"\n        # python 3: csv.reader requires a file open in text mode.\n        # Specify an encoding to avoid dependence on $LANG environment variable.\n        f = open(full_path, \"r\", encoding=encoding)\n        _translations[locale] = {}\n        for i, row in enumerate(csv.reader(f)):\n            if not row or len(row) < 2:\n                continue\n            row = [escape.to_unicode(c).strip() for c in row]\n            english, translation = row[:2]\n            if len(row) > 2:\n                plural = row[2] or \"unknown\"\n            else:\n                plural = \"unknown\"\n            if plural not in (\"plural\", \"singular\", \"unknown\"):\n                gen_log.error(\n                    \"Unrecognized plural indicator %r in %s line %d\",\n                    plural,\n                    path,\n                    i + 1,\n                )\n                continue\n            _translations[locale].setdefault(plural, {})[english] = translation\n        f.close()\n    _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])\n    gen_log.debug(\"Supported locales: %s\", sorted(_supported_locales))",
        "begin_line": 91,
        "end_line": 176,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locale.load_gettext_translations#179",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale",
        "signature": "tornado.locale.load_gettext_translations(directory: str, domain: str)",
        "snippet": "def load_gettext_translations(directory: str, domain: str) -> None:\n    \"\"\"Loads translations from `gettext`'s locale tree\n\n    Locale tree is similar to system's ``/usr/share/locale``, like::\n\n        {directory}/{lang}/LC_MESSAGES/{domain}.mo\n\n    Three steps are required to have your app translated:\n\n    1. Generate POT translation file::\n\n        xgettext --language=Python --keyword=_:1,2 -d mydomain file1.py file2.html etc\n\n    2. Merge against existing POT file::\n\n        msgmerge old.po mydomain.po > new.po\n\n    3. Compile::\n\n        msgfmt mydomain.po -o {directory}/pt_BR/LC_MESSAGES/mydomain.mo\n    \"\"\"\n    import gettext\n\n    global _translations\n    global _supported_locales\n    global _use_gettext\n    _translations = {}\n    for lang in os.listdir(directory):\n        if lang.startswith(\".\"):\n            continue  # skip .svn, etc\n        if os.path.isfile(os.path.join(directory, lang)):\n            continue\n        try:\n            os.stat(os.path.join(directory, lang, \"LC_MESSAGES\", domain + \".mo\"))\n            _translations[lang] = gettext.translation(\n                domain, directory, languages=[lang]\n            )\n        except Exception as e:\n            gen_log.error(\"Cannot load translation for '%s': %s\", lang, str(e))\n            continue\n    _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])\n    _use_gettext = True\n    gen_log.debug(\"Supported locales: %s\", sorted(_supported_locales))",
        "begin_line": 179,
        "end_line": 221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locale.Locale.get_closest#239",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.Locale",
        "signature": "tornado.locale.Locale.get_closest(cls, *locale_codes: str)",
        "snippet": "    def get_closest(cls, *locale_codes: str) -> \"Locale\":\n        \"\"\"Returns the closest match for the given locale code.\"\"\"\n        for code in locale_codes:\n            if not code:\n                continue\n            code = code.replace(\"-\", \"_\")\n            parts = code.split(\"_\")\n            if len(parts) > 2:\n                continue\n            elif len(parts) == 2:\n                code = parts[0].lower() + \"_\" + parts[1].upper()\n            if code in _supported_locales:\n                return cls.get(code)\n            if parts[0].lower() in _supported_locales:\n                return cls.get(parts[0].lower())\n        return cls.get(_default_locale)",
        "begin_line": 239,
        "end_line": 254,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016700066800267202,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locale.Locale.get#257",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.Locale",
        "signature": "tornado.locale.Locale.get(cls, code: str)",
        "snippet": "    def get(cls, code: str) -> \"Locale\":\n        \"\"\"Returns the Locale for the given locale code.\n\n        If it is not supported, we raise an exception.\n        \"\"\"\n        if code not in cls._cache:\n            assert code in _supported_locales\n            translations = _translations.get(code, None)\n            if translations is None:\n                locale = CSVLocale(code, {})  # type: Locale\n            elif _use_gettext:\n                locale = GettextLocale(code, translations)\n            else:\n                locale = CSVLocale(code, translations)\n            cls._cache[code] = locale\n        return cls._cache[code]",
        "begin_line": 257,
        "end_line": 272,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locale.Locale.__init__#274",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.Locale",
        "signature": "tornado.locale.Locale.__init__(self, code: str)",
        "snippet": "    def __init__(self, code: str) -> None:\n        self.code = code\n        self.name = LOCALE_NAMES.get(code, {}).get(\"name\", u\"Unknown\")\n        self.rtl = False\n        for prefix in [\"fa\", \"ar\", \"he\"]:\n            if self.code.startswith(prefix):\n                self.rtl = True\n                break\n\n        # Initialize strings for date formatting\n        _ = self.translate\n        self._months = [\n            _(\"January\"),\n            _(\"February\"),\n            _(\"March\"),\n            _(\"April\"),\n            _(\"May\"),\n            _(\"June\"),\n            _(\"July\"),\n            _(\"August\"),\n            _(\"September\"),\n            _(\"October\"),\n            _(\"November\"),\n            _(\"December\"),\n        ]\n        self._weekdays = [\n            _(\"Monday\"),\n            _(\"Tuesday\"),\n            _(\"Wednesday\"),\n            _(\"Thursday\"),\n            _(\"Friday\"),\n            _(\"Saturday\"),\n            _(\"Sunday\"),\n        ]",
        "begin_line": 274,
        "end_line": 307,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locale.Locale.format_date#326",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.Locale",
        "signature": "tornado.locale.Locale.format_date(self, date: Union[int, float, datetime.datetime], gmt_offset: int=0, relative: bool=True, shorter: bool=False, full_format: bool=False)",
        "snippet": "    def format_date(\n        self,\n        date: Union[int, float, datetime.datetime],\n        gmt_offset: int = 0,\n        relative: bool = True,\n        shorter: bool = False,\n        full_format: bool = False,\n    ) -> str:\n        \"\"\"Formats the given date (which should be GMT).\n\n        By default, we return a relative time (e.g., \"2 minutes ago\"). You\n        can return an absolute date string with ``relative=False``.\n\n        You can force a full format date (\"July 10, 1980\") with\n        ``full_format=True``.\n\n        This method is primarily intended for dates in the past.\n        For dates in the future, we fall back to full format.\n        \"\"\"\n        if isinstance(date, (int, float)):\n            date = datetime.datetime.utcfromtimestamp(date)\n        now = datetime.datetime.utcnow()\n        if date > now:\n            if relative and (date - now).seconds < 60:\n                # Due to click skew, things are some things slightly\n                # in the future. Round timestamps in the immediate\n                # future down to now in relative mode.\n                date = now\n            else:\n                # Otherwise, future dates always use the full format.\n                full_format = True\n        local_date = date - datetime.timedelta(minutes=gmt_offset)\n        local_now = now - datetime.timedelta(minutes=gmt_offset)\n        local_yesterday = local_now - datetime.timedelta(hours=24)\n        difference = now - date\n        seconds = difference.seconds\n        days = difference.days\n\n        _ = self.translate\n        format = None\n        if not full_format:\n            if relative and days == 0:\n                if seconds < 50:\n                    return _(\"1 second ago\", \"%(seconds)d seconds ago\", seconds) % {\n                        \"seconds\": seconds\n                    }\n\n                if seconds < 50 * 60:\n                    minutes = round(seconds / 60.0)\n                    return _(\"1 minute ago\", \"%(minutes)d minutes ago\", minutes) % {\n                        \"minutes\": minutes\n                    }\n\n                hours = round(seconds / (60.0 * 60))\n                return _(\"1 hour ago\", \"%(hours)d hours ago\", hours) % {\"hours\": hours}\n\n            if days == 0:\n                format = _(\"%(time)s\")\n            elif days == 1 and local_date.day == local_yesterday.day and relative:\n                format = _(\"yesterday\") if shorter else _(\"yesterday at %(time)s\")\n            elif days < 5:\n                format = _(\"%(weekday)s\") if shorter else _(\"%(weekday)s at %(time)s\")\n            elif days < 334:  # 11mo, since confusing for same month last year\n                format = (\n                    _(\"%(month_name)s %(day)s\")\n                    if shorter\n                    else _(\"%(month_name)s %(day)s at %(time)s\")\n                )\n\n        if format is None:\n            format = (\n                _(\"%(month_name)s %(day)s, %(year)s\")\n                if shorter\n                else _(\"%(month_name)s %(day)s, %(year)s at %(time)s\")\n            )\n\n        tfhour_clock = self.code not in (\"en\", \"en_US\", \"zh_CN\")\n        if tfhour_clock:\n            str_time = \"%d:%02d\" % (local_date.hour, local_date.minute)\n        elif self.code == \"zh_CN\":\n            str_time = \"%s%d:%02d\" % (\n                (u\"\\u4e0a\\u5348\", u\"\\u4e0b\\u5348\")[local_date.hour >= 12],\n                local_date.hour % 12 or 12,\n                local_date.minute,\n            )\n        else:\n            str_time = \"%d:%02d %s\" % (\n                local_date.hour % 12 or 12,\n                local_date.minute,\n                (\"am\", \"pm\")[local_date.hour >= 12],\n            )\n\n        return format % {\n            \"month_name\": self._months[local_date.month - 1],\n            \"weekday\": self._weekdays[local_date.weekday()],\n            \"day\": str(local_date.day),\n            \"year\": str(local_date.year),\n            \"time\": str_time,\n        }",
        "begin_line": 326,
        "end_line": 424,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locale.Locale.format_day#426",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.Locale",
        "signature": "tornado.locale.Locale.format_day(self, date: datetime.datetime, gmt_offset: int=0, dow: bool=True)",
        "snippet": "    def format_day(\n        self, date: datetime.datetime, gmt_offset: int = 0, dow: bool = True\n    ) -> bool:\n        \"\"\"Formats the given date as a day of week.\n\n        Example: \"Monday, January 22\". You can remove the day of week with\n        ``dow=False``.\n        \"\"\"\n        local_date = date - datetime.timedelta(minutes=gmt_offset)\n        _ = self.translate\n        if dow:\n            return _(\"%(weekday)s, %(month_name)s %(day)s\") % {\n                \"month_name\": self._months[local_date.month - 1],\n                \"weekday\": self._weekdays[local_date.weekday()],\n                \"day\": str(local_date.day),\n            }\n        else:\n            return _(\"%(month_name)s %(day)s\") % {\n                \"month_name\": self._months[local_date.month - 1],\n                \"day\": str(local_date.day),\n            }",
        "begin_line": 426,
        "end_line": 446,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locale.Locale.list#448",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.Locale",
        "signature": "tornado.locale.Locale.list(self, parts: Any)",
        "snippet": "    def list(self, parts: Any) -> str:\n        \"\"\"Returns a comma-separated list for the given list of parts.\n\n        The format is, e.g., \"A, B and C\", \"A and B\" or just \"A\" for lists\n        of size 1.\n        \"\"\"\n        _ = self.translate\n        if len(parts) == 0:\n            return \"\"\n        if len(parts) == 1:\n            return parts[0]\n        comma = u\" \\u0648 \" if self.code.startswith(\"fa\") else u\", \"\n        return _(\"%(commas)s and %(last)s\") % {\n            \"commas\": comma.join(parts[:-1]),\n            \"last\": parts[len(parts) - 1],\n        }",
        "begin_line": 448,
        "end_line": 463,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locale.Locale.friendly_number#465",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.Locale",
        "signature": "tornado.locale.Locale.friendly_number(self, value: int)",
        "snippet": "    def friendly_number(self, value: int) -> str:\n        \"\"\"Returns a comma-separated number for the given integer.\"\"\"\n        if self.code not in (\"en\", \"en_US\"):\n            return str(value)\n        s = str(value)\n        parts = []\n        while s:\n            parts.append(s[-3:])\n            s = s[:-3]\n        return \",\".join(reversed(parts))",
        "begin_line": 465,
        "end_line": 474,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locale.CSVLocale.__init__#480",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.CSVLocale",
        "signature": "tornado.locale.CSVLocale.__init__(self, code: str, translations: Dict[str, Dict[str, str]])",
        "snippet": "    def __init__(self, code: str, translations: Dict[str, Dict[str, str]]) -> None:\n        self.translations = translations\n        super(CSVLocale, self).__init__(code)",
        "begin_line": 480,
        "end_line": 482,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0002256317689530686,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locale.CSVLocale.translate#484",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.CSVLocale",
        "signature": "tornado.locale.CSVLocale.translate(self, message: str, plural_message: str=None, count: int=None)",
        "snippet": "    def translate(\n        self, message: str, plural_message: str = None, count: int = None\n    ) -> str:\n        if plural_message is not None:\n            assert count is not None\n            if count != 1:\n                message = plural_message\n                message_dict = self.translations.get(\"plural\", {})\n            else:\n                message_dict = self.translations.get(\"singular\", {})\n        else:\n            message_dict = self.translations.get(\"unknown\", {})\n        return message_dict.get(message, message)",
        "begin_line": 484,
        "end_line": 496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locale.GettextLocale.__init__#509",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.GettextLocale",
        "signature": "tornado.locale.GettextLocale.__init__(self, code: str, translations: gettext.NullTranslations)",
        "snippet": "    def __init__(self, code: str, translations: gettext.NullTranslations) -> None:\n        self.ngettext = translations.ngettext\n        self.gettext = translations.gettext\n        # self.gettext must exist before __init__ is called, since it\n        # calls into self.translate\n        super(GettextLocale, self).__init__(code)",
        "begin_line": 509,
        "end_line": 514,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locale.GettextLocale.translate#516",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.GettextLocale",
        "signature": "tornado.locale.GettextLocale.translate(self, message: str, plural_message: str=None, count: int=None)",
        "snippet": "    def translate(\n        self, message: str, plural_message: str = None, count: int = None\n    ) -> str:\n        if plural_message is not None:\n            assert count is not None\n            return self.ngettext(message, plural_message, count)\n        else:\n            return self.gettext(message)",
        "begin_line": 516,
        "end_line": 523,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.locale.GettextLocale.pgettext#525",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.GettextLocale",
        "signature": "tornado.locale.GettextLocale.pgettext(self, context: str, message: str, plural_message: str=None, count: int=None)",
        "snippet": "    def pgettext(\n        self, context: str, message: str, plural_message: str = None, count: int = None\n    ) -> str:\n        \"\"\"Allows to set context for translation, accepts plural forms.\n\n        Usage example::\n\n            pgettext(\"law\", \"right\")\n            pgettext(\"good\", \"right\")\n\n        Plural message example::\n\n            pgettext(\"organization\", \"club\", \"clubs\", len(clubs))\n            pgettext(\"stick\", \"club\", \"clubs\", len(clubs))\n\n        To generate POT file with context, add following options to step 1\n        of `load_gettext_translations` sequence::\n\n            xgettext [basic options] --keyword=pgettext:1c,2 --keyword=pgettext:1c,2,3\n\n        .. versionadded:: 4.2\n        \"\"\"\n        if plural_message is not None:\n            assert count is not None\n            msgs_with_ctxt = (\n                \"%s%s%s\" % (context, CONTEXT_SEPARATOR, message),\n                \"%s%s%s\" % (context, CONTEXT_SEPARATOR, plural_message),\n                count,\n            )\n            result = self.ngettext(*msgs_with_ctxt)\n            if CONTEXT_SEPARATOR in result:\n                # Translation not found\n                result = self.ngettext(message, plural_message, count)\n            return result\n        else:\n            msg_with_ctxt = \"%s%s%s\" % (context, CONTEXT_SEPARATOR, message)\n            result = self.gettext(msg_with_ctxt)\n            if CONTEXT_SEPARATOR in result:\n                # Translation not found\n                result = message\n            return result",
        "begin_line": 525,
        "end_line": 565,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.0003274394237066143,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.tcpclient._Connector.__init__#60",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.__init__(self, addrinfo: List[Tuple], connect: Callable[[socket.AddressFamily, Tuple], Tuple[IOStream, 'Future[IOStream]']])",
        "snippet": "    def __init__(\n        self,\n        addrinfo: List[Tuple],\n        connect: Callable[\n            [socket.AddressFamily, Tuple], Tuple[IOStream, \"Future[IOStream]\"]\n        ],\n    ) -> None:\n        self.io_loop = IOLoop.current()\n        self.connect = connect\n\n        self.future = (\n            Future()\n        )  # type: Future[Tuple[socket.AddressFamily, Any, IOStream]]\n        self.timeout = None  # type: Optional[object]\n        self.connect_timeout = None  # type: Optional[object]\n        self.last_error = None  # type: Optional[Exception]\n        self.remaining = len(addrinfo)\n        self.primary_addrs, self.secondary_addrs = self.split(addrinfo)\n        self.streams = set()  # type: Set[IOStream]",
        "begin_line": 60,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005120327700972862,
            "pseudo_dstar_susp": 0.0005787037037037037,
            "pseudo_tarantula_susp": 0.00047778308647873863,
            "pseudo_op2_susp": 0.0005787037037037037,
            "pseudo_barinel_susp": 0.00047778308647873863
        }
    },
    {
        "name": "tornado.tcpclient._Connector.split#81",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.split(addrinfo: List[Tuple])",
        "snippet": "    def split(\n        addrinfo: List[Tuple]\n    ) -> Tuple[\n        List[Tuple[socket.AddressFamily, Tuple]],\n        List[Tuple[socket.AddressFamily, Tuple]],\n    ]:\n        \"\"\"Partition the ``addrinfo`` list by address family.\n\n        Returns two lists.  The first list contains the first entry from\n        ``addrinfo`` and all others with the same family, and the\n        second list contains all other addresses (normally one list will\n        be AF_INET and the other AF_INET6, although non-standard resolvers\n        may return additional families).\n        \"\"\"\n        primary = []\n        secondary = []\n        primary_af = addrinfo[0][0]\n        for af, addr in addrinfo:\n            if af == primary_af:\n                primary.append((af, addr))\n            else:\n                secondary.append((af, addr))\n        return primary, secondary",
        "begin_line": 81,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000508646998982706,
            "pseudo_dstar_susp": 0.0005743825387708214,
            "pseudo_tarantula_susp": 0.00047393364928909954,
            "pseudo_op2_susp": 0.0005743825387708214,
            "pseudo_barinel_susp": 0.00047393364928909954
        }
    },
    {
        "name": "tornado.tcpclient._Connector.start#105",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.start(self, timeout: float=_INITIAL_CONNECT_TIMEOUT, connect_timeout: Union[float, datetime.timedelta]=None)",
        "snippet": "    def start(\n        self,\n        timeout: float = _INITIAL_CONNECT_TIMEOUT,\n        connect_timeout: Union[float, datetime.timedelta] = None,\n    ) -> \"Future[Tuple[socket.AddressFamily, Any, IOStream]]\":\n        self.try_connect(iter(self.primary_addrs))\n        self.set_timeout(timeout)\n        if connect_timeout is not None:\n            self.set_connect_timeout(connect_timeout)\n        return self.future",
        "begin_line": 105,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005186721991701245,
            "pseudo_dstar_susp": 0.0005830903790087463,
            "pseudo_tarantula_susp": 0.0004807692307692308,
            "pseudo_op2_susp": 0.0005830903790087463,
            "pseudo_barinel_susp": 0.0004807692307692308
        }
    },
    {
        "name": "tornado.tcpclient._Connector.try_connect#116",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.try_connect(self, addrs: Iterator[Tuple[socket.AddressFamily, Tuple]])",
        "snippet": "    def try_connect(self, addrs: Iterator[Tuple[socket.AddressFamily, Tuple]]) -> None:\n        try:\n            af, addr = next(addrs)\n        except StopIteration:\n            # We've reached the end of our queue, but the other queue\n            # might still be working.  Send a final error on the future\n            # only when both queues are finished.\n            if self.remaining == 0 and not self.future.done():\n                self.future.set_exception(\n                    self.last_error or IOError(\"connection failed\")\n                )\n            return\n        stream, future = self.connect(af, addr)\n        self.streams.add(stream)\n        future_add_done_callback(\n            future, functools.partial(self.on_connect_done, addrs, af, addr)\n        )",
        "begin_line": 116,
        "end_line": 132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005186721991701245,
            "pseudo_dstar_susp": 0.0005830903790087463,
            "pseudo_tarantula_susp": 0.0004807692307692308,
            "pseudo_op2_susp": 0.0005830903790087463,
            "pseudo_barinel_susp": 0.0004807692307692308
        }
    },
    {
        "name": "tornado.tcpclient._Connector.on_connect_done#134",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.on_connect_done(self, addrs: Iterator[Tuple[socket.AddressFamily, Tuple]], af: socket.AddressFamily, addr: Tuple, future: 'Future[IOStream]')",
        "snippet": "    def on_connect_done(\n        self,\n        addrs: Iterator[Tuple[socket.AddressFamily, Tuple]],\n        af: socket.AddressFamily,\n        addr: Tuple,\n        future: \"Future[IOStream]\",\n    ) -> None:\n        self.remaining -= 1\n        try:\n            stream = future.result()\n        except Exception as e:\n            if self.future.done():\n                return\n            # Error: try again (but remember what happened so we have an\n            # error to raise in the end)\n            self.last_error = e\n            self.try_connect(addrs)\n            if self.timeout is not None:\n                # If the first attempt failed, don't wait for the\n                # timeout to try an address from the secondary queue.\n                self.io_loop.remove_timeout(self.timeout)\n                self.on_timeout()\n            return\n        self.clear_timeouts()\n        if self.future.done():\n            # This is a late arrival; just drop it.\n            stream.close()\n        else:\n            self.streams.discard(stream)\n            self.future.set_result((af, addr, stream))\n            self.close_streams()",
        "begin_line": 134,
        "end_line": 164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005350454788657035,
            "pseudo_dstar_susp": 0.0006027727546714888,
            "pseudo_tarantula_susp": 0.0004952947003467063,
            "pseudo_op2_susp": 0.0006027727546714888,
            "pseudo_barinel_susp": 0.0004952947003467063
        }
    },
    {
        "name": "tornado.tcpclient._Connector.set_timeout#166",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.set_timeout(self, timeout: float)",
        "snippet": "    def set_timeout(self, timeout: float) -> None:\n        self.timeout = self.io_loop.add_timeout(\n            self.io_loop.time() + timeout, self.on_timeout\n        )",
        "begin_line": 166,
        "end_line": 169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005186721991701245,
            "pseudo_dstar_susp": 0.0005830903790087463,
            "pseudo_tarantula_susp": 0.0004807692307692308,
            "pseudo_op2_susp": 0.0005830903790087463,
            "pseudo_barinel_susp": 0.0004807692307692308
        }
    },
    {
        "name": "tornado.tcpclient._Connector.on_timeout#171",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.on_timeout(self)",
        "snippet": "    def on_timeout(self) -> None:\n        self.timeout = None\n        if not self.future.done():\n            self.try_connect(iter(self.secondary_addrs))",
        "begin_line": 171,
        "end_line": 174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00017590149516270889,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.tcpclient._Connector.set_connect_timeout#180",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.set_connect_timeout(self, connect_timeout: Union[float, datetime.timedelta])",
        "snippet": "    def set_connect_timeout(\n        self, connect_timeout: Union[float, datetime.timedelta]\n    ) -> None:\n        self.connect_timeout = self.io_loop.add_timeout(\n            connect_timeout, self.on_connect_timeout\n        )",
        "begin_line": 180,
        "end_line": 185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00016700066800267202,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.tcpclient._Connector.on_connect_timeout#187",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.on_connect_timeout(self)",
        "snippet": "    def on_connect_timeout(self) -> None:\n        if not self.future.done():\n            self.future.set_exception(TimeoutError())\n        self.close_streams()",
        "begin_line": 187,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00020597322348094748,
            "pseudo_dstar_susp": 0.00020597322348094748,
            "pseudo_tarantula_susp": 0.00020597322348094748,
            "pseudo_op2_susp": 0.00020968756552736424,
            "pseudo_barinel_susp": 0.00020597322348094748
        }
    },
    {
        "name": "tornado.tcpclient._Connector.clear_timeouts#192",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.clear_timeouts(self)",
        "snippet": "    def clear_timeouts(self) -> None:\n        if self.timeout is not None:\n            self.io_loop.remove_timeout(self.timeout)\n        if self.connect_timeout is not None:\n            self.io_loop.remove_timeout(self.connect_timeout)",
        "begin_line": 192,
        "end_line": 196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000547945205479452,
            "pseudo_dstar_susp": 0.0006180469715698393,
            "pseudo_tarantula_susp": 0.0005058168942842691,
            "pseudo_op2_susp": 0.0006180469715698393,
            "pseudo_barinel_susp": 0.0005058168942842691
        }
    },
    {
        "name": "tornado.tcpclient._Connector.close_streams#198",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.close_streams(self)",
        "snippet": "    def close_streams(self) -> None:\n        for stream in self.streams:\n            stream.close()",
        "begin_line": 198,
        "end_line": 200,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005216484089723526,
            "pseudo_dstar_susp": 0.0005865102639296188,
            "pseudo_tarantula_susp": 0.00048355899419729207,
            "pseudo_op2_susp": 0.0005865102639296188,
            "pseudo_barinel_susp": 0.00048355899419729207
        }
    },
    {
        "name": "tornado.tcpclient.TCPClient.__init__#210",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient.TCPClient",
        "signature": "tornado.tcpclient.TCPClient.__init__(self, resolver: Resolver=None)",
        "snippet": "    def __init__(self, resolver: Resolver = None) -> None:\n        if resolver is not None:\n            self.resolver = resolver\n            self._own_resolver = False\n        else:\n            self.resolver = Resolver()\n            self._own_resolver = True",
        "begin_line": 210,
        "end_line": 216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007674597083653108,
            "pseudo_dstar_susp": 0.0009784735812133072,
            "pseudo_tarantula_susp": 0.0006988120195667365,
            "pseudo_op2_susp": 0.0009784735812133072,
            "pseudo_barinel_susp": 0.0006988120195667365
        }
    },
    {
        "name": "tornado.tcpclient.TCPClient.close#218",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient.TCPClient",
        "signature": "tornado.tcpclient.TCPClient.close(self)",
        "snippet": "    def close(self) -> None:\n        if self._own_resolver:\n            self.resolver.close()",
        "begin_line": 218,
        "end_line": 220,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007627765064836003,
            "pseudo_dstar_susp": 0.0009727626459143969,
            "pseudo_tarantula_susp": 0.0006954102920723226,
            "pseudo_op2_susp": 0.0009727626459143969,
            "pseudo_barinel_susp": 0.0006954102920723226
        }
    },
    {
        "name": "tornado.tcpclient.TCPClient.connect#222",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient.TCPClient",
        "signature": "tornado.tcpclient.TCPClient.connect(self, host: str, port: int, af: socket.AddressFamily=socket.AF_UNSPEC, ssl_options: Union[Dict[str, Any], ssl.SSLContext]=None, max_buffer_size: int=None, source_ip: str=None, source_port: int=None, timeout: Union[float, datetime.timedelta]=None)",
        "snippet": "    async def connect(\n        self,\n        host: str,\n        port: int,\n        af: socket.AddressFamily = socket.AF_UNSPEC,\n        ssl_options: Union[Dict[str, Any], ssl.SSLContext] = None,\n        max_buffer_size: int = None,\n        source_ip: str = None,\n        source_port: int = None,\n        timeout: Union[float, datetime.timedelta] = None,\n    ) -> IOStream:\n        \"\"\"Connect to the given host and port.\n\n        Asynchronously returns an `.IOStream` (or `.SSLIOStream` if\n        ``ssl_options`` is not None).\n\n        Using the ``source_ip`` kwarg, one can specify the source\n        IP address to use when establishing the connection.\n        In case the user needs to resolve and\n        use a specific interface, it has to be handled outside\n        of Tornado as this depends very much on the platform.\n\n        Raises `TimeoutError` if the input future does not complete before\n        ``timeout``, which may be specified in any form allowed by\n        `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or an absolute time\n        relative to `.IOLoop.time`)\n\n        Similarly, when the user requires a certain source port, it can\n        be specified using the ``source_port`` arg.\n\n        .. versionchanged:: 4.5\n           Added the ``source_ip`` and ``source_port`` arguments.\n\n        .. versionchanged:: 5.0\n           Added the ``timeout`` argument.\n        \"\"\"\n        if timeout is not None:\n            if isinstance(timeout, numbers.Real):\n                timeout = IOLoop.current().time() + timeout\n            elif isinstance(timeout, datetime.timedelta):\n                timeout = IOLoop.current().time() + timeout.total_seconds()\n            else:\n                raise TypeError(\"Unsupported timeout %r\" % timeout)\n        if timeout is not None:\n            addrinfo = await gen.with_timeout(\n                timeout, self.resolver.resolve(host, port, af)\n            )\n        else:\n            addrinfo = await self.resolver.resolve(host, port, af)\n        connector = _Connector(\n            addrinfo,\n            functools.partial(\n                self._create_stream,\n                max_buffer_size,\n                source_ip=source_ip,\n                source_port=source_port,\n            ),\n        )\n        af, addr, stream = await connector.start(connect_timeout=timeout)\n        # TODO: For better performance we could cache the (af, addr)\n        # information here and re-use it on subsequent connections to\n        # the same host. (http://tools.ietf.org/html/rfc6555#section-4.2)\n        if ssl_options is not None:\n            if timeout is not None:\n                stream = await gen.with_timeout(\n                    timeout,\n                    stream.start_tls(\n                        False, ssl_options=ssl_options, server_hostname=host\n                    ),\n                )\n            else:\n                stream = await stream.start_tls(\n                    False, ssl_options=ssl_options, server_hostname=host\n                )\n        return stream",
        "begin_line": 222,
        "end_line": 296,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005656108597285068,
            "pseudo_dstar_susp": 0.0006406149903907751,
            "pseudo_tarantula_susp": 0.0005238344683080147,
            "pseudo_op2_susp": 0.0006406149903907751,
            "pseudo_barinel_susp": 0.0005238344683080147
        }
    },
    {
        "name": "tornado.tcpclient.TCPClient._create_stream#298",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient.TCPClient",
        "signature": "tornado.tcpclient.TCPClient._create_stream(self, max_buffer_size: int, af: socket.AddressFamily, addr: Tuple, source_ip: str=None, source_port: int=None)",
        "snippet": "    def _create_stream(\n        self,\n        max_buffer_size: int,\n        af: socket.AddressFamily,\n        addr: Tuple,\n        source_ip: str = None,\n        source_port: int = None,\n    ) -> Tuple[IOStream, \"Future[IOStream]\"]:\n        # Always connect in plaintext; we'll convert to ssl if necessary\n        # after one connection has completed.\n        source_port_bind = source_port if isinstance(source_port, int) else 0\n        source_ip_bind = source_ip\n        if source_port_bind and not source_ip:\n            # User required a specific port, but did not specify\n            # a certain source IP, will bind to the default loopback.\n            source_ip_bind = \"::1\" if af == socket.AF_INET6 else \"127.0.0.1\"\n            # Trying to use the same address family as the requested af socket:\n            # - 127.0.0.1 for IPv4\n            # - ::1 for IPv6\n        socket_obj = socket.socket(af)\n        set_close_exec(socket_obj.fileno())\n        if source_port_bind or source_ip_bind:\n            # If the user requires binding also to a specific IP/port.\n            try:\n                socket_obj.bind((source_ip_bind, source_port_bind))\n            except socket.error:\n                socket_obj.close()\n                # Fail loudly if unable to use the IP/port.\n                raise\n        try:\n            stream = IOStream(socket_obj, max_buffer_size=max_buffer_size)\n        except socket.error as e:\n            fu = Future()  # type: Future[IOStream]\n            fu.set_exception(e)\n            return stream, fu\n        else:\n            return stream, stream.connect(addr)",
        "begin_line": 298,
        "end_line": 334,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000544069640914037,
            "pseudo_dstar_susp": 0.0006142506142506142,
            "pseudo_tarantula_susp": 0.0005030181086519115,
            "pseudo_op2_susp": 0.0006142506142506142,
            "pseudo_barinel_susp": 0.0005030181086519115
        }
    }
]