[
    {
        "name": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data#9",
        "src_path": "pandas/tests/indexing/multiindex/conftest.py",
        "class_name": "pandas.tests.indexing.multiindex.conftest",
        "signature": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data()",
        "snippet": "def multiindex_dataframe_random_data():\n    \"\"\"DataFrame with 2 level MultiIndex with random data\"\"\"\n    index = MultiIndex(\n        levels=[[\"foo\", \"bar\", \"baz\", \"qux\"], [\"one\", \"two\", \"three\"]],\n        codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],\n        names=[\"first\", \"second\"],\n    )\n    return DataFrame(\n        np.random.randn(10, 3), index=index, columns=Index([\"A\", \"B\", \"C\"], name=\"exp\")\n    )",
        "begin_line": 9,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.conftest.multiindex_year_month_day_dataframe_random_data#22",
        "src_path": "pandas/tests/indexing/multiindex/conftest.py",
        "class_name": "pandas.tests.indexing.multiindex.conftest",
        "signature": "pandas.tests.indexing.multiindex.conftest.multiindex_year_month_day_dataframe_random_data()",
        "snippet": "def multiindex_year_month_day_dataframe_random_data():\n    \"\"\"DataFrame with 3 level MultiIndex (year, month, day) covering\n    first 100 business days from 2000-01-01 with random data\"\"\"\n    tdf = tm.makeTimeDataFrame(100)\n    ymd = tdf.groupby([lambda x: x.year, lambda x: x.month, lambda x: x.day]).sum()\n    # use Int64Index, to make sure things work\n    ymd.index.set_levels([lev.astype(\"i8\") for lev in ymd.index.levels], inplace=True)\n    ymd.index.set_names([\"year\", \"month\", \"day\"], inplace=True)\n    return ymd",
        "begin_line": 22,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_setitem_ndarray_1d#29",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_setitem_ndarray_1d(self)",
        "snippet": "    def test_setitem_ndarray_1d(self):\n        # GH5508\n\n        # len of indexer vs length of the 1d ndarray\n        df = DataFrame(index=Index(np.arange(1, 11)))\n        df[\"foo\"] = np.zeros(10, dtype=np.float64)\n        df[\"bar\"] = np.zeros(10, dtype=np.complex)\n\n        # invalid\n        with pytest.raises(ValueError):\n            df.loc[df.index[2:5], \"bar\"] = np.array([2.33j, 1.23 + 0.1j, 2.2, 1.0])\n\n        # valid\n        df.loc[df.index[2:6], \"bar\"] = np.array([2.33j, 1.23 + 0.1j, 2.2, 1.0])\n\n        result = df.loc[df.index[2:6], \"bar\"]\n        expected = Series(\n            [2.33j, 1.23 + 0.1j, 2.2, 1.0], index=[3, 4, 5, 6], name=\"bar\"\n        )\n        tm.assert_series_equal(result, expected)\n\n        # dtype getting changed?\n        df = DataFrame(index=Index(np.arange(1, 11)))\n        df[\"foo\"] = np.zeros(10, dtype=np.float64)\n        df[\"bar\"] = np.zeros(10, dtype=np.complex)\n\n        with pytest.raises(ValueError):\n            df[2:5] = np.arange(1, 4) * 1j",
        "begin_line": 29,
        "end_line": 56,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_getitem_ndarray_3d#77",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id)",
        "snippet": "    def test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        msg = (\n            r\"Buffer has wrong number of dimensions \\(expected 1, \"\n            r\"got 3\\)|\"\n            \"Cannot index with multidimensional key|\"\n            r\"Wrong number of dimensions. values.ndim != ndim \\[3 != 1\\]|\"\n            \"Index data must be 1-dimensional\"\n        )\n\n        if (\n            isinstance(obj, Series)\n            and idxr_id == \"getitem\"\n            and index.inferred_type\n            in [\n                \"string\",\n                \"datetime64\",\n                \"period\",\n                \"timedelta64\",\n                \"boolean\",\n                \"categorical\",\n            ]\n        ):\n            with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n                idxr[nd3]\n        else:\n            with pytest.raises(ValueError, match=msg):\n                with tm.assert_produces_warning(DeprecationWarning):\n                    idxr[nd3]",
        "begin_line": 77,
        "end_line": 109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_setitem_ndarray_3d#130",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id)",
        "snippet": "    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
        "begin_line": 130,
        "end_line": 153,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_inf_upcast#155",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_inf_upcast(self)",
        "snippet": "    def test_inf_upcast(self):\n        # GH 16957\n        # We should be able to use np.inf as a key\n        # np.inf should cause an index to convert to float\n\n        # Test with np.inf in rows\n        df = DataFrame(columns=[0])\n        df.loc[1] = 1\n        df.loc[2] = 2\n        df.loc[np.inf] = 3\n\n        # make sure we can look up the value\n        assert df.loc[np.inf, 0] == 3\n\n        result = df.index\n        expected = pd.Float64Index([1, 2, np.inf])\n        tm.assert_index_equal(result, expected)\n\n        # Test with np.inf in columns\n        df = DataFrame()\n        df.loc[0, 0] = 1\n        df.loc[1, 1] = 2\n        df.loc[0, np.inf] = 3\n\n        result = df.columns\n        expected = pd.Float64Index([0, 1, np.inf])\n        tm.assert_index_equal(result, expected)",
        "begin_line": 155,
        "end_line": 181,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_setitem_dtype_upcast#183",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_setitem_dtype_upcast(self)",
        "snippet": "    def test_setitem_dtype_upcast(self):\n\n        # GH3216\n        df = DataFrame([{\"a\": 1}, {\"a\": 3, \"b\": 2}])\n        df[\"c\"] = np.nan\n        assert df[\"c\"].dtype == np.float64\n\n        df.loc[0, \"c\"] = \"foo\"\n        expected = DataFrame(\n            [{\"a\": 1, \"b\": np.nan, \"c\": \"foo\"}, {\"a\": 3, \"b\": 2, \"c\": np.nan}]\n        )\n        tm.assert_frame_equal(df, expected)\n\n        # GH10280\n        df = DataFrame(\n            np.arange(6, dtype=\"int64\").reshape(2, 3),\n            index=list(\"ab\"),\n            columns=[\"foo\", \"bar\", \"baz\"],\n        )\n\n        for val in [3.14, \"wxyz\"]:\n            left = df.copy()\n            left.loc[\"a\", \"bar\"] = val\n            right = DataFrame(\n                [[0, val, 2], [3, 4, 5]],\n                index=list(\"ab\"),\n                columns=[\"foo\", \"bar\", \"baz\"],\n            )\n\n            tm.assert_frame_equal(left, right)\n            assert is_integer_dtype(left[\"foo\"])\n            assert is_integer_dtype(left[\"baz\"])\n\n        left = DataFrame(\n            np.arange(6, dtype=\"int64\").reshape(2, 3) / 10.0,\n            index=list(\"ab\"),\n            columns=[\"foo\", \"bar\", \"baz\"],\n        )\n        left.loc[\"a\", \"bar\"] = \"wxyz\"\n\n        right = DataFrame(\n            [[0, \"wxyz\", 0.2], [0.3, 0.4, 0.5]],\n            index=list(\"ab\"),\n            columns=[\"foo\", \"bar\", \"baz\"],\n        )\n\n        tm.assert_frame_equal(left, right)\n        assert is_float_dtype(left[\"foo\"])\n        assert is_float_dtype(left[\"baz\"])",
        "begin_line": 183,
        "end_line": 231,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_dups_fancy_indexing#233",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_dups_fancy_indexing(self)",
        "snippet": "    def test_dups_fancy_indexing(self):\n\n        # GH 3455\n\n        df = tm.makeCustomDataframe(10, 3)\n        df.columns = [\"a\", \"a\", \"b\"]\n        result = df[[\"b\", \"a\"]].columns\n        expected = Index([\"b\", \"a\", \"a\"])\n        tm.assert_index_equal(result, expected)\n\n        # across dtypes\n        df = DataFrame([[1, 2, 1.0, 2.0, 3.0, \"foo\", \"bar\"]], columns=list(\"aaaaaaa\"))\n        df.head()\n        str(df)\n        result = DataFrame([[1, 2, 1.0, 2.0, 3.0, \"foo\", \"bar\"]])\n        result.columns = list(\"aaaaaaa\")\n\n        # TODO(wesm): unused?\n        df_v = df.iloc[:, 4]  # noqa\n        res_v = result.iloc[:, 4]  # noqa\n\n        tm.assert_frame_equal(df, result)\n\n        # GH 3561, dups not in selected order\n        df = DataFrame(\n            {\"test\": [5, 7, 9, 11], \"test1\": [4.0, 5, 6, 7], \"other\": list(\"abcd\")},\n            index=[\"A\", \"A\", \"B\", \"C\"],\n        )\n        rows = [\"C\", \"B\"]\n        expected = DataFrame(\n            {\"test\": [11, 9], \"test1\": [7.0, 6], \"other\": [\"d\", \"c\"]}, index=rows\n        )\n        result = df.loc[rows]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[Index(rows)]\n        tm.assert_frame_equal(result, expected)\n\n        rows = [\"C\", \"B\", \"E\"]\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            df.loc[rows]\n\n        # see GH5553, make sure we use the right indexer\n        rows = [\"F\", \"G\", \"H\", \"C\", \"B\", \"E\"]\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            df.loc[rows]\n\n        # List containing only missing label\n        dfnu = DataFrame(np.random.randn(5, 3), index=list(\"AABCD\"))\n        with pytest.raises(\n            KeyError,\n            match=re.escape(\n                \"\\\"None of [Index(['E'], dtype='object')] are in the [index]\\\"\"\n            ),\n        ):\n            dfnu.loc[[\"E\"]]\n\n        # ToDo: check_index_type can be True after GH 11497\n\n        # GH 4619; duplicate indexer with missing label\n        df = DataFrame({\"A\": [0, 1, 2]})\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            df.loc[[0, 8, 0]]\n\n        df = DataFrame({\"A\": list(\"abc\")})\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            df.loc[[0, 8, 0]]\n\n        # non unique with non unique selector\n        df = DataFrame({\"test\": [5, 7, 9, 11]}, index=[\"A\", \"A\", \"B\", \"C\"])\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            df.loc[[\"A\", \"A\", \"E\"]]",
        "begin_line": 233,
        "end_line": 304,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_dups_fancy_indexing2#306",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_dups_fancy_indexing2(self)",
        "snippet": "    def test_dups_fancy_indexing2(self):\n        # GH 5835\n        # dups on index and missing values\n        df = DataFrame(np.random.randn(5, 5), columns=[\"A\", \"B\", \"B\", \"B\", \"A\"])\n\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            df.loc[:, [\"A\", \"B\", \"C\"]]\n\n        # GH 6504, multi-axis indexing\n        df = DataFrame(\n            np.random.randn(9, 2), index=[1, 1, 1, 2, 2, 2, 3, 3, 3], columns=[\"a\", \"b\"]\n        )\n\n        expected = df.iloc[0:6]\n        result = df.loc[[1, 2]]\n        tm.assert_frame_equal(result, expected)\n\n        expected = df\n        result = df.loc[:, [\"a\", \"b\"]]\n        tm.assert_frame_equal(result, expected)\n\n        expected = df.iloc[0:6, :]\n        result = df.loc[[1, 2], [\"a\", \"b\"]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 306,
        "end_line": 329,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_duplicate_int_indexing#332",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_duplicate_int_indexing(self, case)",
        "snippet": "    def test_duplicate_int_indexing(self, case):\n        # GH 17347\n        s = pd.Series(range(3), index=[1, 1, 3])\n        expected = s[1]\n        result = case(s)[[1]]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 332,
        "end_line": 337,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_indexing_mixed_frame_bug#339",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_indexing_mixed_frame_bug(self)",
        "snippet": "    def test_indexing_mixed_frame_bug(self):\n\n        # GH3492\n        df = DataFrame(\n            {\"a\": {1: \"aaa\", 2: \"bbb\", 3: \"ccc\"}, \"b\": {1: 111, 2: 222, 3: 333}}\n        )\n\n        # this works, new column is created correctly\n        df[\"test\"] = df[\"a\"].apply(lambda x: \"_\" if x == \"aaa\" else x)\n\n        # this does not work, ie column test is not changed\n        idx = df[\"test\"] == \"_\"\n        temp = df.loc[idx, \"a\"].apply(lambda x: \"-----\" if x == \"aaa\" else x)\n        df.loc[idx, \"test\"] = temp\n        assert df.iloc[0, 2] == \"-----\"",
        "begin_line": 339,
        "end_line": 353,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_multitype_list_index_access#355",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_multitype_list_index_access(self)",
        "snippet": "    def test_multitype_list_index_access(self):\n        # GH 10610\n        df = DataFrame(np.random.random((10, 5)), columns=[\"a\"] + [20, 21, 22, 23])\n\n        with pytest.raises(KeyError, match=re.escape(\"'[-8, 26] not in index'\")):\n            df[[22, 26, -8]]\n        assert df[21].shape[0] == df.shape[0]",
        "begin_line": 355,
        "end_line": 361,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_set_index_nan#363",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_set_index_nan(self)",
        "snippet": "    def test_set_index_nan(self):\n\n        # GH 3586\n        df = DataFrame(\n            {\n                \"PRuid\": {\n                    17: \"nonQC\",\n                    18: \"nonQC\",\n                    19: \"nonQC\",\n                    20: \"10\",\n                    21: \"11\",\n                    22: \"12\",\n                    23: \"13\",\n                    24: \"24\",\n                    25: \"35\",\n                    26: \"46\",\n                    27: \"47\",\n                    28: \"48\",\n                    29: \"59\",\n                    30: \"10\",\n                },\n                \"QC\": {\n                    17: 0.0,\n                    18: 0.0,\n                    19: 0.0,\n                    20: np.nan,\n                    21: np.nan,\n                    22: np.nan,\n                    23: np.nan,\n                    24: 1.0,\n                    25: np.nan,\n                    26: np.nan,\n                    27: np.nan,\n                    28: np.nan,\n                    29: np.nan,\n                    30: np.nan,\n                },\n                \"data\": {\n                    17: 7.9544899999999998,\n                    18: 8.0142609999999994,\n                    19: 7.8591520000000008,\n                    20: 0.86140349999999999,\n                    21: 0.87853110000000001,\n                    22: 0.8427041999999999,\n                    23: 0.78587700000000005,\n                    24: 0.73062459999999996,\n                    25: 0.81668560000000001,\n                    26: 0.81927080000000008,\n                    27: 0.80705009999999999,\n                    28: 0.81440240000000008,\n                    29: 0.80140849999999997,\n                    30: 0.81307740000000006,\n                },\n                \"year\": {\n                    17: 2006,\n                    18: 2007,\n                    19: 2008,\n                    20: 1985,\n                    21: 1985,\n                    22: 1985,\n                    23: 1985,\n                    24: 1985,\n                    25: 1985,\n                    26: 1985,\n                    27: 1985,\n                    28: 1985,\n                    29: 1985,\n                    30: 1986,\n                },\n            }\n        ).reset_index()\n\n        result = (\n            df.set_index([\"year\", \"PRuid\", \"QC\"])\n            .reset_index()\n            .reindex(columns=df.columns)\n        )\n        tm.assert_frame_equal(result, df)",
        "begin_line": 363,
        "end_line": 440,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_multi_assign#442",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_multi_assign(self)",
        "snippet": "    def test_multi_assign(self):\n\n        # GH 3626, an assignment of a sub-df to a df\n        df = DataFrame(\n            {\n                \"FC\": [\"a\", \"b\", \"a\", \"b\", \"a\", \"b\"],\n                \"PF\": [0, 0, 0, 0, 1, 1],\n                \"col1\": list(range(6)),\n                \"col2\": list(range(6, 12)),\n            }\n        )\n        df.iloc[1, 0] = np.nan\n        df2 = df.copy()\n\n        mask = ~df2.FC.isna()\n        cols = [\"col1\", \"col2\"]\n\n        dft = df2 * 2\n        dft.iloc[3, 3] = np.nan\n\n        expected = DataFrame(\n            {\n                \"FC\": [\"a\", np.nan, \"a\", \"b\", \"a\", \"b\"],\n                \"PF\": [0, 0, 0, 0, 1, 1],\n                \"col1\": Series([0, 1, 4, 6, 8, 10]),\n                \"col2\": [12, 7, 16, np.nan, 20, 22],\n            }\n        )\n\n        # frame on rhs\n        df2.loc[mask, cols] = dft.loc[mask, cols]\n        tm.assert_frame_equal(df2, expected)\n\n        df2.loc[mask, cols] = dft.loc[mask, cols]\n        tm.assert_frame_equal(df2, expected)\n\n        # with an ndarray on rhs\n        # coerces to float64 because values has float64 dtype\n        # GH 14001\n        expected = DataFrame(\n            {\n                \"FC\": [\"a\", np.nan, \"a\", \"b\", \"a\", \"b\"],\n                \"PF\": [0, 0, 0, 0, 1, 1],\n                \"col1\": [0.0, 1.0, 4.0, 6.0, 8.0, 10.0],\n                \"col2\": [12, 7, 16, np.nan, 20, 22],\n            }\n        )\n        df2 = df.copy()\n        df2.loc[mask, cols] = dft.loc[mask, cols].values\n        tm.assert_frame_equal(df2, expected)\n        df2.loc[mask, cols] = dft.loc[mask, cols].values\n        tm.assert_frame_equal(df2, expected)\n\n        # broadcasting on the rhs is required\n        df = DataFrame(\n            dict(\n                A=[1, 2, 0, 0, 0],\n                B=[0, 0, 0, 10, 11],\n                C=[0, 0, 0, 10, 11],\n                D=[3, 4, 5, 6, 7],\n            )\n        )\n\n        expected = df.copy()\n        mask = expected[\"A\"] == 0\n        for col in [\"A\", \"B\"]:\n            expected.loc[mask, col] = df[\"D\"]\n\n        df.loc[df[\"A\"] == 0, [\"A\", \"B\"]] = df[\"D\"]\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 442,
        "end_line": 511,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_setitem_list#513",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_setitem_list(self)",
        "snippet": "    def test_setitem_list(self):\n\n        # GH 6043\n        # iloc with a list\n        df = DataFrame(index=[0, 1], columns=[0])\n        df.iloc[1, 0] = [1, 2, 3]\n        df.iloc[1, 0] = [1, 2]\n\n        result = DataFrame(index=[0, 1], columns=[0])\n        result.iloc[1, 0] = [1, 2]\n\n        tm.assert_frame_equal(result, df)\n\n        # iloc with an object\n        class TO:\n            def __init__(self, value):\n                self.value = value\n\n            def __str__(self) -> str:\n                return \"[{0}]\".format(self.value)\n\n            __repr__ = __str__\n\n            def __eq__(self, other) -> bool:\n                return self.value == other.value\n\n            def view(self):\n                return self\n\n        df = DataFrame(index=[0, 1], columns=[0])\n        df.iloc[1, 0] = TO(1)\n        df.iloc[1, 0] = TO(2)\n\n        result = DataFrame(index=[0, 1], columns=[0])\n        result.iloc[1, 0] = TO(2)\n\n        tm.assert_frame_equal(result, df)\n\n        # remains object dtype even after setting it back\n        df = DataFrame(index=[0, 1], columns=[0])\n        df.iloc[1, 0] = TO(1)\n        df.iloc[1, 0] = np.nan\n        result = DataFrame(index=[0, 1], columns=[0])\n\n        tm.assert_frame_equal(result, df)",
        "begin_line": 513,
        "end_line": 557,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TO.test_setitem_list#513",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TO",
        "signature": "pandas.tests.indexing.test_indexing.TO.test_setitem_list(self)",
        "snippet": "    def test_setitem_list(self):\n\n        # GH 6043\n        # iloc with a list\n        df = DataFrame(index=[0, 1], columns=[0])\n        df.iloc[1, 0] = [1, 2, 3]\n        df.iloc[1, 0] = [1, 2]\n\n        result = DataFrame(index=[0, 1], columns=[0])\n        result.iloc[1, 0] = [1, 2]\n\n        tm.assert_frame_equal(result, df)\n\n        # iloc with an object\n        class TO:\n            def __init__(self, value):\n                self.value = value\n\n            def __str__(self) -> str:\n                return \"[{0}]\".format(self.value)\n\n            __repr__ = __str__\n\n            def __eq__(self, other) -> bool:\n                return self.value == other.value\n\n            def view(self):\n                return self\n\n        df = DataFrame(index=[0, 1], columns=[0])\n        df.iloc[1, 0] = TO(1)\n        df.iloc[1, 0] = TO(2)\n\n        result = DataFrame(index=[0, 1], columns=[0])\n        result.iloc[1, 0] = TO(2)\n\n        tm.assert_frame_equal(result, df)\n\n        # remains object dtype even after setting it back\n        df = DataFrame(index=[0, 1], columns=[0])\n        df.iloc[1, 0] = TO(1)\n        df.iloc[1, 0] = np.nan\n        result = DataFrame(index=[0, 1], columns=[0])\n\n        tm.assert_frame_equal(result, df)",
        "begin_line": 513,
        "end_line": 557,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TO.__init__#528",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TO",
        "signature": "pandas.tests.indexing.test_indexing.TO.__init__(self, value)",
        "snippet": "            def __init__(self, value):\n                self.value = value",
        "begin_line": 528,
        "end_line": 529,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TO.__str__#531",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TO",
        "signature": "pandas.tests.indexing.test_indexing.TO.__str__(self)",
        "snippet": "            def __str__(self) -> str:\n                return \"[{0}]\".format(self.value)",
        "begin_line": 531,
        "end_line": 532,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TO.__eq__#536",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TO",
        "signature": "pandas.tests.indexing.test_indexing.TO.__eq__(self, other)",
        "snippet": "            def __eq__(self, other) -> bool:\n                return self.value == other.value",
        "begin_line": 536,
        "end_line": 537,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TO.view#539",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TO",
        "signature": "pandas.tests.indexing.test_indexing.TO.view(self)",
        "snippet": "            def view(self):\n                return self",
        "begin_line": 539,
        "end_line": 540,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_string_slice#559",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_string_slice(self)",
        "snippet": "    def test_string_slice(self):\n        # GH 14424\n        # string indexing against datetimelike with object\n        # dtype should properly raises KeyError\n        df = DataFrame([1], Index([pd.Timestamp(\"2011-01-01\")], dtype=object))\n        assert df.index.is_all_dates\n        with pytest.raises(KeyError, match=\"'2011'\"):\n            df[\"2011\"]\n\n        with pytest.raises(KeyError, match=\"'2011'\"):\n            df.loc[\"2011\", 0]\n\n        df = DataFrame()\n        assert not df.index.is_all_dates\n        with pytest.raises(KeyError, match=\"'2011'\"):\n            df[\"2011\"]\n\n        with pytest.raises(KeyError, match=\"'2011'\"):\n            df.loc[\"2011\", 0]",
        "begin_line": 559,
        "end_line": 577,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_astype_assignment#579",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_astype_assignment(self)",
        "snippet": "    def test_astype_assignment(self):\n\n        # GH4312 (iloc)\n        df_orig = DataFrame(\n            [[\"1\", \"2\", \"3\", \".4\", 5, 6.0, \"foo\"]], columns=list(\"ABCDEFG\")\n        )\n\n        df = df_orig.copy()\n        df.iloc[:, 0:2] = df.iloc[:, 0:2].astype(np.int64)\n        expected = DataFrame(\n            [[1, 2, \"3\", \".4\", 5, 6.0, \"foo\"]], columns=list(\"ABCDEFG\")\n        )\n        tm.assert_frame_equal(df, expected)\n\n        df = df_orig.copy()\n        df.iloc[:, 0:2] = df.iloc[:, 0:2]._convert(datetime=True, numeric=True)\n        expected = DataFrame(\n            [[1, 2, \"3\", \".4\", 5, 6.0, \"foo\"]], columns=list(\"ABCDEFG\")\n        )\n        tm.assert_frame_equal(df, expected)\n\n        # GH5702 (loc)\n        df = df_orig.copy()\n        df.loc[:, \"A\"] = df.loc[:, \"A\"].astype(np.int64)\n        expected = DataFrame(\n            [[1, \"2\", \"3\", \".4\", 5, 6.0, \"foo\"]], columns=list(\"ABCDEFG\")\n        )\n        tm.assert_frame_equal(df, expected)\n\n        df = df_orig.copy()\n        df.loc[:, [\"B\", \"C\"]] = df.loc[:, [\"B\", \"C\"]].astype(np.int64)\n        expected = DataFrame(\n            [[\"1\", 2, 3, \".4\", 5, 6.0, \"foo\"]], columns=list(\"ABCDEFG\")\n        )\n        tm.assert_frame_equal(df, expected)\n\n        # full replacements / no nans\n        df = DataFrame({\"A\": [1.0, 2.0, 3.0, 4.0]})\n        df.iloc[:, 0] = df[\"A\"].astype(np.int64)\n        expected = DataFrame({\"A\": [1, 2, 3, 4]})\n        tm.assert_frame_equal(df, expected)\n\n        df = DataFrame({\"A\": [1.0, 2.0, 3.0, 4.0]})\n        df.loc[:, \"A\"] = df[\"A\"].astype(np.int64)\n        expected = DataFrame({\"A\": [1, 2, 3, 4]})\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 579,
        "end_line": 624,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_index_contains#637",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_index_contains(self, index, val)",
        "snippet": "    def test_index_contains(self, index, val):\n        assert val in index",
        "begin_line": 637,
        "end_line": 638,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_index_not_contains#657",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_index_not_contains(self, index, val)",
        "snippet": "    def test_index_not_contains(self, index, val):\n        assert val not in index",
        "begin_line": 657,
        "end_line": 658,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_mixed_index_contains#663",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_mixed_index_contains(self, index, val)",
        "snippet": "    def test_mixed_index_contains(self, index, val):\n        # GH 19860\n        assert val in index",
        "begin_line": 663,
        "end_line": 665,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_mixed_index_not_contains#670",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_mixed_index_not_contains(self, index, val)",
        "snippet": "    def test_mixed_index_not_contains(self, index, val):\n        # GH 19860\n        assert val not in index",
        "begin_line": 670,
        "end_line": 672,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_contains_with_float_index#674",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_contains_with_float_index(self)",
        "snippet": "    def test_contains_with_float_index(self):\n        # GH#22085\n        integer_index = pd.Int64Index([0, 1, 2, 3])\n        uinteger_index = pd.UInt64Index([0, 1, 2, 3])\n        float_index = pd.Float64Index([0.1, 1.1, 2.2, 3.3])\n\n        for index in (integer_index, uinteger_index):\n            assert 1.1 not in index\n            assert 1.0 in index\n            assert 1 in index\n\n        assert 1.1 in float_index\n        assert 1.0 not in float_index\n        assert 1 not in float_index",
        "begin_line": 674,
        "end_line": 687,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestFancy.test_index_type_coercion#689",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestFancy",
        "signature": "pandas.tests.indexing.test_indexing.TestFancy.test_index_type_coercion(self)",
        "snippet": "    def test_index_type_coercion(self):\n\n        # GH 11836\n        # if we have an index type and set it with something that looks\n        # to numpy like the same, but is actually, not\n        # (e.g. setting with a float or string '0')\n        # then we need to coerce to object\n\n        # integer indexes\n        for s in [Series(range(5)), Series(range(5), index=range(1, 6))]:\n\n            assert s.index.is_integer()\n\n            for indexer in [lambda x: x.loc, lambda x: x]:\n                s2 = s.copy()\n                indexer(s2)[0.1] = 0\n                assert s2.index.is_floating()\n                assert indexer(s2)[0.1] == 0\n\n                s2 = s.copy()\n                indexer(s2)[0.0] = 0\n                exp = s.index\n                if 0 not in s:\n                    exp = Index(s.index.tolist() + [0])\n                tm.assert_index_equal(s2.index, exp)\n\n                s2 = s.copy()\n                indexer(s2)[\"0\"] = 0\n                assert s2.index.is_object()\n\n        for s in [Series(range(5), index=np.arange(5.0))]:\n\n            assert s.index.is_floating()\n\n            for idxr in [lambda x: x.loc, lambda x: x]:\n\n                s2 = s.copy()\n                idxr(s2)[0.1] = 0\n                assert s2.index.is_floating()\n                assert idxr(s2)[0.1] == 0\n\n                s2 = s.copy()\n                idxr(s2)[0.0] = 0\n                tm.assert_index_equal(s2.index, s.index)\n\n                s2 = s.copy()\n                idxr(s2)[\"0\"] = 0\n                assert s2.index.is_object()",
        "begin_line": 689,
        "end_line": 736,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_float_index_to_mixed#740",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_float_index_to_mixed(self)",
        "snippet": "    def test_float_index_to_mixed(self):\n        df = DataFrame({0.0: np.random.rand(10), 1.0: np.random.rand(10)})\n        df[\"a\"] = 10\n        tm.assert_frame_equal(\n            DataFrame({0.0: df[0.0], 1.0: df[1.0], \"a\": [10] * 10}), df\n        )",
        "begin_line": 740,
        "end_line": 745,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_float_index_non_scalar_assignment#747",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_float_index_non_scalar_assignment(self)",
        "snippet": "    def test_float_index_non_scalar_assignment(self):\n        df = DataFrame({\"a\": [1, 2, 3], \"b\": [3, 4, 5]}, index=[1.0, 2.0, 3.0])\n        df.loc[df.index[:2]] = 1\n        expected = DataFrame({\"a\": [1, 1, 3], \"b\": [1, 1, 5]}, index=df.index)\n        tm.assert_frame_equal(expected, df)\n\n        df = DataFrame({\"a\": [1, 2, 3], \"b\": [3, 4, 5]}, index=[1.0, 2.0, 3.0])\n        df2 = df.copy()\n        df.loc[df.index] = df.loc[df.index]\n        tm.assert_frame_equal(df, df2)",
        "begin_line": 747,
        "end_line": 756,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_float_index_at_iat#758",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_float_index_at_iat(self)",
        "snippet": "    def test_float_index_at_iat(self):\n        s = Series([1, 2, 3], index=[0.1, 0.2, 0.3])\n        for el, item in s.items():\n            assert s.at[el] == item\n        for i in range(len(s)):\n            assert s.iat[i] == i + 1",
        "begin_line": 758,
        "end_line": 763,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_mixed_index_assignment#765",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_mixed_index_assignment(self)",
        "snippet": "    def test_mixed_index_assignment(self):\n        # GH 19860\n        s = Series([1, 2, 3, 4, 5], index=[\"a\", \"b\", \"c\", 1, 2])\n        s.at[\"a\"] = 11\n        assert s.iat[0] == 11\n        s.at[1] = 22\n        assert s.iat[3] == 22",
        "begin_line": 765,
        "end_line": 771,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_mixed_index_no_fallback#773",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_mixed_index_no_fallback(self)",
        "snippet": "    def test_mixed_index_no_fallback(self):\n        # GH 19860\n        s = Series([1, 2, 3, 4, 5], index=[\"a\", \"b\", \"c\", 1, 2])\n        with pytest.raises(KeyError, match=\"^0$\"):\n            s.at[0]\n        with pytest.raises(KeyError, match=\"^4$\"):\n            s.at[4]",
        "begin_line": 773,
        "end_line": 779,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_rhs_alignment#781",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_rhs_alignment(self)",
        "snippet": "    def test_rhs_alignment(self):\n        # GH8258, tests that both rows & columns are aligned to what is\n        # assigned to. covers both uniform data-type & multi-type cases\n        def run_tests(df, rhs, right):\n            # label, index, slice\n            lbl_one, idx_one, slice_one = list(\"bcd\"), [1, 2, 3], slice(1, 4)\n            lbl_two, idx_two, slice_two = [\"joe\", \"jolie\"], [1, 2], slice(1, 3)\n\n            left = df.copy()\n            left.loc[lbl_one, lbl_two] = rhs\n            tm.assert_frame_equal(left, right)\n\n            left = df.copy()\n            left.iloc[idx_one, idx_two] = rhs\n            tm.assert_frame_equal(left, right)\n\n            left = df.copy()\n            left.iloc[slice_one, slice_two] = rhs\n            tm.assert_frame_equal(left, right)\n\n        xs = np.arange(20).reshape(5, 4)\n        cols = [\"jim\", \"joe\", \"jolie\", \"joline\"]\n        df = DataFrame(xs, columns=cols, index=list(\"abcde\"))\n\n        # right hand side; permute the indices and multiplpy by -2\n        rhs = -2 * df.iloc[3:0:-1, 2:0:-1]\n\n        # expected `right` result; just multiply by -2\n        right = df.copy()\n        right.iloc[1:4, 1:3] *= -2\n\n        # run tests with uniform dtypes\n        run_tests(df, rhs, right)\n\n        # make frames multi-type & re-run tests\n        for frame in [df, rhs, right]:\n            frame[\"joe\"] = frame[\"joe\"].astype(\"float64\")\n            frame[\"jolie\"] = frame[\"jolie\"].map(\"@{0}\".format)\n\n        run_tests(df, rhs, right)",
        "begin_line": 781,
        "end_line": 820,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.run_tests#784",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.run_tests(df, rhs, right)",
        "snippet": "        def run_tests(df, rhs, right):\n            # label, index, slice\n            lbl_one, idx_one, slice_one = list(\"bcd\"), [1, 2, 3], slice(1, 4)\n            lbl_two, idx_two, slice_two = [\"joe\", \"jolie\"], [1, 2], slice(1, 3)\n\n            left = df.copy()\n            left.loc[lbl_one, lbl_two] = rhs\n            tm.assert_frame_equal(left, right)\n\n            left = df.copy()\n            left.iloc[idx_one, idx_two] = rhs\n            tm.assert_frame_equal(left, right)\n\n            left = df.copy()\n            left.iloc[slice_one, slice_two] = rhs\n            tm.assert_frame_equal(left, right)",
        "begin_line": 784,
        "end_line": 799,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_str_label_slicing_with_negative_step#822",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_str_label_slicing_with_negative_step(self)",
        "snippet": "    def test_str_label_slicing_with_negative_step(self):\n        SLC = pd.IndexSlice\n\n        def assert_slices_equivalent(l_slc, i_slc):\n            tm.assert_series_equal(s.loc[l_slc], s.iloc[i_slc])\n\n            if not idx.is_integer:\n                # For integer indices, .loc and plain getitem are position-based.\n                tm.assert_series_equal(s[l_slc], s.iloc[i_slc])\n                tm.assert_series_equal(s.loc[l_slc], s.iloc[i_slc])\n\n        for idx in [_mklbl(\"A\", 20), np.arange(20) + 100, np.linspace(100, 150, 20)]:\n            idx = Index(idx)\n            s = Series(np.arange(20), index=idx)\n            assert_slices_equivalent(SLC[idx[9] :: -1], SLC[9::-1])\n            assert_slices_equivalent(SLC[: idx[9] : -1], SLC[:8:-1])\n            assert_slices_equivalent(SLC[idx[13] : idx[9] : -1], SLC[13:8:-1])\n            assert_slices_equivalent(SLC[idx[9] : idx[13] : -1], SLC[:0])",
        "begin_line": 822,
        "end_line": 839,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.assert_slices_equivalent#825",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.assert_slices_equivalent(l_slc, i_slc)",
        "snippet": "        def assert_slices_equivalent(l_slc, i_slc):\n            tm.assert_series_equal(s.loc[l_slc], s.iloc[i_slc])\n\n            if not idx.is_integer:\n                # For integer indices, .loc and plain getitem are position-based.\n                tm.assert_series_equal(s[l_slc], s.iloc[i_slc])\n                tm.assert_series_equal(s.loc[l_slc], s.iloc[i_slc])",
        "begin_line": 825,
        "end_line": 831,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_slice_with_zero_step_raises#841",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_slice_with_zero_step_raises(self)",
        "snippet": "    def test_slice_with_zero_step_raises(self):\n        s = Series(np.arange(20), index=_mklbl(\"A\", 20))\n        with pytest.raises(ValueError, match=\"slice step cannot be zero\"):\n            s[::0]\n        with pytest.raises(ValueError, match=\"slice step cannot be zero\"):\n            s.loc[::0]",
        "begin_line": 841,
        "end_line": 846,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_indexing_assignment_dict_already_exists#848",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_indexing_assignment_dict_already_exists(self)",
        "snippet": "    def test_indexing_assignment_dict_already_exists(self):\n        df = DataFrame({\"x\": [1, 2, 6], \"y\": [2, 2, 8], \"z\": [-5, 0, 5]}).set_index(\"z\")\n        expected = df.copy()\n        rhs = dict(x=9, y=99)\n        df.loc[5] = rhs\n        expected.loc[5] = [9, 99]\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 848,
        "end_line": 854,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_indexing_dtypes_on_empty#856",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_indexing_dtypes_on_empty(self)",
        "snippet": "    def test_indexing_dtypes_on_empty(self):\n        # Check that .iloc returns correct dtypes GH9983\n        df = DataFrame({\"a\": [1, 2, 3], \"b\": [\"b\", \"b2\", \"b3\"]})\n        df2 = df.iloc[[], :]\n\n        assert df2.loc[:, \"a\"].dtype == np.int64\n        tm.assert_series_equal(df2.loc[:, \"a\"], df2.iloc[:, 0])",
        "begin_line": 856,
        "end_line": 862,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_range_in_series_indexing#865",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_range_in_series_indexing(self, size)",
        "snippet": "    def test_range_in_series_indexing(self, size):\n        # range can cause an indexing error\n        # GH 11652\n        s = Series(index=range(size), dtype=np.float64)\n        s.loc[range(1)] = 42\n        tm.assert_series_equal(s.loc[range(1)], Series(42.0, index=[0]))\n\n        s.loc[range(2)] = 43\n        tm.assert_series_equal(s.loc[range(2)], Series(43.0, index=[0, 1]))",
        "begin_line": 865,
        "end_line": 873,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_non_reducing_slice#893",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_non_reducing_slice(self, slc)",
        "snippet": "    def test_non_reducing_slice(self, slc):\n        df = DataFrame([[0, 1], [2, 3]])\n\n        tslice_ = _non_reducing_slice(slc)\n        assert isinstance(df.loc[tslice_], DataFrame)",
        "begin_line": 893,
        "end_line": 897,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_list_slice#899",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_list_slice(self)",
        "snippet": "    def test_list_slice(self):\n        # like dataframe getitem\n        slices = [[\"A\"], Series([\"A\"]), np.array([\"A\"])]\n        df = DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"A\", \"B\"])\n        expected = pd.IndexSlice[:, [\"A\"]]\n        for subset in slices:\n            result = _non_reducing_slice(subset)\n            tm.assert_frame_equal(df.loc[result], df.loc[expected])",
        "begin_line": 899,
        "end_line": 906,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_maybe_numeric_slice#908",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_maybe_numeric_slice(self)",
        "snippet": "    def test_maybe_numeric_slice(self):\n        df = DataFrame({\"A\": [1, 2], \"B\": [\"c\", \"d\"], \"C\": [True, False]})\n        result = _maybe_numeric_slice(df, slice_=None)\n        expected = pd.IndexSlice[:, [\"A\"]]\n        assert result == expected\n\n        result = _maybe_numeric_slice(df, None, include_bool=True)\n        expected = pd.IndexSlice[:, [\"A\", \"C\"]]\n        result = _maybe_numeric_slice(df, [1])\n        expected = [1]\n        assert result == expected",
        "begin_line": 908,
        "end_line": 918,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_partial_boolean_frame_indexing#920",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_partial_boolean_frame_indexing(self)",
        "snippet": "    def test_partial_boolean_frame_indexing(self):\n        # GH 17170\n        df = DataFrame(\n            np.arange(9.0).reshape(3, 3), index=list(\"abc\"), columns=list(\"ABC\")\n        )\n        index_df = DataFrame(1, index=list(\"ab\"), columns=list(\"AB\"))\n        result = df[index_df.notnull()]\n        expected = DataFrame(\n            np.array([[0.0, 1.0, np.nan], [3.0, 4.0, np.nan], [np.nan] * 3]),\n            index=list(\"abc\"),\n            columns=list(\"ABC\"),\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 920,
        "end_line": 932,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestMisc.test_no_reference_cycle#934",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestMisc",
        "signature": "pandas.tests.indexing.test_indexing.TestMisc.test_no_reference_cycle(self)",
        "snippet": "    def test_no_reference_cycle(self):\n        df = DataFrame({\"a\": [0, 1], \"b\": [2, 3]})\n        for name in (\"loc\", \"iloc\", \"at\", \"iat\"):\n            getattr(df, name)\n        wr = weakref.ref(df)\n        del df\n        assert wr() is None",
        "begin_line": 934,
        "end_line": 940,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestSeriesNoneCoercion.test_coercion_with_setitem#958",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestSeriesNoneCoercion",
        "signature": "pandas.tests.indexing.test_indexing.TestSeriesNoneCoercion.test_coercion_with_setitem(self, start_data, expected_result)",
        "snippet": "    def test_coercion_with_setitem(self, start_data, expected_result):\n        start_series = Series(start_data)\n        start_series[0] = None\n\n        expected_series = Series(expected_result)\n        tm.assert_series_equal(start_series, expected_series)",
        "begin_line": 958,
        "end_line": 963,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestSeriesNoneCoercion.test_coercion_with_loc_setitem#966",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestSeriesNoneCoercion",
        "signature": "pandas.tests.indexing.test_indexing.TestSeriesNoneCoercion.test_coercion_with_loc_setitem(self, start_data, expected_result)",
        "snippet": "    def test_coercion_with_loc_setitem(self, start_data, expected_result):\n        start_series = Series(start_data)\n        start_series.loc[0] = None\n\n        expected_series = Series(expected_result)\n        tm.assert_series_equal(start_series, expected_series)",
        "begin_line": 966,
        "end_line": 971,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestSeriesNoneCoercion.test_coercion_with_setitem_and_series#974",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestSeriesNoneCoercion",
        "signature": "pandas.tests.indexing.test_indexing.TestSeriesNoneCoercion.test_coercion_with_setitem_and_series(self, start_data, expected_result)",
        "snippet": "    def test_coercion_with_setitem_and_series(self, start_data, expected_result):\n        start_series = Series(start_data)\n        start_series[start_series == start_series[0]] = None\n\n        expected_series = Series(expected_result)\n        tm.assert_series_equal(start_series, expected_series)",
        "begin_line": 974,
        "end_line": 979,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestSeriesNoneCoercion.test_coercion_with_loc_and_series#982",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestSeriesNoneCoercion",
        "signature": "pandas.tests.indexing.test_indexing.TestSeriesNoneCoercion.test_coercion_with_loc_and_series(self, start_data, expected_result)",
        "snippet": "    def test_coercion_with_loc_and_series(self, start_data, expected_result):\n        start_series = Series(start_data)\n        start_series.loc[start_series == start_series[0]] = None\n\n        expected_series = Series(expected_result)\n        tm.assert_series_equal(start_series, expected_series)",
        "begin_line": 982,
        "end_line": 987,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestDataframeNoneCoercion.test_coercion_with_loc#1005",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestDataframeNoneCoercion",
        "signature": "pandas.tests.indexing.test_indexing.TestDataframeNoneCoercion.test_coercion_with_loc(self, expected)",
        "snippet": "    def test_coercion_with_loc(self, expected):\n        start_data, expected_result = expected\n\n        start_dataframe = DataFrame({\"foo\": start_data})\n        start_dataframe.loc[0, [\"foo\"]] = None\n\n        expected_dataframe = DataFrame({\"foo\": expected_result})\n        tm.assert_frame_equal(start_dataframe, expected_dataframe)",
        "begin_line": 1005,
        "end_line": 1012,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestDataframeNoneCoercion.test_coercion_with_setitem_and_dataframe#1015",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestDataframeNoneCoercion",
        "signature": "pandas.tests.indexing.test_indexing.TestDataframeNoneCoercion.test_coercion_with_setitem_and_dataframe(self, expected)",
        "snippet": "    def test_coercion_with_setitem_and_dataframe(self, expected):\n        start_data, expected_result = expected\n\n        start_dataframe = DataFrame({\"foo\": start_data})\n        start_dataframe[start_dataframe[\"foo\"] == start_dataframe[\"foo\"][0]] = None\n\n        expected_dataframe = DataFrame({\"foo\": expected_result})\n        tm.assert_frame_equal(start_dataframe, expected_dataframe)",
        "begin_line": 1015,
        "end_line": 1022,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestDataframeNoneCoercion.test_none_coercion_loc_and_dataframe#1025",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestDataframeNoneCoercion",
        "signature": "pandas.tests.indexing.test_indexing.TestDataframeNoneCoercion.test_none_coercion_loc_and_dataframe(self, expected)",
        "snippet": "    def test_none_coercion_loc_and_dataframe(self, expected):\n        start_data, expected_result = expected\n\n        start_dataframe = DataFrame({\"foo\": start_data})\n        start_dataframe.loc[start_dataframe[\"foo\"] == start_dataframe[\"foo\"][0]] = None\n\n        expected_dataframe = DataFrame({\"foo\": expected_result})\n        tm.assert_frame_equal(start_dataframe, expected_dataframe)",
        "begin_line": 1025,
        "end_line": 1032,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.TestDataframeNoneCoercion.test_none_coercion_mixed_dtypes#1034",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing.TestDataframeNoneCoercion",
        "signature": "pandas.tests.indexing.test_indexing.TestDataframeNoneCoercion.test_none_coercion_mixed_dtypes(self)",
        "snippet": "    def test_none_coercion_mixed_dtypes(self):\n        start_dataframe = DataFrame(\n            {\n                \"a\": [1, 2, 3],\n                \"b\": [1.0, 2.0, 3.0],\n                \"c\": [datetime(2000, 1, 1), datetime(2000, 1, 2), datetime(2000, 1, 3)],\n                \"d\": [\"a\", \"b\", \"c\"],\n            }\n        )\n        start_dataframe.iloc[0] = None\n\n        exp = DataFrame(\n            {\n                \"a\": [np.nan, 2, 3],\n                \"b\": [np.nan, 2.0, 3.0],\n                \"c\": [NaT, datetime(2000, 1, 2), datetime(2000, 1, 3)],\n                \"d\": [None, \"b\", \"c\"],\n            }\n        )\n        tm.assert_frame_equal(start_dataframe, exp)",
        "begin_line": 1034,
        "end_line": 1053,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.test_validate_indices_ok#1056",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing",
        "signature": "pandas.tests.indexing.test_indexing.test_validate_indices_ok()",
        "snippet": "def test_validate_indices_ok():\n    indices = np.asarray([0, 1])\n    validate_indices(indices, 2)\n    validate_indices(indices[:0], 0)\n    validate_indices(np.array([-1, -1]), 0)",
        "begin_line": 1056,
        "end_line": 1060,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.test_validate_indices_low#1063",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing",
        "signature": "pandas.tests.indexing.test_indexing.test_validate_indices_low()",
        "snippet": "def test_validate_indices_low():\n    indices = np.asarray([0, -2])\n    with pytest.raises(ValueError, match=\"'indices' contains\"):\n        validate_indices(indices, 2)",
        "begin_line": 1063,
        "end_line": 1066,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.test_validate_indices_high#1069",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing",
        "signature": "pandas.tests.indexing.test_indexing.test_validate_indices_high()",
        "snippet": "def test_validate_indices_high():\n    indices = np.asarray([0, 1, 2])\n    with pytest.raises(IndexError, match=\"indices are out\"):\n        validate_indices(indices, 2)",
        "begin_line": 1069,
        "end_line": 1072,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.test_validate_indices_empty#1075",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing",
        "signature": "pandas.tests.indexing.test_indexing.test_validate_indices_empty()",
        "snippet": "def test_validate_indices_empty():\n    with pytest.raises(IndexError, match=\"indices are out\"):\n        validate_indices(np.array([0, 1]), 0)",
        "begin_line": 1075,
        "end_line": 1077,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.test_extension_array_cross_section#1080",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing",
        "signature": "pandas.tests.indexing.test_indexing.test_extension_array_cross_section()",
        "snippet": "def test_extension_array_cross_section():\n    # A cross-section of a homogeneous EA should be an EA\n    df = pd.DataFrame(\n        {\n            \"A\": pd.core.arrays.integer_array([1, 2]),\n            \"B\": pd.core.arrays.integer_array([3, 4]),\n        },\n        index=[\"a\", \"b\"],\n    )\n    expected = pd.Series(\n        pd.core.arrays.integer_array([1, 3]), index=[\"A\", \"B\"], name=\"a\"\n    )\n    result = df.loc[\"a\"]\n    tm.assert_series_equal(result, expected)\n\n    result = df.iloc[0]\n    tm.assert_series_equal(result, expected)",
        "begin_line": 1080,
        "end_line": 1096,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.test_extension_array_cross_section_converts#1099",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing",
        "signature": "pandas.tests.indexing.test_indexing.test_extension_array_cross_section_converts()",
        "snippet": "def test_extension_array_cross_section_converts():\n    df = pd.DataFrame(\n        {\"A\": pd.core.arrays.integer_array([1, 2]), \"B\": np.array([1, 2])},\n        index=[\"a\", \"b\"],\n    )\n    result = df.loc[\"a\"]\n    expected = pd.Series([1, 1], dtype=object, index=[\"A\", \"B\"], name=\"a\")\n    tm.assert_series_equal(result, expected)\n\n    result = df.iloc[0]\n    tm.assert_series_equal(result, expected)",
        "begin_line": 1099,
        "end_line": 1109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.test_ndframe_indexing_raises#1128",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing",
        "signature": "pandas.tests.indexing.test_indexing.test_ndframe_indexing_raises(idxr, error, error_message)",
        "snippet": "def test_ndframe_indexing_raises(idxr, error, error_message):\n    # GH 25567\n    frame = NDFrame(np.random.randint(5, size=(2, 2, 2)))\n    with pytest.raises(error, match=error_message):\n        idxr(frame)[0]",
        "begin_line": 1128,
        "end_line": 1132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.test_readonly_indices#1135",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing",
        "signature": "pandas.tests.indexing.test_indexing.test_readonly_indices()",
        "snippet": "def test_readonly_indices():\n    # GH#17192 iloc with read-only array raising TypeError\n    df = pd.DataFrame({\"data\": np.ones(100, dtype=\"float64\")})\n    indices = np.array([1, 3, 6])\n    indices.flags.writeable = False\n\n    result = df.iloc[indices]\n    expected = df.loc[[1, 3, 6]]\n    tm.assert_frame_equal(result, expected)\n\n    result = df[\"data\"].iloc[indices]\n    expected = df[\"data\"].loc[[1, 3, 6]]\n    tm.assert_series_equal(result, expected)",
        "begin_line": 1135,
        "end_line": 1147,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.test_1tuple_without_multiindex#1150",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing",
        "signature": "pandas.tests.indexing.test_indexing.test_1tuple_without_multiindex()",
        "snippet": "def test_1tuple_without_multiindex():\n    ser = pd.Series(range(5))\n    key = (slice(3),)\n\n    result = ser[key]\n    expected = ser[key[0]]\n    tm.assert_series_equal(result, expected)",
        "begin_line": 1150,
        "end_line": 1156,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.test_duplicate_index_mistyped_key_raises_keyerror#1159",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing",
        "signature": "pandas.tests.indexing.test_indexing.test_duplicate_index_mistyped_key_raises_keyerror()",
        "snippet": "def test_duplicate_index_mistyped_key_raises_keyerror():\n    # GH#29189 float_index.get_loc(None) should raise KeyError, not TypeError\n    ser = pd.Series([2, 5, 6, 8], index=[2.0, 4.0, 4.0, 5.0])\n    with pytest.raises(KeyError):\n        ser[None]\n\n    with pytest.raises(KeyError):\n        ser.index.get_loc(None)\n\n    with pytest.raises(KeyError):\n        ser.index._engine.get_loc(None)",
        "begin_line": 1159,
        "end_line": 1169,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_indexing.test_setitem_with_bool_mask_and_values_matching_n_trues_in_length#1172",
        "src_path": "pandas/tests/indexing/test_indexing.py",
        "class_name": "pandas.tests.indexing.test_indexing",
        "signature": "pandas.tests.indexing.test_indexing.test_setitem_with_bool_mask_and_values_matching_n_trues_in_length()",
        "snippet": "def test_setitem_with_bool_mask_and_values_matching_n_trues_in_length():\n    # GH 30567\n    ser = pd.Series([None] * 10)\n    mask = [False] * 3 + [True] * 5 + [False] * 2\n    ser[mask] = range(5)\n    result = ser\n    expected = pd.Series([None] * 3 + list(range(5)) + [None] * 2).astype(\"object\")\n    tm.assert_series_equal(result, expected)",
        "begin_line": 1172,
        "end_line": 1179,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._mklbl#10",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._mklbl(prefix, n)",
        "snippet": "def _mklbl(prefix, n):\n    return [\"{prefix}{i}\".format(prefix=prefix, i=i) for i in range(n)]",
        "begin_line": 10,
        "end_line": 11,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._axify#14",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._axify(obj, key, axis)",
        "snippet": "def _axify(obj, key, axis):\n    # create a tuple accessor\n    axes = [slice(None)] * obj.ndim\n    axes[axis] = key\n    return tuple(axes)",
        "begin_line": 14,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.setup_method#37",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n\n        self.series_ints = Series(np.random.rand(4), index=np.arange(0, 8, 2))\n        self.frame_ints = DataFrame(\n            np.random.randn(4, 4), index=np.arange(0, 8, 2), columns=np.arange(0, 12, 3)\n        )\n\n        self.series_uints = Series(\n            np.random.rand(4), index=UInt64Index(np.arange(0, 8, 2))\n        )\n        self.frame_uints = DataFrame(\n            np.random.randn(4, 4),\n            index=UInt64Index(range(0, 8, 2)),\n            columns=UInt64Index(range(0, 12, 3)),\n        )\n\n        self.series_floats = Series(\n            np.random.rand(4), index=Float64Index(range(0, 8, 2))\n        )\n        self.frame_floats = DataFrame(\n            np.random.randn(4, 4),\n            index=Float64Index(range(0, 8, 2)),\n            columns=Float64Index(range(0, 12, 3)),\n        )\n\n        m_idces = [\n            MultiIndex.from_product([[1, 2], [3, 4]]),\n            MultiIndex.from_product([[5, 6], [7, 8]]),\n            MultiIndex.from_product([[9, 10], [11, 12]]),\n        ]\n\n        self.series_multi = Series(np.random.rand(4), index=m_idces[0])\n        self.frame_multi = DataFrame(\n            np.random.randn(4, 4), index=m_idces[0], columns=m_idces[1]\n        )\n\n        self.series_labels = Series(np.random.randn(4), index=list(\"abcd\"))\n        self.frame_labels = DataFrame(\n            np.random.randn(4, 4), index=list(\"abcd\"), columns=list(\"ABCD\")\n        )\n\n        self.series_mixed = Series(np.random.randn(4), index=[2, 4, \"null\", 8])\n        self.frame_mixed = DataFrame(np.random.randn(4, 4), index=[2, 4, \"null\", 8])\n\n        self.series_ts = Series(\n            np.random.randn(4), index=date_range(\"20130101\", periods=4)\n        )\n        self.frame_ts = DataFrame(\n            np.random.randn(4, 4), index=date_range(\"20130101\", periods=4)\n        )\n\n        dates_rev = date_range(\"20130101\", periods=4).sort_values(ascending=False)\n        self.series_ts_rev = Series(np.random.randn(4), index=dates_rev)\n        self.frame_ts_rev = DataFrame(np.random.randn(4, 4), index=dates_rev)\n\n        self.frame_empty = DataFrame()\n        self.series_empty = Series(dtype=object)\n\n        # form agglomerates\n        for kind in self._kinds:\n            d = dict()\n            for typ in self._typs:\n                d[typ] = getattr(self, \"{kind}_{typ}\".format(kind=kind, typ=typ))\n\n            setattr(self, kind, d)",
        "begin_line": 37,
        "end_line": 101,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.generate_indices#103",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.generate_indices(self, f, values=False)",
        "snippet": "    def generate_indices(self, f, values=False):\n        \"\"\" generate the indices\n        if values is True , use the axis values\n        is False, use the range\n        \"\"\"\n\n        axes = f.axes\n        if values:\n            axes = (list(range(len(ax))) for ax in axes)\n\n        return itertools.product(*axes)",
        "begin_line": 103,
        "end_line": 113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.get_value#115",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.get_value(self, name, f, i, values=False)",
        "snippet": "    def get_value(self, name, f, i, values=False):\n        \"\"\" return the value for the location i \"\"\"\n\n        # check against values\n        if values:\n            return f.values[i]\n\n        elif name == \"iat\":\n            return f.iloc[i]\n        else:\n            assert name == \"at\"\n            return f.loc[i]",
        "begin_line": 115,
        "end_line": 126,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_values#128",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_values(self, f, func, values=False)",
        "snippet": "    def check_values(self, f, func, values=False):\n\n        if f is None:\n            return\n        axes = f.axes\n        indicies = itertools.product(*axes)\n\n        for i in indicies:\n            result = getattr(f, func)[i]\n\n            # check against values\n            if values:\n                expected = f.values[i]\n            else:\n                expected = f\n                for a in reversed(i):\n                    expected = expected.__getitem__(a)\n\n            tm.assert_almost_equal(result, expected)",
        "begin_line": 128,
        "end_line": 146,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_result#148",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_result(self, method, key, typs=None, axes=None, fails=None)",
        "snippet": "    def check_result(\n        self, method, key, typs=None, axes=None, fails=None,\n    ):\n        def _eq(axis, obj, key):\n            \"\"\" compare equal for these 2 keys \"\"\"\n\n            axified = _axify(obj, key, axis)\n            try:\n                getattr(obj, method).__getitem__(axified)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        return\n                raise\n\n        if typs is None:\n            typs = self._typs\n\n        if axes is None:\n            axes = [0, 1]\n        else:\n            assert axes in [0, 1]\n            axes = [axes]\n\n        # check\n        for kind in self._kinds:\n\n            d = getattr(self, kind)\n            for ax in axes:\n                for typ in typs:\n                    assert typ in self._typs\n\n                    obj = d[typ]\n                    if ax < obj.ndim:\n                        _eq(axis=ax, obj=obj, key=key)",
        "begin_line": 148,
        "end_line": 185,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base._eq#151",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base._eq(axis, obj, key)",
        "snippet": "        def _eq(axis, obj, key):\n            \"\"\" compare equal for these 2 keys \"\"\"\n\n            axified = _axify(obj, key, axis)\n            try:\n                getattr(obj, method).__getitem__(axified)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        return\n                raise",
        "begin_line": 151,
        "end_line": 164,
        "comment": "",
        "is_bug": false
    }
]