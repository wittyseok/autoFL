[
    {
        "name": "pandas.tests.arithmetic.test_datetime64.assert_all#33",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64",
        "signature": "pandas.tests.arithmetic.test_datetime64.assert_all(obj)",
        "snippet": "def assert_all(obj):\n    \"\"\"\n    Test helper to call call obj.all() the appropriate number of times on\n    a Series or DataFrame.\n    \"\"\"\n    if isinstance(obj, pd.DataFrame):\n        assert obj.all().all()\n    else:\n        assert obj.all()",
        "begin_line": 33,
        "end_line": 41,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons.test_compare_zerodim#53",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons.test_compare_zerodim(self, tz_naive_fixture, box_with_array)",
        "snippet": "    def test_compare_zerodim(self, tz_naive_fixture, box_with_array):\n        # Test comparison with zero-dimensional array is unboxed\n        tz = tz_naive_fixture\n        box = box_with_array\n        xbox = box_with_array if box_with_array is not pd.Index else np.ndarray\n        dti = date_range(\"20130101\", periods=3, tz=tz)\n\n        other = np.array(dti.to_numpy()[0])\n\n        # FIXME: ValueError with transpose on tzaware\n        dtarr = tm.box_expected(dti, box, transpose=False)\n        result = dtarr <= other\n        expected = np.array([True, False, False])\n        expected = tm.box_expected(expected, xbox, transpose=False)\n        tm.assert_equal(result, expected)",
        "begin_line": 53,
        "end_line": 67,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DataFrameComparison.test_tz_aware_scalar_comparison#78",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DataFrameComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DataFrameComparison.test_tz_aware_scalar_comparison(self, timestamps)",
        "snippet": "    def test_tz_aware_scalar_comparison(self, timestamps):\n        # GH#15966\n        df = pd.DataFrame({\"test\": timestamps})\n        expected = pd.DataFrame({\"test\": [False, False]})\n        tm.assert_frame_equal(df == -1, expected)",
        "begin_line": 78,
        "end_line": 82,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DataFrameComparison.test_dt64_nat_comparison#84",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DataFrameComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DataFrameComparison.test_dt64_nat_comparison(self)",
        "snippet": "    def test_dt64_nat_comparison(self):\n        # GH#22242, GH#22163 DataFrame considered NaT == ts incorrectly\n        ts = pd.Timestamp.now()\n        df = pd.DataFrame([ts, pd.NaT])\n        expected = pd.DataFrame([True, False])\n\n        result = df == ts\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 84,
        "end_line": 91,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_nat_comparisons#117",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_nat_comparisons(self, dtype, box, reverse, pair)",
        "snippet": "    def test_nat_comparisons(self, dtype, box, reverse, pair):\n        l, r = pair\n        if reverse:\n            # add lhs / rhs switched data\n            l, r = r, l\n\n        left = Series(l, dtype=dtype)\n        right = box(r, dtype=dtype)\n        # Series, Index\n\n        expected = Series([False, False, True])\n        tm.assert_series_equal(left == right, expected)\n\n        expected = Series([True, True, False])\n        tm.assert_series_equal(left != right, expected)\n\n        expected = Series([False, False, False])\n        tm.assert_series_equal(left < right, expected)\n\n        expected = Series([False, False, False])\n        tm.assert_series_equal(left > right, expected)\n\n        expected = Series([False, False, True])\n        tm.assert_series_equal(left >= right, expected)\n\n        expected = Series([False, False, True])\n        tm.assert_series_equal(left <= right, expected)",
        "begin_line": 117,
        "end_line": 143,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_comparison_invalid#145",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_comparison_invalid(self, box_with_array)",
        "snippet": "    def test_comparison_invalid(self, box_with_array):\n        # GH#4968\n        # invalid date/int comparisons\n        xbox = box_with_array if box_with_array is not pd.Index else np.ndarray\n\n        ser = Series(range(5))\n        ser2 = Series(pd.date_range(\"20010101\", periods=5))\n\n        ser = tm.box_expected(ser, box_with_array)\n        ser2 = tm.box_expected(ser2, box_with_array)\n\n        for (x, y) in [(ser, ser2), (ser2, ser)]:\n\n            result = x == y\n            expected = tm.box_expected([False] * 5, xbox)\n            tm.assert_equal(result, expected)\n\n            result = x != y\n            expected = tm.box_expected([True] * 5, xbox)\n            tm.assert_equal(result, expected)\n            msg = \"Invalid comparison between\"\n            with pytest.raises(TypeError, match=msg):\n                x >= y\n            with pytest.raises(TypeError, match=msg):\n                x > y\n            with pytest.raises(TypeError, match=msg):\n                x < y\n            with pytest.raises(TypeError, match=msg):\n                x <= y",
        "begin_line": 145,
        "end_line": 173,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_nat_comparisons_scalar#184",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_nat_comparisons_scalar(self, dtype, data, box_with_array)",
        "snippet": "    def test_nat_comparisons_scalar(self, dtype, data, box_with_array):\n        if box_with_array is tm.to_array and dtype is object:\n            # dont bother testing ndarray comparison methods as this fails\n            #  on older numpys (since they check object identity)\n            return\n\n        xbox = box_with_array if box_with_array is not pd.Index else np.ndarray\n\n        left = Series(data, dtype=dtype)\n        left = tm.box_expected(left, box_with_array)\n\n        expected = [False, False, False]\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(left == NaT, expected)\n        tm.assert_equal(NaT == left, expected)\n\n        expected = [True, True, True]\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(left != NaT, expected)\n        tm.assert_equal(NaT != left, expected)\n\n        expected = [False, False, False]\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(left < NaT, expected)\n        tm.assert_equal(NaT > left, expected)\n        tm.assert_equal(left <= NaT, expected)\n        tm.assert_equal(NaT >= left, expected)\n\n        tm.assert_equal(left > NaT, expected)\n        tm.assert_equal(NaT < left, expected)\n        tm.assert_equal(left >= NaT, expected)\n        tm.assert_equal(NaT <= left, expected)",
        "begin_line": 184,
        "end_line": 215,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_series_comparison_scalars#217",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_series_comparison_scalars(self)",
        "snippet": "    def test_series_comparison_scalars(self):\n        series = Series(date_range(\"1/1/2000\", periods=10))\n\n        val = datetime(2000, 1, 4)\n        result = series > val\n        expected = Series([x > val for x in series])\n        tm.assert_series_equal(result, expected)\n\n        val = series[5]\n        result = series > val\n        expected = Series([x > val for x in series])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 217,
        "end_line": 228,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_dt64ser_cmp_date_invalid#230",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_dt64ser_cmp_date_invalid(self, box_with_array)",
        "snippet": "    def test_dt64ser_cmp_date_invalid(self, box_with_array):\n        # GH#19800 datetime.date comparison raises to\n        # match DatetimeIndex/Timestamp.  This also matches the behavior\n        # of stdlib datetime.datetime\n\n        ser = pd.date_range(\"20010101\", periods=10)\n        date = ser[0].to_pydatetime().date()\n\n        ser = tm.box_expected(ser, box_with_array)\n        assert_all(~(ser == date))\n        assert_all(ser != date)\n        with pytest.raises(TypeError):\n            ser > date\n        with pytest.raises(TypeError):\n            ser < date\n        with pytest.raises(TypeError):\n            ser >= date\n        with pytest.raises(TypeError):\n            ser <= date",
        "begin_line": 230,
        "end_line": 248,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_timestamp_compare_series#253",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_timestamp_compare_series(self, left, right)",
        "snippet": "    def test_timestamp_compare_series(self, left, right):\n        # see gh-4982\n        # Make sure we can compare Timestamps on the right AND left hand side.\n        ser = pd.Series(pd.date_range(\"20010101\", periods=10), name=\"dates\")\n        s_nat = ser.copy(deep=True)\n\n        ser[0] = pd.Timestamp(\"nat\")\n        ser[3] = pd.Timestamp(\"nat\")\n\n        left_f = getattr(operator, left)\n        right_f = getattr(operator, right)\n\n        # No NaT\n        expected = left_f(ser, pd.Timestamp(\"20010109\"))\n        result = right_f(pd.Timestamp(\"20010109\"), ser)\n        tm.assert_series_equal(result, expected)\n\n        # NaT\n        expected = left_f(ser, pd.Timestamp(\"nat\"))\n        result = right_f(pd.Timestamp(\"nat\"), ser)\n        tm.assert_series_equal(result, expected)\n\n        # Compare to Timestamp with series containing NaT\n        expected = left_f(s_nat, pd.Timestamp(\"20010109\"))\n        result = right_f(pd.Timestamp(\"20010109\"), s_nat)\n        tm.assert_series_equal(result, expected)\n\n        # Compare to NaT with series containing NaT\n        expected = left_f(s_nat, pd.Timestamp(\"nat\"))\n        result = right_f(pd.Timestamp(\"nat\"), s_nat)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 253,
        "end_line": 283,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_dt64arr_timestamp_equality#285",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_dt64arr_timestamp_equality(self, box_with_array)",
        "snippet": "    def test_dt64arr_timestamp_equality(self, box_with_array):\n        # GH#11034\n        xbox = box_with_array if box_with_array is not pd.Index else np.ndarray\n\n        ser = pd.Series([pd.Timestamp(\"2000-01-29 01:59:00\"), \"NaT\"])\n        ser = tm.box_expected(ser, box_with_array)\n\n        result = ser != ser\n        expected = tm.box_expected([False, True], xbox)\n        tm.assert_equal(result, expected)\n\n        result = ser != ser[0]\n        expected = tm.box_expected([False, True], xbox)\n        tm.assert_equal(result, expected)\n\n        result = ser != ser[1]\n        expected = tm.box_expected([True, True], xbox)\n        tm.assert_equal(result, expected)\n\n        result = ser == ser\n        expected = tm.box_expected([True, False], xbox)\n        tm.assert_equal(result, expected)\n\n        result = ser == ser[0]\n        expected = tm.box_expected([True, False], xbox)\n        tm.assert_equal(result, expected)\n\n        result = ser == ser[1]\n        expected = tm.box_expected([False, False], xbox)\n        tm.assert_equal(result, expected)",
        "begin_line": 285,
        "end_line": 314,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_comparison_tzawareness_compat#320",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_comparison_tzawareness_compat(self, op)",
        "snippet": "    def test_comparison_tzawareness_compat(self, op):\n        # GH#18162\n        dr = pd.date_range(\"2016-01-01\", periods=6)\n        dz = dr.tz_localize(\"US/Pacific\")\n\n        # Check that there isn't a problem aware-aware and naive-naive do not\n        # raise\n        naive_series = Series(dr)\n        aware_series = Series(dz)\n        msg = \"Cannot compare tz-naive and tz-aware\"\n        with pytest.raises(TypeError, match=msg):\n            op(dz, naive_series)\n        with pytest.raises(TypeError, match=msg):\n            op(dr, aware_series)",
        "begin_line": 320,
        "end_line": 333,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_comparators#346",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_comparators(self, op)",
        "snippet": "    def test_comparators(self, op):\n        index = tm.makeDateIndex(100)\n        element = index[len(index) // 2]\n        element = _to_M8(element)\n\n        arr = np.array(index)\n        arr_result = op(arr, element)\n        index_result = op(index, element)\n\n        assert isinstance(index_result, np.ndarray)\n        tm.assert_numpy_array_equal(arr_result, index_result)",
        "begin_line": 346,
        "end_line": 356,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_datetimelike#362",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_datetimelike(self, other, tz_naive_fixture)",
        "snippet": "    def test_dti_cmp_datetimelike(self, other, tz_naive_fixture):\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2016-01-01\", periods=2, tz=tz)\n        if tz is not None:\n            if isinstance(other, np.datetime64):\n                # no tzaware version available\n                return\n            other = localize_pydatetime(other, dti.tzinfo)\n\n        result = dti == other\n        expected = np.array([True, False])\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = dti > other\n        expected = np.array([False, True])\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = dti >= other\n        expected = np.array([True, True])\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = dti < other\n        expected = np.array([False, False])\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = dti <= other\n        expected = np.array([True, False])\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 362,
        "end_line": 389,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.dt64arr_cmp_non_datetime#391",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.dt64arr_cmp_non_datetime(self, tz_naive_fixture, box_with_array)",
        "snippet": "    def dt64arr_cmp_non_datetime(self, tz_naive_fixture, box_with_array):\n        # GH#19301 by convention datetime.date is not considered comparable\n        # to Timestamp or DatetimeIndex.  This may change in the future.\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2016-01-01\", periods=2, tz=tz)\n        dtarr = tm.box_expected(dti, box_with_array)\n\n        other = datetime(2016, 1, 1).date()\n        assert not (dtarr == other).any()\n        assert (dtarr != other).all()\n        with pytest.raises(TypeError):\n            dtarr < other\n        with pytest.raises(TypeError):\n            dtarr <= other\n        with pytest.raises(TypeError):\n            dtarr > other\n        with pytest.raises(TypeError):\n            dtarr >= other",
        "begin_line": 391,
        "end_line": 408,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_eq_null_scalar#411",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_eq_null_scalar(self, other, tz_naive_fixture)",
        "snippet": "    def test_dti_eq_null_scalar(self, other, tz_naive_fixture):\n        # GH#19301\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2016-01-01\", periods=2, tz=tz)\n        assert not (dti == other).any()",
        "begin_line": 411,
        "end_line": 415,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_ne_null_scalar#418",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_ne_null_scalar(self, other, tz_naive_fixture)",
        "snippet": "    def test_dti_ne_null_scalar(self, other, tz_naive_fixture):\n        # GH#19301\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2016-01-01\", periods=2, tz=tz)\n        assert (dti != other).all()",
        "begin_line": 418,
        "end_line": 422,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_null_scalar_inequality#425",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_null_scalar_inequality(self, tz_naive_fixture, other, box_with_array)",
        "snippet": "    def test_dti_cmp_null_scalar_inequality(\n        self, tz_naive_fixture, other, box_with_array\n    ):\n        # GH#19301\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2016-01-01\", periods=2, tz=tz)\n        dtarr = tm.box_expected(dti, box_with_array)\n        msg = \"Invalid comparison between\"\n        with pytest.raises(TypeError, match=msg):\n            dtarr < other\n        with pytest.raises(TypeError, match=msg):\n            dtarr <= other\n        with pytest.raises(TypeError, match=msg):\n            dtarr > other\n        with pytest.raises(TypeError, match=msg):\n            dtarr >= other",
        "begin_line": 425,
        "end_line": 440,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_nat#443",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_nat(self, dtype, box_with_array)",
        "snippet": "    def test_dti_cmp_nat(self, dtype, box_with_array):\n        if box_with_array is tm.to_array and dtype is object:\n            # dont bother testing ndarray comparison methods as this fails\n            #  on older numpys (since they check object identity)\n            return\n\n        xbox = box_with_array if box_with_array is not pd.Index else np.ndarray\n\n        left = pd.DatetimeIndex(\n            [pd.Timestamp(\"2011-01-01\"), pd.NaT, pd.Timestamp(\"2011-01-03\")]\n        )\n        right = pd.DatetimeIndex([pd.NaT, pd.NaT, pd.Timestamp(\"2011-01-03\")])\n\n        left = tm.box_expected(left, box_with_array)\n        right = tm.box_expected(right, box_with_array)\n\n        lhs, rhs = left, right\n        if dtype is object:\n            lhs, rhs = left.astype(object), right.astype(object)\n\n        result = rhs == lhs\n        expected = np.array([False, False, True])\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(result, expected)\n\n        result = lhs != rhs\n        expected = np.array([True, True, False])\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(result, expected)\n\n        expected = np.array([False, False, False])\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(lhs == pd.NaT, expected)\n        tm.assert_equal(pd.NaT == rhs, expected)\n\n        expected = np.array([True, True, True])\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(lhs != pd.NaT, expected)\n        tm.assert_equal(pd.NaT != lhs, expected)\n\n        expected = np.array([False, False, False])\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(lhs < pd.NaT, expected)\n        tm.assert_equal(pd.NaT > lhs, expected)",
        "begin_line": 443,
        "end_line": 486,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_nat_behaves_like_float_cmp_nan#488",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_nat_behaves_like_float_cmp_nan(self)",
        "snippet": "    def test_dti_cmp_nat_behaves_like_float_cmp_nan(self):\n        fidx1 = pd.Index([1.0, np.nan, 3.0, np.nan, 5.0, 7.0])\n        fidx2 = pd.Index([2.0, 3.0, np.nan, np.nan, 6.0, 7.0])\n\n        didx1 = pd.DatetimeIndex(\n            [\"2014-01-01\", pd.NaT, \"2014-03-01\", pd.NaT, \"2014-05-01\", \"2014-07-01\"]\n        )\n        didx2 = pd.DatetimeIndex(\n            [\"2014-02-01\", \"2014-03-01\", pd.NaT, pd.NaT, \"2014-06-01\", \"2014-07-01\"]\n        )\n        darr = np.array(\n            [\n                np_datetime64_compat(\"2014-02-01 00:00Z\"),\n                np_datetime64_compat(\"2014-03-01 00:00Z\"),\n                np_datetime64_compat(\"nat\"),\n                np.datetime64(\"nat\"),\n                np_datetime64_compat(\"2014-06-01 00:00Z\"),\n                np_datetime64_compat(\"2014-07-01 00:00Z\"),\n            ]\n        )\n\n        cases = [(fidx1, fidx2), (didx1, didx2), (didx1, darr)]\n\n        # Check pd.NaT is handles as the same as np.nan\n        with tm.assert_produces_warning(None):\n            for idx1, idx2 in cases:\n\n                result = idx1 < idx2\n                expected = np.array([True, False, False, False, True, False])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx2 > idx1\n                expected = np.array([True, False, False, False, True, False])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 <= idx2\n                expected = np.array([True, False, False, False, True, True])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx2 >= idx1\n                expected = np.array([True, False, False, False, True, True])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 == idx2\n                expected = np.array([False, False, False, False, False, True])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 != idx2\n                expected = np.array([True, True, True, True, True, False])\n                tm.assert_numpy_array_equal(result, expected)\n\n        with tm.assert_produces_warning(None):\n            for idx1, val in [(fidx1, np.nan), (didx1, pd.NaT)]:\n                result = idx1 < val\n                expected = np.array([False, False, False, False, False, False])\n                tm.assert_numpy_array_equal(result, expected)\n                result = idx1 > val\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 <= val\n                tm.assert_numpy_array_equal(result, expected)\n                result = idx1 >= val\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 == val\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 != val\n                expected = np.array([True, True, True, True, True, True])\n                tm.assert_numpy_array_equal(result, expected)\n\n        # Check pd.NaT is handles as the same as np.nan\n        with tm.assert_produces_warning(None):\n            for idx1, val in [(fidx1, 3), (didx1, datetime(2014, 3, 1))]:\n                result = idx1 < val\n                expected = np.array([True, False, False, False, False, False])\n                tm.assert_numpy_array_equal(result, expected)\n                result = idx1 > val\n                expected = np.array([False, False, False, False, True, True])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 <= val\n                expected = np.array([True, False, True, False, False, False])\n                tm.assert_numpy_array_equal(result, expected)\n                result = idx1 >= val\n                expected = np.array([False, False, True, False, True, True])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 == val\n                expected = np.array([False, False, True, False, False, False])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 != val\n                expected = np.array([True, True, False, True, True, True])\n                tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 488,
        "end_line": 582,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_comparison_tzawareness_compat#588",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_comparison_tzawareness_compat(self, op, box_df_fail)",
        "snippet": "    def test_comparison_tzawareness_compat(self, op, box_df_fail):\n        # GH#18162\n        box = box_df_fail\n\n        dr = pd.date_range(\"2016-01-01\", periods=6)\n        dz = dr.tz_localize(\"US/Pacific\")\n\n        dr = tm.box_expected(dr, box)\n        dz = tm.box_expected(dz, box)\n\n        msg = \"Cannot compare tz-naive and tz-aware\"\n        with pytest.raises(TypeError, match=msg):\n            op(dr, dz)\n\n        # FIXME: DataFrame case fails to raise for == and !=, wrong\n        #  message for inequalities\n        with pytest.raises(TypeError, match=msg):\n            op(dr, list(dz))\n        with pytest.raises(TypeError, match=msg):\n            op(dr, np.array(list(dz), dtype=object))\n        with pytest.raises(TypeError, match=msg):\n            op(dz, dr)\n\n        # FIXME: DataFrame case fails to raise for == and !=, wrong\n        #  message for inequalities\n        with pytest.raises(TypeError, match=msg):\n            op(dz, list(dr))\n        with pytest.raises(TypeError, match=msg):\n            op(dz, np.array(list(dr), dtype=object))\n\n        # Check that there isn't a problem aware-aware and naive-naive do not\n        # raise\n        assert_all(dr == dr)\n        assert_all(dz == dz)\n\n        # FIXME: DataFrame case fails to raise for == and !=, wrong\n        #  message for inequalities\n        assert (dr == list(dr)).all()\n        assert (dz == list(dz)).all()",
        "begin_line": 588,
        "end_line": 626,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_comparison_tzawareness_compat_scalars#632",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_comparison_tzawareness_compat_scalars(self, op, box_with_array)",
        "snippet": "    def test_comparison_tzawareness_compat_scalars(self, op, box_with_array):\n        # GH#18162\n        dr = pd.date_range(\"2016-01-01\", periods=6)\n        dz = dr.tz_localize(\"US/Pacific\")\n\n        dr = tm.box_expected(dr, box_with_array)\n        dz = tm.box_expected(dz, box_with_array)\n\n        # Check comparisons against scalar Timestamps\n        ts = pd.Timestamp(\"2000-03-14 01:59\")\n        ts_tz = pd.Timestamp(\"2000-03-14 01:59\", tz=\"Europe/Amsterdam\")\n\n        assert_all(dr > ts)\n        msg = \"Cannot compare tz-naive and tz-aware\"\n        with pytest.raises(TypeError, match=msg):\n            op(dr, ts_tz)\n\n        assert_all(dz > ts_tz)\n        with pytest.raises(TypeError, match=msg):\n            op(dz, ts)\n\n        # GH#12601: Check comparison against Timestamps and DatetimeIndex\n        with pytest.raises(TypeError, match=msg):\n            op(ts, dz)",
        "begin_line": 632,
        "end_line": 655,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_scalar_comparison_tzawareness#669",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_scalar_comparison_tzawareness(self, op, other, tz_aware_fixture, box_with_array)",
        "snippet": "    def test_scalar_comparison_tzawareness(\n        self, op, other, tz_aware_fixture, box_with_array\n    ):\n        tz = tz_aware_fixture\n        dti = pd.date_range(\"2016-01-01\", periods=2, tz=tz)\n\n        dtarr = tm.box_expected(dti, box_with_array)\n        msg = \"Cannot compare tz-naive and tz-aware\"\n        with pytest.raises(TypeError, match=msg):\n            op(dtarr, other)\n        with pytest.raises(TypeError, match=msg):\n            op(other, dtarr)",
        "begin_line": 669,
        "end_line": 680,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_nat_comparison_tzawareness#686",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_nat_comparison_tzawareness(self, op)",
        "snippet": "    def test_nat_comparison_tzawareness(self, op):\n        # GH#19276\n        # tzaware DatetimeIndex should not raise when compared to NaT\n        dti = pd.DatetimeIndex(\n            [\"2014-01-01\", pd.NaT, \"2014-03-01\", pd.NaT, \"2014-05-01\", \"2014-07-01\"]\n        )\n        expected = np.array([op == operator.ne] * len(dti))\n        result = op(dti, pd.NaT)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = op(dti.tz_localize(\"US/Pacific\"), pd.NaT)\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 686,
        "end_line": 697,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_str#699",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_str(self, tz_naive_fixture)",
        "snippet": "    def test_dti_cmp_str(self, tz_naive_fixture):\n        # GH#22074\n        # regardless of tz, we expect these comparisons are valid\n        tz = tz_naive_fixture\n        rng = date_range(\"1/1/2000\", periods=10, tz=tz)\n        other = \"1/1/2000\"\n\n        result = rng == other\n        expected = np.array([True] + [False] * 9)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = rng != other\n        expected = np.array([False] + [True] * 9)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = rng < other\n        expected = np.array([False] * 10)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = rng <= other\n        expected = np.array([True] + [False] * 9)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = rng > other\n        expected = np.array([False] + [True] * 9)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = rng >= other\n        expected = np.array([True] * 10)\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 699,
        "end_line": 728,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dt64arr_cmp_scalar_invalid#731",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dt64arr_cmp_scalar_invalid(self, other, tz_naive_fixture, box_with_array)",
        "snippet": "    def test_dt64arr_cmp_scalar_invalid(self, other, tz_naive_fixture, box_with_array):\n        # GH#22074\n        tz = tz_naive_fixture\n        xbox = box_with_array if box_with_array is not pd.Index else np.ndarray\n\n        rng = date_range(\"1/1/2000\", periods=10, tz=tz)\n        rng = tm.box_expected(rng, box_with_array)\n\n        result = rng == other\n        expected = np.array([False] * 10)\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(result, expected)\n\n        result = rng != other\n        expected = np.array([True] * 10)\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(result, expected)\n        msg = \"Invalid comparison between\"\n        with pytest.raises(TypeError, match=msg):\n            rng < other\n        with pytest.raises(TypeError, match=msg):\n            rng <= other\n        with pytest.raises(TypeError, match=msg):\n            rng > other\n        with pytest.raises(TypeError, match=msg):\n            rng >= other",
        "begin_line": 731,
        "end_line": 756,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_list#758",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_list(self)",
        "snippet": "    def test_dti_cmp_list(self):\n        rng = date_range(\"1/1/2000\", periods=10)\n\n        result = rng == list(rng)\n        expected = rng == rng\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 758,
        "end_line": 763,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_tdi_tzawareness#774",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_tdi_tzawareness(self, other)",
        "snippet": "    def test_dti_cmp_tdi_tzawareness(self, other):\n        # GH#22074\n        # reversion test that we _don't_ call _assert_tzawareness_compat\n        # when comparing against TimedeltaIndex\n        dti = date_range(\"2000-01-01\", periods=10, tz=\"Asia/Tokyo\")\n\n        result = dti == other\n        expected = np.array([False] * 10)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = dti != other\n        expected = np.array([True] * 10)\n        tm.assert_numpy_array_equal(result, expected)\n        msg = \"Invalid comparison between\"\n        with pytest.raises(TypeError, match=msg):\n            dti < other\n        with pytest.raises(TypeError, match=msg):\n            dti <= other\n        with pytest.raises(TypeError, match=msg):\n            dti > other\n        with pytest.raises(TypeError, match=msg):\n            dti >= other",
        "begin_line": 774,
        "end_line": 795,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_object_dtype#797",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_object_dtype(self)",
        "snippet": "    def test_dti_cmp_object_dtype(self):\n        # GH#22074\n        dti = date_range(\"2000-01-01\", periods=10, tz=\"Asia/Tokyo\")\n\n        other = dti.astype(\"O\")\n\n        result = dti == other\n        expected = np.array([True] * 10)\n        tm.assert_numpy_array_equal(result, expected)\n\n        other = dti.tz_localize(None)\n        msg = \"Cannot compare tz-naive and tz-aware\"\n        with pytest.raises(TypeError, match=msg):\n            # tzawareness failure\n            dti != other\n\n        other = np.array(list(dti[:5]) + [Timedelta(days=1)] * 5)\n        result = dti == other\n        expected = np.array([True] * 5 + [False] * 5)\n        tm.assert_numpy_array_equal(result, expected)\n        msg = \"Cannot compare type\"\n        with pytest.raises(TypeError, match=msg):\n            dti >= other",
        "begin_line": 797,
        "end_line": 819,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_timedeltalike_scalar#833",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_timedeltalike_scalar(self, tz_naive_fixture, two_hours, box_with_array)",
        "snippet": "    def test_dt64arr_add_timedeltalike_scalar(\n        self, tz_naive_fixture, two_hours, box_with_array\n    ):\n        # GH#22005, GH#22163 check DataFrame doesn't raise TypeError\n        tz = tz_naive_fixture\n\n        rng = pd.date_range(\"2000-01-01\", \"2000-02-01\", tz=tz)\n        expected = pd.date_range(\"2000-01-01 02:00\", \"2000-02-01 02:00\", tz=tz)\n\n        rng = tm.box_expected(rng, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = rng + two_hours\n        tm.assert_equal(result, expected)",
        "begin_line": 833,
        "end_line": 846,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_iadd_timedeltalike_scalar#848",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_iadd_timedeltalike_scalar(self, tz_naive_fixture, two_hours, box_with_array)",
        "snippet": "    def test_dt64arr_iadd_timedeltalike_scalar(\n        self, tz_naive_fixture, two_hours, box_with_array\n    ):\n        tz = tz_naive_fixture\n\n        rng = pd.date_range(\"2000-01-01\", \"2000-02-01\", tz=tz)\n        expected = pd.date_range(\"2000-01-01 02:00\", \"2000-02-01 02:00\", tz=tz)\n\n        rng = tm.box_expected(rng, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        rng += two_hours\n        tm.assert_equal(rng, expected)",
        "begin_line": 848,
        "end_line": 860,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_timedeltalike_scalar#862",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_timedeltalike_scalar(self, tz_naive_fixture, two_hours, box_with_array)",
        "snippet": "    def test_dt64arr_sub_timedeltalike_scalar(\n        self, tz_naive_fixture, two_hours, box_with_array\n    ):\n        tz = tz_naive_fixture\n\n        rng = pd.date_range(\"2000-01-01\", \"2000-02-01\", tz=tz)\n        expected = pd.date_range(\"1999-12-31 22:00\", \"2000-01-31 22:00\", tz=tz)\n\n        rng = tm.box_expected(rng, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = rng - two_hours\n        tm.assert_equal(result, expected)",
        "begin_line": 862,
        "end_line": 874,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_isub_timedeltalike_scalar#876",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_isub_timedeltalike_scalar(self, tz_naive_fixture, two_hours, box_with_array)",
        "snippet": "    def test_dt64arr_isub_timedeltalike_scalar(\n        self, tz_naive_fixture, two_hours, box_with_array\n    ):\n        tz = tz_naive_fixture\n\n        rng = pd.date_range(\"2000-01-01\", \"2000-02-01\", tz=tz)\n        expected = pd.date_range(\"1999-12-31 22:00\", \"2000-01-31 22:00\", tz=tz)\n\n        rng = tm.box_expected(rng, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        rng -= two_hours\n        tm.assert_equal(rng, expected)",
        "begin_line": 876,
        "end_line": 888,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_td64_scalar#890",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_td64_scalar(self, box_with_array)",
        "snippet": "    def test_dt64arr_add_td64_scalar(self, box_with_array):\n        # scalar timedeltas/np.timedelta64 objects\n        # operate with np.timedelta64 correctly\n        ser = Series([Timestamp(\"20130101 9:01\"), Timestamp(\"20130101 9:02\")])\n\n        expected = Series(\n            [Timestamp(\"20130101 9:01:01\"), Timestamp(\"20130101 9:02:01\")]\n        )\n\n        dtarr = tm.box_expected(ser, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = dtarr + np.timedelta64(1, \"s\")\n        tm.assert_equal(result, expected)\n        result = np.timedelta64(1, \"s\") + dtarr\n        tm.assert_equal(result, expected)\n\n        expected = Series(\n            [Timestamp(\"20130101 9:01:00.005\"), Timestamp(\"20130101 9:02:00.005\")]\n        )\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = dtarr + np.timedelta64(5, \"ms\")\n        tm.assert_equal(result, expected)\n        result = np.timedelta64(5, \"ms\") + dtarr\n        tm.assert_equal(result, expected)",
        "begin_line": 890,
        "end_line": 915,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_td64_nat#917",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_td64_nat(self, box_with_array, tz_naive_fixture)",
        "snippet": "    def test_dt64arr_add_sub_td64_nat(self, box_with_array, tz_naive_fixture):\n        # GH#23320 special handling for timedelta64(\"NaT\")\n        tz = tz_naive_fixture\n\n        dti = pd.date_range(\"1994-04-01\", periods=9, tz=tz, freq=\"QS\")\n        other = np.timedelta64(\"NaT\")\n        expected = pd.DatetimeIndex([\"NaT\"] * 9, tz=tz)\n\n        # FIXME: fails with transpose=True due to tz-aware DataFrame\n        #  transpose bug\n        obj = tm.box_expected(dti, box_with_array, transpose=False)\n        expected = tm.box_expected(expected, box_with_array, transpose=False)\n\n        result = obj + other\n        tm.assert_equal(result, expected)\n        result = other + obj\n        tm.assert_equal(result, expected)\n        result = obj - other\n        tm.assert_equal(result, expected)\n        msg = \"cannot subtract\"\n        with pytest.raises(TypeError, match=msg):\n            other - obj",
        "begin_line": 917,
        "end_line": 938,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_td64ndarray#940",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_td64ndarray(self, tz_naive_fixture, box_with_array)",
        "snippet": "    def test_dt64arr_add_sub_td64ndarray(self, tz_naive_fixture, box_with_array):\n\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2016-01-01\", periods=3, tz=tz)\n        tdi = pd.TimedeltaIndex([\"-1 Day\", \"-1 Day\", \"-1 Day\"])\n        tdarr = tdi.values\n\n        expected = pd.date_range(\"2015-12-31\", periods=3, tz=tz)\n\n        dtarr = tm.box_expected(dti, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = dtarr + tdarr\n        tm.assert_equal(result, expected)\n        result = tdarr + dtarr\n        tm.assert_equal(result, expected)\n\n        expected = pd.date_range(\"2016-01-02\", periods=3, tz=tz)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = dtarr - tdarr\n        tm.assert_equal(result, expected)\n        msg = \"cannot subtract|bad operand type for unary -\"\n        with pytest.raises(TypeError, match=msg):\n            tdarr - dtarr",
        "begin_line": 940,
        "end_line": 964,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_dtscalar#977",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_dtscalar(self, box_with_array, ts)",
        "snippet": "    def test_dt64arr_sub_dtscalar(self, box_with_array, ts):\n        # GH#8554, GH#22163 DataFrame op should _not_ return dt64 dtype\n        idx = pd.date_range(\"2013-01-01\", periods=3)\n        idx = tm.box_expected(idx, box_with_array)\n\n        expected = pd.TimedeltaIndex([\"0 Days\", \"1 Day\", \"2 Days\"])\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = idx - ts\n        tm.assert_equal(result, expected)",
        "begin_line": 977,
        "end_line": 986,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_datetime64_not_ns#988",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_datetime64_not_ns(self, box_with_array)",
        "snippet": "    def test_dt64arr_sub_datetime64_not_ns(self, box_with_array):\n        # GH#7996, GH#22163 ensure non-nano datetime64 is converted to nano\n        #  for DataFrame operation\n        dt64 = np.datetime64(\"2013-01-01\")\n        assert dt64.dtype == \"datetime64[D]\"\n\n        dti = pd.date_range(\"20130101\", periods=3)\n        dtarr = tm.box_expected(dti, box_with_array)\n\n        expected = pd.TimedeltaIndex([\"0 Days\", \"1 Day\", \"2 Days\"])\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = dtarr - dt64\n        tm.assert_equal(result, expected)\n\n        result = dt64 - dtarr\n        tm.assert_equal(result, -expected)",
        "begin_line": 988,
        "end_line": 1004,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_timestamp#1006",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_timestamp(self, box_with_array)",
        "snippet": "    def test_dt64arr_sub_timestamp(self, box_with_array):\n        ser = pd.date_range(\"2014-03-17\", periods=2, freq=\"D\", tz=\"US/Eastern\")\n        ts = ser[0]\n\n        ser = tm.box_expected(ser, box_with_array)\n\n        delta_series = pd.Series([np.timedelta64(0, \"D\"), np.timedelta64(1, \"D\")])\n        expected = tm.box_expected(delta_series, box_with_array)\n\n        tm.assert_equal(ser - ts, expected)\n        tm.assert_equal(ts - ser, -expected)",
        "begin_line": 1006,
        "end_line": 1016,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_NaT#1018",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_NaT(self, box_with_array)",
        "snippet": "    def test_dt64arr_sub_NaT(self, box_with_array):\n        # GH#18808\n        dti = pd.DatetimeIndex([pd.NaT, pd.Timestamp(\"19900315\")])\n        ser = tm.box_expected(dti, box_with_array)\n\n        result = ser - pd.NaT\n        expected = pd.Series([pd.NaT, pd.NaT], dtype=\"timedelta64[ns]\")\n        expected = tm.box_expected(expected, box_with_array)\n        tm.assert_equal(result, expected)\n\n        dti_tz = dti.tz_localize(\"Asia/Tokyo\")\n        ser_tz = tm.box_expected(dti_tz, box_with_array)\n\n        result = ser_tz - pd.NaT\n        expected = pd.Series([pd.NaT, pd.NaT], dtype=\"timedelta64[ns]\")\n        expected = tm.box_expected(expected, box_with_array)\n        tm.assert_equal(result, expected)",
        "begin_line": 1018,
        "end_line": 1034,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_naive_sub_dt64ndarray#1039",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_naive_sub_dt64ndarray(self, box_with_array)",
        "snippet": "    def test_dt64arr_naive_sub_dt64ndarray(self, box_with_array):\n        dti = pd.date_range(\"2016-01-01\", periods=3, tz=None)\n        dt64vals = dti.values\n\n        dtarr = tm.box_expected(dti, box_with_array)\n\n        expected = dtarr - dtarr\n        result = dtarr - dt64vals\n        tm.assert_equal(result, expected)\n        result = dt64vals - dtarr\n        tm.assert_equal(result, expected)",
        "begin_line": 1039,
        "end_line": 1049,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_aware_sub_dt64ndarray_raises#1051",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_aware_sub_dt64ndarray_raises(self, tz_aware_fixture, box_with_array)",
        "snippet": "    def test_dt64arr_aware_sub_dt64ndarray_raises(\n        self, tz_aware_fixture, box_with_array\n    ):\n\n        tz = tz_aware_fixture\n        dti = pd.date_range(\"2016-01-01\", periods=3, tz=tz)\n        dt64vals = dti.values\n\n        dtarr = tm.box_expected(dti, box_with_array)\n        msg = \"subtraction must have the same timezones or\"\n        with pytest.raises(TypeError, match=msg):\n            dtarr - dt64vals\n        with pytest.raises(TypeError, match=msg):\n            dt64vals - dtarr",
        "begin_line": 1051,
        "end_line": 1064,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_dt64ndarray_raises#1069",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_dt64ndarray_raises(self, tz_naive_fixture, box_with_array)",
        "snippet": "    def test_dt64arr_add_dt64ndarray_raises(self, tz_naive_fixture, box_with_array):\n\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2016-01-01\", periods=3, tz=tz)\n        dt64vals = dti.values\n\n        dtarr = tm.box_expected(dti, box_with_array)\n        msg = \"cannot add\"\n        with pytest.raises(TypeError, match=msg):\n            dtarr + dt64vals\n        with pytest.raises(TypeError, match=msg):\n            dt64vals + dtarr",
        "begin_line": 1069,
        "end_line": 1080,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_timestamp_raises#1082",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_timestamp_raises(self, box_with_array)",
        "snippet": "    def test_dt64arr_add_timestamp_raises(self, box_with_array):\n        # GH#22163 ensure DataFrame doesn't cast Timestamp to i8\n        idx = DatetimeIndex([\"2011-01-01\", \"2011-01-02\"])\n        idx = tm.box_expected(idx, box_with_array)\n        msg = \"cannot add\"\n        with pytest.raises(TypeError, match=msg):\n            idx + Timestamp(\"2011-01-01\")\n        with pytest.raises(TypeError, match=msg):\n            Timestamp(\"2011-01-01\") + idx",
        "begin_line": 1082,
        "end_line": 1090,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_float#1096",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_float(self, other, box_with_array)",
        "snippet": "    def test_dt64arr_add_sub_float(self, other, box_with_array):\n        dti = DatetimeIndex([\"2011-01-01\", \"2011-01-02\"], freq=\"D\")\n        dtarr = tm.box_expected(dti, box_with_array)\n        msg = \"|\".join([\"unsupported operand type\", \"cannot (add|subtract)\"])\n        with pytest.raises(TypeError, match=msg):\n            dtarr + other\n        with pytest.raises(TypeError, match=msg):\n            other + dtarr\n        with pytest.raises(TypeError, match=msg):\n            dtarr - other\n        with pytest.raises(TypeError, match=msg):\n            other - dtarr",
        "begin_line": 1096,
        "end_line": 1107,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_parr#1111",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_parr(self, dti_freq, pi_freq, box_with_array, box_with_array2)",
        "snippet": "    def test_dt64arr_add_sub_parr(\n        self, dti_freq, pi_freq, box_with_array, box_with_array2\n    ):\n        # GH#20049 subtracting PeriodIndex should raise TypeError\n        dti = pd.DatetimeIndex([\"2011-01-01\", \"2011-01-02\"], freq=dti_freq)\n        pi = dti.to_period(pi_freq)\n\n        dtarr = tm.box_expected(dti, box_with_array)\n        parr = tm.box_expected(pi, box_with_array2)\n        msg = \"|\".join(\n            [\n                \"cannot (add|subtract)\",\n                \"unsupported operand\",\n                \"descriptor.*requires\",\n                \"ufunc.*cannot use operands\",\n            ]\n        )\n        with pytest.raises(TypeError, match=msg):\n            dtarr + parr\n        with pytest.raises(TypeError, match=msg):\n            parr + dtarr\n        with pytest.raises(TypeError, match=msg):\n            dtarr - parr\n        with pytest.raises(TypeError, match=msg):\n            parr - dtarr",
        "begin_line": 1111,
        "end_line": 1135,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_period_scalar#1138",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_period_scalar(self, dti_freq, box_with_array)",
        "snippet": "    def test_dt64arr_add_sub_period_scalar(self, dti_freq, box_with_array):\n        # GH#13078\n        # not supported, check TypeError\n        per = pd.Period(\"2011-01-01\", freq=\"D\")\n\n        idx = pd.DatetimeIndex([\"2011-01-01\", \"2011-01-02\"], freq=dti_freq)\n        dtarr = tm.box_expected(idx, box_with_array)\n        msg = \"|\".join([\"unsupported operand type\", \"cannot (add|subtract)\"])\n        with pytest.raises(TypeError, match=msg):\n            dtarr + per\n        with pytest.raises(TypeError, match=msg):\n            per + dtarr\n        with pytest.raises(TypeError, match=msg):\n            dtarr - per\n        with pytest.raises(TypeError, match=msg):\n            per - dtarr",
        "begin_line": 1138,
        "end_line": 1153,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_series_add_tick_DateOffset#1162",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_series_add_tick_DateOffset(self, box_with_array)",
        "snippet": "    def test_dt64arr_series_add_tick_DateOffset(self, box_with_array):\n        # GH#4532\n        # operate with pd.offsets\n        ser = Series([Timestamp(\"20130101 9:01\"), Timestamp(\"20130101 9:02\")])\n        expected = Series(\n            [Timestamp(\"20130101 9:01:05\"), Timestamp(\"20130101 9:02:05\")]\n        )\n\n        ser = tm.box_expected(ser, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = ser + pd.offsets.Second(5)\n        tm.assert_equal(result, expected)\n\n        result2 = pd.offsets.Second(5) + ser\n        tm.assert_equal(result2, expected)",
        "begin_line": 1162,
        "end_line": 1177,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_series_sub_tick_DateOffset#1179",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_series_sub_tick_DateOffset(self, box_with_array)",
        "snippet": "    def test_dt64arr_series_sub_tick_DateOffset(self, box_with_array):\n        # GH#4532\n        # operate with pd.offsets\n        ser = Series([Timestamp(\"20130101 9:01\"), Timestamp(\"20130101 9:02\")])\n        expected = Series(\n            [Timestamp(\"20130101 9:00:55\"), Timestamp(\"20130101 9:01:55\")]\n        )\n\n        ser = tm.box_expected(ser, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = ser - pd.offsets.Second(5)\n        tm.assert_equal(result, expected)\n\n        result2 = -pd.offsets.Second(5) + ser\n        tm.assert_equal(result2, expected)\n        msg = \"bad operand type for unary\"\n        with pytest.raises(TypeError, match=msg):\n            pd.offsets.Second(5) - ser",
        "begin_line": 1179,
        "end_line": 1197,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_tick_DateOffset_smoke#1202",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_tick_DateOffset_smoke(self, cls_name, box_with_array)",
        "snippet": "    def test_dt64arr_add_sub_tick_DateOffset_smoke(self, cls_name, box_with_array):\n        # GH#4532\n        # smoke tests for valid DateOffsets\n        ser = Series([Timestamp(\"20130101 9:01\"), Timestamp(\"20130101 9:02\")])\n        ser = tm.box_expected(ser, box_with_array)\n\n        offset_cls = getattr(pd.offsets, cls_name)\n        ser + offset_cls(5)\n        offset_cls(5) + ser\n        ser - offset_cls(5)",
        "begin_line": 1202,
        "end_line": 1211,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dti_add_tick_tzaware#1213",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dti_add_tick_tzaware(self, tz_aware_fixture, box_with_array)",
        "snippet": "    def test_dti_add_tick_tzaware(self, tz_aware_fixture, box_with_array):\n        # GH#21610, GH#22163 ensure DataFrame doesn't return object-dtype\n        tz = tz_aware_fixture\n        if tz == \"US/Pacific\":\n            dates = date_range(\"2012-11-01\", periods=3, tz=tz)\n            offset = dates + pd.offsets.Hour(5)\n            assert dates[0] + pd.offsets.Hour(5) == offset[0]\n\n        dates = date_range(\"2010-11-01 00:00\", periods=3, tz=tz, freq=\"H\")\n        expected = DatetimeIndex(\n            [\"2010-11-01 05:00\", \"2010-11-01 06:00\", \"2010-11-01 07:00\"],\n            freq=\"H\",\n            tz=tz,\n        )\n\n        dates = tm.box_expected(dates, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        # TODO: parametrize over the scalar being added?  radd?  sub?\n        offset = dates + pd.offsets.Hour(5)\n        tm.assert_equal(offset, expected)\n        offset = dates + np.timedelta64(5, \"h\")\n        tm.assert_equal(offset, expected)\n        offset = dates + timedelta(hours=5)\n        tm.assert_equal(offset, expected)",
        "begin_line": 1213,
        "end_line": 1237,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_relativedelta_offsets#1242",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_relativedelta_offsets(self, box_with_array)",
        "snippet": "    def test_dt64arr_add_sub_relativedelta_offsets(self, box_with_array):\n        # GH#10699\n        vec = DatetimeIndex(\n            [\n                Timestamp(\"2000-01-05 00:15:00\"),\n                Timestamp(\"2000-01-31 00:23:00\"),\n                Timestamp(\"2000-01-01\"),\n                Timestamp(\"2000-03-31\"),\n                Timestamp(\"2000-02-29\"),\n                Timestamp(\"2000-12-31\"),\n                Timestamp(\"2000-05-15\"),\n                Timestamp(\"2001-06-15\"),\n            ]\n        )\n        vec = tm.box_expected(vec, box_with_array)\n        vec_items = vec.squeeze() if box_with_array is pd.DataFrame else vec\n\n        # DateOffset relativedelta fastpath\n        relative_kwargs = [\n            (\"years\", 2),\n            (\"months\", 5),\n            (\"days\", 3),\n            (\"hours\", 5),\n            (\"minutes\", 10),\n            (\"seconds\", 2),\n            (\"microseconds\", 5),\n        ]\n        for i, kwd in enumerate(relative_kwargs):\n            off = pd.DateOffset(**dict([kwd]))\n\n            expected = DatetimeIndex([x + off for x in vec_items])\n            expected = tm.box_expected(expected, box_with_array)\n            tm.assert_equal(expected, vec + off)\n\n            expected = DatetimeIndex([x - off for x in vec_items])\n            expected = tm.box_expected(expected, box_with_array)\n            tm.assert_equal(expected, vec - off)\n\n            off = pd.DateOffset(**dict(relative_kwargs[: i + 1]))\n\n            expected = DatetimeIndex([x + off for x in vec_items])\n            expected = tm.box_expected(expected, box_with_array)\n            tm.assert_equal(expected, vec + off)\n\n            expected = DatetimeIndex([x - off for x in vec_items])\n            expected = tm.box_expected(expected, box_with_array)\n            tm.assert_equal(expected, vec - off)\n            msg = \"bad operand type for unary\"\n            with pytest.raises(TypeError, match=msg):\n                off - vec",
        "begin_line": 1242,
        "end_line": 1291,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_DateOffsets#1346",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_DateOffsets(self, box_with_array, n, normalize, cls_and_kwargs)",
        "snippet": "    def test_dt64arr_add_sub_DateOffsets(\n        self, box_with_array, n, normalize, cls_and_kwargs\n    ):\n        # GH#10699\n        # assert vectorized operation matches pointwise operations\n\n        if isinstance(cls_and_kwargs, tuple):\n            # If cls_name param is a tuple, then 2nd entry is kwargs for\n            # the offset constructor\n            cls_name, kwargs = cls_and_kwargs\n        else:\n            cls_name = cls_and_kwargs\n            kwargs = {}\n\n        if n == 0 and cls_name in [\n            \"WeekOfMonth\",\n            \"LastWeekOfMonth\",\n            \"FY5253Quarter\",\n            \"FY5253\",\n        ]:\n            # passing n = 0 is invalid for these offset classes\n            return\n\n        vec = DatetimeIndex(\n            [\n                Timestamp(\"2000-01-05 00:15:00\"),\n                Timestamp(\"2000-01-31 00:23:00\"),\n                Timestamp(\"2000-01-01\"),\n                Timestamp(\"2000-03-31\"),\n                Timestamp(\"2000-02-29\"),\n                Timestamp(\"2000-12-31\"),\n                Timestamp(\"2000-05-15\"),\n                Timestamp(\"2001-06-15\"),\n            ]\n        )\n        vec = tm.box_expected(vec, box_with_array)\n        vec_items = vec.squeeze() if box_with_array is pd.DataFrame else vec\n\n        offset_cls = getattr(pd.offsets, cls_name)\n\n        with warnings.catch_warnings(record=True):\n            # pandas.errors.PerformanceWarning: Non-vectorized DateOffset being\n            # applied to Series or DatetimeIndex\n            # we aren't testing that here, so ignore.\n            warnings.simplefilter(\"ignore\", PerformanceWarning)\n\n            offset = offset_cls(n, normalize=normalize, **kwargs)\n\n            expected = DatetimeIndex([x + offset for x in vec_items])\n            expected = tm.box_expected(expected, box_with_array)\n            tm.assert_equal(expected, vec + offset)\n\n            expected = DatetimeIndex([x - offset for x in vec_items])\n            expected = tm.box_expected(expected, box_with_array)\n            tm.assert_equal(expected, vec - offset)\n\n            expected = DatetimeIndex([offset + x for x in vec_items])\n            expected = tm.box_expected(expected, box_with_array)\n            tm.assert_equal(expected, offset + vec)\n            msg = \"bad operand type for unary\"\n            with pytest.raises(TypeError, match=msg):\n                offset - vec",
        "begin_line": 1346,
        "end_line": 1407,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_DateOffset#1409",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_DateOffset(self, box_with_array)",
        "snippet": "    def test_dt64arr_add_sub_DateOffset(self, box_with_array):\n        # GH#10699\n        s = date_range(\"2000-01-01\", \"2000-01-31\", name=\"a\")\n        s = tm.box_expected(s, box_with_array)\n        result = s + pd.DateOffset(years=1)\n        result2 = pd.DateOffset(years=1) + s\n        exp = date_range(\"2001-01-01\", \"2001-01-31\", name=\"a\")\n        exp = tm.box_expected(exp, box_with_array)\n        tm.assert_equal(result, exp)\n        tm.assert_equal(result2, exp)\n\n        result = s - pd.DateOffset(years=1)\n        exp = date_range(\"1999-01-01\", \"1999-01-31\", name=\"a\")\n        exp = tm.box_expected(exp, box_with_array)\n        tm.assert_equal(result, exp)\n\n        s = DatetimeIndex(\n            [\n                Timestamp(\"2000-01-15 00:15:00\", tz=\"US/Central\"),\n                Timestamp(\"2000-02-15\", tz=\"US/Central\"),\n            ],\n            name=\"a\",\n        )\n        s = tm.box_expected(s, box_with_array)\n        result = s + pd.offsets.Day()\n        result2 = pd.offsets.Day() + s\n        exp = DatetimeIndex(\n            [\n                Timestamp(\"2000-01-16 00:15:00\", tz=\"US/Central\"),\n                Timestamp(\"2000-02-16\", tz=\"US/Central\"),\n            ],\n            name=\"a\",\n        )\n        exp = tm.box_expected(exp, box_with_array)\n        tm.assert_equal(result, exp)\n        tm.assert_equal(result2, exp)\n\n        s = DatetimeIndex(\n            [\n                Timestamp(\"2000-01-15 00:15:00\", tz=\"US/Central\"),\n                Timestamp(\"2000-02-15\", tz=\"US/Central\"),\n            ],\n            name=\"a\",\n        )\n        s = tm.box_expected(s, box_with_array)\n        result = s + pd.offsets.MonthEnd()\n        result2 = pd.offsets.MonthEnd() + s\n        exp = DatetimeIndex(\n            [\n                Timestamp(\"2000-01-31 00:15:00\", tz=\"US/Central\"),\n                Timestamp(\"2000-02-29\", tz=\"US/Central\"),\n            ],\n            name=\"a\",\n        )\n        exp = tm.box_expected(exp, box_with_array)\n        tm.assert_equal(result, exp)\n        tm.assert_equal(result2, exp)",
        "begin_line": 1409,
        "end_line": 1465,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_mixed_offset_array#1468",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_mixed_offset_array(self, box_with_array)",
        "snippet": "    def test_dt64arr_add_mixed_offset_array(self, box_with_array):\n        # GH#10699\n        # array of offsets\n        s = DatetimeIndex([Timestamp(\"2000-1-1\"), Timestamp(\"2000-2-1\")])\n        s = tm.box_expected(s, box_with_array)\n\n        warn = None if box_with_array is pd.DataFrame else PerformanceWarning\n        with tm.assert_produces_warning(warn, clear=[pd.core.arrays.datetimelike]):\n            other = pd.Index([pd.offsets.DateOffset(years=1), pd.offsets.MonthEnd()])\n            other = tm.box_expected(other, box_with_array)\n            result = s + other\n            exp = DatetimeIndex([Timestamp(\"2001-1-1\"), Timestamp(\"2000-2-29\")])\n            exp = tm.box_expected(exp, box_with_array)\n            tm.assert_equal(result, exp)\n\n            # same offset\n            other = pd.Index(\n                [pd.offsets.DateOffset(years=1), pd.offsets.DateOffset(years=1)]\n            )\n            other = tm.box_expected(other, box_with_array)\n            result = s + other\n            exp = DatetimeIndex([Timestamp(\"2001-1-1\"), Timestamp(\"2001-2-1\")])\n            exp = tm.box_expected(exp, box_with_array)\n            tm.assert_equal(result, exp)",
        "begin_line": 1468,
        "end_line": 1491,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_offset_ndarray#1494",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_offset_ndarray(self, tz_naive_fixture, box_with_array)",
        "snippet": "    def test_dt64arr_add_sub_offset_ndarray(self, tz_naive_fixture, box_with_array):\n        # GH#18849\n\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2017-01-01\", periods=2, tz=tz)\n        dtarr = tm.box_expected(dti, box_with_array)\n\n        other = np.array([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)])\n\n        warn = None if box_with_array is pd.DataFrame else PerformanceWarning\n        with tm.assert_produces_warning(warn, clear=[pd.core.arrays.datetimelike]):\n            res = dtarr + other\n        expected = DatetimeIndex(\n            [dti[n] + other[n] for n in range(len(dti))], name=dti.name, freq=\"infer\"\n        )\n        expected = tm.box_expected(expected, box_with_array)\n        tm.assert_equal(res, expected)\n\n        with tm.assert_produces_warning(warn, clear=[pd.core.arrays.datetimelike]):\n            res2 = other + dtarr\n        tm.assert_equal(res2, expected)\n\n        with tm.assert_produces_warning(warn, clear=[pd.core.arrays.datetimelike]):\n            res = dtarr - other\n        expected = DatetimeIndex(\n            [dti[n] - other[n] for n in range(len(dti))], name=dti.name, freq=\"infer\"\n        )\n        expected = tm.box_expected(expected, box_with_array)\n        tm.assert_equal(res, expected)",
        "begin_line": 1494,
        "end_line": 1522,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dti_add_sub_nonzero_mth_offset#1573",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dti_add_sub_nonzero_mth_offset(self, op, offset, exp, exp_freq, tz_aware_fixture, box_with_array)",
        "snippet": "    def test_dti_add_sub_nonzero_mth_offset(\n        self, op, offset, exp, exp_freq, tz_aware_fixture, box_with_array\n    ):\n        # GH 26258\n        tz = tz_aware_fixture\n        date = date_range(start=\"01 Jan 2014\", end=\"01 Jan 2017\", freq=\"AS\", tz=tz)\n        date = tm.box_expected(date, box_with_array, False)\n        mth = getattr(date, op)\n        result = mth(offset)\n\n        expected = pd.DatetimeIndex(exp, tz=tz, freq=exp_freq)\n        expected = tm.box_expected(expected, box_with_array, False)\n        tm.assert_equal(result, expected)",
        "begin_line": 1573,
        "end_line": 1585,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_dt64_overflow_masking#1591",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_dt64_overflow_masking(self, box_with_array)",
        "snippet": "    def test_dt64_overflow_masking(self, box_with_array):\n        # GH#25317\n        left = Series([Timestamp(\"1969-12-31\")])\n        right = Series([NaT])\n\n        left = tm.box_expected(left, box_with_array)\n        right = tm.box_expected(right, box_with_array)\n\n        expected = TimedeltaIndex([NaT])\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = left - right\n        tm.assert_equal(result, expected)",
        "begin_line": 1591,
        "end_line": 1603,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_dt64_series_arith_overflow#1605",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_dt64_series_arith_overflow(self)",
        "snippet": "    def test_dt64_series_arith_overflow(self):\n        # GH#12534, fixed by GH#19024\n        dt = pd.Timestamp(\"1700-01-31\")\n        td = pd.Timedelta(\"20000 Days\")\n        dti = pd.date_range(\"1949-09-30\", freq=\"100Y\", periods=4)\n        ser = pd.Series(dti)\n        msg = \"Overflow in int64 addition\"\n        with pytest.raises(OverflowError, match=msg):\n            ser - dt\n        with pytest.raises(OverflowError, match=msg):\n            dt - ser\n        with pytest.raises(OverflowError, match=msg):\n            ser + td\n        with pytest.raises(OverflowError, match=msg):\n            td + ser\n\n        ser.iloc[-1] = pd.NaT\n        expected = pd.Series(\n            [\"2004-10-03\", \"2104-10-04\", \"2204-10-04\", \"NaT\"], dtype=\"datetime64[ns]\"\n        )\n        res = ser + td\n        tm.assert_series_equal(res, expected)\n        res = td + ser\n        tm.assert_series_equal(res, expected)\n\n        ser.iloc[1:] = pd.NaT\n        expected = pd.Series(\n            [\"91279 Days\", \"NaT\", \"NaT\", \"NaT\"], dtype=\"timedelta64[ns]\"\n        )\n        res = ser - dt\n        tm.assert_series_equal(res, expected)\n        res = dt - ser\n        tm.assert_series_equal(res, -expected)",
        "begin_line": 1605,
        "end_line": 1637,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_datetimeindex_sub_timestamp_overflow#1639",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_datetimeindex_sub_timestamp_overflow(self)",
        "snippet": "    def test_datetimeindex_sub_timestamp_overflow(self):\n        dtimax = pd.to_datetime([\"now\", pd.Timestamp.max])\n        dtimin = pd.to_datetime([\"now\", pd.Timestamp.min])\n\n        tsneg = Timestamp(\"1950-01-01\")\n        ts_neg_variants = [\n            tsneg,\n            tsneg.to_pydatetime(),\n            tsneg.to_datetime64().astype(\"datetime64[ns]\"),\n            tsneg.to_datetime64().astype(\"datetime64[D]\"),\n        ]\n\n        tspos = Timestamp(\"1980-01-01\")\n        ts_pos_variants = [\n            tspos,\n            tspos.to_pydatetime(),\n            tspos.to_datetime64().astype(\"datetime64[ns]\"),\n            tspos.to_datetime64().astype(\"datetime64[D]\"),\n        ]\n        msg = \"Overflow in int64 addition\"\n        for variant in ts_neg_variants:\n            with pytest.raises(OverflowError, match=msg):\n                dtimax - variant\n\n        expected = pd.Timestamp.max.value - tspos.value\n        for variant in ts_pos_variants:\n            res = dtimax - variant\n            assert res[1].value == expected\n\n        expected = pd.Timestamp.min.value - tsneg.value\n        for variant in ts_neg_variants:\n            res = dtimin - variant\n            assert res[1].value == expected\n\n        for variant in ts_pos_variants:\n            with pytest.raises(OverflowError, match=msg):\n                dtimin - variant",
        "begin_line": 1639,
        "end_line": 1675,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_datetimeindex_sub_datetimeindex_overflow#1677",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_datetimeindex_sub_datetimeindex_overflow(self)",
        "snippet": "    def test_datetimeindex_sub_datetimeindex_overflow(self):\n        # GH#22492, GH#22508\n        dtimax = pd.to_datetime([\"now\", pd.Timestamp.max])\n        dtimin = pd.to_datetime([\"now\", pd.Timestamp.min])\n\n        ts_neg = pd.to_datetime([\"1950-01-01\", \"1950-01-01\"])\n        ts_pos = pd.to_datetime([\"1980-01-01\", \"1980-01-01\"])\n\n        # General tests\n        expected = pd.Timestamp.max.value - ts_pos[1].value\n        result = dtimax - ts_pos\n        assert result[1].value == expected\n\n        expected = pd.Timestamp.min.value - ts_neg[1].value\n        result = dtimin - ts_neg\n        assert result[1].value == expected\n        msg = \"Overflow in int64 addition\"\n        with pytest.raises(OverflowError, match=msg):\n            dtimax - ts_neg\n\n        with pytest.raises(OverflowError, match=msg):\n            dtimin - ts_pos\n\n        # Edge cases\n        tmin = pd.to_datetime([pd.Timestamp.min])\n        t1 = tmin + pd.Timedelta.max + pd.Timedelta(\"1us\")\n        with pytest.raises(OverflowError, match=msg):\n            t1 - tmin\n\n        tmax = pd.to_datetime([pd.Timestamp.max])\n        t2 = tmax + pd.Timedelta.min - pd.Timedelta(\"1us\")\n        with pytest.raises(OverflowError, match=msg):\n            tmax - t2",
        "begin_line": 1677,
        "end_line": 1709,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_empty_series_add_sub#1713",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_empty_series_add_sub(self)",
        "snippet": "    def test_empty_series_add_sub(self):\n        # GH#13844\n        a = Series(dtype=\"M8[ns]\")\n        b = Series(dtype=\"m8[ns]\")\n        tm.assert_series_equal(a, a + b)\n        tm.assert_series_equal(a, a - b)\n        tm.assert_series_equal(a, b + a)\n        msg = \"cannot subtract\"\n        with pytest.raises(TypeError, match=msg):\n            b - a",
        "begin_line": 1713,
        "end_line": 1722,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_operators_datetimelike#1724",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_operators_datetimelike(self)",
        "snippet": "    def test_operators_datetimelike(self):\n\n        # ## timedelta64 ###\n        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)\n        td1.iloc[2] = np.nan\n\n        # ## datetime64 ###\n        dt1 = Series(\n            [\n                pd.Timestamp(\"20111230\"),\n                pd.Timestamp(\"20120101\"),\n                pd.Timestamp(\"20120103\"),\n            ]\n        )\n        dt1.iloc[2] = np.nan\n        dt2 = Series(\n            [\n                pd.Timestamp(\"20111231\"),\n                pd.Timestamp(\"20120102\"),\n                pd.Timestamp(\"20120104\"),\n            ]\n        )\n        dt1 - dt2\n        dt2 - dt1\n\n        # ## datetime64 with timetimedelta ###\n        dt1 + td1\n        td1 + dt1\n        dt1 - td1\n        # TODO: Decide if this ought to work.\n        # td1 - dt1\n\n        # ## timetimedelta with datetime64 ###\n        td1 + dt1\n        dt1 + td1",
        "begin_line": 1724,
        "end_line": 1758,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64ser_sub_datetime_dtype#1760",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64ser_sub_datetime_dtype(self)",
        "snippet": "    def test_dt64ser_sub_datetime_dtype(self):\n        ts = Timestamp(datetime(1993, 1, 7, 13, 30, 00))\n        dt = datetime(1993, 6, 22, 13, 30)\n        ser = Series([ts])\n        result = pd.to_timedelta(np.abs(ser - dt))\n        assert result.dtype == \"timedelta64[ns]\"",
        "begin_line": 1760,
        "end_line": 1765,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_operators_datetimelike_invalid#1771",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_operators_datetimelike_invalid(self, all_arithmetic_operators)",
        "snippet": "    def test_operators_datetimelike_invalid(self, all_arithmetic_operators):\n        # these are all TypeEror ops\n        op_str = all_arithmetic_operators\n\n        def check(get_ser, test_ser):\n\n            # check that we are getting a TypeError\n            # with 'operate' (from core/ops.py) for the ops that are not\n            # defined\n            op = getattr(get_ser, op_str, None)\n            # Previously, _validate_for_numeric_binop in core/indexes/base.py\n            # did this for us.\n            with pytest.raises(\n                TypeError, match=\"operate|[cC]annot|unsupported operand\"\n            ):\n                op(test_ser)\n\n        # ## timedelta64 ###\n        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)\n        td1.iloc[2] = np.nan\n\n        # ## datetime64 ###\n        dt1 = Series(\n            [Timestamp(\"20111230\"), Timestamp(\"20120101\"), Timestamp(\"20120103\")]\n        )\n        dt1.iloc[2] = np.nan\n        dt2 = Series(\n            [Timestamp(\"20111231\"), Timestamp(\"20120102\"), Timestamp(\"20120104\")]\n        )\n        if op_str not in [\"__sub__\", \"__rsub__\"]:\n            check(dt1, dt2)\n\n        # ## datetime64 with timetimedelta ###\n        # TODO(jreback) __rsub__ should raise?\n        if op_str not in [\"__add__\", \"__radd__\", \"__sub__\"]:\n            check(dt1, td1)\n\n        # 8260, 10763\n        # datetime64 with tz\n        tz = \"US/Eastern\"\n        dt1 = Series(date_range(\"2000-01-01 09:00:00\", periods=5, tz=tz), name=\"foo\")\n        dt2 = dt1.copy()\n        dt2.iloc[2] = np.nan\n        td1 = Series(pd.timedelta_range(\"1 days 1 min\", periods=5, freq=\"H\"))\n        td2 = td1.copy()\n        td2.iloc[1] = np.nan\n\n        if op_str not in [\"__add__\", \"__radd__\", \"__sub__\", \"__rsub__\"]:\n            check(dt2, td2)",
        "begin_line": 1771,
        "end_line": 1819,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.check#1775",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.check(get_ser, test_ser)",
        "snippet": "        def check(get_ser, test_ser):\n\n            # check that we are getting a TypeError\n            # with 'operate' (from core/ops.py) for the ops that are not\n            # defined\n            op = getattr(get_ser, op_str, None)\n            # Previously, _validate_for_numeric_binop in core/indexes/base.py\n            # did this for us.\n            with pytest.raises(\n                TypeError, match=\"operate|[cC]annot|unsupported operand\"\n            ):\n                op(test_ser)",
        "begin_line": 1775,
        "end_line": 1786,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_sub_single_tz#1821",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_sub_single_tz(self)",
        "snippet": "    def test_sub_single_tz(self):\n        # GH#12290\n        s1 = Series([pd.Timestamp(\"2016-02-10\", tz=\"America/Sao_Paulo\")])\n        s2 = Series([pd.Timestamp(\"2016-02-08\", tz=\"America/Sao_Paulo\")])\n        result = s1 - s2\n        expected = Series([Timedelta(\"2days\")])\n        tm.assert_series_equal(result, expected)\n        result = s2 - s1\n        expected = Series([Timedelta(\"-2days\")])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1821,
        "end_line": 1830,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64tz_series_sub_dtitz#1832",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64tz_series_sub_dtitz(self)",
        "snippet": "    def test_dt64tz_series_sub_dtitz(self):\n        # GH#19071 subtracting tzaware DatetimeIndex from tzaware Series\n        # (with same tz) raises, fixed by #19024\n        dti = pd.date_range(\"1999-09-30\", periods=10, tz=\"US/Pacific\")\n        ser = pd.Series(dti)\n        expected = pd.Series(pd.TimedeltaIndex([\"0days\"] * 10))\n\n        res = dti - ser\n        tm.assert_series_equal(res, expected)\n        res = ser - dti\n        tm.assert_series_equal(res, expected)",
        "begin_line": 1832,
        "end_line": 1842,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_sub_datetime_compat#1844",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_sub_datetime_compat(self)",
        "snippet": "    def test_sub_datetime_compat(self):\n        # see GH#14088\n        s = Series([datetime(2016, 8, 23, 12, tzinfo=pytz.utc), pd.NaT])\n        dt = datetime(2016, 8, 22, 12, tzinfo=pytz.utc)\n        exp = Series([Timedelta(\"1 days\"), pd.NaT])\n        tm.assert_series_equal(s - dt, exp)\n        tm.assert_series_equal(s - Timestamp(dt), exp)",
        "begin_line": 1844,
        "end_line": 1850,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64_series_add_mixed_tick_DateOffset#1852",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64_series_add_mixed_tick_DateOffset(self)",
        "snippet": "    def test_dt64_series_add_mixed_tick_DateOffset(self):\n        # GH#4532\n        # operate with pd.offsets\n        s = Series([Timestamp(\"20130101 9:01\"), Timestamp(\"20130101 9:02\")])\n\n        result = s + pd.offsets.Milli(5)\n        result2 = pd.offsets.Milli(5) + s\n        expected = Series(\n            [Timestamp(\"20130101 9:01:00.005\"), Timestamp(\"20130101 9:02:00.005\")]\n        )\n        tm.assert_series_equal(result, expected)\n        tm.assert_series_equal(result2, expected)\n\n        result = s + pd.offsets.Minute(5) + pd.offsets.Milli(5)\n        expected = Series(\n            [Timestamp(\"20130101 9:06:00.005\"), Timestamp(\"20130101 9:07:00.005\")]\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1852,
        "end_line": 1869,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_datetime64_ops_nat#1871",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_datetime64_ops_nat(self)",
        "snippet": "    def test_datetime64_ops_nat(self):\n        # GH#11349\n        datetime_series = Series([NaT, Timestamp(\"19900315\")])\n        nat_series_dtype_timestamp = Series([NaT, NaT], dtype=\"datetime64[ns]\")\n        single_nat_dtype_datetime = Series([NaT], dtype=\"datetime64[ns]\")\n\n        # subtraction\n        tm.assert_series_equal(-NaT + datetime_series, nat_series_dtype_timestamp)\n        msg = \"Unary negative expects\"\n        with pytest.raises(TypeError, match=msg):\n            -single_nat_dtype_datetime + datetime_series\n\n        tm.assert_series_equal(\n            -NaT + nat_series_dtype_timestamp, nat_series_dtype_timestamp\n        )\n        with pytest.raises(TypeError, match=msg):\n            -single_nat_dtype_datetime + nat_series_dtype_timestamp\n\n        # addition\n        tm.assert_series_equal(\n            nat_series_dtype_timestamp + NaT, nat_series_dtype_timestamp\n        )\n        tm.assert_series_equal(\n            NaT + nat_series_dtype_timestamp, nat_series_dtype_timestamp\n        )\n\n        tm.assert_series_equal(\n            nat_series_dtype_timestamp + NaT, nat_series_dtype_timestamp\n        )\n        tm.assert_series_equal(\n            NaT + nat_series_dtype_timestamp, nat_series_dtype_timestamp\n        )",
        "begin_line": 1871,
        "end_line": 1902,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64_mul_div_numeric_invalid#1917",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64_mul_div_numeric_invalid(self, one, dt64_series)",
        "snippet": "    def test_dt64_mul_div_numeric_invalid(self, one, dt64_series):\n        # multiplication\n        msg = \"cannot perform .* with this index type\"\n        with pytest.raises(TypeError, match=msg):\n            dt64_series * one\n        with pytest.raises(TypeError, match=msg):\n            one * dt64_series\n\n        # division\n        with pytest.raises(TypeError, match=msg):\n            dt64_series / one\n        with pytest.raises(TypeError, match=msg):\n            one / dt64_series",
        "begin_line": 1917,
        "end_line": 1929,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64_series_add_intlike#1933",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64_series_add_intlike(self, tz, op)",
        "snippet": "    def test_dt64_series_add_intlike(self, tz, op):\n        # GH#19123\n        dti = pd.DatetimeIndex([\"2016-01-02\", \"2016-02-03\", \"NaT\"], tz=tz)\n        ser = Series(dti)\n\n        other = Series([20, 30, 40], dtype=\"uint8\")\n\n        method = getattr(ser, op)\n        msg = \"|\".join(\n            [\n                \"incompatible type for a .* operation\",\n                \"cannot evaluate a numeric op\",\n                \"ufunc .* cannot use operands\",\n                \"cannot (add|subtract)\",\n            ]\n        )\n        with pytest.raises(TypeError, match=msg):\n            method(1)\n        with pytest.raises(TypeError, match=msg):\n            method(other)\n        with pytest.raises(TypeError, match=msg):\n            method(other.values)\n        with pytest.raises(TypeError, match=msg):\n            method(pd.Index(other))",
        "begin_line": 1933,
        "end_line": 1956,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_operators_datetimelike_with_timezones#1961",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_operators_datetimelike_with_timezones(self)",
        "snippet": "    def test_operators_datetimelike_with_timezones(self):\n        tz = \"US/Eastern\"\n        dt1 = Series(date_range(\"2000-01-01 09:00:00\", periods=5, tz=tz), name=\"foo\")\n        dt2 = dt1.copy()\n        dt2.iloc[2] = np.nan\n\n        td1 = Series(pd.timedelta_range(\"1 days 1 min\", periods=5, freq=\"H\"))\n        td2 = td1.copy()\n        td2.iloc[1] = np.nan\n\n        result = dt1 + td1[0]\n        exp = (dt1.dt.tz_localize(None) + td1[0]).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n\n        result = dt2 + td2[0]\n        exp = (dt2.dt.tz_localize(None) + td2[0]).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n\n        # odd numpy behavior with scalar timedeltas\n        result = td1[0] + dt1\n        exp = (dt1.dt.tz_localize(None) + td1[0]).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n\n        result = td2[0] + dt2\n        exp = (dt2.dt.tz_localize(None) + td2[0]).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n\n        result = dt1 - td1[0]\n        exp = (dt1.dt.tz_localize(None) - td1[0]).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n        msg = \"bad operand type for unary\"\n        with pytest.raises(TypeError, match=msg):\n            td1[0] - dt1\n\n        result = dt2 - td2[0]\n        exp = (dt2.dt.tz_localize(None) - td2[0]).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n        with pytest.raises(TypeError, match=msg):\n            td2[0] - dt2\n\n        result = dt1 + td1\n        exp = (dt1.dt.tz_localize(None) + td1).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n\n        result = dt2 + td2\n        exp = (dt2.dt.tz_localize(None) + td2).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n\n        result = dt1 - td1\n        exp = (dt1.dt.tz_localize(None) - td1).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n\n        result = dt2 - td2\n        exp = (dt2.dt.tz_localize(None) - td2).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n        msg = \"cannot (add|subtract)\"\n        with pytest.raises(TypeError, match=msg):\n            td1 - dt1\n        with pytest.raises(TypeError, match=msg):\n            td2 - dt2",
        "begin_line": 1961,
        "end_line": 2020,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_int#2028",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_int(self, tz_naive_fixture, one)",
        "snippet": "    def test_dti_add_int(self, tz_naive_fixture, one):\n        # Variants of `one` for #19012\n        tz = tz_naive_fixture\n        rng = pd.date_range(\"2000-01-01 09:00\", freq=\"H\", periods=10, tz=tz)\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            result = rng + one\n        expected = pd.date_range(\"2000-01-01 10:00\", freq=\"H\", periods=10, tz=tz)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2028,
        "end_line": 2035,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_iadd_int#2037",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_iadd_int(self, tz_naive_fixture, one)",
        "snippet": "    def test_dti_iadd_int(self, tz_naive_fixture, one):\n        tz = tz_naive_fixture\n        rng = pd.date_range(\"2000-01-01 09:00\", freq=\"H\", periods=10, tz=tz)\n        expected = pd.date_range(\"2000-01-01 10:00\", freq=\"H\", periods=10, tz=tz)\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            rng += one\n        tm.assert_index_equal(rng, expected)",
        "begin_line": 2037,
        "end_line": 2043,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_sub_int#2045",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_sub_int(self, tz_naive_fixture, one)",
        "snippet": "    def test_dti_sub_int(self, tz_naive_fixture, one):\n        tz = tz_naive_fixture\n        rng = pd.date_range(\"2000-01-01 09:00\", freq=\"H\", periods=10, tz=tz)\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            result = rng - one\n        expected = pd.date_range(\"2000-01-01 08:00\", freq=\"H\", periods=10, tz=tz)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2045,
        "end_line": 2051,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_isub_int#2053",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_isub_int(self, tz_naive_fixture, one)",
        "snippet": "    def test_dti_isub_int(self, tz_naive_fixture, one):\n        tz = tz_naive_fixture\n        rng = pd.date_range(\"2000-01-01 09:00\", freq=\"H\", periods=10, tz=tz)\n        expected = pd.date_range(\"2000-01-01 08:00\", freq=\"H\", periods=10, tz=tz)\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            rng -= one\n        tm.assert_index_equal(rng, expected)",
        "begin_line": 2053,
        "end_line": 2059,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_intarray_tick#2066",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_intarray_tick(self, int_holder, freq)",
        "snippet": "    def test_dti_add_intarray_tick(self, int_holder, freq):\n        # GH#19959\n        dti = pd.date_range(\"2016-01-01\", periods=2, freq=freq)\n        other = int_holder([4, -1])\n\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            expected = DatetimeIndex([dti[n] + other[n] for n in range(len(dti))])\n            result = dti + other\n        tm.assert_index_equal(result, expected)\n\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            result = other + dti\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2066,
        "end_line": 2078,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_intarray_non_tick#2082",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_intarray_non_tick(self, int_holder, freq)",
        "snippet": "    def test_dti_add_intarray_non_tick(self, int_holder, freq):\n        # GH#19959\n        dti = pd.date_range(\"2016-01-01\", periods=2, freq=freq)\n        other = int_holder([4, -1])\n\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            expected = DatetimeIndex([dti[n] + other[n] for n in range(len(dti))])\n\n        # tm.assert_produces_warning does not handle cases where we expect\n        # two warnings, in this case PerformanceWarning and FutureWarning.\n        # Until that is fixed, we don't catch either\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            result = dti + other\n        tm.assert_index_equal(result, expected)\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            result = other + dti\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2082,
        "end_line": 2101,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_intarray_no_freq#2104",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_intarray_no_freq(self, int_holder)",
        "snippet": "    def test_dti_add_intarray_no_freq(self, int_holder):\n        # GH#19959\n        dti = pd.DatetimeIndex([\"2016-01-01\", \"NaT\", \"2017-04-05 06:07:08\"])\n        other = int_holder([9, 4, -1])\n        nfmsg = \"Cannot shift with no freq\"\n        tmsg = \"cannot subtract DatetimeArray from\"\n        with pytest.raises(NullFrequencyError, match=nfmsg):\n            dti + other\n        with pytest.raises(NullFrequencyError, match=nfmsg):\n            other + dti\n        with pytest.raises(NullFrequencyError, match=nfmsg):\n            dti - other\n        with pytest.raises(TypeError, match=tmsg):\n            other - dti",
        "begin_line": 2104,
        "end_line": 2117,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_tdi#2122",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_tdi(self, tz_naive_fixture)",
        "snippet": "    def test_dti_add_tdi(self, tz_naive_fixture):\n        # GH#17558\n        tz = tz_naive_fixture\n        dti = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        tdi = pd.timedelta_range(\"0 days\", periods=10)\n        expected = pd.date_range(\"2017-01-01\", periods=10, tz=tz)\n\n        # add with TimdeltaIndex\n        result = dti + tdi\n        tm.assert_index_equal(result, expected)\n\n        result = tdi + dti\n        tm.assert_index_equal(result, expected)\n\n        # add with timedelta64 array\n        result = dti + tdi.values\n        tm.assert_index_equal(result, expected)\n\n        result = tdi.values + dti\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2122,
        "end_line": 2141,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_iadd_tdi#2143",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_iadd_tdi(self, tz_naive_fixture)",
        "snippet": "    def test_dti_iadd_tdi(self, tz_naive_fixture):\n        # GH#17558\n        tz = tz_naive_fixture\n        dti = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        tdi = pd.timedelta_range(\"0 days\", periods=10)\n        expected = pd.date_range(\"2017-01-01\", periods=10, tz=tz)\n\n        # iadd with TimdeltaIndex\n        result = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        result += tdi\n        tm.assert_index_equal(result, expected)\n\n        result = pd.timedelta_range(\"0 days\", periods=10)\n        result += dti\n        tm.assert_index_equal(result, expected)\n\n        # iadd with timedelta64 array\n        result = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        result += tdi.values\n        tm.assert_index_equal(result, expected)\n\n        result = pd.timedelta_range(\"0 days\", periods=10)\n        result += dti\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2143,
        "end_line": 2166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_sub_tdi#2168",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_sub_tdi(self, tz_naive_fixture)",
        "snippet": "    def test_dti_sub_tdi(self, tz_naive_fixture):\n        # GH#17558\n        tz = tz_naive_fixture\n        dti = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        tdi = pd.timedelta_range(\"0 days\", periods=10)\n        expected = pd.date_range(\"2017-01-01\", periods=10, tz=tz, freq=\"-1D\")\n\n        # sub with TimedeltaIndex\n        result = dti - tdi\n        tm.assert_index_equal(result, expected)\n\n        msg = \"cannot subtract .*TimedeltaArray\"\n        with pytest.raises(TypeError, match=msg):\n            tdi - dti\n\n        # sub with timedelta64 array\n        result = dti - tdi.values\n        tm.assert_index_equal(result, expected)\n\n        msg = \"cannot subtract DatetimeArray from\"\n        with pytest.raises(TypeError, match=msg):\n            tdi.values - dti",
        "begin_line": 2168,
        "end_line": 2189,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_isub_tdi#2191",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_isub_tdi(self, tz_naive_fixture)",
        "snippet": "    def test_dti_isub_tdi(self, tz_naive_fixture):\n        # GH#17558\n        tz = tz_naive_fixture\n        dti = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        tdi = pd.timedelta_range(\"0 days\", periods=10)\n        expected = pd.date_range(\"2017-01-01\", periods=10, tz=tz, freq=\"-1D\")\n\n        # isub with TimedeltaIndex\n        result = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        result -= tdi\n        tm.assert_index_equal(result, expected)\n\n        msg = \"cannot subtract .* from a TimedeltaArray\"\n        with pytest.raises(TypeError, match=msg):\n            tdi -= dti\n\n        # isub with timedelta64 array\n        result = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        result -= tdi.values\n        tm.assert_index_equal(result, expected)\n\n        msg = \"|\".join(\n            [\n                \"cannot perform __neg__ with this index type:\",\n                \"ufunc subtract cannot use operands with types\",\n                \"cannot subtract DatetimeArray from\",\n            ]\n        )\n        with pytest.raises(TypeError, match=msg):\n            tdi.values -= dti",
        "begin_line": 2191,
        "end_line": 2220,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_add_datetimelike_and_dti#2239",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_add_datetimelike_and_dti(self, addend, tz)",
        "snippet": "    def test_add_datetimelike_and_dti(self, addend, tz):\n        # GH#9631\n        dti = DatetimeIndex([\"2011-01-01\", \"2011-01-02\"]).tz_localize(tz)\n        msg = (\n            \"cannot add DatetimeArray and {0}\".format(type(addend).__name__)\n        ).replace(\"DatetimeIndex\", \"DatetimeArray\")\n        with pytest.raises(TypeError, match=msg):\n            dti + addend\n        with pytest.raises(TypeError, match=msg):\n            addend + dti",
        "begin_line": 2239,
        "end_line": 2248,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dta_add_sub_index#2252",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dta_add_sub_index(self, tz_naive_fixture)",
        "snippet": "    def test_dta_add_sub_index(self, tz_naive_fixture):\n        # Check that DatetimeArray defers to Index classes\n        dti = date_range(\"20130101\", periods=3, tz=tz_naive_fixture)\n        dta = dti.array\n        result = dta - dti\n        expected = dti - dti\n        tm.assert_index_equal(result, expected)\n\n        tdi = result\n        result = dta + tdi\n        expected = dti + tdi\n        tm.assert_index_equal(result, expected)\n\n        result = dta - tdi\n        expected = dti - tdi\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2252,
        "end_line": 2267,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_sub_dti_dti#2269",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_sub_dti_dti(self)",
        "snippet": "    def test_sub_dti_dti(self):\n        # previously performed setop (deprecated in 0.16.0), now changed to\n        # return subtraction -> TimeDeltaIndex (GH ...)\n\n        dti = date_range(\"20130101\", periods=3)\n        dti_tz = date_range(\"20130101\", periods=3).tz_localize(\"US/Eastern\")\n        dti_tz2 = date_range(\"20130101\", periods=3).tz_localize(\"UTC\")\n        expected = TimedeltaIndex([0, 0, 0])\n\n        result = dti - dti\n        tm.assert_index_equal(result, expected)\n\n        result = dti_tz - dti_tz\n        tm.assert_index_equal(result, expected)\n        msg = \"DatetimeArray subtraction must have the same timezones or\"\n        with pytest.raises(TypeError, match=msg):\n            dti_tz - dti\n\n        with pytest.raises(TypeError, match=msg):\n            dti - dti_tz\n\n        with pytest.raises(TypeError, match=msg):\n            dti_tz - dti_tz2\n\n        # isub\n        dti -= dti\n        tm.assert_index_equal(dti, expected)\n\n        # different length raises ValueError\n        dti1 = date_range(\"20130101\", periods=3)\n        dti2 = date_range(\"20130101\", periods=4)\n        msg = \"cannot add indices of unequal length\"\n        with pytest.raises(ValueError, match=msg):\n            dti1 - dti2\n\n        # NaN propagation\n        dti1 = DatetimeIndex([\"2012-01-01\", np.nan, \"2012-01-03\"])\n        dti2 = DatetimeIndex([\"2012-01-02\", \"2012-01-03\", np.nan])\n        expected = TimedeltaIndex([\"1 days\", np.nan, np.nan])\n        result = dti2 - dti1\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2269,
        "end_line": 2309,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_timedelta64_equal_timedelta_supported_ops#2316",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_timedelta64_equal_timedelta_supported_ops(self, op)",
        "snippet": "    def test_timedelta64_equal_timedelta_supported_ops(self, op):\n        ser = Series(\n            [\n                Timestamp(\"20130301\"),\n                Timestamp(\"20130228 23:00:00\"),\n                Timestamp(\"20130228 22:00:00\"),\n                Timestamp(\"20130228 21:00:00\"),\n            ]\n        )\n\n        intervals = [\"D\", \"h\", \"m\", \"s\", \"us\"]\n\n        # TODO: unused\n        # npy16_mappings = {'D': 24 * 60 * 60 * 1000000,\n        #                   'h': 60 * 60 * 1000000,\n        #                   'm': 60 * 1000000,\n        #                   's': 1000000,\n        #                   'us': 1}\n\n        def timedelta64(*args):\n            # see casting notes in NumPy gh-12927\n            return np.sum(list(starmap(np.timedelta64, zip(args, intervals))))\n\n        for d, h, m, s, us in product(*([range(2)] * 5)):\n            nptd = timedelta64(d, h, m, s, us)\n            pytd = timedelta(days=d, hours=h, minutes=m, seconds=s, microseconds=us)\n            lhs = op(ser, nptd)\n            rhs = op(ser, pytd)\n\n            tm.assert_series_equal(lhs, rhs)",
        "begin_line": 2316,
        "end_line": 2345,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.timedelta64#2335",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.timedelta64(*args)",
        "snippet": "        def timedelta64(*args):\n            # see casting notes in NumPy gh-12927\n            return np.sum(list(starmap(np.timedelta64, zip(args, intervals))))",
        "begin_line": 2335,
        "end_line": 2337,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_ops_nat_mixed_datetime64_timedelta64#2347",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_ops_nat_mixed_datetime64_timedelta64(self)",
        "snippet": "    def test_ops_nat_mixed_datetime64_timedelta64(self):\n        # GH#11349\n        timedelta_series = Series([NaT, Timedelta(\"1s\")])\n        datetime_series = Series([NaT, Timestamp(\"19900315\")])\n        nat_series_dtype_timedelta = Series([NaT, NaT], dtype=\"timedelta64[ns]\")\n        nat_series_dtype_timestamp = Series([NaT, NaT], dtype=\"datetime64[ns]\")\n        single_nat_dtype_datetime = Series([NaT], dtype=\"datetime64[ns]\")\n        single_nat_dtype_timedelta = Series([NaT], dtype=\"timedelta64[ns]\")\n\n        # subtraction\n        tm.assert_series_equal(\n            datetime_series - single_nat_dtype_datetime, nat_series_dtype_timedelta\n        )\n\n        tm.assert_series_equal(\n            datetime_series - single_nat_dtype_timedelta, nat_series_dtype_timestamp\n        )\n        tm.assert_series_equal(\n            -single_nat_dtype_timedelta + datetime_series, nat_series_dtype_timestamp\n        )\n\n        # without a Series wrapping the NaT, it is ambiguous\n        # whether it is a datetime64 or timedelta64\n        # defaults to interpreting it as timedelta64\n        tm.assert_series_equal(\n            nat_series_dtype_timestamp - single_nat_dtype_datetime,\n            nat_series_dtype_timedelta,\n        )\n\n        tm.assert_series_equal(\n            nat_series_dtype_timestamp - single_nat_dtype_timedelta,\n            nat_series_dtype_timestamp,\n        )\n        tm.assert_series_equal(\n            -single_nat_dtype_timedelta + nat_series_dtype_timestamp,\n            nat_series_dtype_timestamp,\n        )\n        msg = \"cannot subtract a datelike\"\n        with pytest.raises(TypeError, match=msg):\n            timedelta_series - single_nat_dtype_datetime\n\n        # addition\n        tm.assert_series_equal(\n            nat_series_dtype_timestamp + single_nat_dtype_timedelta,\n            nat_series_dtype_timestamp,\n        )\n        tm.assert_series_equal(\n            single_nat_dtype_timedelta + nat_series_dtype_timestamp,\n            nat_series_dtype_timestamp,\n        )\n\n        tm.assert_series_equal(\n            nat_series_dtype_timestamp + single_nat_dtype_timedelta,\n            nat_series_dtype_timestamp,\n        )\n        tm.assert_series_equal(\n            single_nat_dtype_timedelta + nat_series_dtype_timestamp,\n            nat_series_dtype_timestamp,\n        )\n\n        tm.assert_series_equal(\n            nat_series_dtype_timedelta + single_nat_dtype_datetime,\n            nat_series_dtype_timestamp,\n        )\n        tm.assert_series_equal(\n            single_nat_dtype_datetime + nat_series_dtype_timedelta,\n            nat_series_dtype_timestamp,\n        )",
        "begin_line": 2347,
        "end_line": 2414,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_ufunc_coercions#2416",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_ufunc_coercions(self)",
        "snippet": "    def test_ufunc_coercions(self):\n        idx = date_range(\"2011-01-01\", periods=3, freq=\"2D\", name=\"x\")\n\n        delta = np.timedelta64(1, \"D\")\n        for result in [idx + delta, np.add(idx, delta)]:\n            assert isinstance(result, DatetimeIndex)\n            exp = date_range(\"2011-01-02\", periods=3, freq=\"2D\", name=\"x\")\n            tm.assert_index_equal(result, exp)\n            assert result.freq == \"2D\"\n\n        for result in [idx - delta, np.subtract(idx, delta)]:\n            assert isinstance(result, DatetimeIndex)\n            exp = date_range(\"2010-12-31\", periods=3, freq=\"2D\", name=\"x\")\n            tm.assert_index_equal(result, exp)\n            assert result.freq == \"2D\"\n\n        delta = np.array(\n            [np.timedelta64(1, \"D\"), np.timedelta64(2, \"D\"), np.timedelta64(3, \"D\")]\n        )\n        for result in [idx + delta, np.add(idx, delta)]:\n            assert isinstance(result, DatetimeIndex)\n            exp = DatetimeIndex(\n                [\"2011-01-02\", \"2011-01-05\", \"2011-01-08\"], freq=\"3D\", name=\"x\"\n            )\n            tm.assert_index_equal(result, exp)\n            assert result.freq == \"3D\"\n\n        for result in [idx - delta, np.subtract(idx, delta)]:\n            assert isinstance(result, DatetimeIndex)\n            exp = DatetimeIndex(\n                [\"2010-12-31\", \"2011-01-01\", \"2011-01-02\"], freq=\"D\", name=\"x\"\n            )\n            tm.assert_index_equal(result, exp)\n            assert result.freq == \"D\"",
        "begin_line": 2416,
        "end_line": 2449,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_series#2455",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_series(self, tz, names)",
        "snippet": "    def test_dti_add_series(self, tz, names):\n        # GH#13905\n        index = DatetimeIndex(\n            [\"2016-06-28 05:30\", \"2016-06-28 05:31\"], tz=tz, name=names[0]\n        )\n        ser = Series([Timedelta(seconds=5)] * 2, index=index, name=names[1])\n        expected = Series(index + Timedelta(seconds=5), index=index, name=names[2])\n\n        # passing name arg isn't enough when names[2] is None\n        expected.name = names[2]\n        assert expected.dtype == index.dtype\n        result = ser + index\n        tm.assert_series_equal(result, expected)\n        result2 = index + ser\n        tm.assert_series_equal(result2, expected)\n\n        expected = index + Timedelta(seconds=5)\n        result3 = ser.values + index\n        tm.assert_index_equal(result3, expected)\n        result4 = index + ser.values\n        tm.assert_index_equal(result4, expected)",
        "begin_line": 2455,
        "end_line": 2475,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_offset_index#2480",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_offset_index(self, tz_naive_fixture, names)",
        "snippet": "    def test_dti_add_offset_index(self, tz_naive_fixture, names):\n        # GH#18849, GH#19744\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2017-01-01\", periods=2, tz=tz, name=names[0])\n        other = pd.Index([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)], name=names[1])\n\n        with tm.assert_produces_warning(\n            PerformanceWarning, clear=[pd.core.arrays.datetimelike]\n        ):\n            res = dti + other\n        expected = DatetimeIndex(\n            [dti[n] + other[n] for n in range(len(dti))], name=names[2], freq=\"infer\"\n        )\n        tm.assert_index_equal(res, expected)\n\n        with tm.assert_produces_warning(\n            PerformanceWarning, clear=[pd.core.arrays.datetimelike]\n        ):\n            res2 = other + dti\n        tm.assert_index_equal(res2, expected)",
        "begin_line": 2480,
        "end_line": 2499,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_sub_offset_index#2504",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_sub_offset_index(self, tz_naive_fixture, names)",
        "snippet": "    def test_dti_sub_offset_index(self, tz_naive_fixture, names):\n        # GH#18824, GH#19744\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2017-01-01\", periods=2, tz=tz, name=names[0])\n        other = pd.Index([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)], name=names[1])\n\n        with tm.assert_produces_warning(\n            PerformanceWarning, clear=[pd.core.arrays.datetimelike]\n        ):\n            res = dti - other\n        expected = DatetimeIndex(\n            [dti[n] - other[n] for n in range(len(dti))], name=names[2], freq=\"infer\"\n        )\n        tm.assert_index_equal(res, expected)",
        "begin_line": 2504,
        "end_line": 2517,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_with_offset_series#2522",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_with_offset_series(self, tz_naive_fixture, names)",
        "snippet": "    def test_dti_with_offset_series(self, tz_naive_fixture, names):\n        # GH#18849\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2017-01-01\", periods=2, tz=tz, name=names[0])\n        other = Series([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)], name=names[1])\n\n        expected_add = Series(\n            [dti[n] + other[n] for n in range(len(dti))], name=names[2]\n        )\n\n        with tm.assert_produces_warning(\n            PerformanceWarning, clear=[pd.core.arrays.datetimelike]\n        ):\n            res = dti + other\n        tm.assert_series_equal(res, expected_add)\n\n        with tm.assert_produces_warning(\n            PerformanceWarning, clear=[pd.core.arrays.datetimelike]\n        ):\n            res2 = other + dti\n        tm.assert_series_equal(res2, expected_add)\n\n        expected_sub = Series(\n            [dti[n] - other[n] for n in range(len(dti))], name=names[2]\n        )\n\n        with tm.assert_produces_warning(\n            PerformanceWarning, clear=[pd.core.arrays.datetimelike]\n        ):\n            res3 = dti - other\n        tm.assert_series_equal(res3, expected_sub)",
        "begin_line": 2522,
        "end_line": 2552,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.test_shift_months#2557",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64",
        "signature": "pandas.tests.arithmetic.test_datetime64.test_shift_months(years, months)",
        "snippet": "def test_shift_months(years, months):\n    dti = DatetimeIndex(\n        [\n            Timestamp(\"2000-01-05 00:15:00\"),\n            Timestamp(\"2000-01-31 00:23:00\"),\n            Timestamp(\"2000-01-01\"),\n            Timestamp(\"2000-02-29\"),\n            Timestamp(\"2000-12-31\"),\n        ]\n    )\n    actual = DatetimeIndex(shift_months(dti.asi8, years * 12 + months))\n\n    raw = [x + pd.offsets.DateOffset(years=years, months=months) for x in dti]\n    expected = DatetimeIndex(raw)\n    tm.assert_index_equal(actual, expected)",
        "begin_line": 2557,
        "end_line": 2571,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.test_dt_subclass_add_timedelta#2586",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64",
        "signature": "pandas.tests.arithmetic.test_datetime64.test_dt_subclass_add_timedelta(lh, rh)",
        "snippet": "def test_dt_subclass_add_timedelta(lh, rh):\n    # GH 25851\n    # ensure that subclassed datetime works for\n    # Timedelta operations\n    result = lh + rh\n    expected = SubDatetime(2000, 1, 1, 1)\n    assert result == expected",
        "begin_line": 2586,
        "end_line": 2592,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.one#23",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.one(request)",
        "snippet": "def one(request):\n    # zero-dim integer array behaves like an integer\n    return request.param",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.zero#42",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.zero(request)",
        "snippet": "def zero(request):\n    # For testing division by (or of) zero for Index with length 5, this\n    # gives several scalar-zeros and length-5 vector-zeros\n    return request.param",
        "begin_line": 42,
        "end_line": 45,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.numeric_idx#61",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.numeric_idx(request)",
        "snippet": "def numeric_idx(request):\n    \"\"\"\n    Several types of numeric-dtypes Index objects\n    \"\"\"\n    return request.param",
        "begin_line": 61,
        "end_line": 65,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.scalar_td#80",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.scalar_td(request)",
        "snippet": "def scalar_td(request):\n    \"\"\"\n    Several variants of Timedelta scalars representing 5 minutes and 4 seconds\n    \"\"\"\n    return request.param",
        "begin_line": 80,
        "end_line": 84,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.three_days#98",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.three_days(request)",
        "snippet": "def three_days(request):\n    \"\"\"\n    Several timedelta-like and DateOffset objects that each represent\n    a 3-day timedelta\n    \"\"\"\n    return request.param",
        "begin_line": 98,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.two_hours#117",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.two_hours(request)",
        "snippet": "def two_hours(request):\n    \"\"\"\n    Several timedelta-like and DateOffset objects that each represent\n    a 2-hour timedelta\n    \"\"\"\n    return request.param",
        "begin_line": 117,
        "end_line": 122,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.not_hourly#140",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.not_hourly(request)",
        "snippet": "def not_hourly(request):\n    \"\"\"\n    Several timedelta-like and DateOffset instances that are _not_\n    compatible with Hourly frequencies.\n    \"\"\"\n    return request.param",
        "begin_line": 140,
        "end_line": 145,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.not_daily#156",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.not_daily(request)",
        "snippet": "def not_daily(request):\n    \"\"\"\n    Several timedelta-like and DateOffset instances that are _not_\n    compatible with Daily frequencies.\n    \"\"\"\n    return request.param",
        "begin_line": 156,
        "end_line": 161,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.mismatched_freq#172",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.mismatched_freq(request)",
        "snippet": "def mismatched_freq(request):\n    \"\"\"\n    Several timedelta-like and DateOffset instances that are _not_\n    compatible with Monthly or Annual frequencies.\n    \"\"\"\n    return request.param",
        "begin_line": 172,
        "end_line": 177,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.box#184",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.box(request)",
        "snippet": "def box(request):\n    \"\"\"\n    Several array-like containers that should have effectively identical\n    behavior with respect to arithmetic operations.\n    \"\"\"\n    return request.param",
        "begin_line": 184,
        "end_line": 189,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.box_df_fail#196",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.box_df_fail(request)",
        "snippet": "def box_df_fail(request):\n    \"\"\"\n    Fixture equivalent to `box` fixture but xfailing the DataFrame case.\n    \"\"\"\n    return request.param",
        "begin_line": 196,
        "end_line": 200,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.box_transpose_fail#212",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.box_transpose_fail(request)",
        "snippet": "def box_transpose_fail(request):\n    \"\"\"\n    Fixture similar to `box` but testing both transpose cases for DataFrame,\n    with the tranpose=True case xfailed.\n    \"\"\"\n    # GH#23620\n    return request.param",
        "begin_line": 212,
        "end_line": 218,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.box_with_array#222",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.box_with_array(request)",
        "snippet": "def box_with_array(request):\n    \"\"\"\n    Fixture to test behavior for Index, Series, DataFrame, and pandas Array\n    classes\n    \"\"\"\n    return request.param",
        "begin_line": 222,
        "end_line": 227,
        "comment": "",
        "is_bug": false
    }
]