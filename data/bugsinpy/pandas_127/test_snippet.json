[
    {
        "name": "pandas.tests.series.test_timeseries._simple_ts#33",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries",
        "signature": "pandas.tests.series.test_timeseries._simple_ts(start, end, freq='D')",
        "snippet": "def _simple_ts(start, end, freq=\"D\"):\n    rng = date_range(start, end, freq=freq)\n    return Series(np.random.randn(len(rng)), index=rng)",
        "begin_line": 33,
        "end_line": 35,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.assert_range_equal#38",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries",
        "signature": "pandas.tests.series.test_timeseries.assert_range_equal(left, right)",
        "snippet": "def assert_range_equal(left, right):\n    assert left.equals(right)\n    assert left.freq == right.freq\n    assert left.tz == right.tz",
        "begin_line": 38,
        "end_line": 41,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_shift#45",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_shift(self, datetime_series)",
        "snippet": "    def test_shift(self, datetime_series):\n        shifted = datetime_series.shift(1)\n        unshifted = shifted.shift(-1)\n\n        tm.assert_index_equal(shifted.index, datetime_series.index)\n        tm.assert_index_equal(unshifted.index, datetime_series.index)\n        tm.assert_numpy_array_equal(\n            unshifted.dropna().values, datetime_series.values[:-1]\n        )\n\n        offset = BDay()\n        shifted = datetime_series.shift(1, freq=offset)\n        unshifted = shifted.shift(-1, freq=offset)\n\n        tm.assert_series_equal(unshifted, datetime_series)\n\n        unshifted = datetime_series.shift(0, freq=offset)\n        tm.assert_series_equal(unshifted, datetime_series)\n\n        shifted = datetime_series.shift(1, freq=\"B\")\n        unshifted = shifted.shift(-1, freq=\"B\")\n\n        tm.assert_series_equal(unshifted, datetime_series)\n\n        # corner case\n        unshifted = datetime_series.shift(0)\n        tm.assert_series_equal(unshifted, datetime_series)\n\n        # Shifting with PeriodIndex\n        ps = tm.makePeriodSeries()\n        shifted = ps.shift(1)\n        unshifted = shifted.shift(-1)\n        tm.assert_index_equal(shifted.index, ps.index)\n        tm.assert_index_equal(unshifted.index, ps.index)\n        tm.assert_numpy_array_equal(unshifted.dropna().values, ps.values[:-1])\n\n        shifted2 = ps.shift(1, \"B\")\n        shifted3 = ps.shift(1, BDay())\n        tm.assert_series_equal(shifted2, shifted3)\n        tm.assert_series_equal(ps, shifted2.shift(-1, \"B\"))\n\n        msg = \"Given freq D does not match PeriodIndex freq B\"\n        with pytest.raises(ValueError, match=msg):\n            ps.shift(freq=\"D\")\n\n        # legacy support\n        shifted4 = ps.shift(1, freq=\"B\")\n        tm.assert_series_equal(shifted2, shifted4)\n\n        shifted5 = ps.shift(1, freq=BDay())\n        tm.assert_series_equal(shifted5, shifted4)\n\n        # 32-bit taking\n        # GH 8129\n        index = date_range(\"2000-01-01\", periods=5)\n        for dtype in [\"int32\", \"int64\"]:\n            s1 = Series(np.arange(5, dtype=dtype), index=index)\n            p = s1.iloc[1]\n            result = s1.shift(periods=p)\n            expected = Series([np.nan, 0, 1, 2, 3], index=index)\n            tm.assert_series_equal(result, expected)\n\n        # xref 8260\n        # with tz\n        s = Series(\n            date_range(\"2000-01-01 09:00:00\", periods=5, tz=\"US/Eastern\"), name=\"foo\"\n        )\n        result = s - s.shift()\n\n        exp = Series(TimedeltaIndex([\"NaT\"] + [\"1 days\"] * 4), name=\"foo\")\n        tm.assert_series_equal(result, exp)\n\n        # incompat tz\n        s2 = Series(date_range(\"2000-01-01 09:00:00\", periods=5, tz=\"CET\"), name=\"foo\")\n        msg = \"DatetimeArray subtraction must have the same timezones or no timezones\"\n        with pytest.raises(TypeError, match=msg):\n            s - s2",
        "begin_line": 45,
        "end_line": 121,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_shift2#123",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_shift2(self)",
        "snippet": "    def test_shift2(self):\n        ts = Series(\n            np.random.randn(5), index=date_range(\"1/1/2000\", periods=5, freq=\"H\")\n        )\n\n        result = ts.shift(1, freq=\"5T\")\n        exp_index = ts.index.shift(1, freq=\"5T\")\n        tm.assert_index_equal(result.index, exp_index)\n\n        # GH #1063, multiple of same base\n        result = ts.shift(1, freq=\"4H\")\n        exp_index = ts.index + offsets.Hour(4)\n        tm.assert_index_equal(result.index, exp_index)\n\n        idx = DatetimeIndex([\"2000-01-01\", \"2000-01-02\", \"2000-01-04\"])\n        msg = \"Cannot shift with no freq\"\n        with pytest.raises(NullFrequencyError, match=msg):\n            idx.shift(1)",
        "begin_line": 123,
        "end_line": 140,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_shift_fill_value#142",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_shift_fill_value(self)",
        "snippet": "    def test_shift_fill_value(self):\n        # GH #24128\n        ts = Series(\n            [1.0, 2.0, 3.0, 4.0, 5.0], index=date_range(\"1/1/2000\", periods=5, freq=\"H\")\n        )\n\n        exp = Series(\n            [0.0, 1.0, 2.0, 3.0, 4.0], index=date_range(\"1/1/2000\", periods=5, freq=\"H\")\n        )\n        # check that fill value works\n        result = ts.shift(1, fill_value=0.0)\n        tm.assert_series_equal(result, exp)\n\n        exp = Series(\n            [0.0, 0.0, 1.0, 2.0, 3.0], index=date_range(\"1/1/2000\", periods=5, freq=\"H\")\n        )\n        result = ts.shift(2, fill_value=0.0)\n        tm.assert_series_equal(result, exp)\n\n        ts = pd.Series([1, 2, 3])\n        res = ts.shift(2, fill_value=0)\n        assert res.dtype == ts.dtype",
        "begin_line": 142,
        "end_line": 163,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_categorical_shift_fill_value#165",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_categorical_shift_fill_value(self)",
        "snippet": "    def test_categorical_shift_fill_value(self):\n        ts = pd.Series([\"a\", \"b\", \"c\", \"d\"], dtype=\"category\")\n        res = ts.shift(1, fill_value=\"a\")\n        expected = pd.Series(\n            pd.Categorical(\n                [\"a\", \"a\", \"b\", \"c\"], categories=[\"a\", \"b\", \"c\", \"d\"], ordered=False\n            )\n        )\n        tm.assert_equal(res, expected)\n\n        # check for incorrect fill_value\n        msg = \"'fill_value=f' is not present in this Categorical's categories\"\n        with pytest.raises(ValueError, match=msg):\n            ts.shift(1, fill_value=\"f\")",
        "begin_line": 165,
        "end_line": 178,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_shift_dst#180",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_shift_dst(self)",
        "snippet": "    def test_shift_dst(self):\n        # GH 13926\n        dates = date_range(\"2016-11-06\", freq=\"H\", periods=10, tz=\"US/Eastern\")\n        s = Series(dates)\n\n        res = s.shift(0)\n        tm.assert_series_equal(res, s)\n        assert res.dtype == \"datetime64[ns, US/Eastern]\"\n\n        res = s.shift(1)\n        exp_vals = [NaT] + dates.astype(object).values.tolist()[:9]\n        exp = Series(exp_vals)\n        tm.assert_series_equal(res, exp)\n        assert res.dtype == \"datetime64[ns, US/Eastern]\"\n\n        res = s.shift(-2)\n        exp_vals = dates.astype(object).values.tolist()[2:] + [NaT, NaT]\n        exp = Series(exp_vals)\n        tm.assert_series_equal(res, exp)\n        assert res.dtype == \"datetime64[ns, US/Eastern]\"\n\n        for ex in [10, -10, 20, -20]:\n            res = s.shift(ex)\n            exp = Series([NaT] * 10, dtype=\"datetime64[ns, US/Eastern]\")\n            tm.assert_series_equal(res, exp)\n            assert res.dtype == \"datetime64[ns, US/Eastern]\"",
        "begin_line": 180,
        "end_line": 205,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_tshift#207",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_tshift(self, datetime_series)",
        "snippet": "    def test_tshift(self, datetime_series):\n        # PeriodIndex\n        ps = tm.makePeriodSeries()\n        shifted = ps.tshift(1)\n        unshifted = shifted.tshift(-1)\n\n        tm.assert_series_equal(unshifted, ps)\n\n        shifted2 = ps.tshift(freq=\"B\")\n        tm.assert_series_equal(shifted, shifted2)\n\n        shifted3 = ps.tshift(freq=BDay())\n        tm.assert_series_equal(shifted, shifted3)\n\n        msg = \"Given freq M does not match PeriodIndex freq B\"\n        with pytest.raises(ValueError, match=msg):\n            ps.tshift(freq=\"M\")\n\n        # DatetimeIndex\n        shifted = datetime_series.tshift(1)\n        unshifted = shifted.tshift(-1)\n\n        tm.assert_series_equal(datetime_series, unshifted)\n\n        shifted2 = datetime_series.tshift(freq=datetime_series.index.freq)\n        tm.assert_series_equal(shifted, shifted2)\n\n        inferred_ts = Series(\n            datetime_series.values, Index(np.asarray(datetime_series.index)), name=\"ts\"\n        )\n        shifted = inferred_ts.tshift(1)\n        unshifted = shifted.tshift(-1)\n        tm.assert_series_equal(shifted, datetime_series.tshift(1))\n        tm.assert_series_equal(unshifted, inferred_ts)\n\n        no_freq = datetime_series[[0, 5, 7]]\n        msg = \"Freq was not given and was not set in the index\"\n        with pytest.raises(ValueError, match=msg):\n            no_freq.tshift()",
        "begin_line": 207,
        "end_line": 245,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_truncate#247",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_truncate(self, datetime_series)",
        "snippet": "    def test_truncate(self, datetime_series):\n        offset = BDay()\n\n        ts = datetime_series[::3]\n\n        start, end = datetime_series.index[3], datetime_series.index[6]\n        start_missing, end_missing = datetime_series.index[2], datetime_series.index[7]\n\n        # neither specified\n        truncated = ts.truncate()\n        tm.assert_series_equal(truncated, ts)\n\n        # both specified\n        expected = ts[1:3]\n\n        truncated = ts.truncate(start, end)\n        tm.assert_series_equal(truncated, expected)\n\n        truncated = ts.truncate(start_missing, end_missing)\n        tm.assert_series_equal(truncated, expected)\n\n        # start specified\n        expected = ts[1:]\n\n        truncated = ts.truncate(before=start)\n        tm.assert_series_equal(truncated, expected)\n\n        truncated = ts.truncate(before=start_missing)\n        tm.assert_series_equal(truncated, expected)\n\n        # end specified\n        expected = ts[:3]\n\n        truncated = ts.truncate(after=end)\n        tm.assert_series_equal(truncated, expected)\n\n        truncated = ts.truncate(after=end_missing)\n        tm.assert_series_equal(truncated, expected)\n\n        # corner case, empty series returned\n        truncated = ts.truncate(after=datetime_series.index[0] - offset)\n        assert len(truncated) == 0\n\n        truncated = ts.truncate(before=datetime_series.index[-1] + offset)\n        assert len(truncated) == 0\n\n        msg = \"Truncate: 1999-12-31 00:00:00 must be after 2000-02-14 00:00:00\"\n        with pytest.raises(ValueError, match=msg):\n            ts.truncate(\n                before=datetime_series.index[-1] + offset,\n                after=datetime_series.index[0] - offset,\n            )",
        "begin_line": 247,
        "end_line": 298,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_truncate_nonsortedindex#300",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_truncate_nonsortedindex(self)",
        "snippet": "    def test_truncate_nonsortedindex(self):\n        # GH 17935\n\n        s = pd.Series([\"a\", \"b\", \"c\", \"d\", \"e\"], index=[5, 3, 2, 9, 0])\n        msg = \"truncate requires a sorted index\"\n\n        with pytest.raises(ValueError, match=msg):\n            s.truncate(before=3, after=9)\n\n        rng = pd.date_range(\"2011-01-01\", \"2012-01-01\", freq=\"W\")\n        ts = pd.Series(np.random.randn(len(rng)), index=rng)\n        msg = \"truncate requires a sorted index\"\n\n        with pytest.raises(ValueError, match=msg):\n            ts.sort_values(ascending=False).truncate(before=\"2011-11\", after=\"2011-12\")",
        "begin_line": 300,
        "end_line": 314,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_asfreq#316",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_asfreq(self)",
        "snippet": "    def test_asfreq(self):\n        ts = Series(\n            [0.0, 1.0, 2.0],\n            index=[\n                datetime(2009, 10, 30),\n                datetime(2009, 11, 30),\n                datetime(2009, 12, 31),\n            ],\n        )\n\n        daily_ts = ts.asfreq(\"B\")\n        monthly_ts = daily_ts.asfreq(\"BM\")\n        tm.assert_series_equal(monthly_ts, ts)\n\n        daily_ts = ts.asfreq(\"B\", method=\"pad\")\n        monthly_ts = daily_ts.asfreq(\"BM\")\n        tm.assert_series_equal(monthly_ts, ts)\n\n        daily_ts = ts.asfreq(BDay())\n        monthly_ts = daily_ts.asfreq(BMonthEnd())\n        tm.assert_series_equal(monthly_ts, ts)\n\n        result = ts[:0].asfreq(\"M\")\n        assert len(result) == 0\n        assert result is not ts\n\n        daily_ts = ts.asfreq(\"D\", fill_value=-1)\n        result = daily_ts.value_counts().sort_index()\n        expected = Series([60, 1, 1, 1], index=[-1.0, 2.0, 1.0, 0.0]).sort_index()\n        tm.assert_series_equal(result, expected)",
        "begin_line": 316,
        "end_line": 345,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_asfreq_datetimeindex_empty_series#347",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_asfreq_datetimeindex_empty_series(self)",
        "snippet": "    def test_asfreq_datetimeindex_empty_series(self):\n        # GH 14320\n        expected = Series(index=pd.DatetimeIndex([\"2016-09-29 11:00\"])).asfreq(\"H\")\n        result = Series(index=pd.DatetimeIndex([\"2016-09-29 11:00\"]), data=[3]).asfreq(\n            \"H\"\n        )\n        tm.assert_index_equal(expected.index, result.index)",
        "begin_line": 347,
        "end_line": 353,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_pct_change#355",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_pct_change(self, datetime_series)",
        "snippet": "    def test_pct_change(self, datetime_series):\n        rs = datetime_series.pct_change(fill_method=None)\n        tm.assert_series_equal(rs, datetime_series / datetime_series.shift(1) - 1)\n\n        rs = datetime_series.pct_change(2)\n        filled = datetime_series.fillna(method=\"pad\")\n        tm.assert_series_equal(rs, filled / filled.shift(2) - 1)\n\n        rs = datetime_series.pct_change(fill_method=\"bfill\", limit=1)\n        filled = datetime_series.fillna(method=\"bfill\", limit=1)\n        tm.assert_series_equal(rs, filled / filled.shift(1) - 1)\n\n        rs = datetime_series.pct_change(freq=\"5D\")\n        filled = datetime_series.fillna(method=\"pad\")\n        tm.assert_series_equal(\n            rs, (filled / filled.shift(freq=\"5D\") - 1).reindex_like(filled)\n        )",
        "begin_line": 355,
        "end_line": 371,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_pct_change_with_duplicate_axis#373",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_pct_change_with_duplicate_axis(self)",
        "snippet": "    def test_pct_change_with_duplicate_axis(self):\n        # GH 28664\n        common_idx = date_range(\"2019-11-14\", periods=5, freq=\"D\")\n        result = Series(range(5), common_idx).pct_change(freq=\"B\")\n\n        # the reason that the expected should be like this is documented at PR 28681\n        expected = Series([np.NaN, np.inf, np.NaN, np.NaN, 3.0], common_idx)\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 373,
        "end_line": 381,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_pct_change_shift_over_nas#383",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_pct_change_shift_over_nas(self)",
        "snippet": "    def test_pct_change_shift_over_nas(self):\n        s = Series([1.0, 1.5, np.nan, 2.5, 3.0])\n\n        chg = s.pct_change()\n        expected = Series([np.nan, 0.5, 0.0, 2.5 / 1.5 - 1, 0.2])\n        tm.assert_series_equal(chg, expected)",
        "begin_line": 383,
        "end_line": 388,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_pct_change_periods_freq#401",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_pct_change_periods_freq(self, freq, periods, fill_method, limit, datetime_series)",
        "snippet": "    def test_pct_change_periods_freq(\n        self, freq, periods, fill_method, limit, datetime_series\n    ):\n        # GH 7292\n        rs_freq = datetime_series.pct_change(\n            freq=freq, fill_method=fill_method, limit=limit\n        )\n        rs_periods = datetime_series.pct_change(\n            periods, fill_method=fill_method, limit=limit\n        )\n        tm.assert_series_equal(rs_freq, rs_periods)\n\n        empty_ts = Series(index=datetime_series.index)\n        rs_freq = empty_ts.pct_change(freq=freq, fill_method=fill_method, limit=limit)\n        rs_periods = empty_ts.pct_change(periods, fill_method=fill_method, limit=limit)\n        tm.assert_series_equal(rs_freq, rs_periods)",
        "begin_line": 401,
        "end_line": 416,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_autocorr#418",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_autocorr(self, datetime_series)",
        "snippet": "    def test_autocorr(self, datetime_series):\n        # Just run the function\n        corr1 = datetime_series.autocorr()\n\n        # Now run it with the lag parameter\n        corr2 = datetime_series.autocorr(lag=1)\n\n        # corr() with lag needs Series of at least length 2\n        if len(datetime_series) <= 2:\n            assert np.isnan(corr1)\n            assert np.isnan(corr2)\n        else:\n            assert corr1 == corr2\n\n        # Choose a random lag between 1 and length of Series - 2\n        # and compare the result with the Series corr() function\n        n = 1 + np.random.randint(max(1, len(datetime_series) - 2))\n        corr1 = datetime_series.corr(datetime_series.shift(n))\n        corr2 = datetime_series.autocorr(lag=n)\n\n        # corr() with lag needs Series of at least length 2\n        if len(datetime_series) <= 2:\n            assert np.isnan(corr1)\n            assert np.isnan(corr2)\n        else:\n            assert corr1 == corr2",
        "begin_line": 418,
        "end_line": 443,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_first_last_valid#445",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_first_last_valid(self, datetime_series)",
        "snippet": "    def test_first_last_valid(self, datetime_series):\n        ts = datetime_series.copy()\n        ts[:5] = np.NaN\n\n        index = ts.first_valid_index()\n        assert index == ts.index[5]\n\n        ts[-5:] = np.NaN\n        index = ts.last_valid_index()\n        assert index == ts.index[-6]\n\n        ts[:] = np.nan\n        assert ts.last_valid_index() is None\n        assert ts.first_valid_index() is None\n\n        ser = Series([], index=[])\n        assert ser.last_valid_index() is None\n        assert ser.first_valid_index() is None\n\n        # GH12800\n        empty = Series()\n        assert empty.last_valid_index() is None\n        assert empty.first_valid_index() is None\n\n        # GH20499: its preserves freq with holes\n        ts.index = date_range(\"20110101\", periods=len(ts), freq=\"B\")\n        ts.iloc[1] = 1\n        ts.iloc[-2] = 1\n        assert ts.first_valid_index() == ts.index[1]\n        assert ts.last_valid_index() == ts.index[-2]\n        assert ts.first_valid_index().freq == ts.index.freq\n        assert ts.last_valid_index().freq == ts.index.freq",
        "begin_line": 445,
        "end_line": 476,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_mpl_compat_hack#478",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_mpl_compat_hack(self, datetime_series)",
        "snippet": "    def test_mpl_compat_hack(self, datetime_series):\n        result = datetime_series[:, np.newaxis]\n        expected = datetime_series.values[:, np.newaxis]\n        tm.assert_almost_equal(result, expected)",
        "begin_line": 478,
        "end_line": 481,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_timeseries_coercion#483",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_timeseries_coercion(self)",
        "snippet": "    def test_timeseries_coercion(self):\n        idx = tm.makeDateIndex(10000)\n        ser = Series(np.random.randn(len(idx)), idx.astype(object))\n        assert ser.index.is_all_dates\n        assert isinstance(ser.index, DatetimeIndex)",
        "begin_line": 483,
        "end_line": 487,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_contiguous_boolean_preserve_freq#489",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_contiguous_boolean_preserve_freq(self)",
        "snippet": "    def test_contiguous_boolean_preserve_freq(self):\n        rng = date_range(\"1/1/2000\", \"3/1/2000\", freq=\"B\")\n\n        mask = np.zeros(len(rng), dtype=bool)\n        mask[10:20] = True\n\n        masked = rng[mask]\n        expected = rng[10:20]\n        assert expected.freq is not None\n        assert_range_equal(masked, expected)\n\n        mask[22] = True\n        masked = rng[mask]\n        assert masked.freq is None",
        "begin_line": 489,
        "end_line": 502,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_to_datetime_unit#504",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_to_datetime_unit(self)",
        "snippet": "    def test_to_datetime_unit(self):\n\n        epoch = 1370745748\n        s = Series([epoch + t for t in range(20)])\n        result = to_datetime(s, unit=\"s\")\n        expected = Series(\n            [Timestamp(\"2013-06-09 02:42:28\") + timedelta(seconds=t) for t in range(20)]\n        )\n        tm.assert_series_equal(result, expected)\n\n        s = Series([epoch + t for t in range(20)]).astype(float)\n        result = to_datetime(s, unit=\"s\")\n        expected = Series(\n            [Timestamp(\"2013-06-09 02:42:28\") + timedelta(seconds=t) for t in range(20)]\n        )\n        tm.assert_series_equal(result, expected)\n\n        s = Series([epoch + t for t in range(20)] + [iNaT])\n        result = to_datetime(s, unit=\"s\")\n        expected = Series(\n            [Timestamp(\"2013-06-09 02:42:28\") + timedelta(seconds=t) for t in range(20)]\n            + [NaT]\n        )\n        tm.assert_series_equal(result, expected)\n\n        s = Series([epoch + t for t in range(20)] + [iNaT]).astype(float)\n        result = to_datetime(s, unit=\"s\")\n        expected = Series(\n            [Timestamp(\"2013-06-09 02:42:28\") + timedelta(seconds=t) for t in range(20)]\n            + [NaT]\n        )\n        tm.assert_series_equal(result, expected)\n\n        # GH13834\n        s = Series([epoch + t for t in np.arange(0, 2, 0.25)] + [iNaT]).astype(float)\n        result = to_datetime(s, unit=\"s\")\n        expected = Series(\n            [\n                Timestamp(\"2013-06-09 02:42:28\") + timedelta(seconds=t)\n                for t in np.arange(0, 2, 0.25)\n            ]\n            + [NaT]\n        )\n        tm.assert_series_equal(result, expected)\n\n        s = concat(\n            [Series([epoch + t for t in range(20)]).astype(float), Series([np.nan])],\n            ignore_index=True,\n        )\n        result = to_datetime(s, unit=\"s\")\n        expected = Series(\n            [Timestamp(\"2013-06-09 02:42:28\") + timedelta(seconds=t) for t in range(20)]\n            + [NaT]\n        )\n        tm.assert_series_equal(result, expected)\n\n        result = to_datetime([1, 2, \"NaT\", pd.NaT, np.nan], unit=\"D\")\n        expected = DatetimeIndex(\n            [Timestamp(\"1970-01-02\"), Timestamp(\"1970-01-03\")] + [\"NaT\"] * 3\n        )\n        tm.assert_index_equal(result, expected)\n\n        msg = \"non convertible value foo with the unit 'D'\"\n        with pytest.raises(ValueError, match=msg):\n            to_datetime([1, 2, \"foo\"], unit=\"D\")\n        msg = \"cannot convert input 111111111 with the unit 'D'\"\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            to_datetime([1, 2, 111111111], unit=\"D\")\n\n        # coerce we can process\n        expected = DatetimeIndex(\n            [Timestamp(\"1970-01-02\"), Timestamp(\"1970-01-03\")] + [\"NaT\"] * 1\n        )\n        result = to_datetime([1, 2, \"foo\"], unit=\"D\", errors=\"coerce\")\n        tm.assert_index_equal(result, expected)\n\n        result = to_datetime([1, 2, 111111111], unit=\"D\", errors=\"coerce\")\n        tm.assert_index_equal(result, expected)",
        "begin_line": 504,
        "end_line": 581,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_series_ctor_datetime64#583",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_series_ctor_datetime64(self)",
        "snippet": "    def test_series_ctor_datetime64(self):\n        rng = date_range(\"1/1/2000 00:00:00\", \"1/1/2000 1:59:50\", freq=\"10s\")\n        dates = np.asarray(rng)\n\n        series = Series(dates)\n        assert np.issubdtype(series.dtype, np.dtype(\"M8[ns]\"))",
        "begin_line": 583,
        "end_line": 588,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_series_repr_nat#590",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_series_repr_nat(self)",
        "snippet": "    def test_series_repr_nat(self):\n        series = Series([0, 1000, 2000, iNaT], dtype=\"M8[ns]\")\n\n        result = repr(series)\n        expected = (\n            \"0   1970-01-01 00:00:00.000000\\n\"\n            \"1   1970-01-01 00:00:00.000001\\n\"\n            \"2   1970-01-01 00:00:00.000002\\n\"\n            \"3                          NaT\\n\"\n            \"dtype: datetime64[ns]\"\n        )\n        assert result == expected",
        "begin_line": 590,
        "end_line": 601,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_asfreq_keep_index_name#603",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_asfreq_keep_index_name(self)",
        "snippet": "    def test_asfreq_keep_index_name(self):\n        # GH #9854\n        index_name = \"bar\"\n        index = pd.date_range(\"20130101\", periods=20, name=index_name)\n        df = pd.DataFrame([x for x in range(20)], columns=[\"foo\"], index=index)\n\n        assert index_name == df.index.name\n        assert index_name == df.asfreq(\"10D\").index.name",
        "begin_line": 603,
        "end_line": 610,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_promote_datetime_date#612",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_promote_datetime_date(self)",
        "snippet": "    def test_promote_datetime_date(self):\n        rng = date_range(\"1/1/2000\", periods=20)\n        ts = Series(np.random.randn(20), index=rng)\n\n        ts_slice = ts[5:]\n        ts2 = ts_slice.copy()\n        ts2.index = [x.date() for x in ts2.index]\n\n        result = ts + ts2\n        result2 = ts2 + ts\n        expected = ts + ts[5:]\n        tm.assert_series_equal(result, expected)\n        tm.assert_series_equal(result2, expected)\n\n        # test asfreq\n        result = ts2.asfreq(\"4H\", method=\"ffill\")\n        expected = ts[5:].asfreq(\"4H\", method=\"ffill\")\n        tm.assert_series_equal(result, expected)\n\n        result = rng.get_indexer(ts2.index)\n        expected = rng.get_indexer(ts_slice.index)\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 612,
        "end_line": 633,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_asfreq_normalize#635",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_asfreq_normalize(self)",
        "snippet": "    def test_asfreq_normalize(self):\n        rng = date_range(\"1/1/2000 09:30\", periods=20)\n        norm = date_range(\"1/1/2000\", periods=20)\n        vals = np.random.randn(20)\n        ts = Series(vals, index=rng)\n\n        result = ts.asfreq(\"D\", normalize=True)\n        norm = date_range(\"1/1/2000\", periods=20)\n        expected = Series(vals, index=norm)\n\n        tm.assert_series_equal(result, expected)\n\n        vals = np.random.randn(20, 3)\n        ts = DataFrame(vals, index=rng)\n\n        result = ts.asfreq(\"D\", normalize=True)\n        expected = DataFrame(vals, index=norm)\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 635,
        "end_line": 653,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_first_subset#655",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_first_subset(self)",
        "snippet": "    def test_first_subset(self):\n        ts = _simple_ts(\"1/1/2000\", \"1/1/2010\", freq=\"12h\")\n        result = ts.first(\"10d\")\n        assert len(result) == 20\n\n        ts = _simple_ts(\"1/1/2000\", \"1/1/2010\")\n        result = ts.first(\"10d\")\n        assert len(result) == 10\n\n        result = ts.first(\"3M\")\n        expected = ts[:\"3/31/2000\"]\n        tm.assert_series_equal(result, expected)\n\n        result = ts.first(\"21D\")\n        expected = ts[:21]\n        tm.assert_series_equal(result, expected)\n\n        result = ts[:0].first(\"3M\")\n        tm.assert_series_equal(result, ts[:0])",
        "begin_line": 655,
        "end_line": 673,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_first_raises#675",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_first_raises(self)",
        "snippet": "    def test_first_raises(self):\n        # GH20725\n        ser = pd.Series(\"a b c\".split())\n        msg = \"'first' only supports a DatetimeIndex index\"\n        with pytest.raises(TypeError, match=msg):\n            ser.first(\"1D\")",
        "begin_line": 675,
        "end_line": 680,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_last_subset#682",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_last_subset(self)",
        "snippet": "    def test_last_subset(self):\n        ts = _simple_ts(\"1/1/2000\", \"1/1/2010\", freq=\"12h\")\n        result = ts.last(\"10d\")\n        assert len(result) == 20\n\n        ts = _simple_ts(\"1/1/2000\", \"1/1/2010\")\n        result = ts.last(\"10d\")\n        assert len(result) == 10\n\n        result = ts.last(\"21D\")\n        expected = ts[\"12/12/2009\":]\n        tm.assert_series_equal(result, expected)\n\n        result = ts.last(\"21D\")\n        expected = ts[-21:]\n        tm.assert_series_equal(result, expected)\n\n        result = ts[:0].last(\"3M\")\n        tm.assert_series_equal(result, ts[:0])",
        "begin_line": 682,
        "end_line": 700,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_last_raises#702",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_last_raises(self)",
        "snippet": "    def test_last_raises(self):\n        # GH20725\n        ser = pd.Series(\"a b c\".split())\n        msg = \"'last' only supports a DatetimeIndex index\"\n        with pytest.raises(TypeError, match=msg):\n            ser.last(\"1D\")",
        "begin_line": 702,
        "end_line": 707,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_format_pre_1900_dates#709",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_format_pre_1900_dates(self)",
        "snippet": "    def test_format_pre_1900_dates(self):\n        rng = date_range(\"1/1/1850\", \"1/1/1950\", freq=\"A-DEC\")\n        rng.format()\n        ts = Series(1, index=rng)\n        repr(ts)",
        "begin_line": 709,
        "end_line": 713,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_at_time#715",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_at_time(self)",
        "snippet": "    def test_at_time(self):\n        rng = date_range(\"1/1/2000\", \"1/5/2000\", freq=\"5min\")\n        ts = Series(np.random.randn(len(rng)), index=rng)\n        rs = ts.at_time(rng[1])\n        assert (rs.index.hour == rng[1].hour).all()\n        assert (rs.index.minute == rng[1].minute).all()\n        assert (rs.index.second == rng[1].second).all()\n\n        result = ts.at_time(\"9:30\")\n        expected = ts.at_time(time(9, 30))\n        tm.assert_series_equal(result, expected)\n\n        df = DataFrame(np.random.randn(len(rng), 3), index=rng)\n\n        result = ts[time(9, 30)]\n        result_df = df.loc[time(9, 30)]\n        expected = ts[(rng.hour == 9) & (rng.minute == 30)]\n        exp_df = df[(rng.hour == 9) & (rng.minute == 30)]\n\n        # expected.index = date_range('1/1/2000', '1/4/2000')\n\n        tm.assert_series_equal(result, expected)\n        tm.assert_frame_equal(result_df, exp_df)\n\n        chunk = df.loc[\"1/4/2000\":]\n        result = chunk.loc[time(9, 30)]\n        expected = result_df[-1:]\n        tm.assert_frame_equal(result, expected)\n\n        # midnight, everything\n        rng = date_range(\"1/1/2000\", \"1/31/2000\")\n        ts = Series(np.random.randn(len(rng)), index=rng)\n\n        result = ts.at_time(time(0, 0))\n        tm.assert_series_equal(result, ts)\n\n        # time doesn't exist\n        rng = date_range(\"1/1/2012\", freq=\"23Min\", periods=384)\n        ts = Series(np.random.randn(len(rng)), rng)\n        rs = ts.at_time(\"16:00\")\n        assert len(rs) == 0",
        "begin_line": 715,
        "end_line": 755,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_at_time_raises#757",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_at_time_raises(self)",
        "snippet": "    def test_at_time_raises(self):\n        # GH20725\n        ser = pd.Series(\"a b c\".split())\n        msg = \"Index must be DatetimeIndex\"\n        with pytest.raises(TypeError, match=msg):\n            ser.at_time(\"00:00\")",
        "begin_line": 757,
        "end_line": 762,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_between#764",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_between(self)",
        "snippet": "    def test_between(self):\n        series = Series(date_range(\"1/1/2000\", periods=10))\n        left, right = series[[2, 7]]\n\n        result = series.between(left, right)\n        expected = (series >= left) & (series <= right)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 764,
        "end_line": 770,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_between_time#772",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_between_time(self)",
        "snippet": "    def test_between_time(self):\n        rng = date_range(\"1/1/2000\", \"1/5/2000\", freq=\"5min\")\n        ts = Series(np.random.randn(len(rng)), index=rng)\n        stime = time(0, 0)\n        etime = time(1, 0)\n\n        close_open = product([True, False], [True, False])\n        for inc_start, inc_end in close_open:\n            filtered = ts.between_time(stime, etime, inc_start, inc_end)\n            exp_len = 13 * 4 + 1\n            if not inc_start:\n                exp_len -= 5\n            if not inc_end:\n                exp_len -= 4\n\n            assert len(filtered) == exp_len\n            for rs in filtered.index:\n                t = rs.time()\n                if inc_start:\n                    assert t >= stime\n                else:\n                    assert t > stime\n\n                if inc_end:\n                    assert t <= etime\n                else:\n                    assert t < etime\n\n        result = ts.between_time(\"00:00\", \"01:00\")\n        expected = ts.between_time(stime, etime)\n        tm.assert_series_equal(result, expected)\n\n        # across midnight\n        rng = date_range(\"1/1/2000\", \"1/5/2000\", freq=\"5min\")\n        ts = Series(np.random.randn(len(rng)), index=rng)\n        stime = time(22, 0)\n        etime = time(9, 0)\n\n        close_open = product([True, False], [True, False])\n        for inc_start, inc_end in close_open:\n            filtered = ts.between_time(stime, etime, inc_start, inc_end)\n            exp_len = (12 * 11 + 1) * 4 + 1\n            if not inc_start:\n                exp_len -= 4\n            if not inc_end:\n                exp_len -= 4\n\n            assert len(filtered) == exp_len\n            for rs in filtered.index:\n                t = rs.time()\n                if inc_start:\n                    assert (t >= stime) or (t <= etime)\n                else:\n                    assert (t > stime) or (t <= etime)\n\n                if inc_end:\n                    assert (t <= etime) or (t >= stime)\n                else:\n                    assert (t < etime) or (t >= stime)",
        "begin_line": 772,
        "end_line": 830,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_between_time_raises#832",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_between_time_raises(self)",
        "snippet": "    def test_between_time_raises(self):\n        # GH20725\n        ser = pd.Series(\"a b c\".split())\n        msg = \"Index must be DatetimeIndex\"\n        with pytest.raises(TypeError, match=msg):\n            ser.between_time(start_time=\"00:00\", end_time=\"12:00\")",
        "begin_line": 832,
        "end_line": 837,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_between_time_types#839",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_between_time_types(self)",
        "snippet": "    def test_between_time_types(self):\n        # GH11818\n        rng = date_range(\"1/1/2000\", \"1/5/2000\", freq=\"5min\")\n        msg = (\n            r\"Cannot convert arg \\[datetime\\.datetime\\(2010, 1, 2, 1, 0\\)\\]\"\n            \" to a time\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            rng.indexer_between_time(datetime(2010, 1, 2, 1), datetime(2010, 1, 2, 5))\n\n        frame = DataFrame({\"A\": 0}, index=rng)\n        with pytest.raises(ValueError, match=msg):\n            frame.between_time(datetime(2010, 1, 2, 1), datetime(2010, 1, 2, 5))\n\n        series = Series(0, index=rng)\n        with pytest.raises(ValueError, match=msg):\n            series.between_time(datetime(2010, 1, 2, 1), datetime(2010, 1, 2, 5))",
        "begin_line": 839,
        "end_line": 855,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_between_time_formats#858",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_between_time_formats(self)",
        "snippet": "    def test_between_time_formats(self):\n        # GH11818\n        rng = date_range(\"1/1/2000\", \"1/5/2000\", freq=\"5min\")\n        ts = DataFrame(np.random.randn(len(rng), 2), index=rng)\n\n        strings = [\n            (\"2:00\", \"2:30\"),\n            (\"0200\", \"0230\"),\n            (\"2:00am\", \"2:30am\"),\n            (\"0200am\", \"0230am\"),\n            (\"2:00:00\", \"2:30:00\"),\n            (\"020000\", \"023000\"),\n            (\"2:00:00am\", \"2:30:00am\"),\n            (\"020000am\", \"023000am\"),\n        ]\n        expected_length = 28\n\n        for time_string in strings:\n            assert len(ts.between_time(*time_string)) == expected_length",
        "begin_line": 858,
        "end_line": 876,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_between_time_axis#878",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_between_time_axis(self)",
        "snippet": "    def test_between_time_axis(self):\n        # issue 8839\n        rng = date_range(\"1/1/2000\", periods=100, freq=\"10min\")\n        ts = Series(np.random.randn(len(rng)), index=rng)\n        stime, etime = (\"08:00:00\", \"09:00:00\")\n        expected_length = 7\n\n        assert len(ts.between_time(stime, etime)) == expected_length\n        assert len(ts.between_time(stime, etime, axis=0)) == expected_length\n        msg = \"No axis named 1 for object type <class 'pandas.core.series.Series'>\"\n        with pytest.raises(ValueError, match=msg):\n            ts.between_time(stime, etime, axis=1)",
        "begin_line": 878,
        "end_line": 889,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_to_period#891",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_to_period(self)",
        "snippet": "    def test_to_period(self):\n        from pandas.core.indexes.period import period_range\n\n        ts = _simple_ts(\"1/1/2000\", \"1/1/2001\")\n\n        pts = ts.to_period()\n        exp = ts.copy()\n        exp.index = period_range(\"1/1/2000\", \"1/1/2001\")\n        tm.assert_series_equal(pts, exp)\n\n        pts = ts.to_period(\"M\")\n        exp.index = exp.index.asfreq(\"M\")\n        tm.assert_index_equal(pts.index, exp.index.asfreq(\"M\"))\n        tm.assert_series_equal(pts, exp)\n\n        # GH 7606 without freq\n        idx = DatetimeIndex([\"2011-01-01\", \"2011-01-02\", \"2011-01-03\", \"2011-01-04\"])\n        exp_idx = pd.PeriodIndex(\n            [\"2011-01-01\", \"2011-01-02\", \"2011-01-03\", \"2011-01-04\"], freq=\"D\"\n        )\n\n        s = Series(np.random.randn(4), index=idx)\n        expected = s.copy()\n        expected.index = exp_idx\n        tm.assert_series_equal(s.to_period(), expected)\n\n        df = DataFrame(np.random.randn(4, 4), index=idx, columns=idx)\n        expected = df.copy()\n        expected.index = exp_idx\n        tm.assert_frame_equal(df.to_period(), expected)\n\n        expected = df.copy()\n        expected.columns = exp_idx\n        tm.assert_frame_equal(df.to_period(axis=1), expected)",
        "begin_line": 891,
        "end_line": 924,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_groupby_count_dateparseerror#926",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_groupby_count_dateparseerror(self)",
        "snippet": "    def test_groupby_count_dateparseerror(self):\n        dr = date_range(start=\"1/1/2012\", freq=\"5min\", periods=10)\n\n        # BAD Example, datetimes first\n        s = Series(np.arange(10), index=[dr, np.arange(10)])\n        grouped = s.groupby(lambda x: x[1] % 2 == 0)\n        result = grouped.count()\n\n        s = Series(np.arange(10), index=[np.arange(10), dr])\n        grouped = s.groupby(lambda x: x[0] % 2 == 0)\n        expected = grouped.count()\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 926,
        "end_line": 938,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_to_csv_numpy_16_bug#940",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_to_csv_numpy_16_bug(self)",
        "snippet": "    def test_to_csv_numpy_16_bug(self):\n        frame = DataFrame({\"a\": date_range(\"1/1/2000\", periods=10)})\n\n        buf = StringIO()\n        frame.to_csv(buf)\n\n        result = buf.getvalue()\n        assert \"2000-01-01\" in result",
        "begin_line": 940,
        "end_line": 947,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_series_map_box_timedelta#949",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_series_map_box_timedelta(self)",
        "snippet": "    def test_series_map_box_timedelta(self):\n        # GH 11349\n        s = Series(timedelta_range(\"1 day 1 s\", periods=5, freq=\"h\"))\n\n        def f(x):\n            return x.total_seconds()\n\n        s.map(f)\n        s.apply(f)\n        DataFrame(s).applymap(f)",
        "begin_line": 949,
        "end_line": 958,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.f#953",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.f(x)",
        "snippet": "        def f(x):\n            return x.total_seconds()",
        "begin_line": 953,
        "end_line": 954,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_asfreq_resample_set_correct_freq#960",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_asfreq_resample_set_correct_freq(self)",
        "snippet": "    def test_asfreq_resample_set_correct_freq(self):\n        # GH5613\n        # we test if .asfreq() and .resample() set the correct value for .freq\n        df = pd.DataFrame(\n            {\"date\": [\"2012-01-01\", \"2012-01-02\", \"2012-01-03\"], \"col\": [1, 2, 3]}\n        )\n        df = df.set_index(pd.to_datetime(df.date))\n\n        # testing the settings before calling .asfreq() and .resample()\n        assert df.index.freq is None\n        assert df.index.inferred_freq == \"D\"\n\n        # does .asfreq() set .freq correctly?\n        assert df.asfreq(\"D\").index.freq == \"D\"\n\n        # does .resample() set .freq correctly?\n        assert df.resample(\"D\").asfreq().index.freq == \"D\"",
        "begin_line": 960,
        "end_line": 976,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_pickle#978",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_pickle(self)",
        "snippet": "    def test_pickle(self):\n\n        # GH4606\n        p = tm.round_trip_pickle(NaT)\n        assert p is NaT\n\n        idx = pd.to_datetime([\"2013-01-01\", NaT, \"2014-01-06\"])\n        idx_p = tm.round_trip_pickle(idx)\n        assert idx_p[0] == idx[0]\n        assert idx_p[1] is NaT\n        assert idx_p[2] == idx[2]\n\n        # GH11002\n        # don't infer freq\n        idx = date_range(\"1750-1-1\", \"2050-1-1\", freq=\"7D\")\n        idx_p = tm.round_trip_pickle(idx)\n        tm.assert_index_equal(idx, idx_p)",
        "begin_line": 978,
        "end_line": 994,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_setops_preserve_freq#997",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_setops_preserve_freq(self, tz)",
        "snippet": "    def test_setops_preserve_freq(self, tz):\n        rng = date_range(\"1/1/2000\", \"1/1/2002\", name=\"idx\", tz=tz)\n\n        result = rng[:50].union(rng[50:100])\n        assert result.name == rng.name\n        assert result.freq == rng.freq\n        assert result.tz == rng.tz\n\n        result = rng[:50].union(rng[30:100])\n        assert result.name == rng.name\n        assert result.freq == rng.freq\n        assert result.tz == rng.tz\n\n        result = rng[:50].union(rng[60:100])\n        assert result.name == rng.name\n        assert result.freq is None\n        assert result.tz == rng.tz\n\n        result = rng[:50].intersection(rng[25:75])\n        assert result.name == rng.name\n        assert result.freqstr == \"D\"\n        assert result.tz == rng.tz\n\n        nofreq = DatetimeIndex(list(rng[25:75]), name=\"other\")\n        result = rng[:50].union(nofreq)\n        assert result.name is None\n        assert result.freq == rng.freq\n        assert result.tz == rng.tz\n\n        result = rng[:50].intersection(nofreq)\n        assert result.name is None\n        assert result.freq == rng.freq\n        assert result.tz == rng.tz",
        "begin_line": 997,
        "end_line": 1029,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_from_M8_structured#1031",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_from_M8_structured(self)",
        "snippet": "    def test_from_M8_structured(self):\n        dates = [(datetime(2012, 9, 9, 0, 0), datetime(2012, 9, 8, 15, 10))]\n        arr = np.array(dates, dtype=[(\"Date\", \"M8[us]\"), (\"Forecasting\", \"M8[us]\")])\n        df = DataFrame(arr)\n\n        assert df[\"Date\"][0] == dates[0][0]\n        assert df[\"Forecasting\"][0] == dates[0][1]\n\n        s = Series(arr[\"Date\"])\n        assert isinstance(s[0], Timestamp)\n        assert s[0] == dates[0][0]\n\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            s = Series.from_array(arr[\"Date\"], Index([0]))\n            assert s[0] == dates[0][0]",
        "begin_line": 1031,
        "end_line": 1045,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_get_level_values_box#1047",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_get_level_values_box(self)",
        "snippet": "    def test_get_level_values_box(self):\n        from pandas import MultiIndex\n\n        dates = date_range(\"1/1/2000\", periods=4)\n        levels = [dates, [0, 1]]\n        codes = [[0, 0, 1, 1, 2, 2, 3, 3], [0, 1, 0, 1, 0, 1, 0, 1]]\n\n        index = MultiIndex(levels=levels, codes=codes)\n\n        assert isinstance(index.get_level_values(0)[0], Timestamp)",
        "begin_line": 1047,
        "end_line": 1056,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_view_tz#1058",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_view_tz(self)",
        "snippet": "    def test_view_tz(self):\n        # GH#24024\n        ser = pd.Series(pd.date_range(\"2000\", periods=4, tz=\"US/Central\"))\n        result = ser.view(\"i8\")\n        expected = pd.Series(\n            [\n                946706400000000000,\n                946792800000000000,\n                946879200000000000,\n                946965600000000000,\n            ]\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1058,
        "end_line": 1070,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_asarray_tz_naive#1072",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_asarray_tz_naive(self)",
        "snippet": "    def test_asarray_tz_naive(self):\n        # This shouldn't produce a warning.\n        ser = pd.Series(pd.date_range(\"2000\", periods=2))\n        expected = np.array([\"2000-01-01\", \"2000-01-02\"], dtype=\"M8[ns]\")\n        with tm.assert_produces_warning(None):\n            result = np.asarray(ser)\n\n        tm.assert_numpy_array_equal(result, expected)\n\n        # optionally, object\n        with tm.assert_produces_warning(None):\n            result = np.asarray(ser, dtype=object)\n\n        expected = np.array([pd.Timestamp(\"2000-01-01\"), pd.Timestamp(\"2000-01-02\")])\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 1072,
        "end_line": 1086,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_timeseries.TestTimeSeries.test_asarray_tz_aware#1088",
        "src_path": "pandas/tests/series/test_timeseries.py",
        "class_name": "pandas.tests.series.test_timeseries.TestTimeSeries",
        "signature": "pandas.tests.series.test_timeseries.TestTimeSeries.test_asarray_tz_aware(self)",
        "snippet": "    def test_asarray_tz_aware(self):\n        tz = \"US/Central\"\n        ser = pd.Series(pd.date_range(\"2000\", periods=2, tz=tz))\n        expected = np.array([\"2000-01-01T06\", \"2000-01-02T06\"], dtype=\"M8[ns]\")\n        # We warn by default and return an ndarray[M8[ns]]\n        with tm.assert_produces_warning(FutureWarning):\n            result = np.asarray(ser)\n\n        tm.assert_numpy_array_equal(result, expected)\n\n        # Old behavior with no warning\n        with tm.assert_produces_warning(None):\n            result = np.asarray(ser, dtype=\"M8[ns]\")\n\n        tm.assert_numpy_array_equal(result, expected)\n\n        # Future behavior with no warning\n        expected = np.array(\n            [pd.Timestamp(\"2000-01-01\", tz=tz), pd.Timestamp(\"2000-01-02\", tz=tz)]\n        )\n        with tm.assert_produces_warning(None):\n            result = np.asarray(ser, dtype=object)\n\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 1088,
        "end_line": 1111,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.datetime_series#7",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.datetime_series()",
        "snippet": "def datetime_series():\n    \"\"\"\n    Fixture for Series of floats with DatetimeIndex\n    \"\"\"\n    s = tm.makeTimeSeries()\n    s.name = \"ts\"\n    return s",
        "begin_line": 7,
        "end_line": 13,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.string_series#17",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.string_series()",
        "snippet": "def string_series():\n    \"\"\"\n    Fixture for Series of floats with Index of unique strings\n    \"\"\"\n    s = tm.makeStringSeries()\n    s.name = \"series\"\n    return s",
        "begin_line": 17,
        "end_line": 23,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.object_series#27",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.object_series()",
        "snippet": "def object_series():\n    \"\"\"\n    Fixture for Series of dtype object with Index of unique strings\n    \"\"\"\n    s = tm.makeObjectSeries()\n    s.name = \"objects\"\n    return s",
        "begin_line": 27,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    }
]