[
    {
        "name": "pandas.tests.plotting.common.TestPlotBase.setup_method#27",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n\n        import matplotlib as mpl\n        from pandas.plotting._matplotlib import compat\n\n        mpl.rcdefaults()\n\n        self.mpl_ge_2_2_3 = compat._mpl_ge_2_2_3()\n        self.mpl_ge_3_0_0 = compat._mpl_ge_3_0_0()\n        self.mpl_ge_3_1_0 = compat._mpl_ge_3_1_0()\n\n        self.bp_n_objects = 7\n        self.polycollection_factor = 2\n        self.default_figsize = (6.4, 4.8)\n        self.default_tick_position = \"left\"\n\n        n = 100\n        with tm.RNGContext(42):\n            gender = np.random.choice([\"Male\", \"Female\"], size=n)\n            classroom = np.random.choice([\"A\", \"B\", \"C\"], size=n)\n\n            self.hist_df = DataFrame(\n                {\n                    \"gender\": gender,\n                    \"classroom\": classroom,\n                    \"height\": random.normal(66, 4, size=n),\n                    \"weight\": random.normal(161, 32, size=n),\n                    \"category\": random.randint(4, size=n),\n                }\n            )\n\n        self.tdf = tm.makeTimeDataFrame()\n        self.hexbin_df = DataFrame(\n            {\n                \"A\": np.random.uniform(size=20),\n                \"B\": np.random.uniform(size=20),\n                \"C\": np.arange(20) + np.random.uniform(size=20),\n            }\n        )",
        "begin_line": 27,
        "end_line": 65,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase.teardown_method#67",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase.teardown_method(self, method)",
        "snippet": "    def teardown_method(self, method):\n        tm.close()",
        "begin_line": 67,
        "end_line": 68,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase.plt#71",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase.plt(self)",
        "snippet": "    def plt(self):\n        import matplotlib.pyplot as plt\n\n        return plt",
        "begin_line": 71,
        "end_line": 74,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase.colorconverter#77",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase.colorconverter(self)",
        "snippet": "    def colorconverter(self):\n        import matplotlib.colors as colors\n\n        return colors.colorConverter",
        "begin_line": 77,
        "end_line": 80,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._check_legend_labels#82",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._check_legend_labels(self, axes, labels=None, visible=True)",
        "snippet": "    def _check_legend_labels(self, axes, labels=None, visible=True):\n        \"\"\"\n        Check each axes has expected legend labels\n\n        Parameters\n        ----------\n        axes : matplotlib Axes object, or its list-like\n        labels : list-like\n            expected legend labels\n        visible : bool\n            expected legend visibility. labels are checked only when visible is\n            True\n        \"\"\"\n\n        if visible and (labels is None):\n            raise ValueError(\"labels must be specified when visible is True\")\n        axes = self._flatten_visible(axes)\n        for ax in axes:\n            if visible:\n                assert ax.get_legend() is not None\n                self._check_text_labels(ax.get_legend().get_texts(), labels)\n            else:\n                assert ax.get_legend() is None",
        "begin_line": 82,
        "end_line": 104,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._check_legend_marker#106",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._check_legend_marker(self, ax, expected_markers=None, visible=True)",
        "snippet": "    def _check_legend_marker(self, ax, expected_markers=None, visible=True):\n        \"\"\"\n        Check ax has expected legend markers\n\n        Parameters\n        ----------\n        ax : matplotlib Axes object\n        expected_markers : list-like\n            expected legend markers\n        visible : bool\n            expected legend visibility. labels are checked only when visible is\n            True\n        \"\"\"\n        if visible and (expected_markers is None):\n            raise ValueError(\"Markers must be specified when visible is True\")\n        if visible:\n            handles, _ = ax.get_legend_handles_labels()\n            markers = [handle.get_marker() for handle in handles]\n            assert markers == expected_markers\n        else:\n            assert ax.get_legend() is None",
        "begin_line": 106,
        "end_line": 126,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._check_data#128",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._check_data(self, xp, rs)",
        "snippet": "    def _check_data(self, xp, rs):\n        \"\"\"\n        Check each axes has identical lines\n\n        Parameters\n        ----------\n        xp : matplotlib Axes object\n        rs : matplotlib Axes object\n        \"\"\"\n        xp_lines = xp.get_lines()\n        rs_lines = rs.get_lines()\n\n        def check_line(xpl, rsl):\n            xpdata = xpl.get_xydata()\n            rsdata = rsl.get_xydata()\n            tm.assert_almost_equal(xpdata, rsdata)\n\n        assert len(xp_lines) == len(rs_lines)\n        [check_line(xpl, rsl) for xpl, rsl in zip(xp_lines, rs_lines)]\n        tm.close()",
        "begin_line": 128,
        "end_line": 147,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase.check_line#140",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase.check_line(xpl, rsl)",
        "snippet": "        def check_line(xpl, rsl):\n            xpdata = xpl.get_xydata()\n            rsdata = rsl.get_xydata()\n            tm.assert_almost_equal(xpdata, rsdata)",
        "begin_line": 140,
        "end_line": 143,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._check_visible#149",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._check_visible(self, collections, visible=True)",
        "snippet": "    def _check_visible(self, collections, visible=True):\n        \"\"\"\n        Check each artist is visible or not\n\n        Parameters\n        ----------\n        collections : matplotlib Artist or its list-like\n            target Artist or its list or collection\n        visible : bool\n            expected visibility\n        \"\"\"\n        from matplotlib.collections import Collection\n\n        if not isinstance(collections, Collection) and not is_list_like(collections):\n            collections = [collections]\n\n        for patch in collections:\n            assert patch.get_visible() == visible",
        "begin_line": 149,
        "end_line": 166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._get_colors_mapped#168",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._get_colors_mapped(self, series, colors)",
        "snippet": "    def _get_colors_mapped(self, series, colors):\n        unique = series.unique()\n        # unique and colors length can be differed\n        # depending on slice value\n        mapped = dict(zip(unique, colors))\n        return [mapped[v] for v in series.values]",
        "begin_line": 168,
        "end_line": 173,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._check_colors#175",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._check_colors(self, collections, linecolors=None, facecolors=None, mapping=None)",
        "snippet": "    def _check_colors(\n        self, collections, linecolors=None, facecolors=None, mapping=None\n    ):\n        \"\"\"\n        Check each artist has expected line colors and face colors\n\n        Parameters\n        ----------\n        collections : list-like\n            list or collection of target artist\n        linecolors : list-like which has the same length as collections\n            list of expected line colors\n        facecolors : list-like which has the same length as collections\n            list of expected face colors\n        mapping : Series\n            Series used for color grouping key\n            used for andrew_curves, parallel_coordinates, radviz test\n        \"\"\"\n\n        from matplotlib.lines import Line2D\n        from matplotlib.collections import Collection, PolyCollection, LineCollection\n\n        conv = self.colorconverter\n        if linecolors is not None:\n\n            if mapping is not None:\n                linecolors = self._get_colors_mapped(mapping, linecolors)\n                linecolors = linecolors[: len(collections)]\n\n            assert len(collections) == len(linecolors)\n            for patch, color in zip(collections, linecolors):\n                if isinstance(patch, Line2D):\n                    result = patch.get_color()\n                    # Line2D may contains string color expression\n                    result = conv.to_rgba(result)\n                elif isinstance(patch, (PolyCollection, LineCollection)):\n                    result = tuple(patch.get_edgecolor()[0])\n                else:\n                    result = patch.get_edgecolor()\n\n                expected = conv.to_rgba(color)\n                assert result == expected\n\n        if facecolors is not None:\n\n            if mapping is not None:\n                facecolors = self._get_colors_mapped(mapping, facecolors)\n                facecolors = facecolors[: len(collections)]\n\n            assert len(collections) == len(facecolors)\n            for patch, color in zip(collections, facecolors):\n                if isinstance(patch, Collection):\n                    # returned as list of np.array\n                    result = patch.get_facecolor()[0]\n                else:\n                    result = patch.get_facecolor()\n\n                if isinstance(result, np.ndarray):\n                    result = tuple(result)\n\n                expected = conv.to_rgba(color)\n                assert result == expected",
        "begin_line": 175,
        "end_line": 236,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._check_text_labels#238",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._check_text_labels(self, texts, expected)",
        "snippet": "    def _check_text_labels(self, texts, expected):\n        \"\"\"\n        Check each text has expected labels\n\n        Parameters\n        ----------\n        texts : matplotlib Text object, or its list-like\n            target text, or its list\n        expected : str or list-like which has the same length as texts\n            expected text label, or its list\n        \"\"\"\n        if not is_list_like(texts):\n            assert texts.get_text() == expected\n        else:\n            labels = [t.get_text() for t in texts]\n            assert len(labels) == len(expected)\n            for label, e in zip(labels, expected):\n                assert label == e",
        "begin_line": 238,
        "end_line": 255,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._check_ticks_props#257",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._check_ticks_props(self, axes, xlabelsize=None, xrot=None, ylabelsize=None, yrot=None)",
        "snippet": "    def _check_ticks_props(\n        self, axes, xlabelsize=None, xrot=None, ylabelsize=None, yrot=None\n    ):\n        \"\"\"\n        Check each axes has expected tick properties\n\n        Parameters\n        ----------\n        axes : matplotlib Axes object, or its list-like\n        xlabelsize : number\n            expected xticks font size\n        xrot : number\n            expected xticks rotation\n        ylabelsize : number\n            expected yticks font size\n        yrot : number\n            expected yticks rotation\n        \"\"\"\n        from matplotlib.ticker import NullFormatter\n\n        axes = self._flatten_visible(axes)\n        for ax in axes:\n            if xlabelsize or xrot:\n                if isinstance(ax.xaxis.get_minor_formatter(), NullFormatter):\n                    # If minor ticks has NullFormatter, rot / fontsize are not\n                    # retained\n                    labels = ax.get_xticklabels()\n                else:\n                    labels = ax.get_xticklabels() + ax.get_xticklabels(minor=True)\n\n                for label in labels:\n                    if xlabelsize is not None:\n                        tm.assert_almost_equal(label.get_fontsize(), xlabelsize)\n                    if xrot is not None:\n                        tm.assert_almost_equal(label.get_rotation(), xrot)\n\n            if ylabelsize or yrot:\n                if isinstance(ax.yaxis.get_minor_formatter(), NullFormatter):\n                    labels = ax.get_yticklabels()\n                else:\n                    labels = ax.get_yticklabels() + ax.get_yticklabels(minor=True)\n\n                for label in labels:\n                    if ylabelsize is not None:\n                        tm.assert_almost_equal(label.get_fontsize(), ylabelsize)\n                    if yrot is not None:\n                        tm.assert_almost_equal(label.get_rotation(), yrot)",
        "begin_line": 257,
        "end_line": 303,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._check_ax_scales#305",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._check_ax_scales(self, axes, xaxis='linear', yaxis='linear')",
        "snippet": "    def _check_ax_scales(self, axes, xaxis=\"linear\", yaxis=\"linear\"):\n        \"\"\"\n        Check each axes has expected scales\n\n        Parameters\n        ----------\n        axes : matplotlib Axes object, or its list-like\n        xaxis : {'linear', 'log'}\n            expected xaxis scale\n        yaxis :  {'linear', 'log'}\n            expected yaxis scale\n        \"\"\"\n        axes = self._flatten_visible(axes)\n        for ax in axes:\n            assert ax.xaxis.get_scale() == xaxis\n            assert ax.yaxis.get_scale() == yaxis",
        "begin_line": 305,
        "end_line": 320,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._check_axes_shape#322",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._check_axes_shape(self, axes, axes_num=None, layout=None, figsize=None)",
        "snippet": "    def _check_axes_shape(self, axes, axes_num=None, layout=None, figsize=None):\n        \"\"\"\n        Check expected number of axes is drawn in expected layout\n\n        Parameters\n        ----------\n        axes : matplotlib Axes object, or its list-like\n        axes_num : number\n            expected number of axes. Unnecessary axes should be set to\n            invisible.\n        layout :  tuple\n            expected layout, (expected number of rows , columns)\n        figsize : tuple\n            expected figsize. default is matplotlib default\n        \"\"\"\n        from pandas.plotting._matplotlib.tools import _flatten\n\n        if figsize is None:\n            figsize = self.default_figsize\n        visible_axes = self._flatten_visible(axes)\n\n        if axes_num is not None:\n            assert len(visible_axes) == axes_num\n            for ax in visible_axes:\n                # check something drawn on visible axes\n                assert len(ax.get_children()) > 0\n\n        if layout is not None:\n            result = self._get_axes_layout(_flatten(axes))\n            assert result == layout\n\n        tm.assert_numpy_array_equal(\n            visible_axes[0].figure.get_size_inches(),\n            np.array(figsize, dtype=np.float64),\n        )",
        "begin_line": 322,
        "end_line": 356,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._get_axes_layout#358",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._get_axes_layout(self, axes)",
        "snippet": "    def _get_axes_layout(self, axes):\n        x_set = set()\n        y_set = set()\n        for ax in axes:\n            # check axes coordinates to estimate layout\n            points = ax.get_position().get_points()\n            x_set.add(points[0][0])\n            y_set.add(points[0][1])\n        return (len(y_set), len(x_set))",
        "begin_line": 358,
        "end_line": 366,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._flatten_visible#368",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._flatten_visible(self, axes)",
        "snippet": "    def _flatten_visible(self, axes):\n        \"\"\"\n        Flatten axes, and filter only visible\n\n        Parameters\n        ----------\n        axes : matplotlib Axes object, or its list-like\n\n        \"\"\"\n        from pandas.plotting._matplotlib.tools import _flatten\n\n        axes = _flatten(axes)\n        axes = [ax for ax in axes if ax.get_visible()]\n        return axes",
        "begin_line": 368,
        "end_line": 381,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._check_has_errorbars#383",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._check_has_errorbars(self, axes, xerr=0, yerr=0)",
        "snippet": "    def _check_has_errorbars(self, axes, xerr=0, yerr=0):\n        \"\"\"\n        Check axes has expected number of errorbars\n\n        Parameters\n        ----------\n        axes : matplotlib Axes object, or its list-like\n        xerr : number\n            expected number of x errorbar\n        yerr : number\n            expected number of y errorbar\n        \"\"\"\n        axes = self._flatten_visible(axes)\n        for ax in axes:\n            containers = ax.containers\n            xerr_count = 0\n            yerr_count = 0\n            for c in containers:\n                has_xerr = getattr(c, \"has_xerr\", False)\n                has_yerr = getattr(c, \"has_yerr\", False)\n                if has_xerr:\n                    xerr_count += 1\n                if has_yerr:\n                    yerr_count += 1\n            assert xerr == xerr_count\n            assert yerr == yerr_count",
        "begin_line": 383,
        "end_line": 408,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._check_box_return_type#410",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._check_box_return_type(self, returned, return_type, expected_keys=None, check_ax_title=True)",
        "snippet": "    def _check_box_return_type(\n        self, returned, return_type, expected_keys=None, check_ax_title=True\n    ):\n        \"\"\"\n        Check box returned type is correct\n\n        Parameters\n        ----------\n        returned : object to be tested, returned from boxplot\n        return_type : str\n            return_type passed to boxplot\n        expected_keys : list-like, optional\n            group labels in subplot case. If not passed,\n            the function checks assuming boxplot uses single ax\n        check_ax_title : bool\n            Whether to check the ax.title is the same as expected_key\n            Intended to be checked by calling from ``boxplot``.\n            Normal ``plot`` doesn't attach ``ax.title``, it must be disabled.\n        \"\"\"\n        from matplotlib.axes import Axes\n\n        types = {\"dict\": dict, \"axes\": Axes, \"both\": tuple}\n        if expected_keys is None:\n            # should be fixed when the returning default is changed\n            if return_type is None:\n                return_type = \"dict\"\n\n            assert isinstance(returned, types[return_type])\n            if return_type == \"both\":\n                assert isinstance(returned.ax, Axes)\n                assert isinstance(returned.lines, dict)\n        else:\n            # should be fixed when the returning default is changed\n            if return_type is None:\n                for r in self._flatten_visible(returned):\n                    assert isinstance(r, Axes)\n                return\n\n            assert isinstance(returned, Series)\n\n            assert sorted(returned.keys()) == sorted(expected_keys)\n            for key, value in returned.items():\n                assert isinstance(value, types[return_type])\n                # check returned dict has correct mapping\n                if return_type == \"axes\":\n                    if check_ax_title:\n                        assert value.get_title() == key\n                elif return_type == \"both\":\n                    if check_ax_title:\n                        assert value.ax.get_title() == key\n                    assert isinstance(value.ax, Axes)\n                    assert isinstance(value.lines, dict)\n                elif return_type == \"dict\":\n                    line = value[\"medians\"][0]\n                    axes = line.axes\n                    if check_ax_title:\n                        assert axes.get_title() == key\n                else:\n                    raise AssertionError",
        "begin_line": 410,
        "end_line": 468,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._check_grid_settings#470",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._check_grid_settings(self, obj, kinds, kws={})",
        "snippet": "    def _check_grid_settings(self, obj, kinds, kws={}):\n        # Make sure plot defaults to rcParams['axes.grid'] setting, GH 9792\n\n        import matplotlib as mpl\n\n        def is_grid_on():\n            xticks = self.plt.gca().xaxis.get_major_ticks()\n            yticks = self.plt.gca().yaxis.get_major_ticks()\n            # for mpl 2.2.2, gridOn and gridline.get_visible disagree.\n            # for new MPL, they are the same.\n\n            if self.mpl_ge_3_1_0:\n                xoff = all(not g.gridline.get_visible() for g in xticks)\n                yoff = all(not g.gridline.get_visible() for g in yticks)\n            else:\n                xoff = all(not g.gridOn for g in xticks)\n                yoff = all(not g.gridOn for g in yticks)\n\n            return not (xoff and yoff)\n\n        spndx = 1\n        for kind in kinds:\n\n            self.plt.subplot(1, 4 * len(kinds), spndx)\n            spndx += 1\n            mpl.rc(\"axes\", grid=False)\n            obj.plot(kind=kind, **kws)\n            assert not is_grid_on()\n\n            self.plt.subplot(1, 4 * len(kinds), spndx)\n            spndx += 1\n            mpl.rc(\"axes\", grid=True)\n            obj.plot(kind=kind, grid=False, **kws)\n            assert not is_grid_on()\n\n            if kind != \"pie\":\n                self.plt.subplot(1, 4 * len(kinds), spndx)\n                spndx += 1\n                mpl.rc(\"axes\", grid=True)\n                obj.plot(kind=kind, **kws)\n                assert is_grid_on()\n\n                self.plt.subplot(1, 4 * len(kinds), spndx)\n                spndx += 1\n                mpl.rc(\"axes\", grid=False)\n                obj.plot(kind=kind, grid=True, **kws)\n                assert is_grid_on()",
        "begin_line": 470,
        "end_line": 516,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase.is_grid_on#475",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase.is_grid_on()",
        "snippet": "        def is_grid_on():\n            xticks = self.plt.gca().xaxis.get_major_ticks()\n            yticks = self.plt.gca().yaxis.get_major_ticks()\n            # for mpl 2.2.2, gridOn and gridline.get_visible disagree.\n            # for new MPL, they are the same.\n\n            if self.mpl_ge_3_1_0:\n                xoff = all(not g.gridline.get_visible() for g in xticks)\n                yoff = all(not g.gridline.get_visible() for g in yticks)\n            else:\n                xoff = all(not g.gridOn for g in xticks)\n                yoff = all(not g.gridOn for g in yticks)\n\n            return not (xoff and yoff)",
        "begin_line": 475,
        "end_line": 488,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common.TestPlotBase._unpack_cycler#518",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common.TestPlotBase",
        "signature": "pandas.tests.plotting.common.TestPlotBase._unpack_cycler(self, rcParams, field='color')",
        "snippet": "    def _unpack_cycler(self, rcParams, field=\"color\"):\n        \"\"\"\n        Auxiliary function for correctly unpacking cycler after MPL >= 1.5\n        \"\"\"\n        return [v[field] for v in rcParams[\"axes.prop_cycle\"]]",
        "begin_line": 518,
        "end_line": 522,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.common._check_plot_works#525",
        "src_path": "pandas/tests/plotting/common.py",
        "class_name": "pandas.tests.plotting.common",
        "signature": "pandas.tests.plotting.common._check_plot_works(f, filterwarnings='always', **kwargs)",
        "snippet": "def _check_plot_works(f, filterwarnings=\"always\", **kwargs):\n    import matplotlib.pyplot as plt\n\n    ret = None\n    with warnings.catch_warnings():\n        warnings.simplefilter(filterwarnings)\n        try:\n            try:\n                fig = kwargs[\"figure\"]\n            except KeyError:\n                fig = plt.gcf()\n\n            plt.clf()\n\n            ax = kwargs.get(\"ax\", fig.add_subplot(211))  # noqa\n            ret = f(**kwargs)\n\n            assert_is_valid_plot_return_object(ret)\n\n            try:\n                kwargs[\"ax\"] = fig.add_subplot(212)\n                ret = f(**kwargs)\n            except Exception:\n                pass\n            else:\n                assert_is_valid_plot_return_object(ret)\n\n            with ensure_clean(return_filelike=True) as path:\n                plt.savefig(path)\n        finally:\n            tm.close(fig)\n\n        return ret",
        "begin_line": 525,
        "end_line": 557,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.setup_method#25",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n        TestPlotBase.setup_method(self, method)\n        import matplotlib as mpl\n\n        mpl.rcdefaults()\n\n        self.ts = tm.makeTimeSeries()\n        self.ts.name = \"ts\"\n\n        self.series = tm.makeStringSeries()\n        self.series.name = \"series\"\n\n        self.iseries = tm.makePeriodSeries()\n        self.iseries.name = \"iseries\"",
        "begin_line": 25,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_plot#41",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_plot(self)",
        "snippet": "    def test_plot(self):\n        _check_plot_works(self.ts.plot, label=\"foo\")\n        _check_plot_works(self.ts.plot, use_index=False)\n        axes = _check_plot_works(self.ts.plot, rot=0)\n        self._check_ticks_props(axes, xrot=0)\n\n        ax = _check_plot_works(self.ts.plot, style=\".\", logy=True)\n        self._check_ax_scales(ax, yaxis=\"log\")\n\n        ax = _check_plot_works(self.ts.plot, style=\".\", logx=True)\n        self._check_ax_scales(ax, xaxis=\"log\")\n\n        ax = _check_plot_works(self.ts.plot, style=\".\", loglog=True)\n        self._check_ax_scales(ax, xaxis=\"log\", yaxis=\"log\")\n\n        _check_plot_works(self.ts[:10].plot.bar)\n        _check_plot_works(self.ts.plot.area, stacked=False)\n        _check_plot_works(self.iseries.plot)\n\n        for kind in [\"line\", \"bar\", \"barh\", \"kde\", \"hist\", \"box\"]:\n            _check_plot_works(self.series[:5].plot, kind=kind)\n\n        _check_plot_works(self.series[:10].plot.barh)\n        ax = _check_plot_works(Series(randn(10)).plot.bar, color=\"black\")\n        self._check_colors([ax.patches[0]], facecolors=[\"black\"])\n\n        # GH 6951\n        ax = _check_plot_works(self.ts.plot, subplots=True)\n        self._check_axes_shape(ax, axes_num=1, layout=(1, 1))\n\n        ax = _check_plot_works(self.ts.plot, subplots=True, layout=(-1, 1))\n        self._check_axes_shape(ax, axes_num=1, layout=(1, 1))\n        ax = _check_plot_works(self.ts.plot, subplots=True, layout=(1, -1))\n        self._check_axes_shape(ax, axes_num=1, layout=(1, 1))",
        "begin_line": 41,
        "end_line": 74,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_plot_figsize_and_title#77",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_plot_figsize_and_title(self)",
        "snippet": "    def test_plot_figsize_and_title(self):\n        # figsize and title\n        _, ax = self.plt.subplots()\n        ax = self.series.plot(title=\"Test\", figsize=(16, 8), ax=ax)\n        self._check_text_labels(ax.title, \"Test\")\n        self._check_axes_shape(ax, axes_num=1, layout=(1, 1), figsize=(16, 8))",
        "begin_line": 77,
        "end_line": 82,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_dont_modify_rcParams#84",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_dont_modify_rcParams(self)",
        "snippet": "    def test_dont_modify_rcParams(self):\n        # GH 8242\n        key = \"axes.prop_cycle\"\n        colors = self.plt.rcParams[key]\n        _, ax = self.plt.subplots()\n        Series([1, 2, 3]).plot(ax=ax)\n        assert colors == self.plt.rcParams[key]",
        "begin_line": 84,
        "end_line": 90,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_ts_line_lim#92",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_ts_line_lim(self)",
        "snippet": "    def test_ts_line_lim(self):\n        fig, ax = self.plt.subplots()\n        ax = self.ts.plot(ax=ax)\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= lines[0].get_data(orig=False)[0][0]\n        assert xmax >= lines[0].get_data(orig=False)[0][-1]\n        tm.close()\n\n        ax = self.ts.plot(secondary_y=True, ax=ax)\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= lines[0].get_data(orig=False)[0][0]\n        assert xmax >= lines[0].get_data(orig=False)[0][-1]",
        "begin_line": 92,
        "end_line": 105,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_ts_area_lim#107",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_ts_area_lim(self)",
        "snippet": "    def test_ts_area_lim(self):\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.area(stacked=False, ax=ax)\n        xmin, xmax = ax.get_xlim()\n        line = ax.get_lines()[0].get_data(orig=False)[0]\n        assert xmin <= line[0]\n        assert xmax >= line[-1]\n        tm.close()\n\n        # GH 7471\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.area(stacked=False, x_compat=True, ax=ax)\n        xmin, xmax = ax.get_xlim()\n        line = ax.get_lines()[0].get_data(orig=False)[0]\n        assert xmin <= line[0]\n        assert xmax >= line[-1]\n        tm.close()\n\n        tz_ts = self.ts.copy()\n        tz_ts.index = tz_ts.tz_localize(\"GMT\").tz_convert(\"CET\")\n        _, ax = self.plt.subplots()\n        ax = tz_ts.plot.area(stacked=False, x_compat=True, ax=ax)\n        xmin, xmax = ax.get_xlim()\n        line = ax.get_lines()[0].get_data(orig=False)[0]\n        assert xmin <= line[0]\n        assert xmax >= line[-1]\n        tm.close()\n\n        _, ax = self.plt.subplots()\n        ax = tz_ts.plot.area(stacked=False, secondary_y=True, ax=ax)\n        xmin, xmax = ax.get_xlim()\n        line = ax.get_lines()[0].get_data(orig=False)[0]\n        assert xmin <= line[0]\n        assert xmax >= line[-1]",
        "begin_line": 107,
        "end_line": 140,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_label#142",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_label(self)",
        "snippet": "    def test_label(self):\n        s = Series([1, 2])\n        _, ax = self.plt.subplots()\n        ax = s.plot(label=\"LABEL\", legend=True, ax=ax)\n        self._check_legend_labels(ax, labels=[\"LABEL\"])\n        self.plt.close()\n        _, ax = self.plt.subplots()\n        ax = s.plot(legend=True, ax=ax)\n        self._check_legend_labels(ax, labels=[\"None\"])\n        self.plt.close()\n        # get name from index\n        s.name = \"NAME\"\n        _, ax = self.plt.subplots()\n        ax = s.plot(legend=True, ax=ax)\n        self._check_legend_labels(ax, labels=[\"NAME\"])\n        self.plt.close()\n        # override the default\n        _, ax = self.plt.subplots()\n        ax = s.plot(legend=True, label=\"LABEL\", ax=ax)\n        self._check_legend_labels(ax, labels=[\"LABEL\"])\n        self.plt.close()\n        # Add lebel info, but don't draw\n        _, ax = self.plt.subplots()\n        ax = s.plot(legend=False, label=\"LABEL\", ax=ax)\n        assert ax.get_legend() is None  # Hasn't been drawn\n        ax.legend()  # draw it\n        self._check_legend_labels(ax, labels=[\"LABEL\"])",
        "begin_line": 142,
        "end_line": 168,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_boolean#170",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_boolean(self)",
        "snippet": "    def test_boolean(self):\n        # GH 23719\n        s = Series([False, False, True])\n        _check_plot_works(s.plot, include_bool=True)\n\n        msg = \"no numeric data to plot\"\n        with pytest.raises(TypeError, match=msg):\n            _check_plot_works(s.plot)",
        "begin_line": 170,
        "end_line": 177,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_line_area_nan_series#179",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_line_area_nan_series(self)",
        "snippet": "    def test_line_area_nan_series(self):\n        values = [1, 2, np.nan, 3]\n        s = Series(values)\n        ts = Series(values, index=tm.makeDateIndex(k=4))\n\n        for d in [s, ts]:\n            ax = _check_plot_works(d.plot)\n            masked = ax.lines[0].get_ydata()\n            # remove nan for comparison purpose\n            exp = np.array([1, 2, 3], dtype=np.float64)\n            tm.assert_numpy_array_equal(np.delete(masked.data, 2), exp)\n            tm.assert_numpy_array_equal(\n                masked.mask, np.array([False, False, True, False])\n            )\n\n            expected = np.array([1, 2, 0, 3], dtype=np.float64)\n            ax = _check_plot_works(d.plot, stacked=True)\n            tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected)\n            ax = _check_plot_works(d.plot.area)\n            tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected)\n            ax = _check_plot_works(d.plot.area, stacked=False)\n            tm.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected)",
        "begin_line": 179,
        "end_line": 200,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_line_use_index_false#202",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_line_use_index_false(self)",
        "snippet": "    def test_line_use_index_false(self):\n        s = Series([1, 2, 3], index=[\"a\", \"b\", \"c\"])\n        s.index.name = \"The Index\"\n        _, ax = self.plt.subplots()\n        ax = s.plot(use_index=False, ax=ax)\n        label = ax.get_xlabel()\n        assert label == \"\"\n        _, ax = self.plt.subplots()\n        ax2 = s.plot.bar(use_index=False, ax=ax)\n        label2 = ax2.get_xlabel()\n        assert label2 == \"\"",
        "begin_line": 202,
        "end_line": 212,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_bar_log#215",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_bar_log(self)",
        "snippet": "    def test_bar_log(self):\n        expected = np.array([1e-1, 1e0, 1e1, 1e2, 1e3, 1e4])\n\n        _, ax = self.plt.subplots()\n        ax = Series([200, 500]).plot.bar(log=True, ax=ax)\n        tm.assert_numpy_array_equal(ax.yaxis.get_ticklocs(), expected)\n        tm.close()\n\n        _, ax = self.plt.subplots()\n        ax = Series([200, 500]).plot.barh(log=True, ax=ax)\n        tm.assert_numpy_array_equal(ax.xaxis.get_ticklocs(), expected)\n        tm.close()\n\n        # GH 9905\n        expected = np.array([1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e0, 1e1])\n\n        _, ax = self.plt.subplots()\n        ax = Series([0.1, 0.01, 0.001]).plot(log=True, kind=\"bar\", ax=ax)\n        ymin = 0.0007943282347242822\n        ymax = 0.12589254117941673\n        res = ax.get_ylim()\n        tm.assert_almost_equal(res[0], ymin)\n        tm.assert_almost_equal(res[1], ymax)\n        tm.assert_numpy_array_equal(ax.yaxis.get_ticklocs(), expected)\n        tm.close()\n\n        _, ax = self.plt.subplots()\n        ax = Series([0.1, 0.01, 0.001]).plot(log=True, kind=\"barh\", ax=ax)\n        res = ax.get_xlim()\n        tm.assert_almost_equal(res[0], ymin)\n        tm.assert_almost_equal(res[1], ymax)\n        tm.assert_numpy_array_equal(ax.xaxis.get_ticklocs(), expected)",
        "begin_line": 215,
        "end_line": 246,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_bar_ignore_index#249",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_bar_ignore_index(self)",
        "snippet": "    def test_bar_ignore_index(self):\n        df = Series([1, 2, 3, 4], index=[\"a\", \"b\", \"c\", \"d\"])\n        _, ax = self.plt.subplots()\n        ax = df.plot.bar(use_index=False, ax=ax)\n        self._check_text_labels(ax.get_xticklabels(), [\"0\", \"1\", \"2\", \"3\"])",
        "begin_line": 249,
        "end_line": 253,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_bar_user_colors#255",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_bar_user_colors(self)",
        "snippet": "    def test_bar_user_colors(self):\n        s = Series([1, 2, 3, 4])\n        ax = s.plot.bar(color=[\"red\", \"blue\", \"blue\", \"red\"])\n        result = [p.get_facecolor() for p in ax.patches]\n        expected = [\n            (1.0, 0.0, 0.0, 1.0),\n            (0.0, 0.0, 1.0, 1.0),\n            (0.0, 0.0, 1.0, 1.0),\n            (1.0, 0.0, 0.0, 1.0),\n        ]\n        assert result == expected",
        "begin_line": 255,
        "end_line": 265,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_rotation#267",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_rotation(self)",
        "snippet": "    def test_rotation(self):\n        df = DataFrame(randn(5, 5))\n        # Default rot 0\n        _, ax = self.plt.subplots()\n        axes = df.plot(ax=ax)\n        self._check_ticks_props(axes, xrot=0)\n\n        _, ax = self.plt.subplots()\n        axes = df.plot(rot=30, ax=ax)\n        self._check_ticks_props(axes, xrot=30)",
        "begin_line": 267,
        "end_line": 276,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_irregular_datetime#278",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_irregular_datetime(self)",
        "snippet": "    def test_irregular_datetime(self):\n        rng = date_range(\"1/1/2000\", \"3/1/2000\")\n        rng = rng[[0, 1, 2, 3, 5, 9, 10, 11, 12]]\n        ser = Series(randn(len(rng)), rng)\n        _, ax = self.plt.subplots()\n        ax = ser.plot(ax=ax)\n        xp = datetime(1999, 1, 1).toordinal()\n        ax.set_xlim(\"1/1/1999\", \"1/1/2001\")\n        assert xp == ax.get_xlim()[0]",
        "begin_line": 278,
        "end_line": 286,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_unsorted_index_xlim#288",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_unsorted_index_xlim(self)",
        "snippet": "    def test_unsorted_index_xlim(self):\n        ser = Series(\n            [0.0, 1.0, np.nan, 3.0, 4.0, 5.0, 6.0],\n            index=[1.0, 0.0, 3.0, 2.0, np.nan, 3.0, 2.0],\n        )\n        _, ax = self.plt.subplots()\n        ax = ser.plot(ax=ax)\n        xmin, xmax = ax.get_xlim()\n        lines = ax.get_lines()\n        assert xmin <= np.nanmin(lines[0].get_data(orig=False)[0])\n        assert xmax >= np.nanmax(lines[0].get_data(orig=False)[0])",
        "begin_line": 288,
        "end_line": 298,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_pie_series#301",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_pie_series(self)",
        "snippet": "    def test_pie_series(self):\n        # if sum of values is less than 1.0, pie handle them as rate and draw\n        # semicircle.\n        series = Series(\n            np.random.randint(1, 5), index=[\"a\", \"b\", \"c\", \"d\", \"e\"], name=\"YLABEL\"\n        )\n        ax = _check_plot_works(series.plot.pie)\n        self._check_text_labels(ax.texts, series.index)\n        assert ax.get_ylabel() == \"YLABEL\"\n\n        # without wedge labels\n        ax = _check_plot_works(series.plot.pie, labels=None)\n        self._check_text_labels(ax.texts, [\"\"] * 5)\n\n        # with less colors than elements\n        color_args = [\"r\", \"g\", \"b\"]\n        ax = _check_plot_works(series.plot.pie, colors=color_args)\n\n        color_expected = [\"r\", \"g\", \"b\", \"r\", \"g\"]\n        self._check_colors(ax.patches, facecolors=color_expected)\n\n        # with labels and colors\n        labels = [\"A\", \"B\", \"C\", \"D\", \"E\"]\n        color_args = [\"r\", \"g\", \"b\", \"c\", \"m\"]\n        ax = _check_plot_works(series.plot.pie, labels=labels, colors=color_args)\n        self._check_text_labels(ax.texts, labels)\n        self._check_colors(ax.patches, facecolors=color_args)\n\n        # with autopct and fontsize\n        ax = _check_plot_works(\n            series.plot.pie, colors=color_args, autopct=\"%.2f\", fontsize=7\n        )\n        pcts = [\"{0:.2f}\".format(s * 100) for s in series.values / float(series.sum())]\n        expected_texts = list(chain.from_iterable(zip(series.index, pcts)))\n        self._check_text_labels(ax.texts, expected_texts)\n        for t in ax.texts:\n            assert t.get_fontsize() == 7\n\n        # includes negative value\n        with pytest.raises(ValueError):\n            series = Series([1, 2, 0, 4, -1], index=[\"a\", \"b\", \"c\", \"d\", \"e\"])\n            series.plot.pie()\n\n        # includes nan\n        series = Series([1, 2, np.nan, 4], index=[\"a\", \"b\", \"c\", \"d\"], name=\"YLABEL\")\n        ax = _check_plot_works(series.plot.pie)\n        self._check_text_labels(ax.texts, [\"a\", \"b\", \"\", \"d\"])",
        "begin_line": 301,
        "end_line": 347,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_pie_nan#349",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_pie_nan(self)",
        "snippet": "    def test_pie_nan(self):\n        s = Series([1, np.nan, 1, 1])\n        _, ax = self.plt.subplots()\n        ax = s.plot.pie(legend=True, ax=ax)\n        expected = [\"0\", \"\", \"2\", \"3\"]\n        result = [x.get_text() for x in ax.texts]\n        assert result == expected",
        "begin_line": 349,
        "end_line": 355,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_df_kwargs#358",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_df_kwargs(self)",
        "snippet": "    def test_hist_df_kwargs(self):\n        df = DataFrame(np.random.randn(10, 2))\n        _, ax = self.plt.subplots()\n        ax = df.plot.hist(bins=5, ax=ax)\n        assert len(ax.patches) == 10",
        "begin_line": 358,
        "end_line": 362,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_df_with_nonnumerics#365",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_df_with_nonnumerics(self)",
        "snippet": "    def test_hist_df_with_nonnumerics(self):\n        # GH 9853\n        with tm.RNGContext(1):\n            df = DataFrame(np.random.randn(10, 4), columns=[\"A\", \"B\", \"C\", \"D\"])\n        df[\"E\"] = [\"x\", \"y\"] * 5\n        _, ax = self.plt.subplots()\n        ax = df.plot.hist(bins=5, ax=ax)\n        assert len(ax.patches) == 20\n\n        _, ax = self.plt.subplots()\n        ax = df.plot.hist(ax=ax)  # bins=10\n        assert len(ax.patches) == 40",
        "begin_line": 365,
        "end_line": 376,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_legacy#379",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_legacy(self)",
        "snippet": "    def test_hist_legacy(self):\n        _check_plot_works(self.ts.hist)\n        _check_plot_works(self.ts.hist, grid=False)\n        _check_plot_works(self.ts.hist, figsize=(8, 10))\n        # _check_plot_works adds an ax so catch warning. see GH #13188\n        with tm.assert_produces_warning(UserWarning):\n            _check_plot_works(self.ts.hist, by=self.ts.index.month)\n        with tm.assert_produces_warning(UserWarning):\n            _check_plot_works(self.ts.hist, by=self.ts.index.month, bins=5)\n\n        fig, ax = self.plt.subplots(1, 1)\n        _check_plot_works(self.ts.hist, ax=ax)\n        _check_plot_works(self.ts.hist, ax=ax, figure=fig)\n        _check_plot_works(self.ts.hist, figure=fig)\n        tm.close()\n\n        fig, (ax1, ax2) = self.plt.subplots(1, 2)\n        _check_plot_works(self.ts.hist, figure=fig, ax=ax1)\n        _check_plot_works(self.ts.hist, figure=fig, ax=ax2)\n\n        with pytest.raises(ValueError):\n            self.ts.hist(by=self.ts.index, figure=fig)",
        "begin_line": 379,
        "end_line": 400,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_bins_legacy#403",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_bins_legacy(self)",
        "snippet": "    def test_hist_bins_legacy(self):\n        df = DataFrame(np.random.randn(10, 2))\n        ax = df.hist(bins=2)[0][0]\n        assert len(ax.patches) == 2",
        "begin_line": 403,
        "end_line": 406,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_layout#409",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_layout(self)",
        "snippet": "    def test_hist_layout(self):\n        df = self.hist_df\n        with pytest.raises(ValueError):\n            df.height.hist(layout=(1, 1))\n\n        with pytest.raises(ValueError):\n            df.height.hist(layout=[1, 1])",
        "begin_line": 409,
        "end_line": 415,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_layout_with_by#418",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_layout_with_by(self)",
        "snippet": "    def test_hist_layout_with_by(self):\n        df = self.hist_df\n\n        # _check_plot_works adds an ax so catch warning. see GH #13188\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.height.hist, by=df.gender, layout=(2, 1))\n        self._check_axes_shape(axes, axes_num=2, layout=(2, 1))\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.height.hist, by=df.gender, layout=(3, -1))\n        self._check_axes_shape(axes, axes_num=2, layout=(3, 1))\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.height.hist, by=df.category, layout=(4, 1))\n        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.height.hist, by=df.category, layout=(2, -1))\n        self._check_axes_shape(axes, axes_num=4, layout=(2, 2))\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.height.hist, by=df.category, layout=(3, -1))\n        self._check_axes_shape(axes, axes_num=4, layout=(3, 2))\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.height.hist, by=df.category, layout=(-1, 4))\n        self._check_axes_shape(axes, axes_num=4, layout=(1, 4))\n\n        with tm.assert_produces_warning(UserWarning):\n            axes = _check_plot_works(df.height.hist, by=df.classroom, layout=(2, 2))\n        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))\n\n        axes = df.height.hist(by=df.category, layout=(4, 2), figsize=(12, 7))\n        self._check_axes_shape(axes, axes_num=4, layout=(4, 2), figsize=(12, 7))",
        "begin_line": 418,
        "end_line": 451,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_no_overlap#454",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_no_overlap(self)",
        "snippet": "    def test_hist_no_overlap(self):\n        from matplotlib.pyplot import subplot, gcf\n\n        x = Series(randn(2))\n        y = Series(randn(2))\n        subplot(121)\n        x.hist()\n        subplot(122)\n        y.hist()\n        fig = gcf()\n        axes = fig.axes\n        assert len(axes) == 2",
        "begin_line": 454,
        "end_line": 465,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_secondary_legend#468",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_secondary_legend(self)",
        "snippet": "    def test_hist_secondary_legend(self):\n        # GH 9610\n        df = DataFrame(np.random.randn(30, 4), columns=list(\"abcd\"))\n\n        # primary -> secondary\n        _, ax = self.plt.subplots()\n        ax = df[\"a\"].plot.hist(legend=True, ax=ax)\n        df[\"b\"].plot.hist(ax=ax, legend=True, secondary_y=True)\n        # both legends are dran on left ax\n        # left and right axis must be visible\n        self._check_legend_labels(ax, labels=[\"a\", \"b (right)\"])\n        assert ax.get_yaxis().get_visible()\n        assert ax.right_ax.get_yaxis().get_visible()\n        tm.close()\n\n        # secondary -> secondary\n        _, ax = self.plt.subplots()\n        ax = df[\"a\"].plot.hist(legend=True, secondary_y=True, ax=ax)\n        df[\"b\"].plot.hist(ax=ax, legend=True, secondary_y=True)\n        # both legends are draw on left ax\n        # left axis must be invisible, right axis must be visible\n        self._check_legend_labels(ax.left_ax, labels=[\"a (right)\", \"b (right)\"])\n        assert not ax.left_ax.get_yaxis().get_visible()\n        assert ax.get_yaxis().get_visible()\n        tm.close()\n\n        # secondary -> primary\n        _, ax = self.plt.subplots()\n        ax = df[\"a\"].plot.hist(legend=True, secondary_y=True, ax=ax)\n        # right axes is returned\n        df[\"b\"].plot.hist(ax=ax, legend=True)\n        # both legends are draw on left ax\n        # left and right axis must be visible\n        self._check_legend_labels(ax.left_ax, labels=[\"a (right)\", \"b\"])\n        assert ax.left_ax.get_yaxis().get_visible()\n        assert ax.get_yaxis().get_visible()\n        tm.close()",
        "begin_line": 468,
        "end_line": 504,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_df_series_secondary_legend#507",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_df_series_secondary_legend(self)",
        "snippet": "    def test_df_series_secondary_legend(self):\n        # GH 9779\n        df = DataFrame(np.random.randn(30, 3), columns=list(\"abc\"))\n        s = Series(np.random.randn(30), name=\"x\")\n\n        # primary -> secondary (without passing ax)\n        _, ax = self.plt.subplots()\n        ax = df.plot(ax=ax)\n        s.plot(legend=True, secondary_y=True, ax=ax)\n        # both legends are dran on left ax\n        # left and right axis must be visible\n        self._check_legend_labels(ax, labels=[\"a\", \"b\", \"c\", \"x (right)\"])\n        assert ax.get_yaxis().get_visible()\n        assert ax.right_ax.get_yaxis().get_visible()\n        tm.close()\n\n        # primary -> secondary (with passing ax)\n        _, ax = self.plt.subplots()\n        ax = df.plot(ax=ax)\n        s.plot(ax=ax, legend=True, secondary_y=True)\n        # both legends are dran on left ax\n        # left and right axis must be visible\n        self._check_legend_labels(ax, labels=[\"a\", \"b\", \"c\", \"x (right)\"])\n        assert ax.get_yaxis().get_visible()\n        assert ax.right_ax.get_yaxis().get_visible()\n        tm.close()\n\n        # secondary -> secondary (without passing ax)\n        _, ax = self.plt.subplots()\n        ax = df.plot(secondary_y=True, ax=ax)\n        s.plot(legend=True, secondary_y=True, ax=ax)\n        # both legends are dran on left ax\n        # left axis must be invisible and right axis must be visible\n        expected = [\"a (right)\", \"b (right)\", \"c (right)\", \"x (right)\"]\n        self._check_legend_labels(ax.left_ax, labels=expected)\n        assert not ax.left_ax.get_yaxis().get_visible()\n        assert ax.get_yaxis().get_visible()\n        tm.close()\n\n        # secondary -> secondary (with passing ax)\n        _, ax = self.plt.subplots()\n        ax = df.plot(secondary_y=True, ax=ax)\n        s.plot(ax=ax, legend=True, secondary_y=True)\n        # both legends are dran on left ax\n        # left axis must be invisible and right axis must be visible\n        expected = [\"a (right)\", \"b (right)\", \"c (right)\", \"x (right)\"]\n        self._check_legend_labels(ax.left_ax, expected)\n        assert not ax.left_ax.get_yaxis().get_visible()\n        assert ax.get_yaxis().get_visible()\n        tm.close()\n\n        # secondary -> secondary (with passing ax)\n        _, ax = self.plt.subplots()\n        ax = df.plot(secondary_y=True, mark_right=False, ax=ax)\n        s.plot(ax=ax, legend=True, secondary_y=True)\n        # both legends are dran on left ax\n        # left axis must be invisible and right axis must be visible\n        expected = [\"a\", \"b\", \"c\", \"x (right)\"]\n        self._check_legend_labels(ax.left_ax, expected)\n        assert not ax.left_ax.get_yaxis().get_visible()\n        assert ax.get_yaxis().get_visible()\n        tm.close()",
        "begin_line": 507,
        "end_line": 568,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_secondary_logy#574",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_secondary_logy(self, input_logy, expected_scale)",
        "snippet": "    def test_secondary_logy(self, input_logy, expected_scale):\n        # GH 25545\n        s1 = Series(np.random.randn(30))\n        s2 = Series(np.random.randn(30))\n\n        # GH 24980\n        ax1 = s1.plot(logy=input_logy)\n        ax2 = s2.plot(secondary_y=True, logy=input_logy)\n\n        assert ax1.get_yscale() == expected_scale\n        assert ax2.get_yscale() == expected_scale",
        "begin_line": 574,
        "end_line": 584,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_plot_fails_with_dupe_color_and_style#587",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_plot_fails_with_dupe_color_and_style(self)",
        "snippet": "    def test_plot_fails_with_dupe_color_and_style(self):\n        x = Series(randn(2))\n        with pytest.raises(ValueError):\n            _, ax = self.plt.subplots()\n            x.plot(style=\"k--\", color=\"k\", ax=ax)",
        "begin_line": 587,
        "end_line": 591,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_kde#595",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_kde(self)",
        "snippet": "    def test_hist_kde(self):\n\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.hist(logy=True, ax=ax)\n        self._check_ax_scales(ax, yaxis=\"log\")\n        xlabels = ax.get_xticklabels()\n        # ticks are values, thus ticklabels are blank\n        self._check_text_labels(xlabels, [\"\"] * len(xlabels))\n        ylabels = ax.get_yticklabels()\n        self._check_text_labels(ylabels, [\"\"] * len(ylabels))\n\n        _check_plot_works(self.ts.plot.kde)\n        _check_plot_works(self.ts.plot.density)\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.kde(logy=True, ax=ax)\n        self._check_ax_scales(ax, yaxis=\"log\")\n        xlabels = ax.get_xticklabels()\n        self._check_text_labels(xlabels, [\"\"] * len(xlabels))\n        ylabels = ax.get_yticklabels()\n        self._check_text_labels(ylabels, [\"\"] * len(ylabels))",
        "begin_line": 595,
        "end_line": 614,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_kde_kwargs#618",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_kde_kwargs(self)",
        "snippet": "    def test_kde_kwargs(self):\n        sample_points = np.linspace(-100, 100, 20)\n        _check_plot_works(self.ts.plot.kde, bw_method=\"scott\", ind=20)\n        _check_plot_works(self.ts.plot.kde, bw_method=None, ind=20)\n        _check_plot_works(self.ts.plot.kde, bw_method=None, ind=np.int(20))\n        _check_plot_works(self.ts.plot.kde, bw_method=0.5, ind=sample_points)\n        _check_plot_works(self.ts.plot.density, bw_method=0.5, ind=sample_points)\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.kde(logy=True, bw_method=0.5, ind=sample_points, ax=ax)\n        self._check_ax_scales(ax, yaxis=\"log\")\n        self._check_text_labels(ax.yaxis.get_label(), \"Density\")",
        "begin_line": 618,
        "end_line": 628,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_kde_missing_vals#632",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_kde_missing_vals(self)",
        "snippet": "    def test_kde_missing_vals(self):\n        s = Series(np.random.uniform(size=50))\n        s[0] = np.nan\n        axes = _check_plot_works(s.plot.kde)\n\n        # gh-14821: check if the values have any missing values\n        assert any(~np.isnan(axes.lines[0].get_xdata()))",
        "begin_line": 632,
        "end_line": 638,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_kwargs#641",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_kwargs(self)",
        "snippet": "    def test_hist_kwargs(self):\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.hist(bins=5, ax=ax)\n        assert len(ax.patches) == 5\n        self._check_text_labels(ax.yaxis.get_label(), \"Frequency\")\n        tm.close()\n\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.hist(orientation=\"horizontal\", ax=ax)\n        self._check_text_labels(ax.xaxis.get_label(), \"Frequency\")\n        tm.close()\n\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.hist(align=\"left\", stacked=True, ax=ax)\n        tm.close()",
        "begin_line": 641,
        "end_line": 655,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_kde_color#659",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_hist_kde_color(self)",
        "snippet": "    def test_hist_kde_color(self):\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.hist(logy=True, bins=10, color=\"b\", ax=ax)\n        self._check_ax_scales(ax, yaxis=\"log\")\n        assert len(ax.patches) == 10\n        self._check_colors(ax.patches, facecolors=[\"b\"] * 10)\n\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.kde(logy=True, color=\"r\", ax=ax)\n        self._check_ax_scales(ax, yaxis=\"log\")\n        lines = ax.get_lines()\n        assert len(lines) == 1\n        self._check_colors(lines, [\"r\"])",
        "begin_line": 659,
        "end_line": 671,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_boxplot_series#674",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_boxplot_series(self)",
        "snippet": "    def test_boxplot_series(self):\n        _, ax = self.plt.subplots()\n        ax = self.ts.plot.box(logy=True, ax=ax)\n        self._check_ax_scales(ax, yaxis=\"log\")\n        xlabels = ax.get_xticklabels()\n        self._check_text_labels(xlabels, [self.ts.name])\n        ylabels = ax.get_yticklabels()\n        self._check_text_labels(ylabels, [\"\"] * len(ylabels))",
        "begin_line": 674,
        "end_line": 681,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_kind_both_ways#684",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_kind_both_ways(self)",
        "snippet": "    def test_kind_both_ways(self):\n        s = Series(range(3))\n        kinds = (\n            plotting.PlotAccessor._common_kinds + plotting.PlotAccessor._series_kinds\n        )\n        _, ax = self.plt.subplots()\n        for kind in kinds:\n\n            s.plot(kind=kind, ax=ax)\n            getattr(s.plot, kind)()",
        "begin_line": 684,
        "end_line": 693,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_invalid_plot_data#696",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_invalid_plot_data(self)",
        "snippet": "    def test_invalid_plot_data(self):\n        s = Series(list(\"abcd\"))\n        _, ax = self.plt.subplots()\n        for kind in plotting.PlotAccessor._common_kinds:\n\n            msg = \"no numeric data to plot\"\n            with pytest.raises(TypeError, match=msg):\n                s.plot(kind=kind, ax=ax)",
        "begin_line": 696,
        "end_line": 703,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_valid_object_plot#706",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_valid_object_plot(self)",
        "snippet": "    def test_valid_object_plot(self):\n        s = Series(range(10), dtype=object)\n        for kind in plotting.PlotAccessor._common_kinds:\n            _check_plot_works(s.plot, kind=kind)",
        "begin_line": 706,
        "end_line": 709,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_partially_invalid_plot_data#711",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_partially_invalid_plot_data(self)",
        "snippet": "    def test_partially_invalid_plot_data(self):\n        s = Series([\"a\", \"b\", 1.0, 2])\n        _, ax = self.plt.subplots()\n        for kind in plotting.PlotAccessor._common_kinds:\n\n            msg = \"no numeric data to plot\"\n            with pytest.raises(TypeError, match=msg):\n                s.plot(kind=kind, ax=ax)",
        "begin_line": 711,
        "end_line": 718,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_invalid_kind#720",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_invalid_kind(self)",
        "snippet": "    def test_invalid_kind(self):\n        s = Series([1, 2])\n        with pytest.raises(ValueError):\n            s.plot(kind=\"aasdf\")",
        "begin_line": 720,
        "end_line": 723,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_dup_datetime_index_plot#726",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_dup_datetime_index_plot(self)",
        "snippet": "    def test_dup_datetime_index_plot(self):\n        dr1 = date_range(\"1/1/2009\", periods=4)\n        dr2 = date_range(\"1/2/2009\", periods=4)\n        index = dr1.append(dr2)\n        values = randn(index.size)\n        s = Series(values, index=index)\n        _check_plot_works(s.plot)",
        "begin_line": 726,
        "end_line": 732,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_errorbar_plot#735",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_errorbar_plot(self)",
        "snippet": "    def test_errorbar_plot(self):\n\n        s = Series(np.arange(10), name=\"x\")\n        s_err = np.random.randn(10)\n        d_err = DataFrame(randn(10, 2), index=s.index, columns=[\"x\", \"y\"])\n        # test line and bar plots\n        kinds = [\"line\", \"bar\"]\n        for kind in kinds:\n            ax = _check_plot_works(s.plot, yerr=Series(s_err), kind=kind)\n            self._check_has_errorbars(ax, xerr=0, yerr=1)\n            ax = _check_plot_works(s.plot, yerr=s_err, kind=kind)\n            self._check_has_errorbars(ax, xerr=0, yerr=1)\n            ax = _check_plot_works(s.plot, yerr=s_err.tolist(), kind=kind)\n            self._check_has_errorbars(ax, xerr=0, yerr=1)\n            ax = _check_plot_works(s.plot, yerr=d_err, kind=kind)\n            self._check_has_errorbars(ax, xerr=0, yerr=1)\n            ax = _check_plot_works(s.plot, xerr=0.2, yerr=0.2, kind=kind)\n            self._check_has_errorbars(ax, xerr=1, yerr=1)\n\n        ax = _check_plot_works(s.plot, xerr=s_err)\n        self._check_has_errorbars(ax, xerr=1, yerr=0)\n\n        # test time series plotting\n        ix = date_range(\"1/1/2000\", \"1/1/2001\", freq=\"M\")\n        ts = Series(np.arange(12), index=ix, name=\"x\")\n        ts_err = Series(np.random.randn(12), index=ix)\n        td_err = DataFrame(randn(12, 2), index=ix, columns=[\"x\", \"y\"])\n\n        ax = _check_plot_works(ts.plot, yerr=ts_err)\n        self._check_has_errorbars(ax, xerr=0, yerr=1)\n        ax = _check_plot_works(ts.plot, yerr=td_err)\n        self._check_has_errorbars(ax, xerr=0, yerr=1)\n\n        # check incorrect lengths and types\n        with pytest.raises(ValueError):\n            s.plot(yerr=np.arange(11))\n\n        s_err = [\"zzz\"] * 10\n        with pytest.raises(TypeError):\n            s.plot(yerr=s_err)",
        "begin_line": 735,
        "end_line": 774,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_table#776",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_table(self)",
        "snippet": "    def test_table(self):\n        _check_plot_works(self.series.plot, table=True)\n        _check_plot_works(self.series.plot, table=self.series)",
        "begin_line": 776,
        "end_line": 778,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_series_grid_settings#781",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_series_grid_settings(self)",
        "snippet": "    def test_series_grid_settings(self):\n        # Make sure plot defaults to rcParams['axes.grid'] setting, GH 9792\n        self._check_grid_settings(\n            Series([1, 2, 3]),\n            plotting.PlotAccessor._series_kinds + plotting.PlotAccessor._common_kinds,\n        )",
        "begin_line": 781,
        "end_line": 786,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_standard_colors#789",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_standard_colors(self)",
        "snippet": "    def test_standard_colors(self):\n        from pandas.plotting._matplotlib.style import _get_standard_colors\n\n        for c in [\"r\", \"red\", \"green\", \"#FF0000\"]:\n            result = _get_standard_colors(1, color=c)\n            assert result == [c]\n\n            result = _get_standard_colors(1, color=[c])\n            assert result == [c]\n\n            result = _get_standard_colors(3, color=c)\n            assert result == [c] * 3\n\n            result = _get_standard_colors(3, color=[c])\n            assert result == [c] * 3",
        "begin_line": 789,
        "end_line": 803,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_standard_colors_all#806",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_standard_colors_all(self)",
        "snippet": "    def test_standard_colors_all(self):\n        import matplotlib.colors as colors\n        from pandas.plotting._matplotlib.style import _get_standard_colors\n\n        # multiple colors like mediumaquamarine\n        for c in colors.cnames:\n            result = _get_standard_colors(num_colors=1, color=c)\n            assert result == [c]\n\n            result = _get_standard_colors(num_colors=1, color=[c])\n            assert result == [c]\n\n            result = _get_standard_colors(num_colors=3, color=c)\n            assert result == [c] * 3\n\n            result = _get_standard_colors(num_colors=3, color=[c])\n            assert result == [c] * 3\n\n        # single letter colors like k\n        for c in colors.ColorConverter.colors:\n            result = _get_standard_colors(num_colors=1, color=c)\n            assert result == [c]\n\n            result = _get_standard_colors(num_colors=1, color=[c])\n            assert result == [c]\n\n            result = _get_standard_colors(num_colors=3, color=c)\n            assert result == [c] * 3\n\n            result = _get_standard_colors(num_colors=3, color=[c])\n            assert result == [c] * 3",
        "begin_line": 806,
        "end_line": 836,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_series_plot_color_kwargs#838",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_series_plot_color_kwargs(self)",
        "snippet": "    def test_series_plot_color_kwargs(self):\n        # GH1890\n        _, ax = self.plt.subplots()\n        ax = Series(np.arange(12) + 1).plot(color=\"green\", ax=ax)\n        self._check_colors(ax.get_lines(), linecolors=[\"green\"])",
        "begin_line": 838,
        "end_line": 842,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_time_series_plot_color_kwargs#844",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_time_series_plot_color_kwargs(self)",
        "snippet": "    def test_time_series_plot_color_kwargs(self):\n        # #1890\n        _, ax = self.plt.subplots()\n        ax = Series(np.arange(12) + 1, index=date_range(\"1/1/2000\", periods=12)).plot(\n            color=\"green\", ax=ax\n        )\n        self._check_colors(ax.get_lines(), linecolors=[\"green\"])",
        "begin_line": 844,
        "end_line": 850,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_time_series_plot_color_with_empty_kwargs#852",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_time_series_plot_color_with_empty_kwargs(self)",
        "snippet": "    def test_time_series_plot_color_with_empty_kwargs(self):\n        import matplotlib as mpl\n\n        def_colors = self._unpack_cycler(mpl.rcParams)\n        index = date_range(\"1/1/2000\", periods=12)\n        s = Series(np.arange(1, 13), index=index)\n\n        ncolors = 3\n\n        _, ax = self.plt.subplots()\n        for i in range(ncolors):\n            ax = s.plot(ax=ax)\n        self._check_colors(ax.get_lines(), linecolors=def_colors[:ncolors])",
        "begin_line": 852,
        "end_line": 864,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_xticklabels#866",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_xticklabels(self)",
        "snippet": "    def test_xticklabels(self):\n        # GH11529\n        s = Series(np.arange(10), index=[\"P{i:02d}\".format(i=i) for i in range(10)])\n        _, ax = self.plt.subplots()\n        ax = s.plot(xticks=[0, 3, 5, 9], ax=ax)\n        exp = [\"P{i:02d}\".format(i=i) for i in [0, 3, 5, 9]]\n        self._check_text_labels(ax.get_xticklabels(), exp)",
        "begin_line": 866,
        "end_line": 872,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_xtick_barPlot#874",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_xtick_barPlot(self)",
        "snippet": "    def test_xtick_barPlot(self):\n        # GH28172\n        s = pd.Series(range(10), index=[\"P{i:02d}\".format(i=i) for i in range(10)])\n        ax = s.plot.bar(xticks=range(0, 11, 2))\n        exp = np.array(list(range(0, 11, 2)))\n        tm.assert_numpy_array_equal(exp, ax.get_xticks())",
        "begin_line": 874,
        "end_line": 879,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_custom_business_day_freq#881",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_custom_business_day_freq(self)",
        "snippet": "    def test_custom_business_day_freq(self):\n        # GH7222\n        from pandas.tseries.offsets import CustomBusinessDay\n\n        s = Series(\n            range(100, 121),\n            index=pd.bdate_range(\n                start=\"2014-05-01\",\n                end=\"2014-06-01\",\n                freq=CustomBusinessDay(holidays=[\"2014-05-26\"]),\n            ),\n        )\n\n        _check_plot_works(s.plot)",
        "begin_line": 881,
        "end_line": 894,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_plot_accessor_updates_on_inplace#897",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_plot_accessor_updates_on_inplace(self)",
        "snippet": "    def test_plot_accessor_updates_on_inplace(self):\n        s = Series([1, 2, 3, 4])\n        _, ax = self.plt.subplots()\n        ax = s.plot(ax=ax)\n        before = ax.xaxis.get_ticklocs()\n\n        s.drop([0, 1], inplace=True)\n        _, ax = self.plt.subplots()\n        after = ax.xaxis.get_ticklocs()\n        tm.assert_numpy_array_equal(before, after)",
        "begin_line": 897,
        "end_line": 906,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_plot_xlim_for_series#909",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_plot_xlim_for_series(self, kind)",
        "snippet": "    def test_plot_xlim_for_series(self, kind):\n        # test if xlim is also correctly plotted in Series for line and area\n        # GH 27686\n        s = Series([2, 3])\n        _, ax = self.plt.subplots()\n        s.plot(kind=kind, ax=ax)\n        xlims = ax.get_xlim()\n\n        assert xlims[0] < 0\n        assert xlims[1] > 1",
        "begin_line": 909,
        "end_line": 918,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_plot_no_rows#920",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_plot_no_rows(self)",
        "snippet": "    def test_plot_no_rows(self):\n        # GH 27758\n        df = pd.Series(dtype=int)\n        assert df.empty\n        ax = df.plot()\n        assert len(ax.get_lines()) == 1\n        line = ax.get_lines()[0]\n        assert len(line.get_xdata()) == 0\n        assert len(line.get_ydata()) == 0",
        "begin_line": 920,
        "end_line": 928,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.plotting.test_series.TestSeriesPlots.test_plot_no_numeric_data#930",
        "src_path": "pandas/tests/plotting/test_series.py",
        "class_name": "pandas.tests.plotting.test_series.TestSeriesPlots",
        "signature": "pandas.tests.plotting.test_series.TestSeriesPlots.test_plot_no_numeric_data(self)",
        "snippet": "    def test_plot_no_numeric_data(self):\n        df = pd.Series([\"a\", \"b\", \"c\"])\n        with pytest.raises(TypeError):\n            df.plot()",
        "begin_line": 930,
        "end_line": 933,
        "comment": "",
        "is_bug": false
    }
]